"use strict";
(self.webpackChunksensei_web = self.webpackChunksensei_web || []).push([
			[179], {
				8588: (be, ue, E) => {
					E.d(ue, {
						KU: () => D,
						Li: () => te,
						O1: () => p,
						RZ: () => y,
						XP: () => G,
						aS: () => P,
						cD: () => N,
						fK: () => Y,
						l_: () => Q,
						vN: () => z
					});
					var p = (() => {
						return (ie = p || (p = {}))[ie.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR", ie[ie.NOT_FOUND = 1] = "NOT_FOUND", p;
						var ie
					})();
					const y = {
							[p.UNKNOWN_ERROR]: "Something went wrong, try again later",
							[p.NOT_FOUND]: "Requested resource not found"
						},
						D = 20,
						z = {
							needsReview: {
								color: "#2295ee",
								trackColor: "#1e5994"
							},
							flaggedContentInReview: {
								color: "#2295ee",
								trackColor: "#1e5994"
							},
							flaggedContentNeedsReview: {
								color: "#EB5933",
								trackColor: "#813b38"
							},
							passed: {
								color: "#00e899",
								trackColor: "#0a7c66"
							},
							notPassed: {
								color: "#eba133",
								trackColor: "#815f36"
							},
							programs: {
								create: {
									color: "#2295ee",
									trackColor: "#1e5994"
								}
							},
							offline: {
								color: "#eba133",
								trackColor: "#815f36"
							},
							eligibleforbeltchange: {
								color: "#2295ee",
								trackColor: "#1e5994"
							},
							noteligibleforbeltchange: {
								color: "#eba133",
								trackColor: "#815f36"
							}
						},
						P = {
							create: "/assets/img/create-white.svg",
							camp: "/assets/img/camps-white.svg",
							jr: "/assets/img/jr-white.svg"
						},
						N = ["white", "yellow", "orange", "green", "purple", "blue", "brown", "red", "black"],
						Y = {
							white: "#ffffff",
							yellow: "#e6b75a",
							orange: "#d86c32",
							green: "#88a335",
							blue: "#4571b6",
							purple: "#854193",
							brown: "#553425",
							red: "#ef3f40",
							black: "#000000"
						},
						G = {
							white: "/assets/img/white-belt.png",
							yellow: "/assets/img/yellow-belt.png",
							orange: "/assets/img/orange-belt.png",
							green: "/assets/img/green-belt.png",
							purple: "/assets/img/purple-belt.png",
							blue: "/assets/img/blue-belt.png",
							brown: "/assets/img/brown-belt.png",
							red: "/assets/img/red-belt.png",
							black: "/assets/img/black-belt.png"
						},
						Q = {
							white: "/assets/img/white.svg",
							yellow: "/assets/img/yellow.svg",
							orange: "/assets/img/orange.svg",
							green: "/assets/img/green.svg",
							blue: "/assets/img/blue.svg",
							black: "/assets/img/black.svg",
							purple: "/assets/img/purple.svg",
							brown: "/assets/img/brown.svg",
							red: "/assets/img/red.svg"
						},
						te = 18e5
				},
				2112: (be, ue, E) => {
					E.d(ue, {
						p: () => D
					});
					var p = E(5424);
					const D = (0, p.R7)({
						source: "Global Module",
						events: {
							"Load User Session Data": (0, p.Ky)(),
							"Get User Session Data": (0, p.uZ)(),
							"Home Component Loaded": (0, p.uZ)(),
							"Get User Profile Data": (0, p.uZ)(),
							Logout: (0, p.uZ)(),
							"Get Reviews": (0, p.uZ)(),
							"Update Reviews Filter": (0, p.Ky)(),
							"Loading Reviews With Filter": (0, p.uZ)(),
							"Load Reviews": (0, p.Ky)(),
							"Set Reviews": (0, p.Ky)(),
							"Update Review": (0, p.Ky)(),
							"Reviews Error": (0, p.Ky)(),
							"Reduce Needs Review Count": (0, p.uZ)(),
							"All Reviews Loaded": (0, p.uZ)(),
							"Get Review By Id": (0, p.Ky)(),
							"Reset Selected Review Id": (0, p.uZ)(),
							"Get Finder": (0, p.uZ)(),
							"Load Finder": (0, p.Ky)(),
							"Loaded Finder": (0, p.uZ)(),
							"Error Finder": (0, p.Ky)()
						}
					})
				},
				2439: (be, ue, E) => {
					E.d(ue, {
						pU: () => tn.p,
						zQ: () => Xe,
						gJ: () => Ge,
						$S: () => Pt,
						Tj: () => ke,
						C2: () => mn,
						Yt: () => Pn,
						vl: () => Sn,
						i5: () => Pe,
						l2: () => Qt,
						nl: () => ot,
						nG: () => ce,
						AL: () => pt,
						uD: () => Un,
						Gr: () => at,
						nR: () => cn,
						As: () => Se,
						e5: () => et,
						X1: () => Fe,
						AM: () => Ue,
						Wk: () => Ee,
						dy: () => oe,
						c7: () => Le
					});
					var p = E(5424),
						y = E(9702),
						D = E(7374),
						z = E(354);
					const P = "global",
						Y = (0, E(343).H)({
							sortComparer: function N(pe, Te) {
								const Je = {
										"sensei-ready": 0,
										"sensei-inreview": 1,
										"sensei-failed": 2,
										"sensei-completed": 3
									},
									yt = Je[pe.attributes.userCodeStatus],
									Ht = Je[Te.attributes.userCodeStatus],
									pn = new Date(pe.createdDate),
									$t = new Date(Te.createdDate);
								return yt - Ht || $t.getTime() - pn.getTime()
							}
						}),
						Q = {
							session: null,
							reviews: Y.getInitialState({
								loading: !1,
								error: null,
								totalCount: null,
								totalNeedReview: 0,
								selectedReviewId: null,
								filter: {
									userCodeStatus: ["sensei-ready", "sensei-inreview", "sensei-completed", "sensei-failed"],
									levelId: null,
									courseId: null,
									programId: null
								}
							}),
							finder: {
								data: null,
								error: null,
								loading: !1
							}
						};
					var X = E(9124);
					const te = (0, p.ZF)(P),
						ie = (0, p.P1)(te, pe => pe.session),
						oe = (0, p.P1)(ie, pe => pe?.user),
						Fe = ((0, p.P1)(oe, pe => pe?.firstName), (0, p.P1)(oe, pe => (pe?.firstName ?? "") + " " + (pe?.lastName ?? ""))),
						Le = (0, p.P1)(oe, pe => pe?.id),
						{
							selectAll: je,
							selectTotal: Ce,
							selectEntities: F
						} = Y.getSelectors(),
						xe = (0, p.P1)(te, pe => pe.reviews),
						Ee = (0, p.P1)(xe, pe => pe.totalCount),
						Ue = (0, p.P1)(xe, pe => pe.totalNeedReview),
						ke = (0, p.P1)(xe, pe => pe.loading),
						Ge = (0, p.P1)(xe, je),
						ft = (0, p.P1)(xe, Ce),
						nt = (0, p.P1)(xe, pe => pe.totalCount),
						Pt = (0, p.P1)(nt, ft, (pe, Te) => pe === Te),
						at = (0, p.P1)(xe, pe => pe.error),
						lt = (0, p.P1)(xe, F),
						et = (0, p.P1)(xe, pe => pe.selectedReviewId),
						Se = (0, p.P1)(et, lt, (pe, Te) => pe && Te[pe] || null),
						Be = (0, p.P1)(Se, pe => pe?.attributes),
						ze = (0, p.P1)(Se, pe => pe?.relationShips?.data),
						it = (0, p.P1)(Be, pe => pe && "sensei-inreview" === pe.userCodeStatus && pe),
						ce = (0, p.P1)(Le, it, ze, Se, (pe, Te, Je, yt) => pe && Te && Je && pe !== Je.assignedTo && !ht(yt) && "sensei-inreview" === yt?.attributes.userCodeStatus),
						ht = pe => +new Date - +new Date(pe?.lastModifiedDate) > 18e5,
						Pe = (0, p.P1)(te, pe => pe.finder),
						pt = (0, p.P1)(Pe, pe => pe.loading),
						Bt = (0, p.P1)(Pe, pe => pe.data),
						ot = (0, p.P1)(Bt, pe => pe?.programs),
						Qt = (0, p.P1)(Pe, pe => pe.error),
						cn = (0, p.P1)(xe, pe => pe.filter),
						Sn = (0, p.P1)(oe, pe => pe?.facilityName),
						Pn = (0, p.P1)(oe, pe => pe?.facilityId),
						mn = (0, p.P1)(oe, pe => pe?.facilityLocation),
						Un = (0, p.P1)(ie, pe => parseInt(pe?.user?.personnelType ?? "") === X.v.HeadQuarters);
					(0, p.P1)(ot, pe => void 0 !== pe ? pe[0].courses : []);
					var Vn = E(7580),
						Zt = E(1565),
						bn = E(5195),
						Bn = E(2837),
						qt = E(9754),
						tn = E(2112),
						en = E(8588),
						Qn = E(8345),
						Wn = E(3991),
						Nn = E(5303),
						ar = E(2720),
						hr = E(6425);
					let un = (() => {
						class pe {
							constructor(Je, yt, Ht, pn, $t, hn, kt) {
								this.actions$ = Je, this.authService = yt, this.mixpanelService = Ht, this.reviewService = pn, this.guideService = $t, this.router = hn, this.store$ = kt, this._updateReviewsFilterAfterHome$ = (0, y.GW)(() => this.actions$.pipe((0, y.l4)(tn.p.homeComponentLoaded), (0, Vn.U)(() => tn.p.updateReviewsFilter({
									reviewsFilter: {
										userCodeStatus: ["sensei-completed", "sensei-failed", "sensei-inreview", "sensei-ready"],
										levelId: null,
										courseId: null,
										programId: null
									}
								})))), this.loadEmployeeList$ = (0, y.GW)(() => this.actions$.pipe((0, y.l4)(tn.p.getUserProfileData), (0, Zt.w)(() => this.authService.getInfo()), (0, D.b)(ct => {
									this.mixpanelService.setUserProfileProperties({
										CenterName: ct.facilityName,
										Role: ct.personnelType,
										$name: `${ct.firstName} ${ct.lastName}`
									})
								}), (0, Vn.U)(ct => tn.p.loadUserSessionData({
									session: {
										user: ct
									}
								})))), this._getReviews$ = (0, y.GW)(() => this.actions$.pipe((0, y.l4)(tn.p.getReviews), (0, y.IC)(() => [this.store$.select(Pt), this.store$.select(cn)]), (0, Zt.w)(([ct, De, B]) => De ? (0, bn.of)(tn.p.allReviewsLoaded()) : this.reviewService.getReviews(B).pipe((0, Vn.U)(J => tn.p.loadReviews({
									reviews: J.userMessageModelFullObj,
									totalCount: J.totalCount,
									totalNeedReview: J.totalSenseiReady
								})), (0, Bn.K)(() => (0, bn.of)(tn.p.reviewsError({
									error: {
										code: en.O1.UNKNOWN_ERROR
									}
								}))))))), this._areFiltersEqual = (ct, De) => !!(ct.userCodeStatus && De.userCodeStatus && (0, Qn.H)(ct.userCodeStatus, De.userCodeStatus) && (0, Qn.J)({
									levelId: ct.levelId,
									courseId: ct.courseId,
									programId: ct.programId
								}, {
									levelId: De.levelId,
									courseId: De.courseId,
									programId: De.programId
								})), this._updateReviewsFilter$ = (0, y.GW)(() => this.store$.select(cn).pipe((0, z.x)((ct, De) => this._areFiltersEqual(ct, De)), (0, Zt.w)(ct => this.reviewService.getReviews(ct, !0).pipe((0, Vn.U)(De => tn.p.setReviews({
									reviews: De.userMessageModelFullObj,
									totalCount: De.totalCount,
									totalNeedReview: De.totalSenseiReady
								})), (0, Bn.K)(() => (0, bn.of)(tn.p.reviewsError({
									error: {
										code: en.O1.UNKNOWN_ERROR
									}
								}))))))), this._loadingReviewsWithFilter$ = (0, y.GW)(() => this.store$.select(cn).pipe((0, z.x)((ct, De) => this._areFiltersEqual(ct, De)), (0, Vn.U)(() => tn.p.loadingReviewsWithFilter()))), this.isLessThanThirtyMinutes = ct => +new Date - +new Date(ct?.lastModifiedDate) > 18e5, this._getSelectedReview$ = (0, y.GW)(() => this.actions$.pipe((0, y.l4)(tn.p.getReviewById), (0, y.IC)(() => [this.store$.select(Se)]), (0, qt.h)(([{
									reviewId: ct
								}, De]) => !(!ct || !De || "sensei-ready" !== De.attributes.userCodeStatus && "sensei-inreview" !== De.attributes.userCodeStatus)), (0, Zt.w)(([{
									reviewId: ct
								}]) => this.reviewService.getReview(ct).pipe((0, Vn.U)(De => tn.p.updateReview({
									id: De.id,
									changes: De
								})), (0, Bn.K)(() => (0, bn.of)(tn.p.reviewsError({
									error: {
										code: en.O1.UNKNOWN_ERROR
									}
								}))))))), this._navigateToSelectedReview$ = (0, y.GW)(() => this.actions$.pipe((0, y.l4)(tn.p.updateReview), (0, y.IC)(() => [this.store$.select(ce)]), (0, Vn.U)(([ct, De]) => ct && !De && this.router.navigate(["/reviews", ct.id]))), {
									dispatch: !1
								}), this._navigateToSelectedReview1$ = (0, y.GW)(() => this.store$.select(Se).pipe((0, y.IC)(() => [this.store$.select(ce)]), (0, qt.h)(([ct, De]) => !(!ct || De || "sensei-completed" !== ct.attributes.userCodeStatus && "sensei-failed" !== ct.attributes.userCodeStatus)), (0, Vn.U)(([ct, De]) => this.router.navigate(["/reviews", ct.id]))), {
									dispatch: !1
								}), this._reduceTotalNeedsReviewCount$ = (0, y.GW)(() => this.store$.select(et).pipe((0, z.x)(), (0, y.IC)(() => [this.store$.select(Se)]), (0, qt.h)(([ct, De]) => !(!ct || !De || "sensei-ready" !== De.attributes.userCodeStatus)), (0, Vn.U)(() => tn.p.reduceNeedsReviewCount()))), this._getFinderData$ = (0, y.GW)(() => this.actions$.pipe((0, y.l4)(tn.p.getFinder), (0, y.IC)(() => this.store$.select(Bt)), (0, qt.h)(([ct, De]) => !De), (0, Zt.w)(() => this.guideService.getGuideFinder().pipe((0, Vn.U)(ct => tn.p.loadFinder({
									data: {
										programs: ct
									}
								})), (0, Bn.K)(() => (0, bn.of)(tn.p.errorFinder({
									error: {
										code: en.O1.UNKNOWN_ERROR
									}
								}))))))), this._loadedFinderData$ = (0, y.GW)(() => this.actions$.pipe((0, y.l4)(tn.p.getFinder), (0, y.IC)(() => this.store$.select(Bt)), (0, qt.h)(([ct, De]) => !!De), (0, Vn.U)(() => tn.p.loadedFinder()))), this._logout$ = (0, y.GW)(() => this.actions$.pipe((0, y.l4)(tn.p.logout), (0, D.b)(() => {
									this.mixpanelService.trackEvent("Log Out"), this.mixpanelService.resetUserIdentity()
								}), (0, Vn.U)(() => {
									this.authService.logout()
								})), {
									dispatch: !1
								})
							}
						}
						return pe.\u0275fac = function(Je) {
							return new(Je || pe)(Wn.LFG(y.eX), Wn.LFG(Nn.e8), Wn.LFG(ar.h), Wn.LFG(Nn.Fn), Wn.LFG(Nn.CC), Wn.LFG(hr.F0), Wn.LFG(p.yh))
						}, pe.\u0275prov = Wn.Yz7({
							token: pe,
							factory: pe.\u0275fac
						}), pe
					})();
					const Nt = (0, p.Tz)({
						name: P,
						reducer: (0, p.Lq)(Q, (0, p.on)(tn.p.loadUserSessionData, (pe, {
							session: Te
						}) => ({
							...pe,
							session: Te
						})), (0, p.on)(tn.p.getReviews, pe => ({
							...pe,
							reviews: {
								...pe.reviews,
								loading: !0,
								error: null
							}
						})), (0, p.on)(tn.p.updateReviewsFilter, (pe, {
							reviewsFilter: Te
						}) => ({
							...pe,
							reviews: {
								...pe.reviews,
								filter: Te
							}
						})), (0, p.on)(tn.p.loadingReviewsWithFilter, pe => ({
							...pe,
							reviews: {
								...Y.setAll([], pe.reviews),
								totalCount: null,
								totalNeedReview: 0,
								error: null,
								loading: !0
							}
						})), (0, p.on)(tn.p.updateReview, (pe, Te) => ({
							...pe,
							reviews: {
								...Y.updateOne(Te, pe.reviews)
							}
						})), (0, p.on)(tn.p.loadReviews, (pe, {
							reviews: Te,
							totalCount: Je,
							totalNeedReview: yt
						}) => ({
							...pe,
							reviews: {
								...Y.addMany(Te, pe.reviews),
								loading: !1,
								error: null,
								totalCount: Je,
								totalNeedReview: yt
							}
						})), (0, p.on)(tn.p.setReviews, (pe, {
							reviews: Te,
							totalCount: Je,
							totalNeedReview: yt
						}) => ({
							...pe,
							reviews: {
								...Y.setAll(Te, pe.reviews),
								loading: !1,
								error: null,
								totalCount: Je,
								totalNeedReview: yt
							}
						})), (0, p.on)(tn.p.reviewsError, (pe, {
							error: Te
						}) => ({
							...pe,
							reviews: {
								...Y.setAll([], pe.reviews),
								loading: !1,
								error: Te
							}
						})), (0, p.on)(tn.p.allReviewsLoaded, pe => ({
							...pe,
							reviews: {
								...pe.reviews,
								loading: !1
							}
						})), (0, p.on)(tn.p.reduceNeedsReviewCount, pe => ({
							...pe,
							reviews: {
								...pe.reviews,
								totalNeedReview: pe.reviews.totalNeedReview - 1
							}
						})), (0, p.on)(tn.p.getReviewById, (pe, {
							reviewId: Te
						}) => ({
							...pe,
							reviews: {
								...pe.reviews,
								selectedReviewId: Te
							}
						})), (0, p.on)(tn.p.resetSelectedReviewId, pe => ({
							...pe,
							reviews: {
								...pe.reviews,
								selectedReviewId: null
							}
						})), (0, p.on)(tn.p.getFinder, pe => ({
							...pe,
							finder: {
								...pe.finder,
								loading: !0
							}
						})), (0, p.on)(tn.p.loadFinder, (pe, {
							data: Te
						}) => ({
							...pe,
							finder: {
								...pe.finder,
								data: Te,
								loading: !1,
								error: null
							}
						})), (0, p.on)(tn.p.loadedFinder, pe => ({
							...pe,
							finder: {
								...pe.finder,
								loading: !1,
								error: null
							}
						})), (0, p.on)(tn.p.errorFinder, (pe, {
							error: Te
						}) => ({
							...pe,
							finder: {
								...pe.finder,
								loading: !1,
								error: Te
							}
						})))
					});
					let Xe = (() => {
						class pe {}
						return pe.\u0275fac = function(Je) {
							return new(Je || pe)
						}, pe.\u0275mod = Wn.oAB({
							type: pe
						}), pe.\u0275inj = Wn.cJS({
							imports: [p.Aw.forFeature(Nt), y.sQ.forFeature([un])]
						}), pe
					})()
				},
				5572: (be, ue, E) => {
					E.d(ue, {
						l1: () => te,
						zR: () => D,
						_C: () => N,
						GF: () => G,
						gp: () => ee,
						Wj: () => P,
						Cy: () => Y,
						ev: () => y,
						vY: () => p.v,
						KA: () => Q,
						q9: () => X
					});
					var p = E(9124),
						y = (() => {
							return (oe = y || (y = {}))[oe.NEEDS_REVIEW = 1] = "NEEDS_REVIEW", oe[oe.IN_REVIEW = 2] = "IN_REVIEW", oe[oe.APPROPRIATE = 3] = "APPROPRIATE", oe[oe.INAPPROPRIATE = 4] = "INAPPROPRIATE", oe[oe.INVALID = 5] = "INVALID", y;
							var oe
						})();
					const D = {
						[y.NEEDS_REVIEW]: "Needs Review",
						[y.IN_REVIEW]: "In Review",
						[y.APPROPRIATE]: "Appropriate",
						[y.INAPPROPRIATE]: "Inappropriate",
						[y.INVALID]: "Invalid"
					};
					var z = (() => {
						return (oe = z || (z = {}))[oe.INAPPROPRIATE_CONTENT = 1] = "INAPPROPRIATE_CONTENT", oe[oe.COPYRIGHT = 2] = "COPYRIGHT", oe[oe.BULLYING = 3] = "BULLYING", oe[oe.BREAKS_GUIDELINE = 4] = "BREAKS_GUIDELINE", oe[oe.DANGEROUS = 5] = "DANGEROUS", z;
						var oe
					})();
					const ee = {
						[z.INAPPROPRIATE_CONTENT]: "Inappropriate Content: This project is offensive",
						[z.COPYRIGHT]: "Copying or Stealing: This project copies someone's work",
						[z.BULLYING]: "Bullying or Harassment: This project is mean to others",
						[z.BREAKS_GUIDELINE]: "Breaks the Rules: This project doesn't follow guidelines",
						[z.DANGEROUS]: "Safety Concerns: This project is dangerous/could hurt someone"
					};
					var P = (() => {
						return (oe = P || (P = {}))[oe.INAPPROPRIATE_CONTENT = 1] = "INAPPROPRIATE_CONTENT", oe[oe.BULLYING = 2] = "BULLYING", oe[oe.BREAKS_GUIDELINE = 3] = "BREAKS_GUIDELINE", oe[oe.DANGEROUS = 4] = "DANGEROUS", P;
						var oe
					})();
					const N = {
						[P.INAPPROPRIATE_CONTENT]: "Inappropriate Content: This comment is offensive",
						[P.BULLYING]: "Bullying or Harassment: This comment is mean to others",
						[P.BREAKS_GUIDELINE]: "Breaks the Rules: This comment doesn't follow guidelines",
						[P.DANGEROUS]: "Safety Concerns: This comment is dangerous/could hurt someone"
					};
					var Y = (() => {
						return (oe = Y || (Y = {}))[oe.INAPPROPRIATE_CONTENT = 1] = "INAPPROPRIATE_CONTENT", oe[oe.BULLYING = 2] = "BULLYING", oe[oe.BREAKS_GUIDELINE = 3] = "BREAKS_GUIDELINE", oe[oe.DANGEROUS = 4] = "DANGEROUS", Y;
						var oe
					})();
					const G = {
						[Y.INAPPROPRIATE_CONTENT]: "Inappropriate Content: This comment is offensive",
						[Y.BULLYING]: "Bullying or Harassment: This comment is mean to others",
						[Y.BREAKS_GUIDELINE]: "Breaks the Rules: This comment doesn't follow guidelines",
						[Y.DANGEROUS]: "Safety Concerns: This comment is dangerous/could hurt someone"
					};
					var Q = (() => {
						return (oe = Q || (Q = {}))[oe.BLAST = 1] = "BLAST", oe[oe.FIRE = 2] = "FIRE", oe[oe.BRAINTEASER = 3] = "BRAINTEASER", oe[oe.SURPRISE = 4] = "SURPRISE", oe[oe.AMAZING = 5] = "AMAZING", oe[oe.ADVENTURE = 6] = "ADVENTURE", oe[oe.COMPLEX = 7] = "COMPLEX", oe[oe.INSPIRING = 8] = "INSPIRING", oe[oe.LOVEDIT = 9] = "LOVEDIT", oe[oe.CREATIVE = 10] = "CREATIVE", oe[oe.COOL = 11] = "COOL", oe[oe.HILARIOUS = 12] = "HILARIOUS", Q;
						var oe
					})();
					const X = {
							[Q.BLAST]: "a blast",
							[Q.FIRE]: "so fire",
							[Q.BRAINTEASER]: "a brain teaser",
							[Q.SURPRISE]: "a surprise",
							[Q.AMAZING]: "amazing",
							[Q.ADVENTURE]: "an adventure",
							[Q.COMPLEX]: "complex",
							[Q.INSPIRING]: "inspiring",
							[Q.LOVEDIT]: "loved it",
							[Q.CREATIVE]: "so creative",
							[Q.COOL]: "too cool",
							[Q.HILARIOUS]: "hilarious"
						},
						te = {
							[Q.FIRE]: "assets/img/emoji-Sofire.svg",
							[Q.BLAST]: "assets/img/emo-blast.svg",
							[Q.BRAINTEASER]: "assets/img/emo-brainteaser.svg",
							[Q.SURPRISE]: "assets/img/emo-surprise.png",
							[Q.AMAZING]: "assets/img/emo-amazing.svg",
							[Q.ADVENTURE]: "assets/img/emoji-Anadventure.svg",
							[Q.COMPLEX]: "assets/img/emoji-complex.svg",
							[Q.INSPIRING]: "assets/img/emoji-Inspiring.svg",
							[Q.LOVEDIT]: "assets/img/emoji-loveit.svg",
							[Q.CREATIVE]: "assets/img/emo-creative.svg",
							[Q.COOL]: "assets/img/emoji-toocool.svg",
							[Q.HILARIOUS]: "assets/img/emoji-Hillarious.svg"
						}
				},
				9124: (be, ue, E) => {
					E.d(ue, {
						v: () => p
					});
					var p = (() => {
						return (y = p || (p = {}))[y.Admin = 1] = "Admin", y[y.Manager = 2] = "Manager", y[y.Staff = 3] = "Staff", y[y.HeadQuarters = 4] = "HeadQuarters", y[y.Parent = 5] = "Parent", p;
						var y
					})()
				},
				5303: (be, ue, E) => {
					E.d(ue, {
						e8: () => z,
						m6: () => Q,
						CC: () => N,
						ak: () => G,
						Fn: () => P,
						lH: () => Y.l
					});
					var p = E(3991),
						y = E(5734),
						D = E(4747);
					let z = (() => {
						class X {
							constructor(ie, oe) {
								this.http = ie, this.msalService = oe
							}
							login(ie, oe) {
								return this.http.post("center/api/login", {
									user: ie,
									password: oe
								})
							}
							getInfo() {
								return this.http.get("api/personnel")
							}
							logout() {
								this.msalService.logout()
							}
						}
						return X.\u0275fac = function(ie) {
							return new(ie || X)(p.LFG(y.eN), p.LFG(D.W2))
						}, X.\u0275prov = p.Yz7({
							token: X,
							factory: X.\u0275fac,
							providedIn: "root"
						}), X
					})();
					var ee = E(8588);
					let P = (() => {
							class X {
								constructor(ie) {
									this.http = ie, this.reviewPageIndex = 0, this.projectPageIndex = 0
								}
								getReviews(ie, oe = !1) {
									return this.reviewPageIndex = oe ? 1 : this.reviewPageIndex + 1, this.http.post("center/api/sensei/userMessage", {
										userCodeStatus: ie.userCodeStatus ?? [],
										pageIndex: this.reviewPageIndex,
										count: ee.KU,
										programId: ie.programId,
										courseId: ie.courseId,
										levelId: ie.levelId
									})
								}
								getReview(ie) {
									return this.http.get(`center/api/sensei/userMessage/${ie}`)
								}
								submitReview(ie, oe) {
									return this.http.patch(`center/api/sensei/userMessage?id=${ie}`, oe)
								}
							}
							return X.\u0275fac = function(ie) {
								return new(ie || X)(p.LFG(y.eN))
							}, X.\u0275prov = p.Yz7({
								token: X,
								factory: X.\u0275fac,
								providedIn: "root"
							}), X
						})(),
						N = (() => {
							class X {
								constructor(ie) {
									this.http = ie
								}
								getGuideFinder() {
									return this.http.get("center/api/sensei/guide")
								}
								getGuideLevelData(ie) {
									return this.http.get(`center/api/sensei/guide/level/${ie}`)
								}
							}
							return X.\u0275fac = function(ie) {
								return new(ie || X)(p.LFG(y.eN))
							}, X.\u0275prov = p.Yz7({
								token: X,
								factory: X.\u0275fac,
								providedIn: "root"
							}), X
						})();
					var Y = E(4149);
					let G = (() => {
							class X {
								constructor(ie) {
									this.http = ie
								}
								getNinjas(ie) {
									return this.http.get(`center/api/common/ninjas?sortBy=${ie.sortBy}&&displayFilters=${ie.displayFilters.join(",")}`)
								}
								updateNinjaBelts(ie) {
									return this.http.post("center/api/userLevel/beltchange", ie)
								}
								getNinjaLevelInfo(ie, oe, we) {
									return this.http.get(`center/api/common/ninjaInfo?courseId=${ie}&userId=${oe}&getBeltChangeInfo=${we}`)
								}
								getNinjaAchivements(ie, oe) {
									return this.http.get(`api/myninjas/achievements?courseId=${ie}&ninjaId=${oe}`)
								}
								getNinjaBeltInfo(ie, oe, we) {
									return this.http.get(`api/myninjas/beltinfo?levelId=${ie}&ninjaId=${oe}&currentLevelId=${we}`)
								}
								getNinjaFlaggedProjects(ie) {
									return this.http.get(`users/community/flagged-projects/ninjas/${ie}`)
								}
								updateNinjaInfo(ie) {
									return this.http.post("api/myninjas/update", ie)
								}
								updateNinjaBirthday(ie) {
									return this.http.post("api/myninjas/update/birthday", ie)
								}
								getNinjaInfo(ie) {
									return this.http.get(`api/myninjas/info/?ninjaId=${ie}`)
								}
								updateSessionInfo(ie) {
									const oe = new FormData;
									return oe.append("sessionSummary", ie.sessionSummary), ie.activityIcons.forEach(we => {
										oe.append("activityIcons", we)
									}), oe.append("ninjaId", ie.ninjaId), oe.append("sessionId", ie.sessionId), oe.append("beltName", ie.beltName), ie.fileName && oe.append("fileName", ie.fileName), ie.file && oe.append("file", ie.file), this.http.put("api/myninjas/session", oe)
								}
								getNinjaSessions(ie) {
									return this.http.get(`api/myninjas/sessioninfos?ninjaId=${ie}`)
								}
								saveSessionInfo(ie) {
									const oe = new FormData;
									return oe.append("sessionSummary", ie.sessionSummary), ie.activityIcons.forEach(we => {
										oe.append("activityIcons", we)
									}), oe.append("beltName", ie.beltName), oe.append("ninjaId", ie.ninjaId), ie.file && oe.append("file", ie.file), this.http.post("api/myninjas/session", oe)
								}
								getFile(ie) {
									return this.http.get(`api/myninjas/download/${ie}`, {
										responseType: "blob"
									})
								}
								deleteSession(ie) {
									return this.http.delete(`api/myninjas/delete/session/?sessionId=${ie.sessionId}&&fileName=${ie.fileName}`)
								}
							}
							return X.\u0275fac = function(ie) {
								return new(ie || X)(p.LFG(y.eN))
							}, X.\u0275prov = p.Yz7({
								token: X,
								factory: X.\u0275fac,
								providedIn: "root"
							}), X
						})(),
						Q = (() => {
							class X {
								constructor(ie) {
									this.http = ie
								}
								getNinjaParentEmails(ie) {
									return this.http.get(`api/emailDump/parent/emailDigest?name=${ie}`)
								}
								getSelectedParentEmail(ie) {
									return this.http.get(`api/emailDump/email/${ie}`)
								}
								sendSelectedParentEmail(ie) {
									return this.http.post("api/emailDump/sendemail", ie)
								}
							}
							return X.\u0275fac = function(ie) {
								return new(ie || X)(p.LFG(y.eN))
							}, X.\u0275prov = p.Yz7({
								token: X,
								factory: X.\u0275fac,
								providedIn: "root"
							}), X
						})()
				},
				2720: (be, ue, E) => {
					E.d(ue, {
						h: () => ee
					});
					var p = E(2358),
						y = E.n(p),
						D = E(9206),
						z = E(3991);
					let ee = (() => {
						class P {
							constructor() {
								y().init(D.N.mixpanelToken, {
									debug: !0
								}), y().set_config({
									persistence: "localStorage",
									secure_cookie: !0,
									ip: !0
								})
							}
							setUserProfileProperties(Y) {
								y().people.set(Y)
							}
							identifyUser(Y) {
								y().identify(Y)
							}
							timeEvent(Y) {
								y().time_event(Y)
							}
							trackEvent(Y, G = {}) {
								y().track(Y, G)
							}
							resetUserIdentity() {
								y().reset()
							}
						}
						return P.\u0275fac = function(Y) {
							return new(Y || P)
						}, P.\u0275prov = z.Yz7({
							token: P,
							factory: P.\u0275fac,
							providedIn: "root"
						}), P
					})()
				},
				4149: (be, ue, E) => {
					E.d(ue, {
						l: () => ee
					});
					var p = E(6425),
						y = E(3216),
						D = E(9754),
						z = E(3991);
					let ee = (() => {
						class P {
							constructor(Y) {
								this.router = Y, this.currentRoute = null, this.backStack = [{
									url: "/",
									state: void 0
								}], this.forwardStack = [], this.nextRoutesExists$ = new y.X(!1), this.previousRoutesExists$ = new y.X(!1), this.emitRouterStatus(), this.currentRoute = {
									url: this.router.url,
									state: this.router.getCurrentNavigation()?.extras.state
								}, this.router.events.pipe((0, D.h)(G => G instanceof p.m2)).subscribe(G => {
									const Q = G.urlAfterRedirects,
										X = this.router.getCurrentNavigation()?.extras.state,
										te = {
											url: Q,
											state: X
										};
									X?.navigatedByRouterService || (this.addRouteToStack(this.backStack, this.currentRoute), this.currentRoute = te, this.forwardStack = [], this.emitRouterStatus())
								})
							}
							goBack() {
								this.addRouteToStack(this.forwardStack, this.currentRoute);
								const Y = this.reduceStack(this.backStack);
								Y && this.navigate(Y)
							}
							goForward() {
								this.addRouteToStack(this.backStack, this.currentRoute);
								const Y = this.reduceStack(this.forwardStack);
								Y && this.navigate(Y)
							}
							reduceStack(Y) {
								const G = Y.pop();
								return this.emitRouterStatus(), G
							}
							addRouteToStack(Y, G) {
								G && Y.push(G), this.emitRouterStatus()
							}
							navigate(Y) {
								this.currentRoute = Y, this.router.navigateByUrl(Y.url, {
									state: {
										...Y.state,
										navigatedByRouterService: !0
									}
								})
							}
							emitRouterStatus() {
								this.nextRoutesExists$.next(this.forwardStack.length > 0), this.previousRoutesExists$.next(this.backStack.length > 0)
							}
						}
						return P.\u0275fac = function(Y) {
							return new(Y || P)(z.LFG(p.F0))
						}, P.\u0275prov = z.Yz7({
							token: P,
							factory: P.\u0275fac,
							providedIn: "root"
						}), P
					})()
				},
				8345: (be, ue, E) => {
					E.d(ue, {
						H: () => y,
						J: () => p
					});
					const p = (D, z) => Object.keys(D).length === Object.keys(z).length && Object.keys(D).every(ee => D[ee] === z[ee]),
						y = (D, z) => D.length === z.length && D.every(ee => z.includes(ee))
				},
				9206: (be, ue, E) => {
					E.d(ue, {
						N: () => p
					});
					const p = {
						name: "prod-us",
						production: !0,
						apiUrl: "https://api.impact.codeninjas.com",
						impactUrl: "https://impact.codeninjas.com/",
						makecodeSandboxUrl: "https://arcade.makecode.com/v1.12.32",
						auth: {
							clientId: "46e8cec8-a25b-4b50-9053-469e906a364e",
							authority: "https://codeninjasusb2c.b2clogin.com/codeninjasusb2c.onmicrosoft.com/b2c_1_signin",
							redirectUri: "https://sensei.codeninjas.com",
							knownAuthorities: ["codeninjasusb2c.b2clogin.com"],
							scope: ["https://codeninjasusb2c.onmicrosoft.com/82346e2e-022a-43b5-9205-f8808023cf40/Api.Access.Full"]
						},
						enableSentry: !1,
						sentryDSN: "https://8aab57f3a9a44db696b644799d282aab@o4504513766490112.ingest.sentry.io/4505113925976064",
						tracingSampleRate: .1,
						hotjarTrackingCode: "3596267",
						enableHotjarTracking: !0,
						mixpanelToken: "3e9bd6436b08dbe0a26e38bd8689c78f"
					}
				},
				1141: (be, ue, E) => {
					var p = E(4510),
						y = E(3991),
						D = E(5734),
						z = E(6425),
						ee = E(4747),
						P = E(2439),
						N = E(5424);
					let Y = (() => {
						class i {
							constructor(t) {
								this.store$ = t
							}
							ngOnInit() {
								setTimeout(() => {
									this.store$.dispatch(P.pU.logout())
								}, 5e3)
							}
						}
						return i.\u0275fac = function(t) {
							return new(t || i)(y.Y36(N.yh))
						}, i.\u0275cmp = y.Xpm({
							type: i,
							selectors: [
								["app-access"]
							],
							decls: 6,
							vars: 0,
							consts: [
								[1, "unauthorized-container"]
							],
							template: function(t, s) {
								1 & t && (y.TgZ(0, "div", 0)(1, "div")(2, "p"), y._uU(3, "You are not authorized to view this page. Please contact support team"), y.qZA(), y.TgZ(4, "p"), y._uU(5, "Redirecting to login page.."), y.qZA()()())
							},
							styles: ["[_nghost-%COMP%]{display:inline-block;width:30vw;height:100%;display:flex;align-items:center;align-content:center;text-align:center}[_nghost-%COMP%]   .unauthorized-container[_ngcontent-%COMP%]{background-color:#2b3354;font-weight:700;font-size:large;width:100vw}[_nghost-%COMP%]   .unauthorized-container[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]{padding:30px;border-radius:10px;color:#f5f5f5}[_nghost-%COMP%]   .unauthorized-container[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{padding:15px}"]
						}), i
					})();
					var G = E(9754),
						Q = E(5572),
						X = E(5391),
						te = E(7774);
					let ie = (() => {
						class i {
							constructor(t) {
								this.store$ = t, this.senseiName$ = this.store$.select(P.X1)
							}
							logout() {
								this.store$.dispatch(P.pU.logout())
							}
						}
						return i.\u0275fac = function(t) {
							return new(t || i)(y.Y36(N.yh))
						}, i.\u0275cmp = y.Xpm({
							type: i,
							selectors: [
								["app-side-nav"]
							],
							decls: 43,
							vars: 3,
							consts: [
								[1, "logo-wrapper"],
								["src", "/assets/img/logo.svg", "alt", ""],
								[1, "nav-wrapper"],
								[1, "nav-item-wrapper"],
								["routerLink", "/home", "routerLinkActive", "active"],
								["src", "/assets/img/home.svg", "alt", "Home"],
								["routerLink", "/reviews", "routerLinkActive", "active"],
								["src", "/assets/img/reviews.svg", "alt", "Reviews"],
								["routerLink", "/my-ninjas", "routerLinkActive", "active"],
								["src", "/assets/img/my-ninja.svg", "alt", "My Ninjas"],
								["routerLink", "/emaildigest", "routerLinkActive", "active"],
								["src", "/assets/img/emailicon.svg", "alt", "Email Digest"],
								["routerLink", "/support", "routerLinkActive", "active"],
								["src", "/assets/img/support.svg", "alt", "Support"],
								[1, "user-wrapper"],
								[1, "user-profile-wrapper"],
								[1, "user-image"],
								["src", "/assets/img/user.jpg", "alt", "User"],
								[1, "name-wrapper"],
								["data-hj-suppress", ""],
								[3, "click"],
								["src", "/assets/img/logout.svg", "alt", "Log out"]
							],
							template: function(t, s) {
								1 & t && (y.TgZ(0, "div", 0), y._UZ(1, "img", 1), y.qZA(), y.TgZ(2, "div", 2)(3, "ul", 3)(4, "li")(5, "a", 4)(6, "span"), y._UZ(7, "img", 5), y.qZA(), y._uU(8, " Home "), y.qZA()(), y.TgZ(9, "li")(10, "a", 6)(11, "span"), y._UZ(12, "img", 7), y.qZA(), y._uU(13, " Reviews "), y.qZA()(), y.TgZ(14, "li")(15, "a", 8)(16, "span"), y._UZ(17, "img", 9), y.qZA(), y._uU(18, " My Ninjas "), y.qZA()(), y.TgZ(19, "li")(20, "a", 10)(21, "span"), y._UZ(22, "img", 11), y.qZA(), y._uU(23, " Email Digest "), y.qZA()(), y.TgZ(24, "li")(25, "a", 12)(26, "span"), y._UZ(27, "img", 13), y.qZA(), y._uU(28, " Support "), y.qZA()()()(), y.TgZ(29, "div", 14)(30, "div", 15)(31, "div", 16), y._UZ(32, "img", 17), y.qZA(), y.TgZ(33, "div", 18)(34, "div", 19), y._uU(35), y.ALo(36, "async"), y.qZA()()(), y.TgZ(37, "ul", 3)(38, "li")(39, "a", 20), y.NdJ("click", function() {
									return s.logout()
								}), y.TgZ(40, "span"), y._UZ(41, "img", 21), y.qZA(), y._uU(42, " Log Out "), y.qZA()()()()), 2 & t && (y.xp6(35), y.Oqu(y.lcZ(36, 1, s.senseiName$)))
							},
							dependencies: [z.rH, z.Od, te.Ov],
							styles: ["[_nghost-%COMP%]{flex-basis:84px;background-color:#070c21;display:flex;flex-direction:column;justify-content:space-between;align-items:center;padding:30px 5px}ul.nav-item-wrapper[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]:last-child{margin-bottom:0}ul.nav-item-wrapper[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{font-size:10px;line-height:12px;font-weight:400;letter-spacing:0px;color:#f5f5f5;text-align:center;display:block;padding:11px;border-radius:8px;margin-bottom:15px;opacity:.6}ul.nav-item-wrapper[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{display:block}ul.nav-item-wrapper[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{max-height:19px;margin-bottom:5px;transition:all .3s cubic-bezier(.25,.8,.25,1)}ul.nav-item-wrapper[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]   a.active[_ngcontent-%COMP%]{background-color:#40455e;opacity:1}ul.nav-item-wrapper[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]:hover   a[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{transform:scale(1.2)}.user-wrapper[_ngcontent-%COMP%]   .user-profile-wrapper[_ngcontent-%COMP%]{text-align:center;margin-bottom:35px}.user-wrapper[_ngcontent-%COMP%]   .user-profile-wrapper[_ngcontent-%COMP%]   .user-image[_ngcontent-%COMP%]{width:52px;height:52px;border-radius:50%;overflow:hidden;margin:0 auto 5px}.user-wrapper[_ngcontent-%COMP%]   .user-profile-wrapper[_ngcontent-%COMP%]   .name-wrapper[_ngcontent-%COMP%]{font-size:10px;line-height:12px;font-weight:400;letter-spacing:0px;color:#f5f5f5}.user-wrapper[_ngcontent-%COMP%]   ul.nav-item-wrapper[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]{opacity:1}"]
						}), i
					})();

					function oe(i, e) {
						1 & i && y._UZ(0, "app-side-nav")
					}

					function we(i, e) {
						1 & i && (y.TgZ(0, "div", 2), y._UZ(1, "router-outlet"), y.qZA())
					}
					const Le = [{
						path: "",
						canActivate: [ee.RQ],
						canActivateChild: [ee.RQ],
						children: [{
							path: "",
							redirectTo: "/home",
							pathMatch: "full"
						}]
					}, {
						path: "",
						component: (() => {
							class i {
								constructor(t, s) {
									this.store$ = t, this.dialog = s, this.hasAccess = !1
								}
								ngOnInit() {
									this.store$.dispatch(P.pU.getUserProfileData()), this.store$.select(P.dy).pipe((0, G.h)(t => !!t)).subscribe(t => {
										t?.personnelType === Q.vY.Parent.toString() ? (this.openAccessPopup(), this.hasAccess = !1) : this.hasAccess = !0
									})
								}
								openAccessPopup() {
									this.dialog.open(Y)
								}
							}
							return i.\u0275fac = function(t) {
								return new(t || i)(y.Y36(N.yh), y.Y36(X.uw))
							}, i.\u0275cmp = y.Xpm({
								type: i,
								selectors: [
									["app-default"]
								],
								decls: 2,
								vars: 2,
								consts: [
									[4, "ngIf"],
									["class", "main", 4, "ngIf"],
									[1, "main"]
								],
								template: function(t, s) {
									1 & t && (y.YNc(0, oe, 1, 0, "app-side-nav", 0), y.YNc(1, we, 2, 0, "div", 1)), 2 & t && (y.Q6J("ngIf", s.hasAccess), y.xp6(1), y.Q6J("ngIf", s.hasAccess))
								},
								dependencies: [te.O5, z.lC, ie],
								styles: ["[_nghost-%COMP%]{display:flex;width:100%;height:100%}.main[_ngcontent-%COMP%]{flex:1;min-width:0}"]
							}), i
						})(),
						canActivateChild: [ee.RQ],
						children: [{
							path: "home",
							loadChildren: () => Promise.all([E.e(504), E.e(592), E.e(392)]).then(E.bind(E, 5392)).then(i => i.HomeModule)
						}, {
							path: "my-ninjas",
							loadChildren: () => Promise.all([E.e(504), E.e(592), E.e(116)]).then(E.bind(E, 2697)).then(i => i.MyNinjasModule)
						}, {
							path: "emaildigest",
							loadChildren: () => Promise.all([E.e(504), E.e(592), E.e(595)]).then(E.bind(E, 4595)).then(i => i.EmailDigestModule)
						}, {
							path: "reviews",
							loadChildren: () => Promise.all([E.e(504), E.e(592), E.e(425)]).then(E.bind(E, 425)).then(i => i.ReviewsModule)
						}, {
							path: "support",
							loadChildren: () => Promise.all([E.e(504), E.e(592), E.e(358)]).then(E.bind(E, 7358)).then(i => i.SupportModule)
						}, {
							path: "support",
							loadChildren: () => Promise.all([E.e(504), E.e(592), E.e(358)]).then(E.bind(E, 7358)).then(i => i.SupportModule)
						}]
					}, {
						path: "**",
						redirectTo: "/home"
					}];
					var je = E(422);
					const Ce = "@ngrx/router-store/request",
						xe = ((0, N.PH)(Ce, (0, N.Ky)()), "@ngrx/router-store/navigation"),
						Ue = ((0, N.PH)(xe, (0, N.Ky)()), "@ngrx/router-store/cancel"),
						Ge = ((0, N.PH)(Ue, (0, N.Ky)()), "@ngrx/router-store/error"),
						nt = ((0, N.PH)(Ge, (0, N.Ky)()), "@ngrx/router-store/navigated");

					function at(i, e) {
						const t = e;
						switch (t.type) {
							case xe:
							case Ge:
							case Ue:
								return {
									state: t.payload.routerState, navigationId: t.payload.event.id
								};
							default:
								return i
						}
					}(0, N.PH)(nt, (0, N.Ky)());
					class lt {
						serialize(e) {
							return {
								root: this.serializeRoute(e.root),
								url: e.url
							}
						}
						serializeRoute(e) {
							const t = e.children.map(s => this.serializeRoute(s));
							return {
								params: e.params,
								data: e.data,
								url: e.url,
								outlet: e.outlet,
								title: e.title,
								routeConfig: e.routeConfig ? {
									path: e.routeConfig.path,
									pathMatch: e.routeConfig.pathMatch,
									redirectTo: e.routeConfig.redirectTo,
									outlet: e.routeConfig.outlet,
									title: "string" == typeof e.routeConfig.title ? e.routeConfig.title : void 0
								} : null,
								queryParams: e.queryParams,
								fragment: e.fragment,
								firstChild: t[0],
								children: t
							}
						}
					}
					var et = (() => {
						return (i = et || (et = {}))[i.PreActivation = 1] = "PreActivation", i[i.PostActivation = 2] = "PostActivation", et;
						var i
					})();
					const Se = "router",
						Be = new y.OlP("@ngrx/router-store Internal Configuration"),
						ze = new y.OlP("@ngrx/router-store Configuration");

					function it(i) {
						return {
							stateKey: Se,
							serializer: lt,
							navigationActionTiming: et.PreActivation,
							...i
						}
					}
					class ce {
						serialize(e) {
							return {
								root: this.serializeRoute(e.root),
								url: e.url
							}
						}
						serializeRoute(e) {
							const t = e.children.map(s => this.serializeRoute(s));
							return {
								params: e.params,
								paramMap: e.paramMap,
								data: e.data,
								url: e.url,
								outlet: e.outlet,
								title: e.title,
								routeConfig: e.routeConfig ? {
									component: e.routeConfig.component,
									path: e.routeConfig.path,
									pathMatch: e.routeConfig.pathMatch,
									redirectTo: e.routeConfig.redirectTo,
									outlet: e.routeConfig.outlet,
									title: e.routeConfig.title
								} : null,
								queryParams: e.queryParams,
								queryParamMap: e.queryParamMap,
								fragment: e.fragment,
								component: e.routeConfig ? e.routeConfig.component : void 0,
								root: void 0,
								parent: void 0,
								firstChild: t[0],
								pathFromRoot: void 0,
								children: t
							}
						}
					}
					class ht {}
					var Pe = (() => {
						return (i = Pe || (Pe = {}))[i.NONE = 1] = "NONE", i[i.ROUTER = 2] = "ROUTER", i[i.STORE = 3] = "STORE", Pe;
						var i
					})();
					let pt = (() => {
						class i {
							constructor(t, s, c, u, h, m) {
								this.store = t, this.router = s, this.serializer = c, this.errorHandler = u, this.config = h, this.activeRuntimeChecks = m, this.lastEvent = null, this.routerState = null, this.trigger = Pe.NONE, this.stateKey = this.config.stateKey, !(0, N.rM)() && (0, y.X6Q)() && (m?.strictActionSerializability || m?.strictStateSerializability) && this.serializer instanceof ce && console.warn("@ngrx/router-store: The serializability runtime checks cannot be enabled with the FullRouterStateSerializer. The FullRouterStateSerializer has an unserializable router state and actions that are not serializable. To use the serializability runtime checks either use the MinimalRouterStateSerializer or implement a custom router state serializer."), this.setUpStoreStateListener(), this.setUpRouterEventsListener()
							}
							setUpStoreStateListener() {
								this.store.pipe((0, N.Ys)(this.stateKey), (0, je.M)(this.store)).subscribe(([t, s]) => {
									this.navigateIfNeeded(t, s)
								})
							}
							navigateIfNeeded(t, s) {
								if (!t || !t.state || this.trigger === Pe.ROUTER || this.lastEvent instanceof z.OD) return;
								const c = t.state.url;
								(function Bt(i, e) {
									return ot(i) === ot(e)
								})(this.router.url, c) || (this.storeState = s, this.trigger = Pe.STORE, this.router.navigateByUrl(c).catch(u => {
									this.errorHandler.handleError(u)
								}))
							}
							setUpRouterEventsListener() {
								const t = this.config.navigationActionTiming === et.PostActivation;
								let s;
								this.router.events.pipe((0, je.M)(this.store)).subscribe(([c, u]) => {
									this.lastEvent = c, c instanceof z.OD ? (this.routerState = this.serializer.serialize(this.router.routerState.snapshot), this.trigger !== Pe.STORE && (this.storeState = u, this.dispatchRouterRequest(c))) : c instanceof z.R9 ? (s = c, !t && this.trigger !== Pe.STORE && this.dispatchRouterNavigation(c)) : c instanceof z.gk ? (this.dispatchRouterCancel(c), this.reset()) : c instanceof z.Q3 ? (this.dispatchRouterError(c), this.reset()) : c instanceof z.m2 && (this.trigger !== Pe.STORE && (t && this.dispatchRouterNavigation(s), this.dispatchRouterNavigated(c)), this.reset())
								})
							}
							dispatchRouterRequest(t) {
								this.dispatchRouterAction(Ce, {
									event: t
								})
							}
							dispatchRouterNavigation(t) {
								const s = this.serializer.serialize(t.state);
								this.dispatchRouterAction(xe, {
									routerState: s,
									event: new z.R9(t.id, t.url, t.urlAfterRedirects, s)
								})
							}
							dispatchRouterCancel(t) {
								this.dispatchRouterAction(Ue, {
									storeState: this.storeState,
									event: t
								})
							}
							dispatchRouterError(t) {
								this.dispatchRouterAction(Ge, {
									storeState: this.storeState,
									event: new z.Q3(t.id, t.url, `${t}`)
								})
							}
							dispatchRouterNavigated(t) {
								const s = this.serializer.serialize(this.router.routerState.snapshot);
								this.dispatchRouterAction(nt, {
									event: t,
									routerState: s
								})
							}
							dispatchRouterAction(t, s) {
								this.trigger = Pe.ROUTER;
								try {
									this.store.dispatch({
										type: t,
										payload: {
											routerState: this.routerState,
											...s,
											event: 0 === this.config.routerState ? s.event : {
												id: s.event.id,
												url: s.event.url,
												urlAfterRedirects: s.event.urlAfterRedirects
											}
										}
									})
								} finally {
									this.trigger = Pe.NONE
								}
							}
							reset() {
								this.trigger = Pe.NONE, this.storeState = null, this.routerState = null
							}
						}
						return i.\u0275fac = function(t) {
							return new(t || i)(y.LFG(N.yh), y.LFG(z.F0), y.LFG(ht), y.LFG(y.qLn), y.LFG(ze), y.LFG(N.hg))
						}, i.\u0275prov = y.Yz7({
							token: i,
							factory: i.\u0275fac
						}), i
					})();

					function ot(i) {
						return i?.length > 0 && "/" === i[i.length - 1] ? i.substring(0, i.length - 1) : i
					}

					function Vt(i = {}) {
						return (0, y.MR2)([{
							provide: Be,
							useValue: i
						}, {
							provide: ze,
							useFactory: it,
							deps: [Be]
						}, {
							provide: ht,
							useClass: i.serializer ? i.serializer : 0 === i.routerState ? ce : lt
						}, {
							provide: y.Xts,
							multi: !0,
							useFactory: () => () => (0, y.f3M)(pt)
						}, pt])
					}
					let Qt = (() => {
						class i {
							static forRoot(t = {}) {
								return {
									ngModule: i,
									providers: [Vt(t)]
								}
							}
						}
						return i.\u0275fac = function(t) {
							return new(t || i)
						}, i.\u0275mod = y.oAB({
							type: i
						}), i.\u0275inj = y.cJS({}), i
					})();
					const mn = {
						stateKey: "router"
					};
					let Un = (() => {
						class i {}
						return i.\u0275fac = function(t) {
							return new(t || i)
						}, i.\u0275mod = y.oAB({
							type: i
						}), i.\u0275inj = y.cJS({
							imports: [N.Aw.forFeature(mn.stateKey, at), Qt.forRoot(mn), N.Aw, Qt]
						}), i
					})();
					const Kn = window !== window.parent && !window.opener;
					let Vn = (() => {
						class i {}
						return i.\u0275fac = function(t) {
							return new(t || i)
						}, i.\u0275mod = y.oAB({
							type: i
						}), i.\u0275inj = y.cJS({
							imports: [z.Bz.forRoot(Le, {
								initialNavigation: Kn ? "disabled" : "enabledNonBlocking"
							}), Un, z.Bz]
						}), i
					})();
					var Zt = E(4337),
						bn = E(8264),
						Bn = E(3),
						qt = E(9206),
						tn = E(2112),
						en = E(2720);
					let Qn = (() => {
						class i {
							constructor(t, s, c, u) {
								this.mixpanelService = t, this.msalBroadcastService = s, this.doc = c, this.store$ = u, this._destroying$ = new bn.x
							}
							setHotjarTracking() {
								const t = this.doc.createElement("script");
								t.type = "text/javascript", t.innerHTML = `(function(h,o,t,j,a,r){\n      h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};\n      h._hjSettings={hjid:${qt.N.hotjarTrackingCode},hjsv:6};\n      a=o.getElementsByTagName('head')[0];\n      r=o.createElement('script');r.async=1;\n      r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;\n      a.appendChild(r);\n  })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');`, this.doc.getElementsByTagName("head")[0].appendChild(t)
							}
							ngOnInit() {
								this.store$.dispatch(tn.p.getFinder()), qt.N.enableHotjarTracking && this.setHotjarTracking(), this.msalBroadcastService.msalSubject$.pipe((0, G.h)(t => t.eventType === Zt.t.LOGIN_SUCCESS), (0, Bn.R)(this._destroying$)).subscribe(t => {
									t.payload?.account?.localAccountId && this.mixpanelService.identifyUser(t.payload?.account?.localAccountId), this.mixpanelService.trackEvent("Log In"), this.mixpanelService.setUserProfileProperties({
										$email: t.payload?.account?.username
									})
								})
							}
							ngOnDestroy() {
								this._destroying$.next(), this._destroying$.complete()
							}
						}
						return i.\u0275fac = function(t) {
							return new(t || i)(y.Y36(en.h), y.Y36(ee.J$), y.Y36(te.K0), y.Y36(N.yh))
						}, i.\u0275cmp = y.Xpm({
							type: i,
							selectors: [
								["app-root"]
							],
							decls: 2,
							vars: 0,
							consts: [
								[1, "app-wrapper"]
							],
							template: function(t, s) {
								1 & t && (y.TgZ(0, "div", 0), y._UZ(1, "router-outlet"), y.qZA())
							},
							dependencies: [z.lC],
							styles: [".app-wrapper[_ngcontent-%COMP%]{height:100vh;width:100%;overflow:hidden;background-image:url(/assets/img/main-bg.png);background-size:cover;background-color:#11162b;display:flex;color:#f5f5f5}"]
						}), i
					})();
					var Wn = E(9702),
						Nn = E(116);
					const hr = [function ar(i) {
						return function(e, t) {
							return i(t.type === P.pU.logout.type ? void 0 : e, t)
						}
					}];
					let un = (() => {
						class i {}
						return i.\u0275fac = function(t) {
							return new(t || i)
						}, i.\u0275mod = y.oAB({
							type: i
						}), i.\u0275inj = y.cJS({
							imports: [te.ez, N.Aw.forRoot({}, {
								metaReducers: hr,
								runtimeChecks: {
									strictStateImmutability: !0,
									strictActionImmutability: !0,
									strictStateSerializability: !0,
									strictActionSerializability: !0,
									strictActionTypeUniqueness: !0
								}
							}), Wn.sQ.forRoot(), Nn.FT.instrument({
								maxAge: 25,
								logOnly: qt.N.production
							})]
						}), i
					})();
					var Nt = E(6191);

					function pe(i) {
						return new y.vHH(3e3, !1)
					}

					function ei() {
						return typeof window < "u" && typeof window.document < "u"
					}

					function ti() {
						return typeof process < "u" && "[object process]" === {}.toString.call(process)
					}

					function Sr(i) {
						switch (i.length) {
							case 0:
								return new Nt.ZN;
							case 1:
								return i[0];
							default:
								return new Nt.ZE(i)
						}
					}

					function $r(i, e, t, s, c = new Map, u = new Map) {
						const h = [],
							m = [];
						let S = -1,
							O = null;
						if (s.forEach($ => {
								const le = $.get("offset"),
									Re = le == S,
									Ae = Re && O || new Map;
								$.forEach((Ze, wt) => {
									let Wt = wt,
										Yt = Ze;
									if ("offset" !== wt) switch (Wt = e.normalizePropertyName(Wt, h), Yt) {
										case Nt.k1:
											Yt = c.get(wt);
											break;
										case Nt.l3:
											Yt = u.get(wt);
											break;
										default:
											Yt = e.normalizeStyleValue(wt, Wt, Yt, h)
									}
									Ae.set(Wt, Yt)
								}), Re || m.push(Ae), O = Ae, S = le
							}), h.length) throw function Dn(i) {
							return new y.vHH(3502, !1)
						}();
						return m
					}

					function Ur(i, e, t, s) {
						switch (e) {
							case "start":
								i.onStart(() => s(t && Ve(t, "start", i)));
								break;
							case "done":
								i.onDone(() => s(t && Ve(t, "done", i)));
								break;
							case "destroy":
								i.onDestroy(() => s(t && Ve(t, "destroy", i)))
						}
					}

					function Ve(i, e, t) {
						const u = V(i.element, i.triggerName, i.fromState, i.toState, e || i.phaseName, t.totalTime ?? i.totalTime, !!t.disabled),
							h = i._data;
						return null != h && (u._data = h), u
					}

					function V(i, e, t, s, c = "", u = 0, h) {
						return {
							element: i,
							triggerName: e,
							fromState: t,
							toState: s,
							phaseName: c,
							totalTime: u,
							disabled: !!h
						}
					}

					function U(i, e, t) {
						let s = i.get(e);
						return s || i.set(e, s = t), s
					}

					function fe(i) {
						const e = i.indexOf(":");
						return [i.substring(1, e), i.slice(e + 1)]
					}
					let f = (i, e) => !1,
						T = (i, e, t) => [],
						L = null;

					function K(i) {
						const e = i.parentNode || i.host;
						return e === L ? null : e
					}(ti() || typeof Element < "u") && (ei() ? (L = (() => document.documentElement)(), f = (i, e) => {
						for (; e;) {
							if (e === i) return !0;
							e = K(e)
						}
						return !1
					}) : f = (i, e) => i.contains(e), T = (i, e, t) => {
						if (t) return Array.from(i.querySelectorAll(e));
						const s = i.querySelector(e);
						return s ? [s] : []
					});
					let He = null,
						gt = !1;
					const Gt = f,
						Rt = T;
					let Jt = (() => {
							class i {
								validateStyleProperty(t) {
									return function st(i) {
										He || (He = function Et() {
											return typeof document < "u" ? document.body : null
										}() || {}, gt = !!He.style && "WebkitAppearance" in He.style);
										let e = !0;
										return He.style && ! function ye(i) {
											return "ebkit" == i.substring(1, 6)
										}(i) && (e = i in He.style, !e && gt && (e = "Webkit" + i.charAt(0).toUpperCase() + i.slice(1) in He.style)), e
									}(t)
								}
								matchesElement(t, s) {
									return !1
								}
								containsElement(t, s) {
									return Gt(t, s)
								}
								getParentElement(t) {
									return K(t)
								}
								query(t, s, c) {
									return Rt(t, s, c)
								}
								computeStyle(t, s, c) {
									return c || ""
								}
								animate(t, s, c, u, h, m = [], S) {
									return new Nt.ZN(c, u)
								}
							}
							return i.\u0275fac = function(t) {
								return new(t || i)
							}, i.\u0275prov = y.Yz7({
								token: i,
								factory: i.\u0275fac
							}), i
						})(),
						Mn = (() => {
							class i {}
							return i.NOOP = new Jt, i
						})();
					const Cn = 1e3,
						Br = "ng-enter",
						me = "ng-leave",
						tt = "ng-trigger",
						qe = ".ng-trigger",
						dt = "ng-animating",
						Dt = ".ng-animating";

					function Mt(i) {
						if ("number" == typeof i) return i;
						const e = i.match(/^(-?[\.\d]+)(m?s)/);
						return !e || e.length < 2 ? 0 : Fn(parseFloat(e[1]), e[2])
					}

					function Fn(i, e) {
						return "s" === e ? i * Cn : i
					}

					function ir(i, e, t) {
						return i.hasOwnProperty("duration") ? i : function cr(i, e, t) {
							let c, u = 0,
								h = "";
							if ("string" == typeof i) {
								const m = i.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);
								if (null === m) return e.push(pe()), {
									duration: 0,
									delay: 0,
									easing: ""
								};
								c = Fn(parseFloat(m[1]), m[2]);
								const S = m[3];
								null != S && (u = Fn(parseFloat(S), m[4]));
								const O = m[5];
								O && (h = O)
							} else c = i;
							if (!t) {
								let m = !1,
									S = e.length;
								c < 0 && (e.push(function Te() {
									return new y.vHH(3100, !1)
								}()), m = !0), u < 0 && (e.push(function Je() {
									return new y.vHH(3101, !1)
								}()), m = !0), m && e.splice(S, 0, pe())
							}
							return {
								duration: c,
								delay: u,
								easing: h
							}
						}(i, e, t)
					}

					function br(i, e = {}) {
						return Object.keys(i).forEach(t => {
							e[t] = i[t]
						}), e
					}

					function $n(i) {
						const e = new Map;
						return Object.keys(i).forEach(t => {
							e.set(t, i[t])
						}), e
					}

					function lr(i, e = new Map, t) {
						if (t)
							for (let [s, c] of t) e.set(s, c);
						for (let [s, c] of i) e.set(s, c);
						return e
					}

					function gr(i, e, t) {
						return t ? e + ":" + t + ";" : ""
					}

					function xi(i) {
						let e = "";
						for (let t = 0; t < i.style.length; t++) {
							const s = i.style.item(t);
							e += gr(0, s, i.style.getPropertyValue(s))
						}
						for (const t in i.style) i.style.hasOwnProperty(t) && !t.startsWith("_") && (e += gr(0, oa(t), i.style[t]));
						i.setAttribute("style", e)
					}

					function ni(i, e, t) {
						i.style && (e.forEach((s, c) => {
							const u = Jo(c);
							t && !t.has(c) && t.set(c, i.style[u]), i.style[u] = s
						}), ti() && xi(i))
					}

					function Si(i, e) {
						i.style && (e.forEach((t, s) => {
							const c = Jo(s);
							i.style[c] = ""
						}), ti() && xi(i))
					}

					function ri(i) {
						return Array.isArray(i) ? 1 == i.length ? i[0] : (0, Nt.vP)(i) : i
					}
					const bs = new RegExp("{{\\s*(.+?)\\s*}}", "g");

					function ia(i) {
						let e = [];
						if ("string" == typeof i) {
							let t;
							for (; t = bs.exec(i);) e.push(t[1]);
							bs.lastIndex = 0
						}
						return e
					}

					function qi(i, e, t) {
						const s = i.toString(),
							c = s.replace(bs, (u, h) => {
								let m = e[h];
								return null == m && (t.push(function Ht(i) {
									return new y.vHH(3003, !1)
								}()), m = ""), m.toString()
							});
						return c == s ? i : c
					}

					function Qo(i) {
						const e = [];
						let t = i.next();
						for (; !t.done;) e.push(t.value), t = i.next();
						return e
					}
					const Is = /-+([a-z0-9])/g;

					function Jo(i) {
						return i.replace(Is, (...e) => e[1].toUpperCase())
					}

					function oa(i) {
						return i.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()
					}

					function Nr(i, e, t) {
						switch (e.type) {
							case 7:
								return i.visitTrigger(e, t);
							case 0:
								return i.visitState(e, t);
							case 1:
								return i.visitTransition(e, t);
							case 2:
								return i.visitSequence(e, t);
							case 3:
								return i.visitGroup(e, t);
							case 4:
								return i.visitAnimate(e, t);
							case 5:
								return i.visitKeyframes(e, t);
							case 6:
								return i.visitStyle(e, t);
							case 8:
								return i.visitReference(e, t);
							case 9:
								return i.visitAnimateChild(e, t);
							case 10:
								return i.visitAnimateRef(e, t);
							case 11:
								return i.visitQuery(e, t);
							case 12:
								return i.visitStagger(e, t);
							default:
								throw function pn(i) {
									return new y.vHH(3004, !1)
								}()
						}
					}

					function Ds(i, e) {
						return window.getComputedStyle(i)[e]
					}
					const so = "*";

					function ua(i, e) {
						const t = [];
						return "string" == typeof i ? i.split(/\s*,\s*/).forEach(s => function Qi(i, e, t) {
							if (":" == i[0]) {
								const S = function ol(i, e) {
									switch (i) {
										case ":enter":
											return "void => *";
										case ":leave":
											return "* => void";
										case ":increment":
											return (t, s) => parseFloat(s) > parseFloat(t);
										case ":decrement":
											return (t, s) => parseFloat(s) < parseFloat(t);
										default:
											return e.push(function xt(i) {
												return new y.vHH(3016, !1)
											}()), "* => *"
									}
								}(i, t);
								if ("function" == typeof S) return void e.push(S);
								i = S
							}
							const s = i.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
							if (null == s || s.length < 4) return t.push(function an(i) {
								return new y.vHH(3015, !1)
							}()), e;
							const c = s[1],
								u = s[2],
								h = s[3];
							e.push(Rs(c, h));
							"<" == u[0] && !(c == so && h == so) && e.push(Rs(h, c))
						}(s, t, e)) : t.push(i), t
					}
					const ko = new Set(["true", "1"]),
						ao = new Set(["false", "0"]);

					function Rs(i, e) {
						const t = ko.has(i) || ao.has(i),
							s = ko.has(e) || ao.has(e);
						return (c, u) => {
							let h = i == so || i == c,
								m = e == so || e == u;
							return !h && t && "boolean" == typeof c && (h = c ? ko.has(i) : ao.has(i)), !m && s && "boolean" == typeof u && (m = u ? ko.has(e) : ao.has(e)), h && m
						}
					}
					const cc = new RegExp("s*:selfs*,?", "g");

					function ha(i, e, t, s) {
						return new Zo(i).build(e, t, s)
					}
					class Zo {
						constructor(e) {
							this._driver = e
						}
						build(e, t, s) {
							const c = new fa(t);
							return this._resetContextStyleTimingState(c), Nr(this, ri(e), c)
						}
						_resetContextStyleTimingState(e) {
							e.currentQuerySelector = "", e.collectedStyles = new Map, e.collectedStyles.set("", new Map), e.currentTime = 0
						}
						visitTrigger(e, t) {
							let s = t.queryCount = 0,
								c = t.depCount = 0;
							const u = [],
								h = [];
							return "@" == e.name.charAt(0) && t.errors.push(function hn() {
								return new y.vHH(3006, !1)
							}()), e.definitions.forEach(m => {
								if (this._resetContextStyleTimingState(t), 0 == m.type) {
									const S = m,
										O = S.name;
									O.toString().split(/\s*,\s*/).forEach($ => {
										S.name = $, u.push(this.visitState(S, t))
									}), S.name = O
								} else if (1 == m.type) {
									const S = this.visitTransition(m, t);
									s += S.queryCount, c += S.depCount, h.push(S)
								} else t.errors.push(function kt() {
									return new y.vHH(3007, !1)
								}())
							}), {
								type: 7,
								name: e.name,
								states: u,
								transitions: h,
								queryCount: s,
								depCount: c,
								options: null
							}
						}
						visitState(e, t) {
							const s = this.visitStyle(e.styles, t),
								c = e.options && e.options.params || null;
							if (s.containsDynamicStyles) {
								const u = new Set,
									h = c || {};
								s.styles.forEach(m => {
									m instanceof Map && m.forEach(S => {
										ia(S).forEach(O => {
											h.hasOwnProperty(O) || u.add(O)
										})
									})
								}), u.size && (Qo(u.values()), t.errors.push(function ct(i, e) {
									return new y.vHH(3008, !1)
								}()))
							}
							return {
								type: 0,
								name: e.name,
								style: s,
								options: c ? {
									params: c
								} : null
							}
						}
						visitTransition(e, t) {
							t.queryCount = 0, t.depCount = 0;
							const s = Nr(this, ri(e.animation), t);
							return {
								type: 1,
								matchers: ua(e.expr, t.errors),
								animation: s,
								queryCount: t.queryCount,
								depCount: t.depCount,
								options: Fi(e.options)
							}
						}
						visitSequence(e, t) {
							return {
								type: 2,
								steps: e.steps.map(s => Nr(this, s, t)),
								options: Fi(e.options)
							}
						}
						visitGroup(e, t) {
							const s = t.currentTime;
							let c = 0;
							const u = e.steps.map(h => {
								t.currentTime = s;
								const m = Nr(this, h, t);
								return c = Math.max(c, t.currentTime), m
							});
							return t.currentTime = c, {
								type: 3,
								steps: u,
								options: Fi(e.options)
							}
						}
						visitAnimate(e, t) {
							const s = function sr(i, e) {
								if (i.hasOwnProperty("duration")) return i;
								if ("number" == typeof i) return Ai(ir(i, e).duration, 0, "");
								const t = i;
								if (t.split(/\s+/).some(u => "{" == u.charAt(0) && "{" == u.charAt(1))) {
									const u = Ai(0, 0, "");
									return u.dynamic = !0, u.strValue = t, u
								}
								const c = ir(t, e);
								return Ai(c.duration, c.delay, c.easing)
							}(e.timings, t.errors);
							t.currentAnimateTimings = s;
							let c, u = e.styles ? e.styles : (0, Nt.oB)({});
							if (5 == u.type) c = this.visitKeyframes(u, t);
							else {
								let h = e.styles,
									m = !1;
								if (!h) {
									m = !0;
									const O = {};
									s.easing && (O.easing = s.easing), h = (0, Nt.oB)(O)
								}
								t.currentTime += s.duration + s.delay;
								const S = this.visitStyle(h, t);
								S.isEmptyStep = m, c = S
							}
							return t.currentAnimateTimings = null, {
								type: 4,
								timings: s,
								style: c,
								options: null
							}
						}
						visitStyle(e, t) {
							const s = this._makeStyleAst(e, t);
							return this._validateStyleAst(s, t), s
						}
						_makeStyleAst(e, t) {
							const s = [],
								c = Array.isArray(e.styles) ? e.styles : [e.styles];
							for (let m of c) "string" == typeof m ? m === Nt.l3 ? s.push(m) : t.errors.push(new y.vHH(3002, !1)) : s.push($n(m));
							let u = !1,
								h = null;
							return s.forEach(m => {
								if (m instanceof Map && (m.has("easing") && (h = m.get("easing"), m.delete("easing")), !u))
									for (let S of m.values())
										if (S.toString().indexOf("{{") >= 0) {
											u = !0;
											break
										}
							}), {
								type: 6,
								styles: s,
								easing: h,
								offset: e.offset,
								containsDynamicStyles: u,
								options: null
							}
						}
						_validateStyleAst(e, t) {
							const s = t.currentAnimateTimings;
							let c = t.currentTime,
								u = t.currentTime;
							s && u > 0 && (u -= s.duration + s.delay), e.styles.forEach(h => {
								"string" != typeof h && h.forEach((m, S) => {
									const O = t.collectedStyles.get(t.currentQuerySelector),
										$ = O.get(S);
									let le = !0;
									$ && (u != c && u >= $.startTime && c <= $.endTime && (t.errors.push(function J(i, e, t, s, c) {
										return new y.vHH(3010, !1)
									}()), le = !1), u = $.startTime), le && O.set(S, {
										startTime: u,
										endTime: c
									}), t.options && function oo(i, e, t) {
										const s = e.params || {},
											c = ia(i);
										c.length && c.forEach(u => {
											s.hasOwnProperty(u) || t.push(function yt(i) {
												return new y.vHH(3001, !1)
											}())
										})
									}(m, t.options, t.errors)
								})
							})
						}
						visitKeyframes(e, t) {
							const s = {
								type: 5,
								styles: [],
								options: null
							};
							if (!t.currentAnimateTimings) return t.errors.push(function k() {
								return new y.vHH(3011, !1)
							}()), s;
							let u = 0;
							const h = [];
							let m = !1,
								S = !1,
								O = 0;
							const $ = e.steps.map(Yt => {
								const sn = this._makeStyleAst(Yt, t);
								let kn = null != sn.offset ? sn.offset : function es(i) {
										if ("string" == typeof i) return null;
										let e = null;
										if (Array.isArray(i)) i.forEach(t => {
											if (t instanceof Map && t.has("offset")) {
												const s = t;
												e = parseFloat(s.get("offset")), s.delete("offset")
											}
										});
										else if (i instanceof Map && i.has("offset")) {
											const t = i;
											e = parseFloat(t.get("offset")), t.delete("offset")
										}
										return e
									}(sn.styles),
									fr = 0;
								return null != kn && (u++, fr = sn.offset = kn), S = S || fr < 0 || fr > 1, m = m || fr < O, O = fr, h.push(fr), sn
							});
							S && t.errors.push(function H() {
								return new y.vHH(3012, !1)
							}()), m && t.errors.push(function ne() {
								return new y.vHH(3200, !1)
							}());
							const le = e.steps.length;
							let Re = 0;
							u > 0 && u < le ? t.errors.push(function Ne() {
								return new y.vHH(3202, !1)
							}()) : 0 == u && (Re = 1 / (le - 1));
							const Ae = le - 1,
								Ze = t.currentTime,
								wt = t.currentAnimateTimings,
								Wt = wt.duration;
							return $.forEach((Yt, sn) => {
								const kn = Re > 0 ? sn == Ae ? 1 : Re * sn : h[sn],
									fr = kn * Wt;
								t.currentTime = Ze + wt.delay + fr, wt.duration = fr, this._validateStyleAst(Yt, t), Yt.offset = kn, s.styles.push(Yt)
							}), s
						}
						visitReference(e, t) {
							return {
								type: 8,
								animation: Nr(this, ri(e.animation), t),
								options: Fi(e.options)
							}
						}
						visitAnimateChild(e, t) {
							return t.depCount++, {
								type: 9,
								options: Fi(e.options)
							}
						}
						visitAnimateRef(e, t) {
							return {
								type: 10,
								animation: this.visitReference(e.animation, t),
								options: Fi(e.options)
							}
						}
						visitQuery(e, t) {
							const s = t.currentQuerySelector,
								c = e.options || {};
							t.queryCount++, t.currentQuery = e;
							const [u, h] = function Ms(i) {
								const e = !!i.split(/\s*,\s*/).find(t => ":self" == t);
								return e && (i = i.replace(cc, "")), i = i.replace(/@\*/g, qe).replace(/@\w+/g, t => qe + "-" + t.slice(1)).replace(/:animating/g, Dt), [i, e]
							}(e.selector);
							t.currentQuerySelector = s.length ? s + " " + u : u, U(t.collectedStyles, t.currentQuerySelector, new Map);
							const m = Nr(this, ri(e.animation), t);
							return t.currentQuery = null, t.currentQuerySelector = s, {
								type: 11,
								selector: u,
								limit: c.limit || 0,
								optional: !!c.optional,
								includeSelf: h,
								animation: m,
								originalSelector: e.selector,
								options: Fi(e.options)
							}
						}
						visitStagger(e, t) {
							t.currentQuery || t.errors.push(function Ye() {
								return new y.vHH(3013, !1)
							}());
							const s = "full" === e.timings ? {
								duration: 0,
								delay: 0,
								easing: "full"
							} : ir(e.timings, t.errors, !0);
							return {
								type: 12,
								animation: Nr(this, ri(e.animation), t),
								timings: s,
								options: null
							}
						}
					}
					class fa {
						constructor(e) {
							this.errors = e, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = new Map, this.options = null, this.unsupportedCSSPropertiesFound = new Set
						}
					}

					function Fi(i) {
						return i ? (i = br(i)).params && (i.params = function Ti(i) {
							return i ? br(i) : null
						}(i.params)) : i = {}, i
					}

					function Ai(i, e, t) {
						return {
							duration: i,
							delay: e,
							easing: t
						}
					}

					function kr(i, e, t, s, c, u, h = null, m = !1) {
						return {
							type: 1,
							element: i,
							keyframes: e,
							preStyleProps: t,
							postStyleProps: s,
							duration: c,
							delay: u,
							totalTime: c + u,
							easing: h,
							subTimeline: m
						}
					}
					class ts {
						constructor() {
							this._map = new Map
						}
						get(e) {
							return this._map.get(e) || []
						}
						append(e, t) {
							let s = this._map.get(e);
							s || this._map.set(e, s = []), s.push(...t)
						}
						has(e) {
							return this._map.has(e)
						}
						clear() {
							this._map.clear()
						}
					}
					const di = new RegExp(":enter", "g"),
						Li = new RegExp(":leave", "g");

					function co(i, e, t, s, c, u = new Map, h = new Map, m, S, O = []) {
						return (new lo).buildKeyframes(i, e, t, s, c, u, h, m, S, O)
					}
					class lo {
						buildKeyframes(e, t, s, c, u, h, m, S, O, $ = []) {
							O = O || new ts;
							const le = new Ui(e, t, O, c, u, $, []);
							le.options = S;
							const Re = S.delay ? Mt(S.delay) : 0;
							le.currentTimeline.delayNextStep(Re), le.currentTimeline.setStyles([h], null, le.errors, S), Nr(this, s, le);
							const Ae = le.timelines.filter(Ze => Ze.containsAnimation());
							if (Ae.length && m.size) {
								let Ze;
								for (let wt = Ae.length - 1; wt >= 0; wt--) {
									const Wt = Ae[wt];
									if (Wt.element === t) {
										Ze = Wt;
										break
									}
								}
								Ze && !Ze.allowOnlyTimelineStyles() && Ze.setStyles([m], null, le.errors, S)
							}
							return Ae.length ? Ae.map(Ze => Ze.buildKeyframes()) : [kr(t, [], [], [], 0, Re, "", !1)]
						}
						visitTrigger(e, t) {}
						visitState(e, t) {}
						visitTransition(e, t) {}
						visitAnimateChild(e, t) {
							const s = t.subInstructions.get(t.element);
							if (s) {
								const c = t.createSubContext(e.options),
									u = t.currentTimeline.currentTime,
									h = this._visitSubInstructions(s, c, c.options);
								u != h && t.transformIntoNewTimeline(h)
							}
							t.previousNode = e
						}
						visitAnimateRef(e, t) {
							const s = t.createSubContext(e.options);
							s.transformIntoNewTimeline(), this._applyAnimationRefDelays([e.options, e.animation.options], t, s), this.visitReference(e.animation, s), t.transformIntoNewTimeline(s.currentTimeline.currentTime), t.previousNode = e
						}
						_applyAnimationRefDelays(e, t, s) {
							for (const c of e) {
								const u = c?.delay;
								if (u) {
									const h = "number" == typeof u ? u : Mt(qi(u, c?.params ?? {}, t.errors));
									s.delayNextStep(h)
								}
							}
						}
						_visitSubInstructions(e, t, s) {
							let u = t.currentTimeline.currentTime;
							const h = null != s.duration ? Mt(s.duration) : null,
								m = null != s.delay ? Mt(s.delay) : null;
							return 0 !== h && e.forEach(S => {
								const O = t.appendInstructionToTimeline(S, h, m);
								u = Math.max(u, O.duration + O.delay)
							}), u
						}
						visitReference(e, t) {
							t.updateOptions(e.options, !0), Nr(this, e.animation, t), t.previousNode = e
						}
						visitSequence(e, t) {
							const s = t.subContextCount;
							let c = t;
							const u = e.options;
							if (u && (u.params || u.delay) && (c = t.createSubContext(u), c.transformIntoNewTimeline(), null != u.delay)) {
								6 == c.previousNode.type && (c.currentTimeline.snapshotCurrentStyles(), c.previousNode = xo);
								const h = Mt(u.delay);
								c.delayNextStep(h)
							}
							e.steps.length && (e.steps.forEach(h => Nr(this, h, c)), c.currentTimeline.applyStylesToKeyframe(), c.subContextCount > s && c.transformIntoNewTimeline()), t.previousNode = e
						}
						visitGroup(e, t) {
							const s = [];
							let c = t.currentTimeline.currentTime;
							const u = e.options && e.options.delay ? Mt(e.options.delay) : 0;
							e.steps.forEach(h => {
								const m = t.createSubContext(e.options);
								u && m.delayNextStep(u), Nr(this, h, m), c = Math.max(c, m.currentTimeline.currentTime), s.push(m.currentTimeline)
							}), s.forEach(h => t.currentTimeline.mergeTimelineCollectedStyles(h)), t.transformIntoNewTimeline(c), t.previousNode = e
						}
						_visitTiming(e, t) {
							if (e.dynamic) {
								const s = e.strValue;
								return ir(t.params ? qi(s, t.params, t.errors) : s, t.errors)
							}
							return {
								duration: e.duration,
								delay: e.delay,
								easing: e.easing
							}
						}
						visitAnimate(e, t) {
							const s = t.currentAnimateTimings = this._visitTiming(e.timings, t),
								c = t.currentTimeline;
							s.delay && (t.incrementTime(s.delay), c.snapshotCurrentStyles());
							const u = e.style;
							5 == u.type ? this.visitKeyframes(u, t) : (t.incrementTime(s.duration), this.visitStyle(u, t), c.applyStylesToKeyframe()), t.currentAnimateTimings = null, t.previousNode = e
						}
						visitStyle(e, t) {
							const s = t.currentTimeline,
								c = t.currentAnimateTimings;
							!c && s.hasCurrentStyleProperties() && s.forwardFrame();
							const u = c && c.easing || e.easing;
							e.isEmptyStep ? s.applyEmptyStep(u) : s.setStyles(e.styles, u, t.errors, t.options), t.previousNode = e
						}
						visitKeyframes(e, t) {
							const s = t.currentAnimateTimings,
								c = t.currentTimeline.duration,
								u = s.duration,
								m = t.createSubContext().currentTimeline;
							m.easing = s.easing, e.styles.forEach(S => {
								m.forwardTime((S.offset || 0) * u), m.setStyles(S.styles, S.easing, t.errors, t.options), m.applyStylesToKeyframe()
							}), t.currentTimeline.mergeTimelineCollectedStyles(m), t.transformIntoNewTimeline(c + u), t.previousNode = e
						}
						visitQuery(e, t) {
							const s = t.currentTimeline.currentTime,
								c = e.options || {},
								u = c.delay ? Mt(c.delay) : 0;
							u && (6 === t.previousNode.type || 0 == s && t.currentTimeline.hasCurrentStyleProperties()) && (t.currentTimeline.snapshotCurrentStyles(), t.previousNode = xo);
							let h = s;
							const m = t.invokeQuery(e.selector, e.originalSelector, e.limit, e.includeSelf, !!c.optional, t.errors);
							t.currentQueryTotal = m.length;
							let S = null;
							m.forEach((O, $) => {
								t.currentQueryIndex = $;
								const le = t.createSubContext(e.options, O);
								u && le.delayNextStep(u), O === t.element && (S = le.currentTimeline), Nr(this, e.animation, le), le.currentTimeline.applyStylesToKeyframe(), h = Math.max(h, le.currentTimeline.currentTime)
							}), t.currentQueryIndex = 0, t.currentQueryTotal = 0, t.transformIntoNewTimeline(h), S && (t.currentTimeline.mergeTimelineCollectedStyles(S), t.currentTimeline.snapshotCurrentStyles()), t.previousNode = e
						}
						visitStagger(e, t) {
							const s = t.parentContext,
								c = t.currentTimeline,
								u = e.timings,
								h = Math.abs(u.duration),
								m = h * (t.currentQueryTotal - 1);
							let S = h * t.currentQueryIndex;
							switch (u.duration < 0 ? "reverse" : u.easing) {
								case "reverse":
									S = m - S;
									break;
								case "full":
									S = s.currentStaggerTime
							}
							const $ = t.currentTimeline;
							S && $.delayNextStep(S);
							const le = $.currentTime;
							Nr(this, e.animation, t), t.previousNode = e, s.currentStaggerTime = c.currentTime - le + (c.startTime - s.currentTimeline.startTime)
						}
					}
					const xo = {};
					class Ui {
						constructor(e, t, s, c, u, h, m, S) {
							this._driver = e, this.element = t, this.subInstructions = s, this._enterClassName = c, this._leaveClassName = u, this.errors = h, this.timelines = m, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = xo, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = S || new wn(this._driver, t, 0), m.push(this.currentTimeline)
						}
						get params() {
							return this.options.params
						}
						updateOptions(e, t) {
							if (!e) return;
							const s = e;
							let c = this.options;
							null != s.duration && (c.duration = Mt(s.duration)), null != s.delay && (c.delay = Mt(s.delay));
							const u = s.params;
							if (u) {
								let h = c.params;
								h || (h = this.options.params = {}), Object.keys(u).forEach(m => {
									(!t || !h.hasOwnProperty(m)) && (h[m] = qi(u[m], h, this.errors))
								})
							}
						}
						_copyOptions() {
							const e = {};
							if (this.options) {
								const t = this.options.params;
								if (t) {
									const s = e.params = {};
									Object.keys(t).forEach(c => {
										s[c] = t[c]
									})
								}
							}
							return e
						}
						createSubContext(e = null, t, s) {
							const c = t || this.element,
								u = new Ui(this._driver, c, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(c, s || 0));
							return u.previousNode = this.previousNode, u.currentAnimateTimings = this.currentAnimateTimings, u.options = this._copyOptions(), u.updateOptions(e), u.currentQueryIndex = this.currentQueryIndex, u.currentQueryTotal = this.currentQueryTotal, u.parentContext = this, this.subContextCount++, u
						}
						transformIntoNewTimeline(e) {
							return this.previousNode = xo, this.currentTimeline = this.currentTimeline.fork(this.element, e), this.timelines.push(this.currentTimeline), this.currentTimeline
						}
						appendInstructionToTimeline(e, t, s) {
							const c = {
									duration: t ?? e.duration,
									delay: this.currentTimeline.currentTime + (s ?? 0) + e.delay,
									easing: ""
								},
								u = new pa(this._driver, e.element, e.keyframes, e.preStyleProps, e.postStyleProps, c, e.stretchStartingKeyframe);
							return this.timelines.push(u), c
						}
						incrementTime(e) {
							this.currentTimeline.forwardTime(this.currentTimeline.duration + e)
						}
						delayNextStep(e) {
							e > 0 && this.currentTimeline.delayNextStep(e)
						}
						invokeQuery(e, t, s, c, u, h) {
							let m = [];
							if (c && m.push(this.element), e.length > 0) {
								e = (e = e.replace(di, "." + this._enterClassName)).replace(Li, "." + this._leaveClassName);
								let O = this._driver.query(this.element, e, 1 != s);
								0 !== s && (O = s < 0 ? O.slice(O.length + s, O.length) : O.slice(0, s)), m.push(...O)
							}
							return !u && 0 == m.length && h.push(function Ft(i) {
								return new y.vHH(3014, !1)
							}()), m
						}
					}
					class wn {
						constructor(e, t, s, c) {
							this._driver = e, this.element = t, this.startTime = s, this._elementTimelineStylesLookup = c, this.duration = 0, this._previousKeyframe = new Map, this._currentKeyframe = new Map, this._keyframes = new Map, this._styleSummary = new Map, this._localTimelineStyles = new Map, this._pendingStyles = new Map, this._backFill = new Map, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(t), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(t, this._localTimelineStyles)), this._loadKeyframe()
						}
						containsAnimation() {
							switch (this._keyframes.size) {
								case 0:
									return !1;
								case 1:
									return this.hasCurrentStyleProperties();
								default:
									return !0
							}
						}
						hasCurrentStyleProperties() {
							return this._currentKeyframe.size > 0
						}
						get currentTime() {
							return this.startTime + this.duration
						}
						delayNextStep(e) {
							const t = 1 === this._keyframes.size && this._pendingStyles.size;
							this.duration || t ? (this.forwardTime(this.currentTime + e), t && this.snapshotCurrentStyles()) : this.startTime += e
						}
						fork(e, t) {
							return this.applyStylesToKeyframe(), new wn(this._driver, e, t || this.currentTime, this._elementTimelineStylesLookup)
						}
						_loadKeyframe() {
							this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = new Map, this._keyframes.set(this.duration, this._currentKeyframe))
						}
						forwardFrame() {
							this.duration += 1, this._loadKeyframe()
						}
						forwardTime(e) {
							this.applyStylesToKeyframe(), this.duration = e, this._loadKeyframe()
						}
						_updateStyle(e, t) {
							this._localTimelineStyles.set(e, t), this._globalTimelineStyles.set(e, t), this._styleSummary.set(e, {
								time: this.currentTime,
								value: t
							})
						}
						allowOnlyTimelineStyles() {
							return this._currentEmptyStepKeyframe !== this._currentKeyframe
						}
						applyEmptyStep(e) {
							e && this._previousKeyframe.set("easing", e);
							for (let [t, s] of this._globalTimelineStyles) this._backFill.set(t, s || Nt.l3), this._currentKeyframe.set(t, Nt.l3);
							this._currentEmptyStepKeyframe = this._currentKeyframe
						}
						setStyles(e, t, s, c) {
							t && this._previousKeyframe.set("easing", t);
							const u = c && c.params || {},
								h = function dc(i, e) {
									const t = new Map;
									let s;
									return i.forEach(c => {
										if ("*" === c) {
											s = s || e.keys();
											for (let u of s) t.set(u, Nt.l3)
										} else lr(c, t)
									}), t
								}(e, this._globalTimelineStyles);
							for (let [m, S] of h) {
								const O = qi(S, u, s);
								this._pendingStyles.set(m, O), this._localTimelineStyles.has(m) || this._backFill.set(m, this._globalTimelineStyles.get(m) ?? Nt.l3), this._updateStyle(m, O)
							}
						}
						applyStylesToKeyframe() {
							0 != this._pendingStyles.size && (this._pendingStyles.forEach((e, t) => {
								this._currentKeyframe.set(t, e)
							}), this._pendingStyles.clear(), this._localTimelineStyles.forEach((e, t) => {
								this._currentKeyframe.has(t) || this._currentKeyframe.set(t, e)
							}))
						}
						snapshotCurrentStyles() {
							for (let [e, t] of this._localTimelineStyles) this._pendingStyles.set(e, t), this._updateStyle(e, t)
						}
						getFinalKeyframe() {
							return this._keyframes.get(this.duration)
						}
						get properties() {
							const e = [];
							for (let t in this._currentKeyframe) e.push(t);
							return e
						}
						mergeTimelineCollectedStyles(e) {
							e._styleSummary.forEach((t, s) => {
								const c = this._styleSummary.get(s);
								(!c || t.time > c.time) && this._updateStyle(s, t.value)
							})
						}
						buildKeyframes() {
							this.applyStylesToKeyframe();
							const e = new Set,
								t = new Set,
								s = 1 === this._keyframes.size && 0 === this.duration;
							let c = [];
							this._keyframes.forEach((m, S) => {
								const O = lr(m, new Map, this._backFill);
								O.forEach(($, le) => {
									$ === Nt.k1 ? e.add(le) : $ === Nt.l3 && t.add(le)
								}), s || O.set("offset", S / this.duration), c.push(O)
							});
							const u = e.size ? Qo(e.values()) : [],
								h = t.size ? Qo(t.values()) : [];
							if (s) {
								const m = c[0],
									S = new Map(m);
								m.set("offset", 0), S.set("offset", 1), c = [m, S]
							}
							return kr(this.element, c, u, h, this.duration, this.startTime, this.easing, !1)
						}
					}
					class pa extends wn {
						constructor(e, t, s, c, u, h, m = !1) {
							super(e, t, h.delay), this.keyframes = s, this.preStyleProps = c, this.postStyleProps = u, this._stretchStartingKeyframe = m, this.timings = {
								duration: h.duration,
								delay: h.delay,
								easing: h.easing
							}
						}
						containsAnimation() {
							return this.keyframes.length > 1
						}
						buildKeyframes() {
							let e = this.keyframes,
								{
									delay: t,
									duration: s,
									easing: c
								} = this.timings;
							if (this._stretchStartingKeyframe && t) {
								const u = [],
									h = s + t,
									m = t / h,
									S = lr(e[0]);
								S.set("offset", 0), u.push(S);
								const O = lr(e[0]);
								O.set("offset", sl(m)), u.push(O);
								const $ = e.length - 1;
								for (let le = 1; le <= $; le++) {
									let Re = lr(e[le]);
									const Ae = Re.get("offset");
									Re.set("offset", sl((t + Ae * s) / h)), u.push(Re)
								}
								s = h, t = 0, c = "", e = u
							}
							return kr(this.element, e, this.preStyleProps, this.postStyleProps, s, t, c, !0)
						}
					}

					function sl(i, e = 3) {
						const t = Math.pow(10, e - 1);
						return Math.round(i * t) / t
					}
					class Ps {}
					const gu = new Set(["width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "left", "top", "bottom", "right", "fontSize", "outlineWidth", "outlineOffset", "paddingTop", "paddingLeft", "paddingBottom", "paddingRight", "marginTop", "marginLeft", "marginBottom", "marginRight", "borderRadius", "borderWidth", "borderTopWidth", "borderLeftWidth", "borderRightWidth", "borderBottomWidth", "textIndent", "perspective"]);
					class fc extends Ps {
						normalizePropertyName(e, t) {
							return Jo(e)
						}
						normalizeStyleValue(e, t, s, c) {
							let u = "";
							const h = s.toString().trim();
							if (gu.has(t) && 0 !== s && "0" !== s)
								if ("number" == typeof s) u = "px";
								else {
									const m = s.match(/^[+-]?[\d\.]+([a-z]*)$/);
									m && 0 == m[1].length && c.push(function $t(i, e) {
										return new y.vHH(3005, !1)
									}())
								} return h + u
						}
					}

					function Ct(i, e, t, s, c, u, h, m, S, O, $, le, Re) {
						return {
							type: 0,
							element: i,
							triggerName: e,
							isRemovalTransition: c,
							fromState: t,
							fromStyles: u,
							toState: s,
							toStyles: h,
							timelines: m,
							queriedElements: S,
							preStyleProps: O,
							postStyleProps: $,
							totalTime: le,
							errors: Re
						}
					}
					const Gn = {};
					class uo {
						constructor(e, t, s) {
							this._triggerName = e, this.ast = t, this._stateStyles = s
						}
						match(e, t, s, c) {
							return function zr(i, e, t, s, c) {
								return i.some(u => u(e, t, s, c))
							}(this.ast.matchers, e, t, s, c)
						}
						buildStyles(e, t, s) {
							let c = this._stateStyles.get("*");
							return void 0 !== e && (c = this._stateStyles.get(e?.toString()) || c), c ? c.buildStyles(t, s) : new Map
						}
						build(e, t, s, c, u, h, m, S, O, $) {
							const le = [],
								Re = this.ast.options && this.ast.options.params || Gn,
								Ze = this.buildStyles(s, m && m.params || Gn, le),
								wt = S && S.params || Gn,
								Wt = this.buildStyles(c, wt, le),
								Yt = new Set,
								sn = new Map,
								kn = new Map,
								fr = "void" === c,
								ui = {
									params: pc(wt, Re),
									delay: this.ast.options?.delay
								},
								oi = $ ? [] : co(e, t, this.ast.animation, u, h, Ze, Wt, ui, O, le);
							let Jr = 0;
							if (oi.forEach(yo => {
									Jr = Math.max(yo.duration + yo.delay, Jr)
								}), le.length) return Ct(t, this._triggerName, s, c, fr, Ze, Wt, [], [], sn, kn, Jr, le);
							oi.forEach(yo => {
								const zi = yo.element,
									gp = U(sn, zi, new Set);
								yo.preStyleProps.forEach(na => gp.add(na));
								const oc = U(kn, zi, new Set);
								yo.postStyleProps.forEach(na => oc.add(na)), zi !== t && Yt.add(zi)
							});
							const wr = Qo(Yt.values());
							return Ct(t, this._triggerName, s, c, fr, Ze, Wt, oi, wr, sn, kn, Jr)
						}
					}

					function pc(i, e) {
						const t = br(e);
						for (const s in i) i.hasOwnProperty(s) && null != i[s] && (t[s] = i[s]);
						return t
					}
					class ns {
						constructor(e, t, s) {
							this.styles = e, this.defaultParams = t, this.normalizer = s
						}
						buildStyles(e, t) {
							const s = new Map,
								c = br(this.defaultParams);
							return Object.keys(e).forEach(u => {
								const h = e[u];
								null !== h && (c[u] = h)
							}), this.styles.styles.forEach(u => {
								"string" != typeof u && u.forEach((h, m) => {
									h && (h = qi(h, c, t));
									const S = this.normalizer.normalizePropertyName(m, t);
									h = this.normalizer.normalizeStyleValue(m, S, h, t), s.set(m, h)
								})
							}), s
						}
					}
					class ga {
						constructor(e, t, s) {
							this.name = e, this.ast = t, this._normalizer = s, this.transitionFactories = [], this.states = new Map, t.states.forEach(c => {
								this.states.set(c.name, new ns(c.style, c.options && c.options.params || {}, s))
							}), gc(this.states, "true", "1"), gc(this.states, "false", "0"), t.transitions.forEach(c => {
								this.transitionFactories.push(new uo(e, c, this.states))
							}), this.fallbackTransition = function ma(i, e, t) {
								return new uo(i, {
									type: 1,
									animation: {
										type: 2,
										steps: [],
										options: null
									},
									matchers: [(h, m) => !0],
									options: null,
									queryCount: 0,
									depCount: 0
								}, e)
							}(e, this.states)
						}
						get containsQueries() {
							return this.ast.queryCount > 0
						}
						matchTransition(e, t, s, c) {
							return this.transitionFactories.find(h => h.match(e, t, s, c)) || null
						}
						matchStyles(e, t, s) {
							return this.fallbackTransition.buildStyles(e, t, s)
						}
					}

					function gc(i, e, t) {
						i.has(e) ? i.has(t) || i.set(t, i.get(e)) : i.has(t) && i.set(e, i.get(t))
					}
					const mc = new ts;
					class Ns {
						constructor(e, t, s) {
							this.bodyNode = e, this._driver = t, this._normalizer = s, this._animations = new Map, this._playersById = new Map, this.players = []
						}
						register(e, t) {
							const s = [],
								c = [],
								u = ha(this._driver, t, s, c);
							if (s.length) throw function En(i) {
								return new y.vHH(3503, !1)
							}();
							this._animations.set(e, u)
						}
						_buildPlayer(e, t, s) {
							const c = e.element,
								u = $r(0, this._normalizer, 0, e.keyframes, t, s);
							return this._driver.animate(c, u, e.duration, e.delay, e.easing, [], !0)
						}
						create(e, t, s = {}) {
							const c = [],
								u = this._animations.get(e);
							let h;
							const m = new Map;
							if (u ? (h = co(this._driver, t, u, Br, me, new Map, new Map, s, mc, c), h.forEach($ => {
									const le = U(m, $.element, new Map);
									$.postStyleProps.forEach(Re => le.set(Re, null))
								})) : (c.push(function Me() {
									return new y.vHH(3300, !1)
								}()), h = []), c.length) throw function Ie(i) {
								return new y.vHH(3504, !1)
							}();
							m.forEach(($, le) => {
								$.forEach((Re, Ae) => {
									$.set(Ae, this._driver.computeStyle(le, Ae, Nt.l3))
								})
							});
							const O = Sr(h.map($ => {
								const le = m.get($.element);
								return this._buildPlayer($, new Map, le)
							}));
							return this._playersById.set(e, O), O.onDestroy(() => this.destroy(e)), this.players.push(O), O
						}
						destroy(e) {
							const t = this._getPlayer(e);
							t.destroy(), this._playersById.delete(e);
							const s = this.players.indexOf(t);
							s >= 0 && this.players.splice(s, 1)
						}
						_getPlayer(e) {
							const t = this._playersById.get(e);
							if (!t) throw function ge(i) {
								return new y.vHH(3301, !1)
							}();
							return t
						}
						listen(e, t, s, c) {
							const u = V(t, "", "", "");
							return Ur(this._getPlayer(e), s, u, c), () => {}
						}
						command(e, t, s, c) {
							if ("register" == s) return void this.register(e, c[0]);
							if ("create" == s) return void this.create(e, t, c[0] || {});
							const u = this._getPlayer(e);
							switch (s) {
								case "play":
									u.play();
									break;
								case "pause":
									u.pause();
									break;
								case "reset":
									u.reset();
									break;
								case "restart":
									u.restart();
									break;
								case "finish":
									u.finish();
									break;
								case "init":
									u.init();
									break;
								case "setPosition":
									u.setPosition(parseFloat(c[0]));
									break;
								case "destroy":
									this.destroy(e)
							}
						}
					}
					const Kr = "ng-animate-queued",
						Bi = "ng-animate-disabled",
						ks = [],
						_c = {
							namespaceId: "",
							setForRemoval: !1,
							setForMove: !1,
							hasAnimation: !1,
							removedBeforeQueried: !1
						},
						ll = {
							namespaceId: "",
							setForMove: !1,
							setForRemoval: !1,
							hasAnimation: !1,
							removedBeforeQueried: !0
						},
						Hr = "__ng_removed";
					class fo {
						get params() {
							return this.options.params
						}
						constructor(e, t = "") {
							this.namespaceId = t;
							const s = e && e.hasOwnProperty("value");
							if (this.value = function vc(i) {
									return i ?? null
								}(s ? e.value : e), s) {
								const u = br(e);
								delete u.value, this.options = u
							} else this.options = {};
							this.options.params || (this.options.params = {})
						}
						absorbOptions(e) {
							const t = e.params;
							if (t) {
								const s = this.options.params;
								Object.keys(t).forEach(c => {
									null == s[c] && (s[c] = t[c])
								})
							}
						}
					}
					const Eo = "void",
						po = new fo(Eo);
					class xs {
						constructor(e, t, s) {
							this.id = e, this.hostElement = t, this._engine = s, this.players = [], this._triggers = new Map, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + e, ur(t, this._hostClassName)
						}
						listen(e, t, s, c) {
							if (!this._triggers.has(t)) throw function Ke(i, e) {
								return new y.vHH(3302, !1)
							}();
							if (null == s || 0 == s.length) throw function Tt(i) {
								return new y.vHH(3303, !1)
							}();
							if (! function yc(i) {
									return "start" == i || "done" == i
								}(s)) throw function Xt(i, e) {
								return new y.vHH(3400, !1)
							}();
							const u = U(this._elementListeners, e, []),
								h = {
									name: t,
									phase: s,
									callback: c
								};
							u.push(h);
							const m = U(this._engine.statesByElement, e, new Map);
							return m.has(t) || (ur(e, tt), ur(e, tt + "-" + t), m.set(t, po)), () => {
								this._engine.afterFlush(() => {
									const S = u.indexOf(h);
									S >= 0 && u.splice(S, 1), this._triggers.has(t) || m.delete(t)
								})
							}
						}
						register(e, t) {
							return !this._triggers.has(e) && (this._triggers.set(e, t), !0)
						}
						_getTrigger(e) {
							const t = this._triggers.get(e);
							if (!t) throw function Tn(i) {
								return new y.vHH(3401, !1)
							}();
							return t
						}
						trigger(e, t, s, c = !0) {
							const u = this._getTrigger(t),
								h = new Xi(this.id, t, e);
							let m = this._engine.statesByElement.get(e);
							m || (ur(e, tt), ur(e, tt + "-" + t), this._engine.statesByElement.set(e, m = new Map));
							let S = m.get(t);
							const O = new fo(s, this.id);
							if (!(s && s.hasOwnProperty("value")) && S && O.absorbOptions(S.options), m.set(t, O), S || (S = po), O.value !== Eo && S.value === O.value) {
								if (! function dl(i, e) {
										const t = Object.keys(i),
											s = Object.keys(e);
										if (t.length != s.length) return !1;
										for (let c = 0; c < t.length; c++) {
											const u = t[c];
											if (!e.hasOwnProperty(u) || i[u] !== e[u]) return !1
										}
										return !0
									}(S.params, O.params)) {
									const wt = [],
										Wt = u.matchStyles(S.value, S.params, wt),
										Yt = u.matchStyles(O.value, O.params, wt);
									wt.length ? this._engine.reportError(wt) : this._engine.afterFlush(() => {
										Si(e, Wt), ni(e, Yt)
									})
								}
								return
							}
							const Re = U(this._engine.playersByElement, e, []);
							Re.forEach(wt => {
								wt.namespaceId == this.id && wt.triggerName == t && wt.queued && wt.destroy()
							});
							let Ae = u.matchTransition(S.value, O.value, e, O.params),
								Ze = !1;
							if (!Ae) {
								if (!c) return;
								Ae = u.fallbackTransition, Ze = !0
							}
							return this._engine.totalQueuedPlayers++, this._queue.push({
								element: e,
								triggerName: t,
								transition: Ae,
								fromState: S,
								toState: O,
								player: h,
								isFallbackTransition: Ze
							}), Ze || (ur(e, Kr), h.onStart(() => {
								yi(e, Kr)
							})), h.onDone(() => {
								let wt = this.players.indexOf(h);
								wt >= 0 && this.players.splice(wt, 1);
								const Wt = this._engine.playersByElement.get(e);
								if (Wt) {
									let Yt = Wt.indexOf(h);
									Yt >= 0 && Wt.splice(Yt, 1)
								}
							}), this.players.push(h), Re.push(h), h
						}
						deregister(e) {
							this._triggers.delete(e), this._engine.statesByElement.forEach(t => t.delete(e)), this._elementListeners.forEach((t, s) => {
								this._elementListeners.set(s, t.filter(c => c.name != e))
							})
						}
						clearElementCache(e) {
							this._engine.statesByElement.delete(e), this._elementListeners.delete(e);
							const t = this._engine.playersByElement.get(e);
							t && (t.forEach(s => s.destroy()), this._engine.playersByElement.delete(e))
						}
						_signalRemovalForInnerTriggers(e, t) {
							const s = this._engine.driver.query(e, qe, !0);
							s.forEach(c => {
								if (c[Hr]) return;
								const u = this._engine.fetchNamespacesByElement(c);
								u.size ? u.forEach(h => h.triggerLeaveAnimation(c, t, !1, !0)) : this.clearElementCache(c)
							}), this._engine.afterFlushAnimationsDone(() => s.forEach(c => this.clearElementCache(c)))
						}
						triggerLeaveAnimation(e, t, s, c) {
							const u = this._engine.statesByElement.get(e),
								h = new Map;
							if (u) {
								const m = [];
								if (u.forEach((S, O) => {
										if (h.set(O, S.value), this._triggers.has(O)) {
											const $ = this.trigger(e, O, Eo, c);
											$ && m.push($)
										}
									}), m.length) return this._engine.markElementAsRemoved(this.id, e, !0, t, h), s && Sr(m).onDone(() => this._engine.processLeaveNode(e)), !0
							}
							return !1
						}
						prepareLeaveAnimationListeners(e) {
							const t = this._elementListeners.get(e),
								s = this._engine.statesByElement.get(e);
							if (t && s) {
								const c = new Set;
								t.forEach(u => {
									const h = u.name;
									if (c.has(h)) return;
									c.add(h);
									const S = this._triggers.get(h).fallbackTransition,
										O = s.get(h) || po,
										$ = new fo(Eo),
										le = new Xi(this.id, h, e);
									this._engine.totalQueuedPlayers++, this._queue.push({
										element: e,
										triggerName: h,
										transition: S,
										fromState: O,
										toState: $,
										player: le,
										isFallbackTransition: !0
									})
								})
							}
						}
						removeNode(e, t) {
							const s = this._engine;
							if (e.childElementCount && this._signalRemovalForInnerTriggers(e, t), this.triggerLeaveAnimation(e, t, !0)) return;
							let c = !1;
							if (s.totalAnimations) {
								const u = s.players.length ? s.playersByQueriedElement.get(e) : [];
								if (u && u.length) c = !0;
								else {
									let h = e;
									for (; h = h.parentNode;)
										if (s.statesByElement.get(h)) {
											c = !0;
											break
										}
								}
							}
							if (this.prepareLeaveAnimationListeners(e), c) s.markElementAsRemoved(this.id, e, !1, t);
							else {
								const u = e[Hr];
								(!u || u === _c) && (s.afterFlush(() => this.clearElementCache(e)), s.destroyInnerAnimations(e), s._onRemovalComplete(e, t))
							}
						}
						insertNode(e, t) {
							ur(e, this._hostClassName)
						}
						drainQueuedTransitions(e) {
							const t = [];
							return this._queue.forEach(s => {
								const c = s.player;
								if (c.destroyed) return;
								const u = s.element,
									h = this._elementListeners.get(u);
								h && h.forEach(m => {
									if (m.name == s.triggerName) {
										const S = V(u, s.triggerName, s.fromState.value, s.toState.value);
										S._data = e, Ur(s.player, m.phase, S, m.callback)
									}
								}), c.markedForDestroy ? this._engine.afterFlush(() => {
									c.destroy()
								}) : t.push(s)
							}), this._queue = [], t.sort((s, c) => {
								const u = s.transition.ast.depCount,
									h = c.transition.ast.depCount;
								return 0 == u || 0 == h ? u - h : this._engine.driver.containsElement(s.element, c.element) ? 1 : -1
							})
						}
						destroy(e) {
							this.players.forEach(t => t.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, e)
						}
						elementContainsData(e) {
							let t = !1;
							return this._elementListeners.has(e) && (t = !0), t = !!this._queue.find(s => s.element === e) || t, t
						}
					}
					class va {
						_onRemovalComplete(e, t) {
							this.onRemovalComplete(e, t)
						}
						constructor(e, t, s) {
							this.bodyNode = e, this.driver = t, this._normalizer = s, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (c, u) => {}
						}
						get queuedPlayers() {
							const e = [];
							return this._namespaceList.forEach(t => {
								t.players.forEach(s => {
									s.queued && e.push(s)
								})
							}), e
						}
						createNamespace(e, t) {
							const s = new xs(e, t, this);
							return this.bodyNode && this.driver.containsElement(this.bodyNode, t) ? this._balanceNamespaceList(s, t) : (this.newHostElements.set(t, s), this.collectEnterElement(t)), this._namespaceLookup[e] = s
						}
						_balanceNamespaceList(e, t) {
							const s = this._namespaceList,
								c = this.namespacesByHostElement;
							if (s.length - 1 >= 0) {
								let h = !1,
									m = this.driver.getParentElement(t);
								for (; m;) {
									const S = c.get(m);
									if (S) {
										const O = s.indexOf(S);
										s.splice(O + 1, 0, e), h = !0;
										break
									}
									m = this.driver.getParentElement(m)
								}
								h || s.unshift(e)
							} else s.push(e);
							return c.set(t, e), e
						}
						register(e, t) {
							let s = this._namespaceLookup[e];
							return s || (s = this.createNamespace(e, t)), s
						}
						registerTrigger(e, t, s) {
							let c = this._namespaceLookup[e];
							c && c.register(t, s) && this.totalAnimations++
						}
						destroy(e, t) {
							if (!e) return;
							const s = this._fetchNamespace(e);
							this.afterFlush(() => {
								this.namespacesByHostElement.delete(s.hostElement), delete this._namespaceLookup[e];
								const c = this._namespaceList.indexOf(s);
								c >= 0 && this._namespaceList.splice(c, 1)
							}), this.afterFlushAnimationsDone(() => s.destroy(t))
						}
						_fetchNamespace(e) {
							return this._namespaceLookup[e]
						}
						fetchNamespacesByElement(e) {
							const t = new Set,
								s = this.statesByElement.get(e);
							if (s)
								for (let c of s.values())
									if (c.namespaceId) {
										const u = this._fetchNamespace(c.namespaceId);
										u && t.add(u)
									} return t
						}
						trigger(e, t, s, c) {
							if (rs(t)) {
								const u = this._fetchNamespace(e);
								if (u) return u.trigger(t, s, c), !0
							}
							return !1
						}
						insertNode(e, t, s, c) {
							if (!rs(t)) return;
							const u = t[Hr];
							if (u && u.setForRemoval) {
								u.setForRemoval = !1, u.setForMove = !0;
								const h = this.collectedLeaveElements.indexOf(t);
								h >= 0 && this.collectedLeaveElements.splice(h, 1)
							}
							if (e) {
								const h = this._fetchNamespace(e);
								h && h.insertNode(t, s)
							}
							c && this.collectEnterElement(t)
						}
						collectEnterElement(e) {
							this.collectedEnterElements.push(e)
						}
						markElementAsDisabled(e, t) {
							t ? this.disabledNodes.has(e) || (this.disabledNodes.add(e), ur(e, Bi)) : this.disabledNodes.has(e) && (this.disabledNodes.delete(e), yi(e, Bi))
						}
						removeNode(e, t, s, c) {
							if (rs(t)) {
								const u = e ? this._fetchNamespace(e) : null;
								if (u ? u.removeNode(t, c) : this.markElementAsRemoved(e, t, !1, c), s) {
									const h = this.namespacesByHostElement.get(t);
									h && h.id !== e && h.removeNode(t, c)
								}
							} else this._onRemovalComplete(t, c)
						}
						markElementAsRemoved(e, t, s, c, u) {
							this.collectedLeaveElements.push(t), t[Hr] = {
								namespaceId: e,
								setForRemoval: c,
								hasAnimation: s,
								removedBeforeQueried: !1,
								previousTriggersValues: u
							}
						}
						listen(e, t, s, c, u) {
							return rs(t) ? this._fetchNamespace(e).listen(t, s, c, u) : () => {}
						}
						_buildInstruction(e, t, s, c, u) {
							return e.transition.build(this.driver, e.element, e.fromState.value, e.toState.value, s, c, e.fromState.options, e.toState.options, t, u)
						}
						destroyInnerAnimations(e) {
							let t = this.driver.query(e, qe, !0);
							t.forEach(s => this.destroyActiveAnimationsForElement(s)), 0 != this.playersByQueriedElement.size && (t = this.driver.query(e, Dt, !0), t.forEach(s => this.finishActiveQueriedAnimationOnElement(s)))
						}
						destroyActiveAnimationsForElement(e) {
							const t = this.playersByElement.get(e);
							t && t.forEach(s => {
								s.queued ? s.markedForDestroy = !0 : s.destroy()
							})
						}
						finishActiveQueriedAnimationOnElement(e) {
							const t = this.playersByQueriedElement.get(e);
							t && t.forEach(s => s.finish())
						}
						whenRenderingDone() {
							return new Promise(e => {
								if (this.players.length) return Sr(this.players).onDone(() => e());
								e()
							})
						}
						processLeaveNode(e) {
							const t = e[Hr];
							if (t && t.setForRemoval) {
								if (e[Hr] = _c, t.namespaceId) {
									this.destroyInnerAnimations(e);
									const s = this._fetchNamespace(t.namespaceId);
									s && s.clearElementCache(e)
								}
								this._onRemovalComplete(e, t.setForRemoval)
							}
							e.classList?.contains(Bi) && this.markElementAsDisabled(e, !1), this.driver.query(e, ".ng-animate-disabled", !0).forEach(s => {
								this.markElementAsDisabled(s, !1)
							})
						}
						flush(e = -1) {
							let t = [];
							if (this.newHostElements.size && (this.newHostElements.forEach((s, c) => this._balanceNamespaceList(s, c)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length)
								for (let s = 0; s < this.collectedEnterElements.length; s++) ur(this.collectedEnterElements[s], "ng-star-inserted");
							if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {
								const s = [];
								try {
									t = this._flushAnimations(s, e)
								} finally {
									for (let c = 0; c < s.length; c++) s[c]()
								}
							} else
								for (let s = 0; s < this.collectedLeaveElements.length; s++) this.processLeaveNode(this.collectedLeaveElements[s]);
							if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(s => s()), this._flushFns = [], this._whenQuietFns.length) {
								const s = this._whenQuietFns;
								this._whenQuietFns = [], t.length ? Sr(t).onDone(() => {
									s.forEach(c => c())
								}) : s.forEach(c => c())
							}
						}
						reportError(e) {
							throw function Zn(i) {
								return new y.vHH(3402, !1)
							}()
						}
						_flushAnimations(e, t) {
							const s = new ts,
								c = [],
								u = new Map,
								h = [],
								m = new Map,
								S = new Map,
								O = new Map,
								$ = new Set;
							this.disabledNodes.forEach(fn => {
								$.add(fn);
								const In = this.driver.query(fn, ".ng-animate-queued", !0);
								for (let An = 0; An < In.length; An++) $.add(In[An])
							});
							const le = this.bodyNode,
								Re = Array.from(this.statesByElement.keys()),
								Ae = Ca(Re, this.collectedEnterElements),
								Ze = new Map;
							let wt = 0;
							Ae.forEach((fn, In) => {
								const An = Br + wt++;
								Ze.set(In, An), fn.forEach(tr => ur(tr, An))
							});
							const Wt = [],
								Yt = new Set,
								sn = new Set;
							for (let fn = 0; fn < this.collectedLeaveElements.length; fn++) {
								const In = this.collectedLeaveElements[fn],
									An = In[Hr];
								An && An.setForRemoval && (Wt.push(In), Yt.add(In), An.hasAnimation ? this.driver.query(In, ".ng-star-inserted", !0).forEach(tr => Yt.add(tr)) : sn.add(In))
							}
							const kn = new Map,
								fr = Ca(Re, Array.from(Yt));
							fr.forEach((fn, In) => {
								const An = me + wt++;
								kn.set(In, An), fn.forEach(tr => ur(tr, An))
							}), e.push(() => {
								Ae.forEach((fn, In) => {
									const An = Ze.get(In);
									fn.forEach(tr => yi(tr, An))
								}), fr.forEach((fn, In) => {
									const An = kn.get(In);
									fn.forEach(tr => yi(tr, An))
								}), Wt.forEach(fn => {
									this.processLeaveNode(fn)
								})
							});
							const ui = [],
								oi = [];
							for (let fn = this._namespaceList.length - 1; fn >= 0; fn--) this._namespaceList[fn].drainQueuedTransitions(t).forEach(An => {
								const tr = An.player,
									Xr = An.element;
								if (ui.push(tr), this.collectedEnterElements.length) {
									const vi = Xr[Hr];
									if (vi && vi.setForMove) {
										if (vi.previousTriggersValues && vi.previousTriggersValues.has(An.triggerName)) {
											const Ts = vi.previousTriggersValues.get(An.triggerName),
												Yi = this.statesByElement.get(An.element);
											if (Yi && Yi.has(An.triggerName)) {
												const cu = Yi.get(An.triggerName);
												cu.value = Ts, Yi.set(An.triggerName, cu)
											}
										}
										return void tr.destroy()
									}
								}
								const Ki = !le || !this.driver.containsElement(le, Xr),
									Di = kn.get(Xr),
									Wo = Ze.get(Xr),
									Ar = this._buildInstruction(An, s, Wo, Di, Ki);
								if (Ar.errors && Ar.errors.length) return void oi.push(Ar);
								if (Ki) return tr.onStart(() => Si(Xr, Ar.fromStyles)), tr.onDestroy(() => ni(Xr, Ar.toStyles)), void c.push(tr);
								if (An.isFallbackTransition) return tr.onStart(() => Si(Xr, Ar.fromStyles)), tr.onDestroy(() => ni(Xr, Ar.toStyles)), void c.push(tr);
								const Jd = [];
								Ar.timelines.forEach(vi => {
									vi.stretchStartingKeyframe = !0, this.disabledNodes.has(vi.element) || Jd.push(vi)
								}), Ar.timelines = Jd, s.append(Xr, Ar.timelines), h.push({
									instruction: Ar,
									player: tr,
									element: Xr
								}), Ar.queriedElements.forEach(vi => U(m, vi, []).push(tr)), Ar.preStyleProps.forEach((vi, Ts) => {
									if (vi.size) {
										let Yi = S.get(Ts);
										Yi || S.set(Ts, Yi = new Set), vi.forEach((cu, Xd) => Yi.add(Xd))
									}
								}), Ar.postStyleProps.forEach((vi, Ts) => {
									let Yi = O.get(Ts);
									Yi || O.set(Ts, Yi = new Set), vi.forEach((cu, Xd) => Yi.add(Xd))
								})
							});
							if (oi.length) {
								const fn = [];
								oi.forEach(In => {
									fn.push(function Pr(i, e) {
										return new y.vHH(3505, !1)
									}())
								}), ui.forEach(In => In.destroy()), this.reportError(fn)
							}
							const Jr = new Map,
								wr = new Map;
							h.forEach(fn => {
								const In = fn.element;
								s.has(In) && (wr.set(In, In), this._beforeAnimationBuild(fn.player.namespaceId, fn.instruction, Jr))
							}), c.forEach(fn => {
								const In = fn.element;
								this._getPreviousPlayers(In, !1, fn.namespaceId, fn.triggerName, null).forEach(tr => {
									U(Jr, In, []).push(tr), tr.destroy()
								})
							});
							const yo = Wt.filter(fn => Cc(fn, S, O)),
								zi = new Map;
							Ea(zi, this.driver, sn, O, Nt.l3).forEach(fn => {
								Cc(fn, S, O) && yo.push(fn)
							});
							const oc = new Map;
							Ae.forEach((fn, In) => {
								Ea(oc, this.driver, new Set(fn), S, Nt.k1)
							}), yo.forEach(fn => {
								const In = zi.get(fn),
									An = oc.get(fn);
								zi.set(fn, new Map([...Array.from(In?.entries() ?? []), ...Array.from(An?.entries() ?? [])]))
							});
							const na = [],
								qd = [],
								Qd = {};
							h.forEach(fn => {
								const {
									element: In,
									player: An,
									instruction: tr
								} = fn;
								if (s.has(In)) {
									if ($.has(In)) return An.onDestroy(() => ni(In, tr.toStyles)), An.disabled = !0, An.overrideTotalTime(tr.totalTime), void c.push(An);
									let Xr = Qd;
									if (wr.size > 1) {
										let Di = In;
										const Wo = [];
										for (; Di = Di.parentNode;) {
											const Ar = wr.get(Di);
											if (Ar) {
												Xr = Ar;
												break
											}
											Wo.push(Di)
										}
										Wo.forEach(Ar => wr.set(Ar, Xr))
									}
									const Ki = this._buildAnimation(An.namespaceId, tr, Jr, u, oc, zi);
									if (An.setRealPlayer(Ki), Xr === Qd) na.push(An);
									else {
										const Di = this.playersByElement.get(Xr);
										Di && Di.length && (An.parentPlayer = Sr(Di)), c.push(An)
									}
								} else Si(In, tr.fromStyles), An.onDestroy(() => ni(In, tr.toStyles)), qd.push(An), $.has(In) && c.push(An)
							}), qd.forEach(fn => {
								const In = u.get(fn.element);
								if (In && In.length) {
									const An = Sr(In);
									fn.setRealPlayer(An)
								}
							}), c.forEach(fn => {
								fn.parentPlayer ? fn.syncPlayerEvents(fn.parentPlayer) : fn.destroy()
							});
							for (let fn = 0; fn < Wt.length; fn++) {
								const In = Wt[fn],
									An = In[Hr];
								if (yi(In, me), An && An.hasAnimation) continue;
								let tr = [];
								if (m.size) {
									let Ki = m.get(In);
									Ki && Ki.length && tr.push(...Ki);
									let Di = this.driver.query(In, Dt, !0);
									for (let Wo = 0; Wo < Di.length; Wo++) {
										let Ar = m.get(Di[Wo]);
										Ar && Ar.length && tr.push(...Ar)
									}
								}
								const Xr = tr.filter(Ki => !Ki.destroyed);
								Xr.length ? yr(this, In, Xr) : this.processLeaveNode(In)
							}
							return Wt.length = 0, na.forEach(fn => {
								this.players.push(fn), fn.onDone(() => {
									fn.destroy();
									const In = this.players.indexOf(fn);
									this.players.splice(In, 1)
								}), fn.play()
							}), na
						}
						elementContainsData(e, t) {
							let s = !1;
							const c = t[Hr];
							return c && c.setForRemoval && (s = !0), this.playersByElement.has(t) && (s = !0), this.playersByQueriedElement.has(t) && (s = !0), this.statesByElement.has(t) && (s = !0), this._fetchNamespace(e).elementContainsData(t) || s
						}
						afterFlush(e) {
							this._flushFns.push(e)
						}
						afterFlushAnimationsDone(e) {
							this._whenQuietFns.push(e)
						}
						_getPreviousPlayers(e, t, s, c, u) {
							let h = [];
							if (t) {
								const m = this.playersByQueriedElement.get(e);
								m && (h = m)
							} else {
								const m = this.playersByElement.get(e);
								if (m) {
									const S = !u || u == Eo;
									m.forEach(O => {
										O.queued || !S && O.triggerName != c || h.push(O)
									})
								}
							}
							return (s || c) && (h = h.filter(m => !(s && s != m.namespaceId || c && c != m.triggerName))), h
						}
						_beforeAnimationBuild(e, t, s) {
							const u = t.element,
								h = t.isRemovalTransition ? void 0 : e,
								m = t.isRemovalTransition ? void 0 : t.triggerName;
							for (const S of t.timelines) {
								const O = S.element,
									$ = O !== u,
									le = U(s, O, []);
								this._getPreviousPlayers(O, $, h, m, t.toState).forEach(Ae => {
									const Ze = Ae.getRealPlayer();
									Ze.beforeDestroy && Ze.beforeDestroy(), Ae.destroy(), le.push(Ae)
								})
							}
							Si(u, t.fromStyles)
						}
						_buildAnimation(e, t, s, c, u, h) {
							const m = t.triggerName,
								S = t.element,
								O = [],
								$ = new Set,
								le = new Set,
								Re = t.timelines.map(Ze => {
									const wt = Ze.element;
									$.add(wt);
									const Wt = wt[Hr];
									if (Wt && Wt.removedBeforeQueried) return new Nt.ZN(Ze.duration, Ze.delay);
									const Yt = wt !== S,
										sn = function ul(i) {
											const e = [];
											return Ec(i, e), e
										}((s.get(wt) || ks).map(Jr => Jr.getRealPlayer())).filter(Jr => !!Jr.element && Jr.element === wt),
										kn = u.get(wt),
										fr = h.get(wt),
										ui = $r(0, this._normalizer, 0, Ze.keyframes, kn, fr),
										oi = this._buildPlayer(Ze, ui, sn);
									if (Ze.subTimeline && c && le.add(wt), Yt) {
										const Jr = new Xi(e, m, wt);
										Jr.setRealPlayer(oi), O.push(Jr)
									}
									return oi
								});
							O.forEach(Ze => {
								U(this.playersByQueriedElement, Ze.element, []).push(Ze), Ze.onDone(() => function ya(i, e, t) {
									let s = i.get(e);
									if (s) {
										if (s.length) {
											const c = s.indexOf(t);
											s.splice(c, 1)
										}
										0 == s.length && i.delete(e)
									}
									return s
								}(this.playersByQueriedElement, Ze.element, Ze))
							}), $.forEach(Ze => ur(Ze, dt));
							const Ae = Sr(Re);
							return Ae.onDestroy(() => {
								$.forEach(Ze => yi(Ze, dt)), ni(S, t.toStyles)
							}), le.forEach(Ze => {
								U(c, Ze, []).push(Ae)
							}), Ae
						}
						_buildPlayer(e, t, s) {
							return t.length > 0 ? this.driver.animate(e.element, t, e.duration, e.delay, e.easing, s) : new Nt.ZN(e.duration, e.delay)
						}
					}
					class Xi {
						constructor(e, t, s) {
							this.namespaceId = e, this.triggerName = t, this.element = s, this._player = new Nt.ZN, this._containsRealPlayer = !1, this._queuedCallbacks = new Map, this.destroyed = !1, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0
						}
						setRealPlayer(e) {
							this._containsRealPlayer || (this._player = e, this._queuedCallbacks.forEach((t, s) => {
								t.forEach(c => Ur(e, s, void 0, c))
							}), this._queuedCallbacks.clear(), this._containsRealPlayer = !0, this.overrideTotalTime(e.totalTime), this.queued = !1)
						}
						getRealPlayer() {
							return this._player
						}
						overrideTotalTime(e) {
							this.totalTime = e
						}
						syncPlayerEvents(e) {
							const t = this._player;
							t.triggerCallback && e.onStart(() => t.triggerCallback("start")), e.onDone(() => this.finish()), e.onDestroy(() => this.destroy())
						}
						_queueEvent(e, t) {
							U(this._queuedCallbacks, e, []).push(t)
						}
						onDone(e) {
							this.queued && this._queueEvent("done", e), this._player.onDone(e)
						}
						onStart(e) {
							this.queued && this._queueEvent("start", e), this._player.onStart(e)
						}
						onDestroy(e) {
							this.queued && this._queueEvent("destroy", e), this._player.onDestroy(e)
						}
						init() {
							this._player.init()
						}
						hasStarted() {
							return !this.queued && this._player.hasStarted()
						}
						play() {
							!this.queued && this._player.play()
						}
						pause() {
							!this.queued && this._player.pause()
						}
						restart() {
							!this.queued && this._player.restart()
						}
						finish() {
							this._player.finish()
						}
						destroy() {
							this.destroyed = !0, this._player.destroy()
						}
						reset() {
							!this.queued && this._player.reset()
						}
						setPosition(e) {
							this.queued || this._player.setPosition(e)
						}
						getPosition() {
							return this.queued ? 0 : this._player.getPosition()
						}
						triggerCallback(e) {
							const t = this._player;
							t.triggerCallback && t.triggerCallback(e)
						}
					}

					function rs(i) {
						return i && 1 === i.nodeType
					}

					function Fs(i, e) {
						const t = i.style.display;
						return i.style.display = e ?? "none", t
					}

					function Ea(i, e, t, s, c) {
						const u = [];
						t.forEach(S => u.push(Fs(S)));
						const h = [];
						s.forEach((S, O) => {
							const $ = new Map;
							S.forEach(le => {
								const Re = e.computeStyle(O, le, c);
								$.set(le, Re), (!Re || 0 == Re.length) && (O[Hr] = ll, h.push(O))
							}), i.set(O, $)
						});
						let m = 0;
						return t.forEach(S => Fs(S, u[m++])), h
					}

					function Ca(i, e) {
						const t = new Map;
						if (i.forEach(m => t.set(m, [])), 0 == e.length) return t;
						const s = 1,
							c = new Set(e),
							u = new Map;

						function h(m) {
							if (!m) return s;
							let S = u.get(m);
							if (S) return S;
							const O = m.parentNode;
							return S = t.has(O) ? O : c.has(O) ? s : h(O), u.set(m, S), S
						}
						return e.forEach(m => {
							const S = h(m);
							S !== s && t.get(S).push(m)
						}), t
					}

					function ur(i, e) {
						i.classList?.add(e)
					}

					function yi(i, e) {
						i.classList?.remove(e)
					}

					function yr(i, e, t) {
						Sr(t).onDone(() => i.processLeaveNode(e))
					}

					function Ec(i, e) {
						for (let t = 0; t < i.length; t++) {
							const s = i[t];
							s instanceof Nt.ZE ? Ec(s.players, e) : e.push(s)
						}
					}

					function Cc(i, e, t) {
						const s = t.get(i);
						if (!s) return !1;
						let c = e.get(i);
						return c ? s.forEach(u => c.add(u)) : e.set(i, s), t.delete(i), !0
					}
					class is {
						constructor(e, t, s) {
							this.bodyNode = e, this._driver = t, this._normalizer = s, this._triggerCache = {}, this.onRemovalComplete = (c, u) => {}, this._transitionEngine = new va(e, t, s), this._timelineEngine = new Ns(e, t, s), this._transitionEngine.onRemovalComplete = (c, u) => this.onRemovalComplete(c, u)
						}
						registerTrigger(e, t, s, c, u) {
							const h = e + "-" + c;
							let m = this._triggerCache[h];
							if (!m) {
								const S = [],
									O = [],
									$ = ha(this._driver, u, S, O);
								if (S.length) throw function nr(i, e) {
									return new y.vHH(3404, !1)
								}();
								m = function Ri(i, e, t) {
									return new ga(i, e, t)
								}(c, $, this._normalizer), this._triggerCache[h] = m
							}
							this._transitionEngine.registerTrigger(t, c, m)
						}
						register(e, t) {
							this._transitionEngine.register(e, t)
						}
						destroy(e, t) {
							this._transitionEngine.destroy(e, t)
						}
						onInsert(e, t, s, c) {
							this._transitionEngine.insertNode(e, t, s, c)
						}
						onRemove(e, t, s, c) {
							this._transitionEngine.removeNode(e, t, c || !1, s)
						}
						disableAnimations(e, t) {
							this._transitionEngine.markElementAsDisabled(e, t)
						}
						process(e, t, s, c) {
							if ("@" == s.charAt(0)) {
								const [u, h] = fe(s);
								this._timelineEngine.command(u, t, h, c)
							} else this._transitionEngine.trigger(e, t, s, c)
						}
						listen(e, t, s, c, u) {
							if ("@" == s.charAt(0)) {
								const [h, m] = fe(s);
								return this._timelineEngine.listen(h, t, m, u)
							}
							return this._transitionEngine.listen(e, t, s, c, u)
						}
						flush(e = -1) {
							this._transitionEngine.flush(e)
						}
						get players() {
							return this._transitionEngine.players.concat(this._timelineEngine.players)
						}
						whenRenderingDone() {
							return this._transitionEngine.whenRenderingDone()
						}
					}
					let os = (() => {
						class i {
							constructor(t, s, c) {
								this._element = t, this._startStyles = s, this._endStyles = c, this._state = 0;
								let u = i.initialStylesByElement.get(t);
								u || i.initialStylesByElement.set(t, u = new Map), this._initialStyles = u
							}
							start() {
								this._state < 1 && (this._startStyles && ni(this._element, this._startStyles, this._initialStyles), this._state = 1)
							}
							finish() {
								this.start(), this._state < 2 && (ni(this._element, this._initialStyles), this._endStyles && (ni(this._element, this._endStyles), this._endStyles = null), this._state = 1)
							}
							destroy() {
								this.finish(), this._state < 3 && (i.initialStylesByElement.delete(this._element), this._startStyles && (Si(this._element, this._startStyles), this._endStyles = null), this._endStyles && (Si(this._element, this._endStyles), this._endStyles = null), ni(this._element, this._initialStyles), this._state = 3)
							}
						}
						return i.initialStylesByElement = new WeakMap, i
					})();

					function I(i) {
						let e = null;
						return i.forEach((t, s) => {
							(function W(i) {
								return "display" === i || "position" === i
							})(s) && (e = e || new Map, e.set(s, t))
						}), e
					}
					class M {
						constructor(e, t, s, c) {
							this.element = e, this.keyframes = t, this.options = s, this._specialStyles = c, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this._originalOnDoneFns = [], this._originalOnStartFns = [], this.time = 0, this.parentPlayer = null, this.currentSnapshot = new Map, this._duration = s.duration, this._delay = s.delay || 0, this.time = this._duration + this._delay
						}
						_onFinish() {
							this._finished || (this._finished = !0, this._onDoneFns.forEach(e => e()), this._onDoneFns = [])
						}
						init() {
							this._buildPlayer(), this._preparePlayerBeforeStart()
						}
						_buildPlayer() {
							if (this._initialized) return;
							this._initialized = !0;
							const e = this.keyframes;
							this.domPlayer = this._triggerWebAnimation(this.element, e, this.options), this._finalKeyframe = e.length ? e[e.length - 1] : new Map, this.domPlayer.addEventListener("finish", () => this._onFinish())
						}
						_preparePlayerBeforeStart() {
							this._delay ? this._resetDomPlayerState() : this.domPlayer.pause()
						}
						_convertKeyframesToObject(e) {
							const t = [];
							return e.forEach(s => {
								t.push(Object.fromEntries(s))
							}), t
						}
						_triggerWebAnimation(e, t, s) {
							return e.animate(this._convertKeyframesToObject(t), s)
						}
						onStart(e) {
							this._originalOnStartFns.push(e), this._onStartFns.push(e)
						}
						onDone(e) {
							this._originalOnDoneFns.push(e), this._onDoneFns.push(e)
						}
						onDestroy(e) {
							this._onDestroyFns.push(e)
						}
						play() {
							this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(e => e()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play()
						}
						pause() {
							this.init(), this.domPlayer.pause()
						}
						finish() {
							this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish()
						}
						reset() {
							this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1, this._onStartFns = this._originalOnStartFns, this._onDoneFns = this._originalOnDoneFns
						}
						_resetDomPlayerState() {
							this.domPlayer && this.domPlayer.cancel()
						}
						restart() {
							this.reset(), this.play()
						}
						hasStarted() {
							return this._started
						}
						destroy() {
							this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(e => e()), this._onDestroyFns = [])
						}
						setPosition(e) {
							void 0 === this.domPlayer && this.init(), this.domPlayer.currentTime = e * this.time
						}
						getPosition() {
							return this.domPlayer.currentTime / this.time
						}
						get totalTime() {
							return this._delay + this._duration
						}
						beforeDestroy() {
							const e = new Map;
							this.hasStarted() && this._finalKeyframe.forEach((s, c) => {
								"offset" !== c && e.set(c, this._finished ? s : Ds(this.element, c))
							}), this.currentSnapshot = e
						}
						triggerCallback(e) {
							const t = "start" === e ? this._onStartFns : this._onDoneFns;
							t.forEach(s => s()), t.length = 0
						}
					}
					class ae {
						validateStyleProperty(e) {
							return !0
						}
						validateAnimatableStyleProperty(e) {
							return !0
						}
						matchesElement(e, t) {
							return !1
						}
						containsElement(e, t) {
							return Gt(e, t)
						}
						getParentElement(e) {
							return K(e)
						}
						query(e, t, s) {
							return Rt(e, t, s)
						}
						computeStyle(e, t, s) {
							return window.getComputedStyle(e)[t]
						}
						animate(e, t, s, c, u, h = []) {
							const S = {
								duration: s,
								delay: c,
								fill: 0 == c ? "both" : "forwards"
							};
							u && (S.easing = u);
							const O = new Map,
								$ = h.filter(Ae => Ae instanceof M);
							(function sa(i, e) {
								return 0 === i || 0 === e
							})(s, c) && $.forEach(Ae => {
								Ae.currentSnapshot.forEach((Ze, wt) => O.set(wt, Ze))
							});
							let le = function or(i) {
								return i.length ? i[0] instanceof Map ? i : i.map(e => $n(e)) : []
							}(t).map(Ae => lr(Ae));
							le = function il(i, e, t) {
								if (t.size && e.length) {
									let s = e[0],
										c = [];
									if (t.forEach((u, h) => {
											s.has(h) || c.push(h), s.set(h, u)
										}), c.length)
										for (let u = 1; u < e.length; u++) {
											let h = e[u];
											c.forEach(m => h.set(m, Ds(i, m)))
										}
								}
								return e
							}(e, le, O);
							const Re = function hl(i, e) {
								let t = null,
									s = null;
								return Array.isArray(e) && e.length ? (t = I(e[0]), e.length > 1 && (s = I(e[e.length - 1]))) : e instanceof Map && (t = I(e)), t || s ? new os(i, t, s) : null
							}(e, le);
							return new M(e, le, S, Re)
						}
					}
					let Oe = (() => {
						class i extends Nt._j {
							constructor(t, s) {
								super(), this._nextAnimationId = 0, this._renderer = t.createRenderer(s.body, {
									id: "0",
									encapsulation: y.ifc.None,
									styles: [],
									data: {
										animation: []
									}
								})
							}
							build(t) {
								const s = this._nextAnimationId.toString();
								this._nextAnimationId++;
								const c = Array.isArray(t) ? (0, Nt.vP)(t) : t;
								return dn(this._renderer, null, s, "register", [c]), new ut(s, this._renderer)
							}
						}
						return i.\u0275fac = function(t) {
							return new(t || i)(y.LFG(y.FYo), y.LFG(te.K0))
						}, i.\u0275prov = y.Yz7({
							token: i,
							factory: i.\u0275fac
						}), i
					})();
					class ut extends Nt.LC {
						constructor(e, t) {
							super(), this._id = e, this._renderer = t
						}
						create(e, t) {
							return new It(this._id, e, t || {}, this._renderer)
						}
					}
					class It {
						constructor(e, t, s, c) {
							this.id = e, this.element = t, this._renderer = c, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", s)
						}
						_listen(e, t) {
							return this._renderer.listen(this.element, `@@${this.id}:${e}`, t)
						}
						_command(e, ...t) {
							return dn(this._renderer, this.element, this.id, e, t)
						}
						onDone(e) {
							this._listen("done", e)
						}
						onStart(e) {
							this._listen("start", e)
						}
						onDestroy(e) {
							this._listen("destroy", e)
						}
						init() {
							this._command("init")
						}
						hasStarted() {
							return this._started
						}
						play() {
							this._command("play"), this._started = !0
						}
						pause() {
							this._command("pause")
						}
						restart() {
							this._command("restart")
						}
						finish() {
							this._command("finish")
						}
						destroy() {
							this._command("destroy")
						}
						reset() {
							this._command("reset"), this._started = !1
						}
						setPosition(e) {
							this._command("setPosition", e)
						}
						getPosition() {
							return this._renderer.engine.players[+this.id]?.getPosition() ?? 0
						}
					}

					function dn(i, e, t, s, c) {
						return i.setProperty(e, `@@${t}:${s}`, c)
					}
					const Yn = "@.disabled";
					let rr = (() => {
						class i {
							constructor(t, s, c) {
								this.delegate = t, this.engine = s, this._zone = c, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, this.promise = Promise.resolve(0), s.onRemovalComplete = (u, h) => {
									const m = h?.parentNode(u);
									m && h.removeChild(m, u)
								}
							}
							createRenderer(t, s) {
								const u = this.delegate.createRenderer(t, s);
								if (!(t && s && s.data && s.data.animation)) {
									let $ = this._rendererCache.get(u);
									return $ || ($ = new jn("", u, this.engine, () => this._rendererCache.delete(u)), this._rendererCache.set(u, $)), $
								}
								const h = s.id,
									m = s.id + "-" + this._currentId;
								this._currentId++, this.engine.register(m, t);
								const S = $ => {
									Array.isArray($) ? $.forEach(S) : this.engine.registerTrigger(h, m, t, $.name, $)
								};
								return s.data.animation.forEach(S), new Rr(this, m, u, this.engine)
							}
							begin() {
								this._cdRecurDepth++, this.delegate.begin && this.delegate.begin()
							}
							_scheduleCountTask() {
								this.promise.then(() => {
									this._microtaskId++
								})
							}
							scheduleListenerCallback(t, s, c) {
								t >= 0 && t < this._microtaskId ? this._zone.run(() => s(c)) : (0 == this._animationCallbacksBuffer.length && Promise.resolve(null).then(() => {
									this._zone.run(() => {
										this._animationCallbacksBuffer.forEach(u => {
											const [h, m] = u;
											h(m)
										}), this._animationCallbacksBuffer = []
									})
								}), this._animationCallbacksBuffer.push([s, c]))
							}
							end() {
								this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => {
									this._scheduleCountTask(), this.engine.flush(this._microtaskId)
								}), this.delegate.end && this.delegate.end()
							}
							whenRenderingDone() {
								return this.engine.whenRenderingDone()
							}
						}
						return i.\u0275fac = function(t) {
							return new(t || i)(y.LFG(y.FYo), y.LFG(is), y.LFG(y.R0b))
						}, i.\u0275prov = y.Yz7({
							token: i,
							factory: i.\u0275fac
						}), i
					})();
					class jn {
						constructor(e, t, s, c) {
							this.namespaceId = e, this.delegate = t, this.engine = s, this._onDestroy = c, this.destroyNode = this.delegate.destroyNode ? u => t.destroyNode(u) : null
						}
						get data() {
							return this.delegate.data
						}
						destroy() {
							this.engine.destroy(this.namespaceId, this.delegate), this.delegate.destroy(), this._onDestroy?.()
						}
						createElement(e, t) {
							return this.delegate.createElement(e, t)
						}
						createComment(e) {
							return this.delegate.createComment(e)
						}
						createText(e) {
							return this.delegate.createText(e)
						}
						appendChild(e, t) {
							this.delegate.appendChild(e, t), this.engine.onInsert(this.namespaceId, t, e, !1)
						}
						insertBefore(e, t, s, c = !0) {
							this.delegate.insertBefore(e, t, s), this.engine.onInsert(this.namespaceId, t, e, c)
						}
						removeChild(e, t, s) {
							this.engine.onRemove(this.namespaceId, t, this.delegate, s)
						}
						selectRootElement(e, t) {
							return this.delegate.selectRootElement(e, t)
						}
						parentNode(e) {
							return this.delegate.parentNode(e)
						}
						nextSibling(e) {
							return this.delegate.nextSibling(e)
						}
						setAttribute(e, t, s, c) {
							this.delegate.setAttribute(e, t, s, c)
						}
						removeAttribute(e, t, s) {
							this.delegate.removeAttribute(e, t, s)
						}
						addClass(e, t) {
							this.delegate.addClass(e, t)
						}
						removeClass(e, t) {
							this.delegate.removeClass(e, t)
						}
						setStyle(e, t, s, c) {
							this.delegate.setStyle(e, t, s, c)
						}
						removeStyle(e, t, s) {
							this.delegate.removeStyle(e, t, s)
						}
						setProperty(e, t, s) {
							"@" == t.charAt(0) && t == Yn ? this.disableAnimations(e, !!s) : this.delegate.setProperty(e, t, s)
						}
						setValue(e, t) {
							this.delegate.setValue(e, t)
						}
						listen(e, t, s) {
							return this.delegate.listen(e, t, s)
						}
						disableAnimations(e, t) {
							this.engine.disableAnimations(e, t)
						}
					}
					class Rr extends jn {
						constructor(e, t, s, c, u) {
							super(t, s, c, u), this.factory = e, this.namespaceId = t
						}
						setProperty(e, t, s) {
							"@" == t.charAt(0) ? "." == t.charAt(1) && t == Yn ? this.disableAnimations(e, s = void 0 === s || !!s) : this.engine.process(this.namespaceId, e, t.slice(1), s) : this.delegate.setProperty(e, t, s)
						}
						listen(e, t, s) {
							if ("@" == t.charAt(0)) {
								const c = function dr(i) {
									switch (i) {
										case "body":
											return document.body;
										case "document":
											return document;
										case "window":
											return window;
										default:
											return i
									}
								}(e);
								let u = t.slice(1),
									h = "";
								return "@" != u.charAt(0) && ([u, h] = function Tr(i) {
									const e = i.indexOf(".");
									return [i.substring(0, e), i.slice(e + 1)]
								}(u)), this.engine.listen(this.namespaceId, c, u, h, m => {
									this.factory.scheduleListenerCallback(m._data || -1, s, m)
								})
							}
							return this.delegate.listen(e, t, s)
						}
					}
					const Yr = [{
							provide: Nt._j,
							useClass: Oe
						}, {
							provide: Ps,
							useFactory: function Ii() {
								return new fc
							}
						}, {
							provide: is,
							useClass: (() => {
								class i extends is {
									constructor(t, s, c, u) {
										super(t.body, s, c)
									}
									ngOnDestroy() {
										this.flush()
									}
								}
								return i.\u0275fac = function(t) {
									return new(t || i)(y.LFG(te.K0), y.LFG(Mn), y.LFG(Ps), y.LFG(y.z2F))
								}, i.\u0275prov = y.Yz7({
									token: i,
									factory: i.\u0275fac
								}), i
							})()
						}, {
							provide: y.FYo,
							useFactory: function Hi(i, e, t) {
								return new rr(i, e, t)
							},
							deps: [p.se, is, y.R0b]
						}],
						Mi = [{
							provide: Mn,
							useFactory: () => new ae
						}, {
							provide: y.QbO,
							useValue: "BrowserAnimations"
						}, ...Yr],
						Co = [{
							provide: Mn,
							useClass: Jt
						}, {
							provide: y.QbO,
							useValue: "NoopAnimations"
						}, ...Yr];
					let So = (() => {
						class i {
							static withConfig(t) {
								return {
									ngModule: i,
									providers: t.disableAnimations ? Co : Mi
								}
							}
						}
						return i.\u0275fac = function(t) {
							return new(t || i)
						}, i.\u0275mod = y.oAB({
							type: i
						}), i.\u0275inj = y.cJS({
							providers: Mi,
							imports: [p.b2]
						}), i
					})();
					var Sa = E(3710),
						lh = E(6443);
					let Ls = (() => {
						class i {
							constructor(t) {
								this.store$ = t
							}
							intercept(t, s) {
								return this.store$.select(P.dy).pipe((0, Sa.P)(), (0, lh.z)(c => {
									const u = `${qt.N.apiUrl}/${t.url}`,
										h = t.clone(c?.facilityId ? {
											url: u,
											setHeaders: {
												facilityId: c.facilityId
											}
										} : {
											url: u
										});
									return s.handle(h)
								}))
							}
						}
						return i.\u0275fac = function(t) {
							return new(t || i)(y.LFG(N.yh))
						}, i.\u0275prov = y.Yz7({
							token: i,
							factory: i.\u0275fac
						}), i
					})();
					var _e = E(4367),
						St = (() => {
							return (i = St || (St = {})).AcquireTokenByCode = "acquireTokenByCode", i.AcquireTokenByRefreshToken = "acquireTokenByRefreshToken", i.AcquireTokenSilent = "acquireTokenSilent", i.AcquireTokenSilentAsync = "acquireTokenSilentAsync", i.AcquireTokenPopup = "acquireTokenPopup", i.CryptoOptsGetPublicKeyThumbprint = "cryptoOptsGetPublicKeyThumbprint", i.CryptoOptsSignJwt = "cryptoOptsSignJwt", i.SilentCacheClientAcquireToken = "silentCacheClientAcquireToken", i.SilentIframeClientAcquireToken = "silentIframeClientAcquireToken", i.SilentRefreshClientAcquireToken = "silentRefreshClientAcquireToken", i.SsoSilent = "ssoSilent", i.StandardInteractionClientGetDiscoveredAuthority = "standardInteractionClientGetDiscoveredAuthority", i.FetchAccountIdWithNativeBroker = "fetchAccountIdWithNativeBroker", i.NativeInteractionClientAcquireToken = "nativeInteractionClientAcquireToken", i.BaseClientCreateTokenRequestHeaders = "baseClientCreateTokenRequestHeaders", i.BrokerHandhshake = "brokerHandshake", i.AcquireTokenByRefreshTokenInBroker = "acquireTokenByRefreshTokenInBroker", i.AcquireTokenByBroker = "acquireTokenByBroker", i.RefreshTokenClientExecuteTokenRequest = "refreshTokenClientExecuteTokenRequest", i.RefreshTokenClientAcquireToken = "refreshTokenClientAcquireToken", i.RefreshTokenClientAcquireTokenWithCachedRefreshToken = "refreshTokenClientAcquireTokenWithCachedRefreshToken", i.RefreshTokenClientAcquireTokenByRefreshToken = "refreshTokenClientAcquireTokenByRefreshToken", i.RefreshTokenClientCreateTokenRequestBody = "refreshTokenClientCreateTokenRequestBody", i.AcquireTokenFromCache = "acquireTokenFromCache", i.AcquireTokenBySilentIframe = "acquireTokenBySilentIframe", i.InitializeBaseRequest = "initializeBaseRequest", i.InitializeSilentRequest = "initializeSilentRequest", i.InitializeClientApplication = "initializeClientApplication", i.SilentIframeClientTokenHelper = "silentIframeClientTokenHelper", i.SilentHandlerInitiateAuthRequest = "silentHandlerInitiateAuthRequest", i.SilentHandlerMonitorIframeForHash = "silentHandlerMonitorIframeForHash", i.SilentHandlerLoadFrame = "silentHandlerLoadFrame", i.StandardInteractionClientCreateAuthCodeClient = "standardInteractionClientCreateAuthCodeClient", i.StandardInteractionClientGetClientConfiguration = "standardInteractionClientGetClientConfiguration", i.StandardInteractionClientInitializeAuthorizationRequest = "standardInteractionClientInitializeAuthorizationRequest", i.StandardInteractionClientInitializeAuthorizationCodeRequest = "standardInteractionClientInitializeAuthorizationCodeRequest", i.GetAuthCodeUrl = "getAuthCodeUrl", i.HandleCodeResponseFromServer = "handleCodeResponseFromServer", i.HandleCodeResponseFromHash = "handleCodeResponseFromHash", i.UpdateTokenEndpointAuthority = "updateTokenEndpointAuthority", i.AuthClientAcquireToken = "authClientAcquireToken", i.AuthClientExecuteTokenRequest = "authClientExecuteTokenRequest", i.AuthClientCreateTokenRequestBody = "authClientCreateTokenRequestBody", i.AuthClientCreateQueryString = "authClientCreateQueryString", i.PopTokenGenerateCnf = "popTokenGenerateCnf", i.PopTokenGenerateKid = "popTokenGenerateKid", i.HandleServerTokenResponse = "handleServerTokenResponse", i.AuthorityFactoryCreateDiscoveredInstance = "authorityFactoryCreateDiscoveredInstance", i.AuthorityResolveEndpointsAsync = "authorityResolveEndpointsAsync", i.AuthorityGetCloudDiscoveryMetadataFromNetwork = "authorityGetCloudDiscoveryMetadataFromNetwork", i.AuthorityUpdateCloudDiscoveryMetadata = "authorityUpdateCloudDiscoveryMetadata", i.AuthorityGetEndpointMetadataFromNetwork = "authorityGetEndpointMetadataFromNetwork", i.AuthorityUpdateEndpointMetadata = "authorityUpdateEndpointMetadata", i.AuthorityUpdateMetadataWithRegionalInformation = "authorityUpdateMetadataWithRegionalInformation", i.RegionDiscoveryDetectRegion = "regionDiscoveryDetectRegion", i.RegionDiscoveryGetRegionFromIMDS = "regionDiscoveryGetRegionFromIMDS", i.RegionDiscoveryGetCurrentVersion = "regionDiscoveryGetCurrentVersion", i.AcquireTokenByCodeAsync = "acquireTokenByCodeAsync", i.GetEndpointMetadataFromNetwork = "getEndpointMetadataFromNetwork", i.GetCloudDiscoveryMetadataFromNetworkMeasurement = "getCloudDiscoveryMetadataFromNetworkMeasurement", i.HandleRedirectPromiseMeasurement = "handleRedirectPromiseMeasurement", i.UpdateCloudDiscoveryMetadataMeasurement = "updateCloudDiscoveryMetadataMeasurement", i.UsernamePasswordClientAcquireToken = "usernamePasswordClientAcquireToken", i.NativeMessageHandlerHandshake = "nativeMessageHandlerHandshake", St;
							var i
						})(),
						fi = (() => {
							return (i = fi || (fi = {}))[i.NotStarted = 0] = "NotStarted", i[i.InProgress = 1] = "InProgress", i[i.Completed = 2] = "Completed", fi;
							var i
						})(),
						mu = new Set(["accessTokenSize", "durationMs", "idTokenSize", "matsSilentStatus", "matsHttpStatus", "refreshTokenSize", "queuedTimeMs", "startTimeMs", "status"]),
						q = E(9986),
						_t = E(2689),
						vn = E(2728),
						Ir = function(i) {
							function e(t, s, c) {
								var u = i.call(this, t, s, c) || this;
								return u.name = "ServerError", Object.setPrototypeOf(u, e.prototype), u
							}
							return (0, _t.ZT)(e, i), e
						}(vn.l),
						Ta = ["interaction_required", "consent_required", "login_required"],
						wa = ["message_only", "additional_action", "basic_action", "user_password_expired", "consent_required"],
						Fo_noTokensFoundError_code = "no_tokens_found",
						Fo_noTokensFoundError_desc = "No refresh token found in the cache. Please sign-in.",
						Fo_native_account_unavailable_code = "native_account_unavailable",
						Fo_native_account_unavailable_desc = "The requested account is not available in the native broker. It may have been deleted or logged out. Please sign-in again using an interactive API.",
						Oi = function(i) {
							function e(t, s, c, u, h, m, S) {
								var O = i.call(this, t, s, c) || this;
								return Object.setPrototypeOf(O, e.prototype), O.timestamp = u || q.gT.EMPTY_STRING, O.traceId = h || q.gT.EMPTY_STRING, O.correlationId = m || q.gT.EMPTY_STRING, O.claims = S || q.gT.EMPTY_STRING, O.name = "InteractionRequiredAuthError", O
							}
							return (0, _t.ZT)(e, i), e.isInteractionRequiredError = function(t, s, c) {
								var u = !!t && Ta.indexOf(t) > -1,
									h = !!c && wa.indexOf(c) > -1,
									m = !!s && Ta.some(function(S) {
										return s.indexOf(S) > -1
									});
								return u || m || h
							}, e.createNoTokensFoundError = function() {
								return new e(Fo_noTokensFoundError_code, Fo_noTokensFoundError_desc)
							}, e.createNativeAccountUnavailableError = function() {
								return new e(Fo_native_account_unavailable_code, Fo_native_account_unavailable_desc)
							}, e
						}(vn.l),
						Qe = E(4857),
						ba_missingKidError_code = "missing_kid_error",
						ba_missingKidError_desc = "The JOSE Header for the requested JWT, JWS or JWK object requires a keyId to be configured as the 'kid' header claim. No 'kid' value was provided.",
						ba_missingAlgError_code = "missing_alg_error",
						ba_missingAlgError_desc = "The JOSE Header for the requested JWT, JWS or JWK object requires an algorithm to be specified as the 'alg' header claim. No 'alg' value was provided.",
						_u = function(i) {
							function e(t, s) {
								var c = i.call(this, t, s) || this;
								return c.name = "JoseHeaderError", Object.setPrototypeOf(c, e.prototype), c
							}
							return (0, _t.ZT)(e, i), e.createMissingKidError = function() {
								return new e(ba_missingKidError_code, ba_missingKidError_desc)
							}, e.createMissingAlgError = function() {
								return new e(ba_missingAlgError_code, ba_missingAlgError_desc)
							}, e
						}(vn.l),
						Ia = function() {
							function i(e) {
								this.typ = e.typ, this.alg = e.alg, this.kid = e.kid
							}
							return i.getShrHeaderString = function(e) {
								if (!e.kid) throw _u.createMissingKidError();
								if (!e.alg) throw _u.createMissingAlgError();
								var t = new i({
									typ: e.typ || q.L.Pop,
									kid: e.kid,
									alg: e.alg
								});
								return JSON.stringify(t)
							}, i
						}(),
						Er = function() {
							function i() {}
							return i.decimalToHex = function(e) {
								for (var t = e.toString(16); t.length < 2;) t = "0" + t;
								return t
							}, i
						}(),
						Tc = function() {
							function i(e) {
								this.cryptoObj = e
							}
							return i.prototype.generateGuid = function() {
								try {
									var e = new Uint8Array(16);
									return this.cryptoObj.getRandomValues(e), e[6] |= 64, e[6] &= 79, e[8] |= 128, e[8] &= 191, Er.decimalToHex(e[0]) + Er.decimalToHex(e[1]) + Er.decimalToHex(e[2]) + Er.decimalToHex(e[3]) + "-" + Er.decimalToHex(e[4]) + Er.decimalToHex(e[5]) + "-" + Er.decimalToHex(e[6]) + Er.decimalToHex(e[7]) + "-" + Er.decimalToHex(e[8]) + Er.decimalToHex(e[9]) + "-" + Er.decimalToHex(e[10]) + Er.decimalToHex(e[11]) + Er.decimalToHex(e[12]) + Er.decimalToHex(e[13]) + Er.decimalToHex(e[14]) + Er.decimalToHex(e[15])
								} catch {
									for (var t = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx", s = "0123456789abcdef", c = 0, u = q.gT.EMPTY_STRING, h = 0; h < 36; h++) "-" !== t[h] && "4" !== t[h] && (c = 16 * Math.random() | 0), "x" === t[h] ? u += s[c] : "y" === t[h] ? (c &= 3, u += s[c |= 8]) : u += t[h];
									return u
								}
							}, i.prototype.isGuid = function(e) {
								return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(e)
							}, i
						}(),
						pi = function() {
							function i() {}
							return i.stringToUtf8Arr = function(e) {
								for (var t, s = 0, c = e.length, u = 0; u < c; u++) s += (t = e.charCodeAt(u)) < 128 ? 1 : t < 2048 ? 2 : t < 65536 ? 3 : t < 2097152 ? 4 : t < 67108864 ? 5 : 6;
								for (var h = new Uint8Array(s), m = 0, S = 0; m < s; S++)(t = e.charCodeAt(S)) < 128 ? h[m++] = t : t < 2048 ? (h[m++] = 192 + (t >>> 6), h[m++] = 128 + (63 & t)) : t < 65536 ? (h[m++] = 224 + (t >>> 12), h[m++] = 128 + (t >>> 6 & 63), h[m++] = 128 + (63 & t)) : t < 2097152 ? (h[m++] = 240 + (t >>> 18), h[m++] = 128 + (t >>> 12 & 63), h[m++] = 128 + (t >>> 6 & 63), h[m++] = 128 + (63 & t)) : t < 67108864 ? (h[m++] = 248 + (t >>> 24), h[m++] = 128 + (t >>> 18 & 63), h[m++] = 128 + (t >>> 12 & 63), h[m++] = 128 + (t >>> 6 & 63), h[m++] = 128 + (63 & t)) : (h[m++] = 252 + (t >>> 30), h[m++] = 128 + (t >>> 24 & 63), h[m++] = 128 + (t >>> 18 & 63), h[m++] = 128 + (t >>> 12 & 63), h[m++] = 128 + (t >>> 6 & 63), h[m++] = 128 + (63 & t));
								return h
							}, i.stringToArrayBuffer = function(e) {
								for (var t = new ArrayBuffer(e.length), s = new Uint8Array(t), c = 0; c < e.length; c++) s[c] = e.charCodeAt(c);
								return t
							}, i.utf8ArrToString = function(e) {
								for (var t = q.gT.EMPTY_STRING, s = void 0, c = e.length, u = 0; u < c; u++) s = e[u], t += String.fromCharCode(s > 251 && s < 254 && u + 5 < c ? 1073741824 * (s - 252) + (e[++u] - 128 << 24) + (e[++u] - 128 << 18) + (e[++u] - 128 << 12) + (e[++u] - 128 << 6) + e[++u] - 128 : s > 247 && s < 252 && u + 4 < c ? (s - 248 << 24) + (e[++u] - 128 << 18) + (e[++u] - 128 << 12) + (e[++u] - 128 << 6) + e[++u] - 128 : s > 239 && s < 248 && u + 3 < c ? (s - 240 << 18) + (e[++u] - 128 << 12) + (e[++u] - 128 << 6) + e[++u] - 128 : s > 223 && s < 240 && u + 2 < c ? (s - 224 << 12) + (e[++u] - 128 << 6) + e[++u] - 128 : s > 191 && s < 224 && u + 1 < c ? (s - 192 << 6) + e[++u] - 128 : s);
								return t
							}, i.getSortedObjectString = function(e) {
								return JSON.stringify(e, Object.keys(e).sort())
							}, i
						}(),
						pl = function() {
							function i() {}
							return i.prototype.urlEncode = function(e) {
								return encodeURIComponent(this.encode(e).replace(/=/g, q.gT.EMPTY_STRING).replace(/\+/g, "-").replace(/\//g, "_"))
							}, i.prototype.urlEncodeArr = function(e) {
								return this.base64EncArr(e).replace(/=/g, q.gT.EMPTY_STRING).replace(/\+/g, "-").replace(/\//g, "_")
							}, i.prototype.encode = function(e) {
								var t = pi.stringToUtf8Arr(e);
								return this.base64EncArr(t)
							}, i.prototype.base64EncArr = function(e) {
								for (var t = (3 - e.length % 3) % 3, s = q.gT.EMPTY_STRING, c = void 0, u = e.length, h = 0, m = 0; m < u; m++) h |= e[m] << (16 >>> (c = m % 3) & 24), (2 === c || e.length - m == 1) && (s += String.fromCharCode(this.uint6ToB64(h >>> 18 & 63), this.uint6ToB64(h >>> 12 & 63), this.uint6ToB64(h >>> 6 & 63), this.uint6ToB64(63 & h)), h = 0);
								return 0 === t ? s : s.substring(0, s.length - t) + (1 === t ? "=" : "==")
							}, i.prototype.uint6ToB64 = function(e) {
								return e < 26 ? e + 65 : e < 52 ? e + 71 : e < 62 ? e - 4 : 62 === e ? 43 : 63 === e ? 47 : 65
							}, i
						}(),
						Lo = function() {
							function i() {}
							return i.prototype.decode = function(e) {
								var t = e.replace(/-/g, "+").replace(/_/g, "/");
								switch (t.length % 4) {
									case 0:
										break;
									case 2:
										t += "==";
										break;
									case 3:
										t += "=";
										break;
									default:
										throw new Error("Invalid base64 string")
								}
								var s = this.base64DecToArr(t);
								return pi.utf8ArrToString(s)
							}, i.prototype.base64DecToArr = function(e, t) {
								for (var s = e.replace(/[^A-Za-z0-9\+\/]/g, q.gT.EMPTY_STRING), c = s.length, u = t ? Math.ceil((3 * c + 1 >>> 2) / t) * t : 3 * c + 1 >>> 2, h = new Uint8Array(u), m = void 0, S = void 0, O = 0, $ = 0, le = 0; le < c; le++)
									if (S = 3 & le, O |= this.b64ToUint6(s.charCodeAt(le)) << 18 - 6 * S, 3 === S || c - le == 1) {
										for (m = 0; m < 3 && $ < u; m++, $++) h[$] = O >>> (16 >>> m & 24) & 255;
										O = 0
									} return h
							}, i.prototype.b64ToUint6 = function(e) {
								return e > 64 && e < 91 ? e - 65 : e > 96 && e < 123 ? e - 71 : e > 47 && e < 58 ? e + 4 : 43 === e ? 62 : 47 === e ? 63 : 0
							}, i
						}(),
						rn = E(5963),
						wc = function() {
							function i(e) {
								this.base64Encode = new pl, this.cryptoObj = e
							}
							return i.prototype.generateCodes = function() {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var e, t;
									return (0, _e.Jh)(this, function(s) {
										switch (s.label) {
											case 0:
												return e = this.generateCodeVerifier(), [4, this.generateCodeChallengeFromVerifier(e)];
											case 1:
												return t = s.sent(), [2, {
													verifier: e,
													challenge: t
												}]
										}
									})
								})
							}, i.prototype.generateCodeVerifier = function() {
								try {
									var e = new Uint8Array(32);
									return this.cryptoObj.getRandomValues(e), this.base64Encode.urlEncodeArr(e)
								} catch (s) {
									throw rn.U.createPkceNotGeneratedError(s)
								}
							}, i.prototype.generateCodeChallengeFromVerifier = function(e) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var t, s;
									return (0, _e.Jh)(this, function(c) {
										switch (c.label) {
											case 0:
												return c.trys.push([0, 2, , 3]), [4, this.cryptoObj.sha256Digest(e)];
											case 1:
												return t = c.sent(), [2, this.base64Encode.urlEncodeArr(new Uint8Array(t))];
											case 2:
												throw s = c.sent(), rn.U.createPkceNotGeneratedError(s);
											case 3:
												return [2]
										}
									})
								})
							}, i
						}(),
						uh = function() {
							function i() {}
							return i.prototype.getRandomValues = function(e) {
								return window.crypto.getRandomValues(e)
							}, i.prototype.generateKey = function(e, t, s) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(c) {
										return [2, window.crypto.subtle.generateKey(e, t, s)]
									})
								})
							}, i.prototype.exportKey = function(e) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(t) {
										return [2, window.crypto.subtle.exportKey(Qe.Mm, e)]
									})
								})
							}, i.prototype.importKey = function(e, t, s, c) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(u) {
										return [2, window.crypto.subtle.importKey(Qe.Mm, e, t, s, c)]
									})
								})
							}, i.prototype.sign = function(e, t, s) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(c) {
										return [2, window.crypto.subtle.sign(e, t, s)]
									})
								})
							}, i.prototype.digest = function(e, t) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(s) {
										return [2, window.crypto.subtle.digest(e, t)]
									})
								})
							}, i
						}(),
						vu = function() {
							function i() {}
							return i.prototype.initPrng = function(e) {
								return window.msrCrypto.initPrng((0, _e.fl)(e))
							}, i.prototype.getRandomValues = function(e) {
								return window.msrCrypto.getRandomValues(e)
							}, i.prototype.generateKey = function(e, t, s) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(c) {
										return [2, window.msrCrypto.subtle.generateKey(e, t, s)]
									})
								})
							}, i.prototype.exportKey = function(e) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(t) {
										return [2, window.msrCrypto.subtle.exportKey(Qe.Mm, e)]
									})
								})
							}, i.prototype.importKey = function(e, t, s, c) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(u) {
										return [2, window.msrCrypto.subtle.importKey(Qe.Mm, e, t, s, c)]
									})
								})
							}, i.prototype.sign = function(e, t, s) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(c) {
										return [2, window.msrCrypto.subtle.sign(e, t, s)]
									})
								})
							}, i.prototype.digest = function(e, t) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(s) {
										return [2, window.msrCrypto.subtle.digest(e, t)]
									})
								})
							}, i
						}(),
						Aa = function() {
							function i() {}
							return i.prototype.getRandomValues = function(e) {
								return window.msCrypto.getRandomValues(e)
							}, i.prototype.generateKey = function(e, t, s) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(c) {
										return [2, new Promise(function(u, h) {
											var m = window.msCrypto.subtle.generateKey(e, t, s);
											m.addEventListener("complete", function(S) {
												u(S.target.result)
											}), m.addEventListener("error", function(S) {
												h(S)
											})
										})]
									})
								})
							}, i.prototype.exportKey = function(e) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(t) {
										return [2, new Promise(function(s, c) {
											var u = window.msCrypto.subtle.exportKey(Qe.Mm, e);
											u.addEventListener("complete", function(h) {
												var S = pi.utf8ArrToString(new Uint8Array(h.target.result)).replace(/\r/g, q.gT.EMPTY_STRING).replace(/\n/g, q.gT.EMPTY_STRING).replace(/\t/g, q.gT.EMPTY_STRING).split(" ").join(q.gT.EMPTY_STRING).replace("\0", q.gT.EMPTY_STRING);
												try {
													s(JSON.parse(S))
												} catch (O) {
													c(O)
												}
											}), u.addEventListener("error", function(h) {
												c(h)
											})
										})]
									})
								})
							}, i.prototype.importKey = function(e, t, s, c) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var u, h;
									return (0, _e.Jh)(this, function(m) {
										return u = pi.getSortedObjectString(e), h = pi.stringToArrayBuffer(u), [2, new Promise(function(S, O) {
											var $ = window.msCrypto.subtle.importKey(Qe.Mm, h, t, s, c);
											$.addEventListener("complete", function(le) {
												S(le.target.result)
											}), $.addEventListener("error", function(le) {
												O(le)
											})
										})]
									})
								})
							}, i.prototype.sign = function(e, t, s) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(c) {
										return [2, new Promise(function(u, h) {
											var m = window.msCrypto.subtle.sign(e, t, s);
											m.addEventListener("complete", function(S) {
												u(S.target.result)
											}), m.addEventListener("error", function(S) {
												h(S)
											})
										})]
									})
								})
							}, i.prototype.digest = function(e, t) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(s) {
										return [2, new Promise(function(c, u) {
											var h = window.msCrypto.subtle.digest(e, t.buffer);
											h.addEventListener("complete", function(m) {
												c(m.target.result)
											}), h.addEventListener("error", function(m) {
												u(m)
											})
										})]
									})
								})
							}, i
						}(),
						Zi = E(3593),
						To = "RSASSA-PKCS1-v1_5",
						Uo = "SHA-256",
						gl = 2048,
						bc = new Uint8Array([1, 0, 1]),
						wo = function() {
							function i(e, t) {
								var s, c;
								if (this.logger = e, this.cryptoOptions = t, this.hasBrowserCrypto()) this.logger.verbose("BrowserCrypto: modern crypto interface available"), this.subtleCrypto = new uh;
								else if (this.hasIECrypto()) this.logger.verbose("BrowserCrypto: MS crypto interface available"), this.subtleCrypto = new Aa;
								else {
									if (!this.hasMsrCrypto() || null === (s = this.cryptoOptions) || void 0 === s || !s.useMsrCrypto) throw this.hasMsrCrypto() && this.logger.info("BrowserCrypto: MSR Crypto interface available but system.cryptoOptions.useMsrCrypto not enabled"), this.logger.error("BrowserCrypto: No crypto interfaces available."), rn.U.createCryptoNotAvailableError("Browser crypto, msCrypto, or msrCrypto interfaces not available.");
									this.logger.verbose("BrowserCrypto: MSR crypto interface available"), this.subtleCrypto = new vu
								}
								if (this.subtleCrypto.initPrng) {
									if (this.logger.verbose("BrowserCrypto: Interface requires entropy"), null === (c = this.cryptoOptions) || void 0 === c || !c.entropy) throw this.logger.error("BrowserCrypto: Interface requires entropy but none provided."), Zi.W.createEntropyNotProvided();
									this.logger.verbose("BrowserCrypto: Entropy provided"), this.subtleCrypto.initPrng(this.cryptoOptions.entropy)
								}
								this.keygenAlgorithmOptions = {
									name: To,
									hash: Uo,
									modulusLength: gl,
									publicExponent: bc
								}
							}
							return i.prototype.hasIECrypto = function() {
								return "msCrypto" in window
							}, i.prototype.hasBrowserCrypto = function() {
								return "crypto" in window
							}, i.prototype.hasMsrCrypto = function() {
								return "msrCrypto" in window
							}, i.prototype.sha256Digest = function(e) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var t;
									return (0, _e.Jh)(this, function(s) {
										return t = pi.stringToUtf8Arr(e), [2, this.subtleCrypto.digest({
											name: Uo
										}, t)]
									})
								})
							}, i.prototype.getRandomValues = function(e) {
								return this.subtleCrypto.getRandomValues(e)
							}, i.prototype.generateKeyPair = function(e, t) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(s) {
										return [2, this.subtleCrypto.generateKey(this.keygenAlgorithmOptions, e, t)]
									})
								})
							}, i.prototype.exportJwk = function(e) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(t) {
										return [2, this.subtleCrypto.exportKey(e)]
									})
								})
							}, i.prototype.importJwk = function(e, t, s) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(c) {
										return [2, this.subtleCrypto.importKey(e, this.keygenAlgorithmOptions, t, s)]
									})
								})
							}, i.prototype.sign = function(e, t) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(s) {
										return [2, this.subtleCrypto.sign(this.keygenAlgorithmOptions, e, t)]
									})
								})
							}, i
						}(),
						dh = function() {
							function i() {
								this.dbName = Qe.H4, this.version = Qe.kd, this.tableName = Qe.Gv, this.dbOpen = !1
							}
							return i.prototype.open = function() {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var e = this;
									return (0, _e.Jh)(this, function(t) {
										return [2, new Promise(function(s, c) {
											var u = window.indexedDB.open(e.dbName, e.version);
											u.addEventListener("upgradeneeded", function(h) {
												h.target.result.createObjectStore(e.tableName)
											}), u.addEventListener("success", function(h) {
												e.db = h.target.result, e.dbOpen = !0, s()
											}), u.addEventListener("error", function() {
												return c(rn.U.createDatabaseUnavailableError())
											})
										})]
									})
								})
							}, i.prototype.closeConnection = function() {
								var e = this.db;
								e && this.dbOpen && (e.close(), this.dbOpen = !1)
							}, i.prototype.validateDbIsOpen = function() {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(e) {
										switch (e.label) {
											case 0:
												return this.dbOpen ? [3, 2] : [4, this.open()];
											case 1:
												return [2, e.sent()];
											case 2:
												return [2]
										}
									})
								})
							}, i.prototype.getItem = function(e) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var t = this;
									return (0, _e.Jh)(this, function(s) {
										switch (s.label) {
											case 0:
												return [4, this.validateDbIsOpen()];
											case 1:
												return s.sent(), [2, new Promise(function(c, u) {
													if (!t.db) return u(rn.U.createDatabaseNotOpenError());
													var S = t.db.transaction([t.tableName], "readonly").objectStore(t.tableName).get(e);
													S.addEventListener("success", function(O) {
														var $ = O;
														t.closeConnection(), c($.target.result)
													}), S.addEventListener("error", function(O) {
														t.closeConnection(), u(O)
													})
												})]
										}
									})
								})
							}, i.prototype.setItem = function(e, t) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var s = this;
									return (0, _e.Jh)(this, function(c) {
										switch (c.label) {
											case 0:
												return [4, this.validateDbIsOpen()];
											case 1:
												return c.sent(), [2, new Promise(function(u, h) {
													if (!s.db) return h(rn.U.createDatabaseNotOpenError());
													var O = s.db.transaction([s.tableName], "readwrite").objectStore(s.tableName).put(t, e);
													O.addEventListener("success", function() {
														s.closeConnection(), u()
													}), O.addEventListener("error", function($) {
														s.closeConnection(), h($)
													})
												})]
										}
									})
								})
							}, i.prototype.removeItem = function(e) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var t = this;
									return (0, _e.Jh)(this, function(s) {
										switch (s.label) {
											case 0:
												return [4, this.validateDbIsOpen()];
											case 1:
												return s.sent(), [2, new Promise(function(c, u) {
													if (!t.db) return u(rn.U.createDatabaseNotOpenError());
													var S = t.db.transaction([t.tableName], "readwrite").objectStore(t.tableName).delete(e);
													S.addEventListener("success", function() {
														t.closeConnection(), c()
													}), S.addEventListener("error", function(O) {
														t.closeConnection(), u(O)
													})
												})]
										}
									})
								})
							}, i.prototype.getKeys = function() {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var e = this;
									return (0, _e.Jh)(this, function(t) {
										switch (t.label) {
											case 0:
												return [4, this.validateDbIsOpen()];
											case 1:
												return t.sent(), [2, new Promise(function(s, c) {
													if (!e.db) return c(rn.U.createDatabaseNotOpenError());
													var m = e.db.transaction([e.tableName], "readonly").objectStore(e.tableName).getAllKeys();
													m.addEventListener("success", function(S) {
														var O = S;
														e.closeConnection(), s(O.target.result)
													}), m.addEventListener("error", function(S) {
														e.closeConnection(), c(S)
													})
												})]
										}
									})
								})
							}, i.prototype.containsKey = function(e) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var t = this;
									return (0, _e.Jh)(this, function(s) {
										switch (s.label) {
											case 0:
												return [4, this.validateDbIsOpen()];
											case 1:
												return s.sent(), [2, new Promise(function(c, u) {
													if (!t.db) return u(rn.U.createDatabaseNotOpenError());
													var S = t.db.transaction([t.tableName], "readonly").objectStore(t.tableName).count(e);
													S.addEventListener("success", function(O) {
														var $ = O;
														t.closeConnection(), c(1 === $.target.result)
													}), S.addEventListener("error", function(O) {
														t.closeConnection(), u(O)
													})
												})]
										}
									})
								})
							}, i.prototype.deleteDatabase = function() {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(e) {
										return this.db && this.dbOpen && this.closeConnection(), [2, new Promise(function(t, s) {
											var c = window.indexedDB.deleteDatabase(Qe.H4);
											c.addEventListener("success", function() {
												return t(!0)
											}), c.addEventListener("blocked", function() {
												return t(!0)
											}), c.addEventListener("error", function() {
												return s(!1)
											})
										})]
									})
								})
							}, i
						}(),
						ml = function() {
							function i() {
								this.cache = new Map
							}
							return i.prototype.getItem = function(e) {
								return this.cache.get(e) || null
							}, i.prototype.setItem = function(e, t) {
								this.cache.set(e, t)
							}, i.prototype.removeItem = function(e) {
								this.cache.delete(e)
							}, i.prototype.getKeys = function() {
								var e = [];
								return this.cache.forEach(function(t, s) {
									e.push(s)
								}), e
							}, i.prototype.containsKey = function(e) {
								return this.cache.has(e)
							}, i.prototype.clear = function() {
								this.cache.clear()
							}, i
						}(),
						mr = function() {
							function i(e, t) {
								this.inMemoryCache = new ml, this.indexedDBCache = new dh, this.logger = e, this.storeName = t
							}
							return i.prototype.handleDatabaseAccessError = function(e) {
								if (!(e instanceof rn.U && e.errorCode === rn.n.databaseUnavailable.code)) throw e;
								this.logger.error("Could not access persistent storage. This may be caused by browser privacy features which block persistent storage in third-party contexts.")
							}, i.prototype.getItem = function(e) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var t, s;
									return (0, _e.Jh)(this, function(c) {
										switch (c.label) {
											case 0:
												if (t = this.inMemoryCache.getItem(e)) return [3, 4];
												c.label = 1;
											case 1:
												return c.trys.push([1, 3, , 4]), this.logger.verbose("Queried item not found in in-memory cache, now querying persistent storage."), [4, this.indexedDBCache.getItem(e)];
											case 2:
												return [2, c.sent()];
											case 3:
												return s = c.sent(), this.handleDatabaseAccessError(s), [3, 4];
											case 4:
												return [2, t]
										}
									})
								})
							}, i.prototype.setItem = function(e, t) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var s;
									return (0, _e.Jh)(this, function(c) {
										switch (c.label) {
											case 0:
												this.inMemoryCache.setItem(e, t), c.label = 1;
											case 1:
												return c.trys.push([1, 3, , 4]), [4, this.indexedDBCache.setItem(e, t)];
											case 2:
												return c.sent(), [3, 4];
											case 3:
												return s = c.sent(), this.handleDatabaseAccessError(s), [3, 4];
											case 4:
												return [2]
										}
									})
								})
							}, i.prototype.removeItem = function(e) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var t;
									return (0, _e.Jh)(this, function(s) {
										switch (s.label) {
											case 0:
												this.inMemoryCache.removeItem(e), s.label = 1;
											case 1:
												return s.trys.push([1, 3, , 4]), [4, this.indexedDBCache.removeItem(e)];
											case 2:
												return s.sent(), [3, 4];
											case 3:
												return t = s.sent(), this.handleDatabaseAccessError(t), [3, 4];
											case 4:
												return [2]
										}
									})
								})
							}, i.prototype.getKeys = function() {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var e, t;
									return (0, _e.Jh)(this, function(s) {
										switch (s.label) {
											case 0:
												if (0 !== (e = this.inMemoryCache.getKeys()).length) return [3, 4];
												s.label = 1;
											case 1:
												return s.trys.push([1, 3, , 4]), this.logger.verbose("In-memory cache is empty, now querying persistent storage."), [4, this.indexedDBCache.getKeys()];
											case 2:
												return [2, s.sent()];
											case 3:
												return t = s.sent(), this.handleDatabaseAccessError(t), [3, 4];
											case 4:
												return [2, e]
										}
									})
								})
							}, i.prototype.containsKey = function(e) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var t, s;
									return (0, _e.Jh)(this, function(c) {
										switch (c.label) {
											case 0:
												if (t = this.inMemoryCache.containsKey(e)) return [3, 4];
												c.label = 1;
											case 1:
												return c.trys.push([1, 3, , 4]), this.logger.verbose("Key not found in in-memory cache, now querying persistent storage."), [4, this.indexedDBCache.containsKey(e)];
											case 2:
												return [2, c.sent()];
											case 3:
												return s = c.sent(), this.handleDatabaseAccessError(s), [3, 4];
											case 4:
												return [2, t]
										}
									})
								})
							}, i.prototype.clearInMemory = function() {
								this.logger.verbose("Deleting in-memory keystore " + this.storeName), this.inMemoryCache.clear(), this.logger.verbose("In-memory keystore " + this.storeName + " deleted")
							}, i.prototype.clearPersistent = function() {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var e, t;
									return (0, _e.Jh)(this, function(s) {
										switch (s.label) {
											case 0:
												return s.trys.push([0, 2, , 3]), this.logger.verbose("Deleting persistent keystore"), [4, this.indexedDBCache.deleteDatabase()];
											case 1:
												return (e = s.sent()) && this.logger.verbose("Persistent keystore deleted"), [2, e];
											case 2:
												return t = s.sent(), this.handleDatabaseAccessError(t), [2, !1];
											case 3:
												return [2]
										}
									})
								})
							}, i
						}(),
						bo = (() => {
							return (i = bo || (bo = {})).asymmetricKeys = "asymmetricKeys", i.symmetricKeys = "symmetricKeys", bo;
							var i
						})(),
						Op = function() {
							function i(e) {
								this.logger = e, this.asymmetricKeys = new mr(this.logger, bo.asymmetricKeys), this.symmetricKeys = new mr(this.logger, bo.symmetricKeys)
							}
							return i.prototype.clear = function() {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var e;
									return (0, _e.Jh)(this, function(t) {
										switch (t.label) {
											case 0:
												this.asymmetricKeys.clearInMemory(), this.symmetricKeys.clearInMemory(), t.label = 1;
											case 1:
												return t.trys.push([1, 3, , 4]), [4, this.asymmetricKeys.clearPersistent()];
											case 2:
												return t.sent(), [2, !0];
											case 3:
												return (e = t.sent()) instanceof Error ? this.logger.error("Clearing keystore failed with error: " + e.message) : this.logger.error("Clearing keystore failed with unknown error"), [2, !1];
											case 4:
												return [2]
										}
									})
								})
							}, i
						}(),
						yu = function() {
							function i(e, t, s) {
								this.logger = e, this.browserCrypto = new wo(this.logger, s), this.b64Encode = new pl, this.b64Decode = new Lo, this.guidGenerator = new Tc(this.browserCrypto), this.pkceGenerator = new wc(this.browserCrypto), this.cache = new Op(this.logger), this.performanceClient = t
							}
							return i.prototype.createNewGuid = function() {
								return this.guidGenerator.generateGuid()
							}, i.prototype.base64Encode = function(e) {
								return this.b64Encode.encode(e)
							}, i.prototype.base64Decode = function(e) {
								return this.b64Decode.decode(e)
							}, i.prototype.generatePkceCodes = function() {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(e) {
										return [2, this.pkceGenerator.generateCodes()]
									})
								})
							}, i.prototype.getPublicKeyThumbprint = function(e) {
								var t;
								return (0, _e.mG)(this, void 0, void 0, function() {
									var s, c, u, m, S, O, $;
									return (0, _e.Jh)(this, function(le) {
										switch (le.label) {
											case 0:
												return s = null === (t = this.performanceClient) || void 0 === t ? void 0 : t.startMeasurement(St.CryptoOptsGetPublicKeyThumbprint, e.correlationId), [4, this.browserCrypto.generateKeyPair(i.EXTRACTABLE, i.POP_KEY_USAGES)];
											case 1:
												return c = le.sent(), [4, this.browserCrypto.exportJwk(c.publicKey)];
											case 2:
												return u = le.sent(), m = pi.getSortedObjectString({
													e: u.e,
													kty: u.kty,
													n: u.n
												}), [4, this.hashString(m)];
											case 3:
												return S = le.sent(), [4, this.browserCrypto.exportJwk(c.privateKey)];
											case 4:
												return O = le.sent(), [4, this.browserCrypto.importJwk(O, !1, ["sign"])];
											case 5:
												return $ = le.sent(), [4, this.cache.asymmetricKeys.setItem(S, {
													privateKey: $,
													publicKey: c.publicKey,
													requestMethod: e.resourceRequestMethod,
													requestUri: e.resourceRequestUri
												})];
											case 6:
												return le.sent(), s && s.endMeasurement({
													success: !0
												}), [2, S]
										}
									})
								})
							}, i.prototype.removeTokenBindingKey = function(e) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(s) {
										switch (s.label) {
											case 0:
												return [4, this.cache.asymmetricKeys.removeItem(e)];
											case 1:
												return s.sent(), [4, this.cache.asymmetricKeys.containsKey(e)];
											case 2:
												return [2, !s.sent()]
										}
									})
								})
							}, i.prototype.clearKeystore = function() {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(e) {
										switch (e.label) {
											case 0:
												return [4, this.cache.clear()];
											case 1:
												return [2, e.sent()]
										}
									})
								})
							}, i.prototype.signJwt = function(e, t, s) {
								var c;
								return (0, _e.mG)(this, void 0, void 0, function() {
									var u, h, m, S, O, $, le, Re, Ae, Ze, wt, Wt, Yt;
									return (0, _e.Jh)(this, function(sn) {
										switch (sn.label) {
											case 0:
												return u = null === (c = this.performanceClient) || void 0 === c ? void 0 : c.startMeasurement(St.CryptoOptsSignJwt, s), [4, this.cache.asymmetricKeys.getItem(t)];
											case 1:
												if (!(h = sn.sent())) throw rn.U.createSigningKeyNotFoundInStorageError(t);
												return [4, this.browserCrypto.exportJwk(h.publicKey)];
											case 2:
												return m = sn.sent(), S = pi.getSortedObjectString(m), O = this.b64Encode.urlEncode(JSON.stringify({
													kid: t
												})), $ = Ia.getShrHeaderString({
													kid: O,
													alg: m.alg
												}), le = this.b64Encode.urlEncode($), e.cnf = {
													jwk: JSON.parse(S)
												}, Re = this.b64Encode.urlEncode(JSON.stringify(e)), Ze = pi.stringToArrayBuffer(Ae = le + "." + Re), [4, this.browserCrypto.sign(h.privateKey, Ze)];
											case 3:
												return wt = sn.sent(), Wt = this.b64Encode.urlEncodeArr(new Uint8Array(wt)), Yt = Ae + "." + Wt, u && u.endMeasurement({
													success: !0
												}), [2, Yt]
										}
									})
								})
							}, i.prototype.hashString = function(e) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var t, s;
									return (0, _e.Jh)(this, function(c) {
										switch (c.label) {
											case 0:
												return [4, this.browserCrypto.sha256Digest(e)];
											case 1:
												return t = c.sent(), s = new Uint8Array(t), [2, this.b64Encode.urlEncodeArr(s)]
										}
									})
								})
							}, i.POP_KEY_USAGES = ["sign", "verify"], i.EXTRACTABLE = !0, i
						}(),
						_n = E(1327),
						Wr = (() => {
							return (i = Wr || (Wr = {}))[i.Error = 0] = "Error", i[i.Warning = 1] = "Warning", i[i.Info = 2] = "Info", i[i.Verbose = 3] = "Verbose", i[i.Trace = 4] = "Trace", Wr;
							var i
						})(),
						Eu = function() {
							function i(e, t, s) {
								this.level = Wr.Info;
								var u = e || i.createDefaultLoggerOptions();
								this.localCallback = u.loggerCallback || function() {}, this.piiLoggingEnabled = u.piiLoggingEnabled || !1, this.level = "number" == typeof u.logLevel ? u.logLevel : Wr.Info, this.correlationId = u.correlationId || q.gT.EMPTY_STRING, this.packageName = t || q.gT.EMPTY_STRING, this.packageVersion = s || q.gT.EMPTY_STRING
							}
							return i.createDefaultLoggerOptions = function() {
								return {
									loggerCallback: function() {},
									piiLoggingEnabled: !1,
									logLevel: Wr.Info
								}
							}, i.prototype.clone = function(e, t, s) {
								return new i({
									loggerCallback: this.localCallback,
									piiLoggingEnabled: this.piiLoggingEnabled,
									logLevel: this.level,
									correlationId: s || this.correlationId
								}, e, t)
							}, i.prototype.logMessage = function(e, t) {
								if (!(t.logLevel > this.level || !this.piiLoggingEnabled && t.containsPii)) {
									var c, s = (new Date).toUTCString();
									c = _n.x.isEmpty(t.correlationId) ? _n.x.isEmpty(this.correlationId) ? "[" + s + "]" : "[" + s + "] : [" + this.correlationId + "]" : "[" + s + "] : [" + t.correlationId + "]", this.executeCallback(t.logLevel, c + " : " + this.packageName + "@" + this.packageVersion + " : " + Wr[t.logLevel] + " - " + e, t.containsPii || !1)
								}
							}, i.prototype.executeCallback = function(e, t, s) {
								this.localCallback && this.localCallback(e, t, s)
							}, i.prototype.error = function(e, t) {
								this.logMessage(e, {
									logLevel: Wr.Error,
									containsPii: !1,
									correlationId: t || q.gT.EMPTY_STRING
								})
							}, i.prototype.errorPii = function(e, t) {
								this.logMessage(e, {
									logLevel: Wr.Error,
									containsPii: !0,
									correlationId: t || q.gT.EMPTY_STRING
								})
							}, i.prototype.warning = function(e, t) {
								this.logMessage(e, {
									logLevel: Wr.Warning,
									containsPii: !1,
									correlationId: t || q.gT.EMPTY_STRING
								})
							}, i.prototype.warningPii = function(e, t) {
								this.logMessage(e, {
									logLevel: Wr.Warning,
									containsPii: !0,
									correlationId: t || q.gT.EMPTY_STRING
								})
							}, i.prototype.info = function(e, t) {
								this.logMessage(e, {
									logLevel: Wr.Info,
									containsPii: !1,
									correlationId: t || q.gT.EMPTY_STRING
								})
							}, i.prototype.infoPii = function(e, t) {
								this.logMessage(e, {
									logLevel: Wr.Info,
									containsPii: !0,
									correlationId: t || q.gT.EMPTY_STRING
								})
							}, i.prototype.verbose = function(e, t) {
								this.logMessage(e, {
									logLevel: Wr.Verbose,
									containsPii: !1,
									correlationId: t || q.gT.EMPTY_STRING
								})
							}, i.prototype.verbosePii = function(e, t) {
								this.logMessage(e, {
									logLevel: Wr.Verbose,
									containsPii: !0,
									correlationId: t || q.gT.EMPTY_STRING
								})
							}, i.prototype.trace = function(e, t) {
								this.logMessage(e, {
									logLevel: Wr.Trace,
									containsPii: !1,
									correlationId: t || q.gT.EMPTY_STRING
								})
							}, i.prototype.tracePii = function(e, t) {
								this.logMessage(e, {
									logLevel: Wr.Trace,
									containsPii: !0,
									correlationId: t || q.gT.EMPTY_STRING
								})
							}, i.prototype.isPiiLoggingEnabled = function() {
								return this.piiLoggingEnabled || !1
							}, i
						}(),
						Cu = function() {
							function i(e, t, s, c, u, h) {
								this.authority = t, this.libraryName = c, this.libraryVersion = u, this.applicationTelemetry = h, this.clientId = e, this.logger = s, this.callbacks = new Map, this.eventsByCorrelationId = new Map, this.queueMeasurements = new Map, this.preQueueTimeByCorrelationId = new Map
							}
							return i.prototype.startPerformanceMeasurement = function(e, t) {
								return {}
							}, i.prototype.startPerformanceMeasuremeant = function(e, t) {
								return {}
							}, i.prototype.getIntFields = function() {
								return mu
							}, i.prototype.getPreQueueTime = function(e, t) {
								var s = this.preQueueTimeByCorrelationId.get(t);
								if (s) {
									if (s.name === e) return s.time;
									this.logger.trace("PerformanceClient.getPreQueueTime: no pre-queue time found for " + e + ", unable to add queue measurement")
								} else this.logger.trace("PerformanceClient.getPreQueueTime: no pre-queue times found for correlationId: " + t + ", unable to add queue measurement")
							}, i.prototype.calculateQueuedTime = function(e, t) {
								return e < 1 ? (this.logger.trace("PerformanceClient: preQueueTime should be a positive integer and not " + e), 0) : t < 1 ? (this.logger.trace("PerformanceClient: currentTime should be a positive integer and not " + t), 0) : t < e ? (this.logger.trace("PerformanceClient: currentTime is less than preQueueTime, check how time is being retrieved"), 0) : t - e
							}, i.prototype.addQueueMeasurement = function(e, t, s, c) {
								if (t) {
									if (0 === s) this.logger.trace("PerformanceClient.addQueueMeasurement: queue time provided for " + e + " is " + s);
									else if (!s) return void this.logger.trace("PerformanceClient.addQueueMeasurement: no queue time provided for " + e);
									var u = {
											eventName: e,
											queueTime: s,
											manuallyCompleted: c
										},
										h = this.queueMeasurements.get(t);
									h ? (h.push(u), this.queueMeasurements.set(t, h)) : (this.logger.trace("PerformanceClient.addQueueMeasurement: adding correlationId " + t + " to queue measurements"), this.queueMeasurements.set(t, [u])), this.preQueueTimeByCorrelationId.delete(t)
								} else this.logger.trace("PerformanceClient.addQueueMeasurement: correlationId not provided for " + e + ", cannot add queue measurement")
							}, i.prototype.startMeasurement = function(e, t) {
								var c, u, s = this,
									h = t || this.generateId();
								t || this.logger.info("PerformanceClient: No correlation id provided for " + e + ", generating", h), this.logger.trace("PerformanceClient: Performance measurement started for " + e, h);
								var m = this.startPerformanceMeasuremeant(e, h);
								m.startMeasurement();
								var S = {
									eventId: this.generateId(),
									status: fi.InProgress,
									authority: this.authority,
									libraryName: this.libraryName,
									libraryVersion: this.libraryVersion,
									clientId: this.clientId,
									name: e,
									startTimeMs: Date.now(),
									correlationId: h,
									appName: null === (c = this.applicationTelemetry) || void 0 === c ? void 0 : c.appName,
									appVersion: null === (u = this.applicationTelemetry) || void 0 === u ? void 0 : u.appVersion
								};
								return this.cacheEventByCorrelationId(S), {
									endMeasurement: function(O) {
										return s.endMeasurement((0, _t.pi)((0, _t.pi)({}, S), O), m)
									},
									discardMeasurement: function() {
										return s.discardMeasurements(S.correlationId)
									},
									addStaticFields: function(O) {
										return s.addStaticFields(O, S.correlationId)
									},
									increment: function(O) {
										return s.increment(O, S.correlationId)
									},
									measurement: m,
									event: S
								}
							}, i.prototype.endMeasurement = function(e, t) {
								var c, u, s = this,
									h = this.eventsByCorrelationId.get(e.correlationId);
								if (!h) return this.logger.trace("PerformanceClient: Measurement not found for " + e.eventId, e.correlationId), null;
								var m = e.eventId === h.eventId,
									S = {
										totalQueueTime: 0,
										totalQueueCount: 0,
										manuallyCompletedCount: 0
									};
								m ? (S = this.getQueueInfo(e.correlationId), this.discardCache(h.correlationId)) : null === (c = h.incompleteSubMeasurements) || void 0 === c || c.delete(e.eventId), t?.endMeasurement();
								var O = t?.flushMeasurement();
								if (!O) return this.logger.trace("PerformanceClient: Performance measurement not taken", h.correlationId), null;
								if (this.logger.trace("PerformanceClient: Performance measurement ended for " + e.name + ": " + O + " ms", e.correlationId), !m) return h[e.name + "DurationMs"] = Math.floor(O), (0, _t.pi)({}, h);
								var $ = (0, _t.pi)((0, _t.pi)({}, h), e),
									le = 0;
								return null === (u = $.incompleteSubMeasurements) || void 0 === u || u.forEach(function(Re) {
									s.logger.trace("PerformanceClient: Incomplete submeasurement " + Re.name + " found for " + e.name, $.correlationId), le++
								}), $.incompleteSubMeasurements = void 0, $ = (0, _t.pi)((0, _t.pi)({}, $), {
									durationMs: Math.round(O),
									queuedTimeMs: S.totalQueueTime,
									queuedCount: S.totalQueueCount,
									queuedManuallyCompletedCount: S.manuallyCompletedCount,
									status: fi.Completed,
									incompleteSubsCount: le
								}), this.truncateIntegralFields($, this.getIntFields()), this.emitEvents([$], e.correlationId), $
							}, i.prototype.addStaticFields = function(e, t) {
								this.logger.trace("PerformanceClient: Updating static fields");
								var s = this.eventsByCorrelationId.get(t);
								s ? this.eventsByCorrelationId.set(t, (0, _t.pi)((0, _t.pi)({}, s), e)) : this.logger.trace("PerformanceClient: Event not found for", t)
							}, i.prototype.increment = function(e, t) {
								this.logger.trace("PerformanceClient: Updating counters");
								var s = this.eventsByCorrelationId.get(t);
								if (s)
									for (var c in e) s.hasOwnProperty(c) || (s[c] = 0), s[c] += e[c];
								else this.logger.trace("PerformanceClient: Event not found for", t)
							}, i.prototype.cacheEventByCorrelationId = function(e) {
								var t = this.eventsByCorrelationId.get(e.correlationId);
								t ? (this.logger.trace("PerformanceClient: Performance measurement for " + e.name + " added/updated", e.correlationId), t.incompleteSubMeasurements = t.incompleteSubMeasurements || new Map, t.incompleteSubMeasurements.set(e.eventId, {
									name: e.name,
									startTimeMs: e.startTimeMs
								})) : (this.logger.trace("PerformanceClient: Performance measurement for " + e.name + " started", e.correlationId), this.eventsByCorrelationId.set(e.correlationId, (0, _t.pi)({}, e)))
							}, i.prototype.getQueueInfo = function(e) {
								var t = this.queueMeasurements.get(e);
								t || this.logger.trace("PerformanceClient: no queue measurements found for for correlationId: " + e);
								var s = 0,
									c = 0,
									u = 0;
								return t?.forEach(function(h) {
									s += h.queueTime, c++, u += h.manuallyCompleted ? 1 : 0
								}), {
									totalQueueTime: s,
									totalQueueCount: c,
									manuallyCompletedCount: u
								}
							}, i.prototype.discardMeasurements = function(e) {
								this.logger.trace("PerformanceClient: Performance measurements discarded", e), this.eventsByCorrelationId.delete(e)
							}, i.prototype.discardCache = function(e) {
								this.discardMeasurements(e), this.logger.trace("PerformanceClient: QueueMeasurements discarded", e), this.queueMeasurements.delete(e), this.logger.trace("PerformanceClient: Pre-queue times discarded", e), this.preQueueTimeByCorrelationId.delete(e)
							}, i.prototype.addPerformanceCallback = function(e) {
								var t = this.generateId();
								return this.callbacks.set(t, e), this.logger.verbose("PerformanceClient: Performance callback registered with id: " + t), t
							}, i.prototype.removePerformanceCallback = function(e) {
								var t = this.callbacks.delete(e);
								return this.logger.verbose(t ? "PerformanceClient: Performance callback " + e + " removed." : "PerformanceClient: Performance callback " + e + " not removed."), t
							}, i.prototype.emitEvents = function(e, t) {
								var s = this;
								this.logger.verbose("PerformanceClient: Emitting performance events", t), this.callbacks.forEach(function(c, u) {
									s.logger.trace("PerformanceClient: Emitting event to callback " + u, t), c.apply(null, [e])
								})
							}, i.prototype.truncateIntegralFields = function(e, t) {
								t.forEach(function(s) {
									s in e && "number" == typeof e[s] && (e[s] = Math.floor(e[s]))
								})
							}, i
						}(),
						ss = function() {
							function i() {}
							return i.prototype.startMeasurement = function() {}, i.prototype.endMeasurement = function() {}, i.prototype.flushMeasurement = function() {
								return null
							}, i
						}(),
						hh = function(i) {
							function e() {
								return null !== i && i.apply(this, arguments) || this
							}
							return (0, _t.ZT)(e, i), e.prototype.generateId = function() {
								return "callback-id"
							}, e.prototype.startPerformanceMeasuremeant = function() {
								return new ss
							}, e.prototype.startPerformanceMeasurement = function() {
								return new ss
							}, e.prototype.calculateQueuedTime = function(t, s) {
								return 0
							}, e.prototype.addQueueMeasurement = function(t, s, c) {}, e.prototype.setPreQueueTime = function(t, s) {}, e
						}(Cu),
						Ic = {
							createNewGuid: function() {
								throw vn.l.createUnexpectedError("Crypto interface - createNewGuid() has not been implemented")
							},
							base64Decode: function() {
								throw vn.l.createUnexpectedError("Crypto interface - base64Decode() has not been implemented")
							},
							base64Encode: function() {
								throw vn.l.createUnexpectedError("Crypto interface - base64Encode() has not been implemented")
							},
							generatePkceCodes: function() {
								return (0, _t.mG)(this, void 0, void 0, function() {
									return (0, _t.Jh)(this, function(e) {
										throw vn.l.createUnexpectedError("Crypto interface - generatePkceCodes() has not been implemented")
									})
								})
							},
							getPublicKeyThumbprint: function() {
								return (0, _t.mG)(this, void 0, void 0, function() {
									return (0, _t.Jh)(this, function(e) {
										throw vn.l.createUnexpectedError("Crypto interface - getPublicKeyThumbprint() has not been implemented")
									})
								})
							},
							removeTokenBindingKey: function() {
								return (0, _t.mG)(this, void 0, void 0, function() {
									return (0, _t.Jh)(this, function(e) {
										throw vn.l.createUnexpectedError("Crypto interface - removeTokenBindingKey() has not been implemented")
									})
								})
							},
							clearKeystore: function() {
								return (0, _t.mG)(this, void 0, void 0, function() {
									return (0, _t.Jh)(this, function(e) {
										throw vn.l.createUnexpectedError("Crypto interface - clearKeystore() has not been implemented")
									})
								})
							},
							signJwt: function() {
								return (0, _t.mG)(this, void 0, void 0, function() {
									return (0, _t.Jh)(this, function(e) {
										throw vn.l.createUnexpectedError("Crypto interface - signJwt() has not been implemented")
									})
								})
							},
							hashString: function() {
								return (0, _t.mG)(this, void 0, void 0, function() {
									return (0, _t.Jh)(this, function(e) {
										throw vn.l.createUnexpectedError("Crypto interface - hashString() has not been implemented")
									})
								})
							}
						},
						zt = E(2709);

					function Bo(i, e) {
						if (_n.x.isEmpty(i)) throw zt.e.createClientInfoEmptyError();
						try {
							var t = e.base64Decode(i);
							return JSON.parse(t)
						} catch (s) {
							throw zt.e.createClientInfoDecodingError(s.message)
						}
					}

					function eo(i) {
						if (_n.x.isEmpty(i)) throw zt.e.createClientInfoDecodingError("Home account ID was empty.");
						var e = i.split(q.Bv.CLIENT_INFO_SEPARATOR, 2);
						return {
							uid: e[0],
							utid: e.length < 2 ? q.gT.EMPTY_STRING : e[1]
						}
					}
					var Pi = (() => {
							return (i = Pi || (Pi = {}))[i.Default = 0] = "Default", i[i.Adfs = 1] = "Adfs", i[i.Dsts = 2] = "Dsts", Pi;
							var i
						})(),
						v = function() {
							function i() {}
							return i.prototype.generateAccountId = function() {
								return [this.homeAccountId, this.environment].join(q.Bv.CACHE_KEY_SEPARATOR).toLowerCase()
							}, i.prototype.generateAccountKey = function() {
								return i.generateAccountCacheKey({
									homeAccountId: this.homeAccountId,
									environment: this.environment,
									tenantId: this.realm,
									username: this.username,
									localAccountId: this.localAccountId
								})
							}, i.prototype.generateType = function() {
								switch (this.authorityType) {
									case q.iR.ADFS_ACCOUNT_TYPE:
										return q.LL.ADFS;
									case q.iR.MSAV1_ACCOUNT_TYPE:
										return q.LL.MSA;
									case q.iR.MSSTS_ACCOUNT_TYPE:
										return q.LL.MSSTS;
									case q.iR.GENERIC_ACCOUNT_TYPE:
										return q.LL.GENERIC;
									default:
										throw zt.e.createUnexpectedAccountTypeError()
								}
							}, i.prototype.getAccountInfo = function() {
								return {
									homeAccountId: this.homeAccountId,
									environment: this.environment,
									tenantId: this.realm,
									username: this.username,
									localAccountId: this.localAccountId,
									name: this.name,
									idTokenClaims: this.idTokenClaims,
									nativeAccountId: this.nativeAccountId
								}
							}, i.generateAccountCacheKey = function(e) {
								return [e.homeAccountId, e.environment || q.gT.EMPTY_STRING, e.tenantId || q.gT.EMPTY_STRING].join(q.Bv.CACHE_KEY_SEPARATOR).toLowerCase()
							}, i.createAccount = function(e, t, s, c, u, h, m, S) {
								var O, $, le, Re, Ae, Ze, wt = new i;
								wt.authorityType = q.iR.MSSTS_ACCOUNT_TYPE, wt.clientInfo = e, wt.homeAccountId = t, wt.nativeAccountId = S;
								var Wt = m || c && c.getPreferredCache();
								if (!Wt) throw zt.e.createInvalidCacheEnvironmentError();
								if (wt.environment = Wt, wt.realm = (null === (O = s?.claims) || void 0 === O ? void 0 : O.tid) || q.gT.EMPTY_STRING, s) {
									wt.idTokenClaims = s.claims, wt.localAccountId = (null === ($ = s?.claims) || void 0 === $ ? void 0 : $.oid) || (null === (le = s?.claims) || void 0 === le ? void 0 : le.sub) || q.gT.EMPTY_STRING;
									var Yt = null === (Re = s?.claims) || void 0 === Re ? void 0 : Re.preferred_username,
										sn = null !== (Ae = s?.claims) && void 0 !== Ae && Ae.emails ? s.claims.emails[0] : null;
									wt.username = Yt || sn || q.gT.EMPTY_STRING, wt.name = null === (Ze = s?.claims) || void 0 === Ze ? void 0 : Ze.name
								}
								return wt.cloudGraphHostName = u, wt.msGraphHost = h, wt
							}, i.createGenericAccount = function(e, t, s, c, u, h) {
								var m, S, O, $, le = new i;
								le.authorityType = s && s.authorityType === Pi.Adfs ? q.iR.ADFS_ACCOUNT_TYPE : q.iR.GENERIC_ACCOUNT_TYPE, le.homeAccountId = e, le.realm = q.gT.EMPTY_STRING;
								var Re = h || s && s.getPreferredCache();
								if (!Re) throw zt.e.createInvalidCacheEnvironmentError();
								return t && (le.localAccountId = (null === (m = t?.claims) || void 0 === m ? void 0 : m.oid) || (null === (S = t?.claims) || void 0 === S ? void 0 : S.sub) || q.gT.EMPTY_STRING, le.username = (null === (O = t?.claims) || void 0 === O ? void 0 : O.upn) || q.gT.EMPTY_STRING, le.name = (null === ($ = t?.claims) || void 0 === $ ? void 0 : $.name) || q.gT.EMPTY_STRING, le.idTokenClaims = t?.claims), le.environment = Re, le.cloudGraphHostName = c, le.msGraphHost = u, le
							}, i.generateHomeAccountId = function(e, t, s, c, u) {
								var h, m = null !== (h = u?.claims) && void 0 !== h && h.sub ? u.claims.sub : q.gT.EMPTY_STRING;
								if (t === Pi.Adfs || t === Pi.Dsts) return m;
								if (e) try {
									var S = Bo(e, c);
									if (!_n.x.isEmpty(S.uid) && !_n.x.isEmpty(S.utid)) return "" + S.uid + q.Bv.CLIENT_INFO_SEPARATOR + S.utid
								} catch {}
								return s.verbose("No client info in response"), m
							}, i.isAccountEntity = function(e) {
								return !!e && e.hasOwnProperty("homeAccountId") && e.hasOwnProperty("environment") && e.hasOwnProperty("realm") && e.hasOwnProperty("localAccountId") && e.hasOwnProperty("username") && e.hasOwnProperty("authorityType")
							}, i.accountInfoIsEqual = function(e, t, s) {
								if (!e || !t) return !1;
								var c = !0;
								if (s) {
									var u = e.idTokenClaims || {},
										h = t.idTokenClaims || {};
									c = u.iat === h.iat && u.nonce === h.nonce
								}
								return e.homeAccountId === t.homeAccountId && e.localAccountId === t.localAccountId && e.username === t.username && e.tenantId === t.tenantId && e.environment === t.environment && e.nativeAccountId === t.nativeAccountId && c
							}, i
						}(),
						C = function() {
							function i() {}
							return i._initRegex = function() {
								var e = q.Bv.CACHE_KEY_SEPARATOR;
								i.credentialRegexMap = new Map;
								for (var t = 0, s = Object.keys(q.d3); t < s.length; t++) {
									var c = s[t],
										u = q.d3[c].toLowerCase();
									try {
										i.credentialRegexMap.set(q.d3[c], new RegExp("(?<=" + e + i.credentialDomainRegex + ")" + e + u + e))
									} catch {
										i.credentialRegexMap.set(q.d3[c], new RegExp("" + e + i.credentialDomainRegex + e + u + e))
									}
								}
							}, i.prototype.generateAccountId = function() {
								return i.generateAccountIdForCacheKey(this.homeAccountId, this.environment)
							}, i.prototype.generateCredentialId = function() {
								return i.generateCredentialIdForCacheKey(this.credentialType, this.clientId, this.realm, this.familyId)
							}, i.prototype.generateTarget = function() {
								return i.generateTargetForCacheKey(this.target)
							}, i.prototype.generateCredentialKey = function() {
								return i.generateCredentialCacheKey(this.homeAccountId, this.environment, this.credentialType, this.clientId, this.realm, this.target, this.familyId, this.tokenType, this.requestedClaimsHash)
							}, i.prototype.generateType = function() {
								switch (this.credentialType) {
									case q.d3.ID_TOKEN:
										return q.LL.ID_TOKEN;
									case q.d3.ACCESS_TOKEN:
									case q.d3.ACCESS_TOKEN_WITH_AUTH_SCHEME:
										return q.LL.ACCESS_TOKEN;
									case q.d3.REFRESH_TOKEN:
										return q.LL.REFRESH_TOKEN;
									default:
										throw zt.e.createUnexpectedCredentialTypeError()
								}
							}, i.getCredentialType = function(e) {
								for (var t, s = 0, c = Object.keys(q.d3); s < c.length; s++) {
									var u = c[s];
									if (null !== (t = this.credentialRegexMap.get(q.d3[u])) && void 0 !== t && t.test(e.toLowerCase())) return q.d3[u]
								}
								return q.gT.NOT_DEFINED
							}, i.generateCredentialCacheKey = function(e, t, s, c, u, h, m, S, O) {
								return [this.generateAccountIdForCacheKey(e, t), this.generateCredentialIdForCacheKey(s, c, u, m), this.generateTargetForCacheKey(h), this.generateClaimsHashForCacheKey(O), this.generateSchemeForCacheKey(S)].join(q.Bv.CACHE_KEY_SEPARATOR).toLowerCase()
							}, i.generateAccountIdForCacheKey = function(e, t) {
								return [e, t].join(q.Bv.CACHE_KEY_SEPARATOR).toLowerCase()
							}, i.generateCredentialIdForCacheKey = function(e, t, s, c) {
								return [e, e === q.d3.REFRESH_TOKEN && c || t, s || q.gT.EMPTY_STRING].join(q.Bv.CACHE_KEY_SEPARATOR).toLowerCase()
							}, i.generateTargetForCacheKey = function(e) {
								return (e || q.gT.EMPTY_STRING).toLowerCase()
							}, i.generateClaimsHashForCacheKey = function(e) {
								return (e || q.gT.EMPTY_STRING).toLowerCase()
							}, i.generateSchemeForCacheKey = function(e) {
								return e && e.toLowerCase() !== q.hO.BEARER.toLowerCase() ? e.toLowerCase() : q.gT.EMPTY_STRING
							}, i.credentialDomainRegex = "(https?:\\/\\/)?((([\\w-]+\\.)*([\\w-]{1,63})(\\.(\\w{2,63})))|(localhost))(\\:[0-9]{4,5})?(\\/[\\w-]+)?", i
						}();
					C._initRegex();
					var g = E(4381),
						b = function() {
							function i(e) {
								var t = this,
									s = e ? _n.x.trimArrayEntries((0, _t.pr)(e)) : [],
									c = s ? _n.x.removeEmptyStringsFromArray(s) : [];
								this.validateInputScopes(c), this.scopes = new Set, c.forEach(function(u) {
									return t.scopes.add(u)
								})
							}
							return i.fromString = function(e) {
								return new i((e || q.gT.EMPTY_STRING).split(" "))
							}, i.prototype.validateInputScopes = function(e) {
								if (!e || e.length < 1) throw g.r.createEmptyScopesArrayError()
							}, i.prototype.containsScope = function(e) {
								var s = new i(this.printScopesLowerCase().split(" "));
								return !_n.x.isEmpty(e) && s.scopes.has(e.toLowerCase())
							}, i.prototype.containsScopeSet = function(e) {
								var t = this;
								return !(!e || e.scopes.size <= 0) && this.scopes.size >= e.scopes.size && e.asArray().every(function(s) {
									return t.containsScope(s)
								})
							}, i.prototype.containsOnlyOIDCScopes = function() {
								var e = this,
									t = 0;
								return q.$f.forEach(function(s) {
									e.containsScope(s) && (t += 1)
								}), this.scopes.size === t
							}, i.prototype.appendScope = function(e) {
								_n.x.isEmpty(e) || this.scopes.add(e.trim())
							}, i.prototype.appendScopes = function(e) {
								var t = this;
								try {
									e.forEach(function(s) {
										return t.appendScope(s)
									})
								} catch (s) {
									throw zt.e.createAppendScopeSetError(s)
								}
							}, i.prototype.removeScope = function(e) {
								if (_n.x.isEmpty(e)) throw zt.e.createRemoveEmptyScopeFromSetError(e);
								this.scopes.delete(e.trim())
							}, i.prototype.removeOIDCScopes = function() {
								var e = this;
								q.$f.forEach(function(t) {
									e.scopes.delete(t)
								})
							}, i.prototype.unionScopeSets = function(e) {
								if (!e) throw zt.e.createEmptyInputScopeSetError();
								var t = new Set;
								return e.scopes.forEach(function(s) {
									return t.add(s.toLowerCase())
								}), this.scopes.forEach(function(s) {
									return t.add(s.toLowerCase())
								}), t
							}, i.prototype.intersectingScopeSets = function(e) {
								if (!e) throw zt.e.createEmptyInputScopeSetError();
								e.containsOnlyOIDCScopes() || e.removeOIDCScopes();
								var t = this.unionScopeSets(e),
									s = e.getScopeCount(),
									c = this.getScopeCount();
								return t.size < c + s
							}, i.prototype.getScopeCount = function() {
								return this.scopes.size
							}, i.prototype.asArray = function() {
								var e = [];
								return this.scopes.forEach(function(t) {
									return e.push(t)
								}), e
							}, i.prototype.printScopes = function() {
								return this.scopes ? this.asArray().join(" ") : q.gT.EMPTY_STRING
							}, i.prototype.printScopesLowerCase = function() {
								return this.printScopes().toLowerCase()
							}, i
						}(),
						x = function() {
							function i(e, t) {
								if (_n.x.isEmpty(e)) throw zt.e.createTokenNullOrEmptyError(e);
								this.rawToken = e, this.claims = i.extractTokenClaims(e, t)
							}
							return i.extractTokenClaims = function(e, t) {
								var s = _n.x.decodeAuthToken(e);
								try {
									var u = t.base64Decode(s.JWSPayload);
									return JSON.parse(u)
								} catch (h) {
									throw zt.e.createTokenParsingError(h)
								}
							}, i.checkMaxAge = function(e, t) {
								if (0 === t || Date.now() - 3e5 > e + t) throw zt.e.createMaxAgeTranspiredError()
							}, i
						}(),
						re = function() {
							function i(e, t) {
								this.clientId = e, this.cryptoImpl = t
							}
							return i.prototype.getAllAccounts = function() {
								var e = this,
									t = this.getAccountsFilteredBy(),
									s = Object.keys(t).map(function(h) {
										return t[h]
									});
								return s.length < 1 ? [] : s.map(function(h) {
									var S = i.toObject(new v, h).getAccountInfo(),
										O = e.readIdTokenFromCache(e.clientId, S);
									return O && !S.idTokenClaims && (S.idToken = O.secret, S.idTokenClaims = new x(O.secret, e.cryptoImpl).claims), S
								})
							}, i.prototype.saveCacheRecord = function(e) {
								return (0, _t.mG)(this, void 0, void 0, function() {
									return (0, _t.Jh)(this, function(t) {
										switch (t.label) {
											case 0:
												if (!e) throw zt.e.createNullOrUndefinedCacheRecord();
												return e.account && this.setAccount(e.account), e.idToken && this.setIdTokenCredential(e.idToken), e.accessToken ? [4, this.saveAccessToken(e.accessToken)] : [3, 2];
											case 1:
												t.sent(), t.label = 2;
											case 2:
												return e.refreshToken && this.setRefreshTokenCredential(e.refreshToken), e.appMetadata && this.setAppMetadata(e.appMetadata), [2]
										}
									})
								})
							}, i.prototype.saveAccessToken = function(e) {
								return (0, _t.mG)(this, void 0, void 0, function() {
									var t, s, c, u, h = this;
									return (0, _t.Jh)(this, function(m) {
										switch (m.label) {
											case 0:
												return t = this.getCredentialsFilteredBy({
													clientId: e.clientId,
													credentialType: e.credentialType,
													environment: e.environment,
													homeAccountId: e.homeAccountId,
													realm: e.realm,
													tokenType: e.tokenType,
													requestedClaimsHash: e.requestedClaimsHash
												}), s = b.fromString(e.target), (c = Object.keys(t.accessTokens).map(function(S) {
													return t.accessTokens[S]
												})) ? (u = [], c.forEach(function(S) {
													b.fromString(S.target).intersectingScopeSets(s) && u.push(h.removeCredential(S))
												}), [4, Promise.all(u)]) : [3, 2];
											case 1:
												m.sent(), m.label = 2;
											case 2:
												return this.setAccessTokenCredential(e), [2]
										}
									})
								})
							}, i.prototype.getAccountsFilteredBy = function(e) {
								return this.getAccountsFilteredByInternal(e ? e.homeAccountId : q.gT.EMPTY_STRING, e ? e.environment : q.gT.EMPTY_STRING, e ? e.realm : q.gT.EMPTY_STRING, e ? e.nativeAccountId : q.gT.EMPTY_STRING)
							}, i.prototype.getAccountsFilteredByInternal = function(e, t, s, c) {
								var u = this,
									h = this.getKeys(),
									m = {};
								return h.forEach(function(S) {
									var O = u.getAccount(S);
									O && (e && !u.matchHomeAccountId(O, e) || t && !u.matchEnvironment(O, t) || s && !u.matchRealm(O, s) || c && !u.matchNativeAccountId(O, c) || (m[S] = O))
								}), m
							}, i.prototype.getCredentialsFilteredBy = function(e) {
								return this.getCredentialsFilteredByInternal(e.homeAccountId, e.environment, e.credentialType, e.clientId, e.familyId, e.realm, e.target, e.userAssertionHash, e.tokenType, e.keyId, e.requestedClaimsHash)
							}, i.prototype.getCredentialsFilteredByInternal = function(e, t, s, c, u, h, m, S, O, $, le) {
								var Re = this,
									Ae = this.getKeys(),
									Ze = {
										idTokens: {},
										accessTokens: {},
										refreshTokens: {}
									};
								return Ae.forEach(function(wt) {
									var Wt = C.getCredentialType(wt);
									if (Wt !== q.gT.NOT_DEFINED) {
										var Yt = Re.getSpecificCredential(wt, Wt);
										if (Yt && (!S || Re.matchUserAssertionHash(Yt, S)) && ("string" != typeof e || Re.matchHomeAccountId(Yt, e)) && (!t || Re.matchEnvironment(Yt, t)) && (!h || Re.matchRealm(Yt, h)) && (!s || Re.matchCredentialType(Yt, s)) && (!c || Re.matchClientId(Yt, c)) && (!u || Re.matchFamilyId(Yt, u)) && (!m || Re.matchTarget(Yt, m)) && (!le && !Yt.requestedClaimsHash || Yt.requestedClaimsHash === le) && (s !== q.d3.ACCESS_TOKEN_WITH_AUTH_SCHEME || !(O && !Re.matchTokenType(Yt, O) || O === q.hO.SSH && $ && !Re.matchKeyId(Yt, $)))) {
											var sn = Re.updateCredentialCacheKey(wt, Yt);
											switch (Wt) {
												case q.d3.ID_TOKEN:
													Ze.idTokens[sn] = Yt;
													break;
												case q.d3.ACCESS_TOKEN:
												case q.d3.ACCESS_TOKEN_WITH_AUTH_SCHEME:
													Ze.accessTokens[sn] = Yt;
													break;
												case q.d3.REFRESH_TOKEN:
													Ze.refreshTokens[sn] = Yt
											}
										}
									}
								}), Ze
							}, i.prototype.getAppMetadataFilteredBy = function(e) {
								return this.getAppMetadataFilteredByInternal(e.environment, e.clientId)
							}, i.prototype.getAppMetadataFilteredByInternal = function(e, t) {
								var s = this,
									c = this.getKeys(),
									u = {};
								return c.forEach(function(h) {
									if (s.isAppMetadata(h)) {
										var m = s.getAppMetadata(h);
										m && (e && !s.matchEnvironment(m, e) || t && !s.matchClientId(m, t) || (u[h] = m))
									}
								}), u
							}, i.prototype.getAuthorityMetadataByAlias = function(e) {
								var t = this,
									s = this.getAuthorityMetadataKeys(),
									c = null;
								return s.forEach(function(u) {
									if (t.isAuthorityMetadata(u) && -1 !== u.indexOf(t.clientId)) {
										var h = t.getAuthorityMetadata(u);
										h && -1 !== h.aliases.indexOf(e) && (c = h)
									}
								}), c
							}, i.prototype.removeAllAccounts = function() {
								return (0, _t.mG)(this, void 0, void 0, function() {
									var e, t, s = this;
									return (0, _t.Jh)(this, function(c) {
										switch (c.label) {
											case 0:
												return e = this.getKeys(), t = [], e.forEach(function(u) {
													s.getAccount(u) && t.push(s.removeAccount(u))
												}), [4, Promise.all(t)];
											case 1:
												return c.sent(), [2, !0]
										}
									})
								})
							}, i.prototype.removeAccount = function(e) {
								return (0, _t.mG)(this, void 0, void 0, function() {
									var t;
									return (0, _t.Jh)(this, function(s) {
										switch (s.label) {
											case 0:
												if (!(t = this.getAccount(e))) throw zt.e.createNoAccountFoundError();
												return [4, this.removeAccountContext(t)];
											case 1:
												return [2, s.sent() && this.removeItem(e, q.Xj.ACCOUNT)]
										}
									})
								})
							}, i.prototype.removeAccountContext = function(e) {
								return (0, _t.mG)(this, void 0, void 0, function() {
									var t, s, c, u = this;
									return (0, _t.Jh)(this, function(h) {
										switch (h.label) {
											case 0:
												return t = this.getKeys(), s = e.generateAccountId(), c = [], t.forEach(function(m) {
													var S = C.getCredentialType(m);
													if (S !== q.gT.NOT_DEFINED) {
														var O = u.getSpecificCredential(m, S);
														O && s === O.generateAccountId() && c.push(u.removeCredential(O))
													}
												}), [4, Promise.all(c)];
											case 1:
												return h.sent(), [2, !0]
										}
									})
								})
							}, i.prototype.removeCredential = function(e) {
								return (0, _t.mG)(this, void 0, void 0, function() {
									var t, c;
									return (0, _t.Jh)(this, function(u) {
										switch (u.label) {
											case 0:
												if (t = e.generateCredentialKey(), e.credentialType.toLowerCase() !== q.d3.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) return [3, 4];
												if (e.tokenType !== q.hO.POP) return [3, 4];
												if (!(c = e.keyId)) return [3, 4];
												u.label = 1;
											case 1:
												return u.trys.push([1, 3, , 4]), [4, this.cryptoImpl.removeTokenBindingKey(c)];
											case 2:
												return u.sent(), [3, 4];
											case 3:
												throw u.sent(), zt.e.createBindingKeyNotRemovedError();
											case 4:
												return [2, this.removeItem(t, q.Xj.CREDENTIAL)]
										}
									})
								})
							}, i.prototype.removeAppMetadata = function() {
								var e = this;
								return this.getKeys().forEach(function(s) {
									e.isAppMetadata(s) && e.removeItem(s, q.Xj.APP_METADATA)
								}), !0
							}, i.prototype.readCacheRecord = function(e, t, s, c) {
								var u = this.readAccountFromCache(e),
									h = this.readIdTokenFromCache(t, e),
									m = this.readAccessTokenFromCache(t, e, s),
									S = this.readRefreshTokenFromCache(t, e, !1),
									O = this.readAppMetadataFromCache(c, t);
								return u && h && (u.idTokenClaims = new x(h.secret, this.cryptoImpl).claims), {
									account: u,
									idToken: h,
									accessToken: m,
									refreshToken: S,
									appMetadata: O
								}
							}, i.prototype.readAccountFromCache = function(e) {
								var t = v.generateAccountCacheKey(e);
								return this.getAccount(t)
							}, i.prototype.readAccountFromCacheWithNativeAccountId = function(e) {
								var s = this.getAccountsFilteredBy({
										nativeAccountId: e
									}),
									c = Object.keys(s).map(function(u) {
										return s[u]
									});
								if (c.length < 1) return null;
								if (c.length > 1) throw zt.e.createMultipleMatchingAccountsInCacheError();
								return c[0]
							}, i.prototype.readIdTokenFromCache = function(e, t) {
								var c = this.getCredentialsFilteredBy({
										homeAccountId: t.homeAccountId,
										environment: t.environment,
										credentialType: q.d3.ID_TOKEN,
										clientId: e,
										realm: t.tenantId
									}),
									u = Object.keys(c.idTokens).map(function(m) {
										return c.idTokens[m]
									}),
									h = u.length;
								if (h < 1) return null;
								if (h > 1) throw zt.e.createMultipleMatchingTokensInCacheError();
								return u[0]
							}, i.prototype.readAccessTokenFromCache = function(e, t, s) {
								var c = new b(s.scopes || []),
									u = s.authenticationScheme || q.hO.BEARER,
									h = u && u.toLowerCase() !== q.hO.BEARER.toLowerCase() ? q.d3.ACCESS_TOKEN_WITH_AUTH_SCHEME : q.d3.ACCESS_TOKEN,
									m = {
										homeAccountId: t.homeAccountId,
										environment: t.environment,
										credentialType: h,
										clientId: e,
										realm: t.tenantId,
										target: c.printScopesLowerCase(),
										tokenType: u,
										keyId: s.sshKid,
										requestedClaimsHash: s.requestedClaimsHash
									},
									S = this.getCredentialsFilteredBy(m),
									O = Object.keys(S.accessTokens).map(function(le) {
										return S.accessTokens[le]
									}),
									$ = O.length;
								if ($ < 1) return null;
								if ($ > 1) throw zt.e.createMultipleMatchingTokensInCacheError();
								return O[0]
							}, i.prototype.readRefreshTokenFromCache = function(e, t, s) {
								var h = this.getCredentialsFilteredBy({
										homeAccountId: t.homeAccountId,
										environment: t.environment,
										credentialType: q.d3.REFRESH_TOKEN,
										clientId: e,
										familyId: s ? q.ch : void 0
									}),
									m = Object.keys(h.refreshTokens).map(function(O) {
										return h.refreshTokens[O]
									});
								return m.length < 1 ? null : m[0]
							}, i.prototype.readAppMetadataFromCache = function(e, t) {
								var c = this.getAppMetadataFilteredBy({
										environment: e,
										clientId: t
									}),
									u = Object.keys(c).map(function(m) {
										return c[m]
									}),
									h = u.length;
								if (h < 1) return null;
								if (h > 1) throw zt.e.createMultipleMatchingAppMetadataInCacheError();
								return u[0]
							}, i.prototype.isAppMetadataFOCI = function(e, t) {
								var s = this.readAppMetadataFromCache(e, t);
								return !(!s || s.familyId !== q.ch)
							}, i.prototype.matchHomeAccountId = function(e, t) {
								return "string" == typeof e.homeAccountId && t === e.homeAccountId
							}, i.prototype.matchUserAssertionHash = function(e, t) {
								return !(!e.userAssertionHash || t !== e.userAssertionHash)
							}, i.prototype.matchEnvironment = function(e, t) {
								var s = this.getAuthorityMetadataByAlias(t);
								return !!(s && s.aliases.indexOf(e.environment) > -1)
							}, i.prototype.matchCredentialType = function(e, t) {
								return e.credentialType && t.toLowerCase() === e.credentialType.toLowerCase()
							}, i.prototype.matchClientId = function(e, t) {
								return !(!e.clientId || t !== e.clientId)
							}, i.prototype.matchFamilyId = function(e, t) {
								return !(!e.familyId || t !== e.familyId)
							}, i.prototype.matchRealm = function(e, t) {
								return !(!e.realm || t !== e.realm)
							}, i.prototype.matchNativeAccountId = function(e, t) {
								return !(!e.nativeAccountId || t !== e.nativeAccountId)
							}, i.prototype.matchTarget = function(e, t) {
								if (e.credentialType !== q.d3.ACCESS_TOKEN && e.credentialType !== q.d3.ACCESS_TOKEN_WITH_AUTH_SCHEME || !e.target) return !1;
								var c = b.fromString(e.target),
									u = b.fromString(t);
								return u.containsOnlyOIDCScopes() ? u.removeScope(q.gT.OFFLINE_ACCESS_SCOPE) : u.removeOIDCScopes(), c.containsScopeSet(u)
							}, i.prototype.matchTokenType = function(e, t) {
								return !(!e.tokenType || e.tokenType !== t)
							}, i.prototype.matchKeyId = function(e, t) {
								return !(!e.keyId || e.keyId !== t)
							}, i.prototype.isAppMetadata = function(e) {
								return -1 !== e.indexOf(q.dg)
							}, i.prototype.isAuthorityMetadata = function(e) {
								return -1 !== e.indexOf(q.QU.CACHE_KEY)
							}, i.prototype.generateAuthorityMetadataCacheKey = function(e) {
								return q.QU.CACHE_KEY + "-" + this.clientId + "-" + e
							}, i.prototype.getSpecificCredential = function(e, t) {
								switch (t) {
									case q.d3.ID_TOKEN:
										return this.getIdTokenCredential(e);
									case q.d3.ACCESS_TOKEN:
									case q.d3.ACCESS_TOKEN_WITH_AUTH_SCHEME:
										return this.getAccessTokenCredential(e);
									case q.d3.REFRESH_TOKEN:
										return this.getRefreshTokenCredential(e);
									default:
										return null
								}
							}, i.toObject = function(e, t) {
								for (var s in t) e[s] = t[s];
								return e
							}, i
						}(),
						de = function(i) {
							function e() {
								return null !== i && i.apply(this, arguments) || this
							}
							return (0, _t.ZT)(e, i), e.prototype.setAccount = function() {
								throw vn.l.createUnexpectedError("Storage interface - setAccount() has not been implemented for the cacheStorage interface.")
							}, e.prototype.getAccount = function() {
								throw vn.l.createUnexpectedError("Storage interface - getAccount() has not been implemented for the cacheStorage interface.")
							}, e.prototype.setIdTokenCredential = function() {
								throw vn.l.createUnexpectedError("Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.")
							}, e.prototype.getIdTokenCredential = function() {
								throw vn.l.createUnexpectedError("Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.")
							}, e.prototype.setAccessTokenCredential = function() {
								throw vn.l.createUnexpectedError("Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.")
							}, e.prototype.getAccessTokenCredential = function() {
								throw vn.l.createUnexpectedError("Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.")
							}, e.prototype.setRefreshTokenCredential = function() {
								throw vn.l.createUnexpectedError("Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.")
							}, e.prototype.getRefreshTokenCredential = function() {
								throw vn.l.createUnexpectedError("Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.")
							}, e.prototype.setAppMetadata = function() {
								throw vn.l.createUnexpectedError("Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.")
							}, e.prototype.getAppMetadata = function() {
								throw vn.l.createUnexpectedError("Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.")
							}, e.prototype.setServerTelemetry = function() {
								throw vn.l.createUnexpectedError("Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.")
							}, e.prototype.getServerTelemetry = function() {
								throw vn.l.createUnexpectedError("Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.")
							}, e.prototype.setAuthorityMetadata = function() {
								throw vn.l.createUnexpectedError("Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.")
							}, e.prototype.getAuthorityMetadata = function() {
								throw vn.l.createUnexpectedError("Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.")
							}, e.prototype.getAuthorityMetadataKeys = function() {
								throw vn.l.createUnexpectedError("Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.")
							}, e.prototype.setThrottlingCache = function() {
								throw vn.l.createUnexpectedError("Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.")
							}, e.prototype.getThrottlingCache = function() {
								throw vn.l.createUnexpectedError("Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.")
							}, e.prototype.removeItem = function() {
								throw vn.l.createUnexpectedError("Storage interface - removeItem() has not been implemented for the cacheStorage interface.")
							}, e.prototype.containsKey = function() {
								throw vn.l.createUnexpectedError("Storage interface - containsKey() has not been implemented for the cacheStorage interface.")
							}, e.prototype.getKeys = function() {
								throw vn.l.createUnexpectedError("Storage interface - getKeys() has not been implemented for the cacheStorage interface.")
							}, e.prototype.clear = function() {
								return (0, _t.mG)(this, void 0, void 0, function() {
									return (0, _t.Jh)(this, function(s) {
										throw vn.l.createUnexpectedError("Storage interface - clear() has not been implemented for the cacheStorage interface.")
									})
								})
							}, e.prototype.updateCredentialCacheKey = function() {
								throw vn.l.createUnexpectedError("Storage interface - updateCredentialCacheKey() has not been implemented for the cacheStorage interface.")
							}, e
						}(re),
						We = function(i) {
							function e() {
								return null !== i && i.apply(this, arguments) || this
							}
							return (0, _t.ZT)(e, i), e.createIdTokenEntity = function(t, s, c, u, h) {
								var m = new e;
								return m.credentialType = q.d3.ID_TOKEN, m.homeAccountId = t, m.environment = s, m.clientId = u, m.secret = c, m.realm = h, m
							}, e.isIdTokenEntity = function(t) {
								return !!t && t.hasOwnProperty("homeAccountId") && t.hasOwnProperty("environment") && t.hasOwnProperty("credentialType") && t.hasOwnProperty("realm") && t.hasOwnProperty("clientId") && t.hasOwnProperty("secret") && t.credentialType === q.d3.ID_TOKEN
							}, e
						}(C),
						bt = function() {
							function i() {}
							return i.nowSeconds = function() {
								return Math.round((new Date).getTime() / 1e3)
							}, i.isTokenExpired = function(e, t) {
								var s = Number(e) || 0;
								return i.nowSeconds() + t > s
							}, i.wasClockTurnedBack = function(e) {
								return Number(e) > i.nowSeconds()
							}, i.delay = function(e, t) {
								return new Promise(function(s) {
									return setTimeout(function() {
										return s(t)
									}, e)
								})
							}, i
						}(),
						Kt = function(i) {
							function e() {
								return null !== i && i.apply(this, arguments) || this
							}
							return (0, _t.ZT)(e, i), e.createAccessTokenEntity = function(t, s, c, u, h, m, S, O, $, le, Re, Ae, Ze, wt, Wt) {
								var Yt, sn, kn = new e;
								kn.homeAccountId = t, kn.credentialType = q.d3.ACCESS_TOKEN, kn.secret = c;
								var fr = bt.nowSeconds();
								if (kn.cachedAt = fr.toString(), kn.expiresOn = S.toString(), kn.extendedExpiresOn = O.toString(), le && (kn.refreshOn = le.toString()), kn.environment = s, kn.clientId = u, kn.realm = h, kn.target = m, kn.userAssertionHash = Ae, kn.tokenType = _n.x.isEmpty(Re) ? q.hO.BEARER : Re, wt && (kn.requestedClaims = wt, kn.requestedClaimsHash = Wt), (null === (Yt = kn.tokenType) || void 0 === Yt ? void 0 : Yt.toLowerCase()) !== q.hO.BEARER.toLowerCase()) switch (kn.credentialType = q.d3.ACCESS_TOKEN_WITH_AUTH_SCHEME, kn.tokenType) {
									case q.hO.POP:
										var ui = x.extractTokenClaims(c, $);
										if (null === (sn = ui?.cnf) || void 0 === sn || !sn.kid) throw zt.e.createTokenClaimsRequiredError();
										kn.keyId = ui.cnf.kid;
										break;
									case q.hO.SSH:
										kn.keyId = Ze
								}
								return kn
							}, e.isAccessTokenEntity = function(t) {
								return !!t && t.hasOwnProperty("homeAccountId") && t.hasOwnProperty("environment") && t.hasOwnProperty("credentialType") && t.hasOwnProperty("realm") && t.hasOwnProperty("clientId") && t.hasOwnProperty("secret") && t.hasOwnProperty("target") && (t.credentialType === q.d3.ACCESS_TOKEN || t.credentialType === q.d3.ACCESS_TOKEN_WITH_AUTH_SCHEME)
							}, e
						}(C),
						on = function(i) {
							function e() {
								return null !== i && i.apply(this, arguments) || this
							}
							return (0, _t.ZT)(e, i), e.createRefreshTokenEntity = function(t, s, c, u, h, m) {
								var S = new e;
								return S.clientId = u, S.credentialType = q.d3.REFRESH_TOKEN, S.environment = s, S.homeAccountId = t, S.secret = c, S.userAssertionHash = m, h && (S.familyId = h), S
							}, e.isRefreshTokenEntity = function(t) {
								return !!t && t.hasOwnProperty("homeAccountId") && t.hasOwnProperty("environment") && t.hasOwnProperty("credentialType") && t.hasOwnProperty("clientId") && t.hasOwnProperty("secret") && t.credentialType === q.d3.REFRESH_TOKEN
							}, e
						}(C),
						zn = function() {
							function i() {}
							return i.prototype.generateAppMetadataKey = function() {
								return i.generateAppMetadataCacheKey(this.environment, this.clientId)
							}, i.generateAppMetadataCacheKey = function(e, t) {
								return [q.dg, e, t].join(q.Bv.CACHE_KEY_SEPARATOR).toLowerCase()
							}, i.createAppMetadataEntity = function(e, t, s) {
								var c = new i;
								return c.clientId = e, c.environment = t, s && (c.familyId = s), c
							}, i.isAppMetadataEntity = function(e, t) {
								return !!t && 0 === e.indexOf(q.dg) && t.hasOwnProperty("clientId") && t.hasOwnProperty("environment")
							}, i
						}(),
						xr = function() {
							function i() {
								this.failedRequests = [], this.errors = [], this.cacheHits = 0
							}
							return i.isServerTelemetryEntity = function(e, t) {
								var s = 0 === e.indexOf(q.HN.CACHE_KEY),
									c = !0;
								return t && (c = t.hasOwnProperty("failedRequests") && t.hasOwnProperty("errors") && t.hasOwnProperty("cacheHits")), s && c
							}, i
						}(),
						Gi = function() {
							function i() {
								this.expiresAt = bt.nowSeconds() + q.QU.REFRESH_TIME_SECONDS
							}
							return i.prototype.updateCloudDiscoveryMetadata = function(e, t) {
								this.aliases = e.aliases, this.preferred_cache = e.preferred_cache, this.preferred_network = e.preferred_network, this.aliasesFromNetwork = t
							}, i.prototype.updateEndpointMetadata = function(e, t) {
								this.authorization_endpoint = e.authorization_endpoint, this.token_endpoint = e.token_endpoint, this.end_session_endpoint = e.end_session_endpoint, this.issuer = e.issuer, this.endpointsFromNetwork = t, this.jwks_uri = e.jwks_uri
							}, i.prototype.updateCanonicalAuthority = function(e) {
								this.canonical_authority = e
							}, i.prototype.resetExpiresAt = function() {
								this.expiresAt = bt.nowSeconds() + q.QU.REFRESH_TIME_SECONDS
							}, i.prototype.isExpired = function() {
								return this.expiresAt <= bt.nowSeconds()
							}, i.isAuthorityMetadataEntity = function(e, t) {
								return !!t && 0 === e.indexOf(q.QU.CACHE_KEY) && t.hasOwnProperty("aliases") && t.hasOwnProperty("preferred_cache") && t.hasOwnProperty("preferred_network") && t.hasOwnProperty("canonical_authority") && t.hasOwnProperty("authorization_endpoint") && t.hasOwnProperty("token_endpoint") && t.hasOwnProperty("issuer") && t.hasOwnProperty("aliasesFromNetwork") && t.hasOwnProperty("endpointsFromNetwork") && t.hasOwnProperty("expiresAt") && t.hasOwnProperty("jwks_uri")
							}, i
						}(),
						to = function() {
							function i() {}
							return i.isThrottlingEntity = function(e, t) {
								var s = !1;
								e && (s = 0 === e.indexOf(q.bb.THROTTLING_PREFIX));
								var c = !0;
								return t && (c = t.hasOwnProperty("throttleTime")), s && c
							}, i
						}(),
						gi = function() {
							function i() {}
							return i.setRequestState = function(e, t, s) {
								var c = i.generateLibraryState(e, s);
								return _n.x.isEmpty(t) ? c : "" + c + q.gT.RESOURCE_DELIM + t
							}, i.generateLibraryState = function(e, t) {
								if (!e) throw zt.e.createNoCryptoObjectError("generateLibraryState");
								var s = {
									id: e.createNewGuid()
								};
								t && (s.meta = t);
								var c = JSON.stringify(s);
								return e.base64Encode(c)
							}, i.parseRequestState = function(e, t) {
								if (!e) throw zt.e.createNoCryptoObjectError("parseRequestState");
								if (_n.x.isEmpty(t)) throw zt.e.createInvalidStateError(t, "Null, undefined or empty state");
								try {
									var s = t.split(q.gT.RESOURCE_DELIM),
										c = s[0],
										u = s.length > 1 ? s.slice(1).join(q.gT.RESOURCE_DELIM) : q.gT.EMPTY_STRING,
										h = e.base64Decode(c),
										m = JSON.parse(h);
									return {
										userRequestState: _n.x.isEmpty(u) ? q.gT.EMPTY_STRING : u,
										libraryState: m
									}
								} catch (S) {
									throw zt.e.createInvalidStateError(t, S)
								}
							}, i
						}(),
						Cr = (() => {
							return (i = Cr || (Cr = {})).HOME_ACCOUNT_ID = "home_account_id", i.UPN = "UPN", Cr;
							var i
						})(),
						Su = function() {
							function i(e) {
								this.validateWindowStorage(e), this.windowStorage = window[e]
							}
							return i.prototype.validateWindowStorage = function(e) {
								if (e !== Qe.Ix.LocalStorage && e !== Qe.Ix.SessionStorage) throw Zi.W.createStorageNotSupportedError(e);
								if (!window[e]) throw Zi.W.createStorageNotSupportedError(e)
							}, i.prototype.getItem = function(e) {
								return this.windowStorage.getItem(e)
							}, i.prototype.setItem = function(e, t) {
								this.windowStorage.setItem(e, t)
							}, i.prototype.removeItem = function(e) {
								this.windowStorage.removeItem(e)
							}, i.prototype.getKeys = function() {
								return Object.keys(this.windowStorage)
							}, i.prototype.containsKey = function(e) {
								return this.windowStorage.hasOwnProperty(e)
							}, i
						}(),
						Xn = E(6767),
						_l = function() {
							function i() {}
							return i.extractBrowserRequestState = function(e, t) {
								if (_n.x.isEmpty(t)) return null;
								try {
									return gi.parseRequestState(e, t).libraryState.meta
								} catch (c) {
									throw zt.e.createInvalidStateError(t, c)
								}
							}, i.parseServerResponseFromHash = function(e) {
								if (!e) return {};
								var t = new Xn.G(e);
								return Xn.G.getDeserializedHash(t.getHash())
							}, i
						}(),
						Dc = function(i) {
							function e(t, s, c, u) {
								var h = i.call(this, t, c) || this;
								return h.COOKIE_LIFE_MULTIPLIER = 864e5, h.cacheConfig = s, h.logger = u, h.internalStorage = new ml, h.browserStorage = h.setupBrowserStorage(h.cacheConfig.cacheLocation), h.temporaryCacheStorage = h.setupTemporaryCacheStorage(h.cacheConfig.cacheLocation), h.migrateCacheEntries(), h
							}
							return (0, _e.ZT)(e, i), e.prototype.setupBrowserStorage = function(t) {
								switch (t) {
									case Qe.Ix.LocalStorage:
									case Qe.Ix.SessionStorage:
										try {
											return new Su(t)
										} catch (s) {
											this.logger.verbose(s);
											break
										}
								}
								return this.cacheConfig.cacheLocation = Qe.Ix.MemoryStorage, new ml
							}, e.prototype.setupTemporaryCacheStorage = function(t) {
								switch (t) {
									case Qe.Ix.LocalStorage:
									case Qe.Ix.SessionStorage:
										try {
											return new Su(Qe.Ix.SessionStorage)
										} catch (s) {
											return this.logger.verbose(s), this.internalStorage
										}
									default:
										return this.internalStorage
								}
							}, e.prototype.migrateCacheEntries = function() {
								var t = this,
									c = q.gT.CACHE_PREFIX + "." + q.Vi.CLIENT_INFO,
									u = q.gT.CACHE_PREFIX + "." + q.Vi.ERROR,
									h = q.gT.CACHE_PREFIX + "." + q.Vi.ERROR_DESC,
									le = [this.browserStorage.getItem(q.gT.CACHE_PREFIX + "." + q.Vi.ID_TOKEN), this.browserStorage.getItem(c), this.browserStorage.getItem(u), this.browserStorage.getItem(h)];
								[q.Vi.ID_TOKEN, q.Vi.CLIENT_INFO, q.Vi.ERROR, q.Vi.ERROR_DESC].forEach(function(Ae, Ze) {
									return t.migrateCacheEntry(Ae, le[Ze])
								})
							}, e.prototype.migrateCacheEntry = function(t, s) {
								s && this.setTemporaryCache(t, s, !0)
							}, e.prototype.validateAndParseJson = function(t) {
								try {
									var s = JSON.parse(t);
									return s && "object" == typeof s ? s : null
								} catch {
									return null
								}
							}, e.prototype.getItem = function(t) {
								return this.browserStorage.getItem(t)
							}, e.prototype.setItem = function(t, s) {
								this.browserStorage.setItem(t, s)
							}, e.prototype.getAccount = function(t) {
								var s = this.getItem(t);
								if (!s) return null;
								var c = this.validateAndParseJson(s);
								return c && v.isAccountEntity(c) ? re.toObject(new v, c) : null
							}, e.prototype.setAccount = function(t) {
								this.logger.trace("BrowserCacheManager.setAccount called");
								var s = t.generateAccountKey();
								this.setItem(s, JSON.stringify(t))
							}, e.prototype.getIdTokenCredential = function(t) {
								var s = this.getItem(t);
								if (!s) return this.logger.trace("BrowserCacheManager.getIdTokenCredential: called, no cache hit"), null;
								var c = this.validateAndParseJson(s);
								return c && We.isIdTokenEntity(c) ? (this.logger.trace("BrowserCacheManager.getIdTokenCredential: cache hit"), re.toObject(new We, c)) : (this.logger.trace("BrowserCacheManager.getIdTokenCredential: called, no cache hit"), null)
							}, e.prototype.setIdTokenCredential = function(t) {
								this.logger.trace("BrowserCacheManager.setIdTokenCredential called");
								var s = t.generateCredentialKey();
								this.setItem(s, JSON.stringify(t))
							}, e.prototype.getAccessTokenCredential = function(t) {
								var s = this.getItem(t);
								if (!s) return this.logger.trace("BrowserCacheManager.getAccessTokenCredential: called, no cache hit"), null;
								var c = this.validateAndParseJson(s);
								return c && Kt.isAccessTokenEntity(c) ? (this.logger.trace("BrowserCacheManager.getAccessTokenCredential: cache hit"), re.toObject(new Kt, c)) : (this.logger.trace("BrowserCacheManager.getAccessTokenCredential: called, no cache hit"), null)
							}, e.prototype.setAccessTokenCredential = function(t) {
								this.logger.trace("BrowserCacheManager.setAccessTokenCredential called");
								var s = t.generateCredentialKey();
								this.setItem(s, JSON.stringify(t))
							}, e.prototype.getRefreshTokenCredential = function(t) {
								var s = this.getItem(t);
								if (!s) return this.logger.trace("BrowserCacheManager.getRefreshTokenCredential: called, no cache hit"), null;
								var c = this.validateAndParseJson(s);
								return c && on.isRefreshTokenEntity(c) ? (this.logger.trace("BrowserCacheManager.getRefreshTokenCredential: cache hit"), re.toObject(new on, c)) : (this.logger.trace("BrowserCacheManager.getRefreshTokenCredential: called, no cache hit"), null)
							}, e.prototype.setRefreshTokenCredential = function(t) {
								this.logger.trace("BrowserCacheManager.setRefreshTokenCredential called");
								var s = t.generateCredentialKey();
								this.setItem(s, JSON.stringify(t))
							}, e.prototype.getAppMetadata = function(t) {
								var s = this.getItem(t);
								if (!s) return this.logger.trace("BrowserCacheManager.getAppMetadata: called, no cache hit"), null;
								var c = this.validateAndParseJson(s);
								return c && zn.isAppMetadataEntity(t, c) ? (this.logger.trace("BrowserCacheManager.getAppMetadata: cache hit"), re.toObject(new zn, c)) : (this.logger.trace("BrowserCacheManager.getAppMetadata: called, no cache hit"), null)
							}, e.prototype.setAppMetadata = function(t) {
								this.logger.trace("BrowserCacheManager.setAppMetadata called");
								var s = t.generateAppMetadataKey();
								this.setItem(s, JSON.stringify(t))
							}, e.prototype.getServerTelemetry = function(t) {
								var s = this.getItem(t);
								if (!s) return this.logger.trace("BrowserCacheManager.getServerTelemetry: called, no cache hit"), null;
								var c = this.validateAndParseJson(s);
								return c && xr.isServerTelemetryEntity(t, c) ? (this.logger.trace("BrowserCacheManager.getServerTelemetry: cache hit"), re.toObject(new xr, c)) : (this.logger.trace("BrowserCacheManager.getServerTelemetry: called, no cache hit"), null)
							}, e.prototype.setServerTelemetry = function(t, s) {
								this.logger.trace("BrowserCacheManager.setServerTelemetry called"), this.setItem(t, JSON.stringify(s))
							}, e.prototype.getAuthorityMetadata = function(t) {
								var s = this.internalStorage.getItem(t);
								if (!s) return this.logger.trace("BrowserCacheManager.getAuthorityMetadata: called, no cache hit"), null;
								var c = this.validateAndParseJson(s);
								return c && Gi.isAuthorityMetadataEntity(t, c) ? (this.logger.trace("BrowserCacheManager.getAuthorityMetadata: cache hit"), re.toObject(new Gi, c)) : null
							}, e.prototype.getAuthorityMetadataKeys = function() {
								var t = this;
								return this.internalStorage.getKeys().filter(function(c) {
									return t.isAuthorityMetadata(c)
								})
							}, e.prototype.setWrapperMetadata = function(t, s) {
								this.internalStorage.setItem(Qe.Bs.WRAPPER_SKU, t), this.internalStorage.setItem(Qe.Bs.WRAPPER_VER, s)
							}, e.prototype.getWrapperMetadata = function() {
								return [this.internalStorage.getItem(Qe.Bs.WRAPPER_SKU) || q.gT.EMPTY_STRING, this.internalStorage.getItem(Qe.Bs.WRAPPER_VER) || q.gT.EMPTY_STRING]
							}, e.prototype.setAuthorityMetadata = function(t, s) {
								this.logger.trace("BrowserCacheManager.setAuthorityMetadata called"), this.internalStorage.setItem(t, JSON.stringify(s))
							}, e.prototype.getActiveAccount = function() {
								var t = this.generateCacheKey(q.Vi.ACTIVE_ACCOUNT_FILTERS),
									s = this.getItem(t);
								if (!s) {
									this.logger.trace("BrowserCacheManager.getActiveAccount: No active account filters cache schema found, looking for legacy schema");
									var c = this.generateCacheKey(q.Vi.ACTIVE_ACCOUNT),
										u = this.getItem(c);
									if (!u) return this.logger.trace("BrowserCacheManager.getActiveAccount: No active account found"), null;
									var h = this.getAccountInfoByFilter({
										localAccountId: u
									})[0] || null;
									return h ? (this.logger.trace("BrowserCacheManager.getActiveAccount: Legacy active account cache schema found"), this.logger.trace("BrowserCacheManager.getActiveAccount: Adding active account filters cache schema"), this.setActiveAccount(h), h) : null
								}
								var m = this.validateAndParseJson(s);
								return m ? (this.logger.trace("BrowserCacheManager.getActiveAccount: Active account filters schema found"), this.getAccountInfoByFilter({
									homeAccountId: m.homeAccountId,
									localAccountId: m.localAccountId
								})[0] || null) : (this.logger.trace("BrowserCacheManager.getActiveAccount: No active account found"), null)
							}, e.prototype.setActiveAccount = function(t) {
								var s = this.generateCacheKey(q.Vi.ACTIVE_ACCOUNT_FILTERS),
									c = this.generateCacheKey(q.Vi.ACTIVE_ACCOUNT);
								t ? (this.logger.verbose("setActiveAccount: Active account set"), this.browserStorage.setItem(s, JSON.stringify({
									homeAccountId: t.homeAccountId,
									localAccountId: t.localAccountId
								})), this.browserStorage.setItem(c, t.localAccountId)) : (this.logger.verbose("setActiveAccount: No account passed, active account not set"), this.browserStorage.removeItem(s), this.browserStorage.removeItem(c))
							}, e.prototype.getAccountInfoByFilter = function(t) {
								var s = this.getAllAccounts();
								return this.logger.trace("BrowserCacheManager.getAccountInfoByFilter: total " + s.length + " accounts found"), s.filter(function(c) {
									return !(t.username && t.username.toLowerCase() !== c.username.toLowerCase() || t.homeAccountId && t.homeAccountId !== c.homeAccountId || t.localAccountId && t.localAccountId !== c.localAccountId || t.tenantId && t.tenantId !== c.tenantId || t.environment && t.environment !== c.environment)
								})
							}, e.prototype.getAccountInfoByHints = function(t, s) {
								var c = this.getAllAccounts().filter(function(u) {
									return s ? s === (u.idTokenClaims && u.idTokenClaims.sid) : !!t && t === u.username
								});
								if (1 === c.length) return c[0];
								if (c.length > 1) throw zt.e.createMultipleMatchingAccountsInCacheError();
								return null
							}, e.prototype.getThrottlingCache = function(t) {
								var s = this.getItem(t);
								if (!s) return this.logger.trace("BrowserCacheManager.getThrottlingCache: called, no cache hit"), null;
								var c = this.validateAndParseJson(s);
								return c && to.isThrottlingEntity(t, c) ? (this.logger.trace("BrowserCacheManager.getThrottlingCache: cache hit"), re.toObject(new to, c)) : (this.logger.trace("BrowserCacheManager.getThrottlingCache: called, no cache hit"), null)
							}, e.prototype.setThrottlingCache = function(t, s) {
								this.logger.trace("BrowserCacheManager.setThrottlingCache called"), this.setItem(t, JSON.stringify(s))
							}, e.prototype.getTemporaryCache = function(t, s) {
								var c = s ? this.generateCacheKey(t) : t;
								if (this.cacheConfig.storeAuthStateInCookie) {
									var u = this.getItemCookie(c);
									if (u) return this.logger.trace("BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies"), u
								}
								var h = this.temporaryCacheStorage.getItem(c);
								if (!h) {
									if (this.cacheConfig.cacheLocation === Qe.Ix.LocalStorage) {
										var m = this.browserStorage.getItem(c);
										if (m) return this.logger.trace("BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage"), m
									}
									return this.logger.trace("BrowserCacheManager.getTemporaryCache: No cache item found in local storage"), null
								}
								return this.logger.trace("BrowserCacheManager.getTemporaryCache: Temporary cache item returned"), h
							}, e.prototype.setTemporaryCache = function(t, s, c) {
								var u = c ? this.generateCacheKey(t) : t;
								this.temporaryCacheStorage.setItem(u, s), this.cacheConfig.storeAuthStateInCookie && (this.logger.trace("BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie"), this.setItemCookie(u, s))
							}, e.prototype.removeItem = function(t) {
								return this.browserStorage.removeItem(t), this.temporaryCacheStorage.removeItem(t), this.cacheConfig.storeAuthStateInCookie && (this.logger.trace("BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie"), this.clearItemCookie(t)), !0
							}, e.prototype.containsKey = function(t) {
								return this.browserStorage.containsKey(t) || this.temporaryCacheStorage.containsKey(t)
							}, e.prototype.getKeys = function() {
								return (0, _e.fl)(this.browserStorage.getKeys(), this.temporaryCacheStorage.getKeys())
							}, e.prototype.clear = function() {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var t = this;
									return (0, _e.Jh)(this, function(s) {
										switch (s.label) {
											case 0:
												return [4, this.removeAllAccounts()];
											case 1:
												return s.sent(), this.removeAppMetadata(), this.getKeys().forEach(function(c) {
													(t.browserStorage.containsKey(c) || t.temporaryCacheStorage.containsKey(c)) && (-1 !== c.indexOf(q.gT.CACHE_PREFIX) || -1 !== c.indexOf(t.clientId)) && t.removeItem(c)
												}), this.internalStorage.clear(), [2]
										}
									})
								})
							}, e.prototype.setItemCookie = function(t, s, c) {
								var u = encodeURIComponent(t) + "=" + encodeURIComponent(s) + ";path=/;SameSite=Lax;";
								c && (u += "expires=" + this.getCookieExpirationTime(c) + ";"), this.cacheConfig.secureCookies && (u += "Secure;"), document.cookie = u
							}, e.prototype.getItemCookie = function(t) {
								for (var s = encodeURIComponent(t) + "=", c = document.cookie.split(";"), u = 0; u < c.length; u++) {
									for (var h = c[u];
										" " === h.charAt(0);) h = h.substring(1);
									if (0 === h.indexOf(s)) return decodeURIComponent(h.substring(s.length, h.length))
								}
								return q.gT.EMPTY_STRING
							}, e.prototype.clearMsalCookies = function() {
								var t = this,
									s = q.gT.CACHE_PREFIX + "." + this.clientId;
								document.cookie.split(";").forEach(function(u) {
									for (;
										" " === u.charAt(0);) u = u.substring(1);
									if (0 === u.indexOf(s)) {
										var h = u.split("=")[0];
										t.clearItemCookie(h)
									}
								})
							}, e.prototype.clearItemCookie = function(t) {
								this.setItemCookie(t, q.gT.EMPTY_STRING, -1)
							}, e.prototype.getCookieExpirationTime = function(t) {
								return new Date((new Date).getTime() + t * this.COOKIE_LIFE_MULTIPLIER).toUTCString()
							}, e.prototype.getCache = function() {
								return this.browserStorage
							}, e.prototype.setCache = function() {}, e.prototype.generateCacheKey = function(t) {
								return this.validateAndParseJson(t) ? JSON.stringify(t) : _n.x.startsWith(t, q.gT.CACHE_PREFIX) || _n.x.startsWith(t, q.Vi.ADAL_ID_TOKEN) ? t : q.gT.CACHE_PREFIX + "." + this.clientId + "." + t
							}, e.prototype.generateAuthorityKey = function(t) {
								var s = gi.parseRequestState(this.cryptoImpl, t).libraryState.id;
								return this.generateCacheKey(Qe.c4.AUTHORITY + "." + s)
							}, e.prototype.generateNonceKey = function(t) {
								var s = gi.parseRequestState(this.cryptoImpl, t).libraryState.id;
								return this.generateCacheKey(Qe.c4.NONCE_IDTOKEN + "." + s)
							}, e.prototype.generateStateKey = function(t) {
								var s = gi.parseRequestState(this.cryptoImpl, t).libraryState.id;
								return this.generateCacheKey(Qe.c4.REQUEST_STATE + "." + s)
							}, e.prototype.getCachedAuthority = function(t) {
								var s = this.generateStateKey(t),
									c = this.getTemporaryCache(s);
								if (!c) return null;
								var u = this.generateAuthorityKey(c);
								return this.getTemporaryCache(u)
							}, e.prototype.updateCacheEntries = function(t, s, c, u, h) {
								this.logger.trace("BrowserCacheManager.updateCacheEntries called");
								var m = this.generateStateKey(t);
								this.setTemporaryCache(m, t, !1);
								var S = this.generateNonceKey(t);
								this.setTemporaryCache(S, s, !1);
								var O = this.generateAuthorityKey(t);
								if (this.setTemporaryCache(O, c, !1), h) {
									var $ = {
										credential: h.homeAccountId,
										type: Cr.HOME_ACCOUNT_ID
									};
									this.setTemporaryCache(Qe.c4.CCS_CREDENTIAL, JSON.stringify($), !0)
								} else _n.x.isEmpty(u) || ($ = {
									credential: u,
									type: Cr.UPN
								}, this.setTemporaryCache(Qe.c4.CCS_CREDENTIAL, JSON.stringify($), !0))
							}, e.prototype.resetRequestCache = function(t) {
								var s = this;
								this.logger.trace("BrowserCacheManager.resetRequestCache called"), _n.x.isEmpty(t) || this.getKeys().forEach(function(c) {
									-1 !== c.indexOf(t) && s.removeItem(c)
								}), t && (this.removeItem(this.generateStateKey(t)), this.removeItem(this.generateNonceKey(t)), this.removeItem(this.generateAuthorityKey(t))), this.removeItem(this.generateCacheKey(Qe.c4.REQUEST_PARAMS)), this.removeItem(this.generateCacheKey(Qe.c4.ORIGIN_URI)), this.removeItem(this.generateCacheKey(Qe.c4.URL_HASH)), this.removeItem(this.generateCacheKey(Qe.c4.CORRELATION_ID)), this.removeItem(this.generateCacheKey(Qe.c4.CCS_CREDENTIAL)), this.removeItem(this.generateCacheKey(Qe.c4.NATIVE_REQUEST)), this.setInteractionInProgress(!1)
							}, e.prototype.cleanRequestByState = function(t) {
								if (this.logger.trace("BrowserCacheManager.cleanRequestByState called"), t) {
									var s = this.generateStateKey(t),
										c = this.temporaryCacheStorage.getItem(s);
									this.logger.infoPii("BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: " + c), this.resetRequestCache(c || q.gT.EMPTY_STRING)
								}
								this.clearMsalCookies()
							}, e.prototype.cleanRequestByInteractionType = function(t) {
								var s = this;
								this.logger.trace("BrowserCacheManager.cleanRequestByInteractionType called"), this.getKeys().forEach(function(c) {
									if (-1 !== c.indexOf(Qe.c4.REQUEST_STATE)) {
										var u = s.temporaryCacheStorage.getItem(c);
										if (u) {
											var h = _l.extractBrowserRequestState(s.cryptoImpl, u);
											h && h.interactionType === t && (s.logger.infoPii("BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: " + u), s.resetRequestCache(u))
										}
									}
								}), this.clearMsalCookies(), this.setInteractionInProgress(!1)
							}, e.prototype.cacheCodeRequest = function(t, s) {
								this.logger.trace("BrowserCacheManager.cacheCodeRequest called");
								var c = s.base64Encode(JSON.stringify(t));
								this.setTemporaryCache(Qe.c4.REQUEST_PARAMS, c, !0)
							}, e.prototype.getCachedRequest = function(t, s) {
								this.logger.trace("BrowserCacheManager.getCachedRequest called");
								var c = this.getTemporaryCache(Qe.c4.REQUEST_PARAMS, !0);
								if (!c) throw rn.U.createNoTokenRequestCacheError();
								var u = this.validateAndParseJson(s.base64Decode(c));
								if (!u) throw rn.U.createUnableToParseTokenRequestCacheError();
								if (this.removeItem(this.generateCacheKey(Qe.c4.REQUEST_PARAMS)), _n.x.isEmpty(u.authority)) {
									var h = this.generateAuthorityKey(t),
										m = this.getTemporaryCache(h);
									if (!m) throw rn.U.createNoCachedAuthorityError();
									u.authority = m
								}
								return u
							}, e.prototype.getCachedNativeRequest = function() {
								this.logger.trace("BrowserCacheManager.getCachedNativeRequest called");
								var t = this.getTemporaryCache(Qe.c4.NATIVE_REQUEST, !0);
								return t ? this.validateAndParseJson(t) || (this.logger.error("BrowserCacheManager.getCachedNativeRequest: Unable to parse native request"), null) : (this.logger.trace("BrowserCacheManager.getCachedNativeRequest: No cached native request found"), null)
							}, e.prototype.isInteractionInProgress = function(t) {
								var s = this.getInteractionInProgress();
								return t ? s === this.clientId : !!s
							}, e.prototype.getInteractionInProgress = function() {
								return this.getTemporaryCache(q.gT.CACHE_PREFIX + "." + Qe.c4.INTERACTION_STATUS_KEY, !1)
							}, e.prototype.setInteractionInProgress = function(t) {
								var s = q.gT.CACHE_PREFIX + "." + Qe.c4.INTERACTION_STATUS_KEY;
								if (t) {
									if (this.getInteractionInProgress()) throw rn.U.createInteractionInProgressError();
									this.setTemporaryCache(s, this.clientId, !1)
								} else !t && this.getInteractionInProgress() === this.clientId && this.removeItem(s)
							}, e.prototype.getLegacyLoginHint = function() {
								var t = this.getTemporaryCache(q.Vi.ADAL_ID_TOKEN);
								t && (this.browserStorage.removeItem(q.Vi.ADAL_ID_TOKEN), this.logger.verbose("Cached ADAL id token retrieved."));
								var s = this.getTemporaryCache(q.Vi.ID_TOKEN, !0);
								s && (this.removeItem(this.generateCacheKey(q.Vi.ID_TOKEN)), this.logger.verbose("Cached MSAL.js v1 id token retrieved"));
								var c = s || t;
								if (c) {
									var u = new x(c, this.cryptoImpl);
									if (u.claims && u.claims.preferred_username) return this.logger.verbose("No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 preferred_username as loginHint"), u.claims.preferred_username;
									if (u.claims && u.claims.upn) return this.logger.verbose("No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 upn as loginHint"), u.claims.upn;
									this.logger.verbose("No SSO params used and ADAL/MSAL v1 token retrieved, however, no account hint claim found. Enable preferred_username or upn id token claim to get SSO.")
								}
								return null
							}, e.prototype.updateCredentialCacheKey = function(t, s) {
								var c = s.generateCredentialKey();
								if (t !== c) {
									var u = this.getItem(t);
									if (u) return this.removeItem(t), this.setItem(c, u), this.logger.verbose("Updated an outdated " + s.credentialType + " cache key"), c;
									this.logger.error("Attempted to update an outdated " + s.credentialType + " cache key but no item matching the outdated key was found in storage")
								}
								return t
							}, e.prototype.getRedirectRequestContext = function() {
								return this.getTemporaryCache(Qe.c4.REDIRECT_CONTEXT, !0)
							}, e.prototype.setRedirectRequestContext = function(t) {
								this.setTemporaryCache(Qe.c4.REDIRECT_CONTEXT, t, !0)
							}, e
						}(re),
						vl = function(i, e) {
							return new Dc(i, {
								cacheLocation: Qe.Ix.MemoryStorage,
								storeAuthStateInCookie: !1,
								secureCookies: !1
							}, Ic, e)
						},
						as = (() => {
							return (i = as || (as = {})).AAD = "AAD", i.OIDC = "OIDC", as;
							var i
						})(),
						Io = (() => {
							return (i = Io || (Io = {}))[i.None = 0] = "None", i.AzurePublic = "https://login.microsoftonline.com", i.AzurePpe = "https://login.windows-ppe.net", i.AzureChina = "https://login.chinacloudapi.cn", i.AzureGermany = "https://login.microsoftonline.de", i.AzureUsGovernment = "https://login.microsoftonline.us", Io;
							var i
						})(),
						fh = "@azure/msal-common",
						Ra = "11.0.0",
						Tu = {
							tokenRenewalOffsetSeconds: 300,
							preventCorsPreflight: !1
						},
						Ac = {
							loggerCallback: function() {},
							piiLoggingEnabled: !1,
							logLevel: Wr.Info,
							correlationId: q.gT.EMPTY_STRING
						},
						yl = {
							sendGetRequestAsync: function() {
								return (0, _t.mG)(this, void 0, void 0, function() {
									return (0, _t.Jh)(this, function(e) {
										throw vn.l.createUnexpectedError("Network interface - sendGetRequestAsync() has not been implemented")
									})
								})
							},
							sendPostRequestAsync: function() {
								return (0, _t.mG)(this, void 0, void 0, function() {
									return (0, _t.Jh)(this, function(e) {
										throw vn.l.createUnexpectedError("Network interface - sendPostRequestAsync() has not been implemented")
									})
								})
							}
						},
						ph = {
							sku: q.gT.SKU,
							version: Ra,
							cpu: q.gT.EMPTY_STRING,
							os: q.gT.EMPTY_STRING
						},
						Np = {
							clientSecret: q.gT.EMPTY_STRING,
							clientAssertion: void 0
						},
						kp = {
							azureCloudInstance: Io.None,
							tenant: "" + q.gT.DEFAULT_COMMON_TENANT
						},
						Ma = {
							application: {
								appName: "",
								appVersion: ""
							}
						};

					function xp(i) {
						return (0, _t.pi)({
							clientCapabilities: [],
							azureCloudOptions: kp,
							skipAuthorityMetadataCache: !1
						}, i)
					}
					var v_ = {
							sendGetRequestAsync: function() {
								return Promise.reject(vn.l.createUnexpectedError("Network interface - sendGetRequestAsync() has not been implemented for the Network interface."))
							},
							sendPostRequestAsync: function() {
								return Promise.reject(vn.l.createUnexpectedError("Network interface - sendPostRequestAsync() has not been implemented for the Network interface."))
							}
						},
						Mr = E(4098),
						Fp = function() {
							function i() {}
							return i.prototype.navigateInternal = function(e, t) {
								return i.defaultNavigateWindow(e, t)
							}, i.prototype.navigateExternal = function(e, t) {
								return i.defaultNavigateWindow(e, t)
							}, i.defaultNavigateWindow = function(e, t) {
								return t.noHistory ? window.location.replace(e) : window.location.assign(e), new Promise(function(s) {
									setTimeout(function() {
										s(!0)
									}, t.timeout)
								})
							}, i
						}(),
						y_ = 6e4,
						wu = 6e3,
						Lp = 3e4,
						Up = 2e3,
						Cl = "@azure/msal-browser",
						Mc = "2.34.0",
						gh = function() {
							function i(e, t) {
								this.eventCallbacks = new Map, this.logger = e, this.browserCrypto = t, this.listeningToStorageEvents = !1, this.handleAccountCacheChange = this.handleAccountCacheChange.bind(this)
							}
							return i.prototype.addEventCallback = function(e) {
								if (typeof window < "u") {
									var t = this.browserCrypto.createNewGuid();
									return this.eventCallbacks.set(t, e), this.logger.verbose("Event callback registered with id: " + t), t
								}
								return null
							}, i.prototype.removeEventCallback = function(e) {
								this.eventCallbacks.delete(e), this.logger.verbose("Event callback " + e + " removed.")
							}, i.prototype.enableAccountStorageEvents = function() {
								typeof window > "u" || (this.listeningToStorageEvents ? this.logger.verbose("Account storage listener already registered.") : (this.logger.verbose("Adding account storage listener."), this.listeningToStorageEvents = !0, window.addEventListener("storage", this.handleAccountCacheChange)))
							}, i.prototype.disableAccountStorageEvents = function() {
								typeof window > "u" || (this.listeningToStorageEvents ? (this.logger.verbose("Removing account storage listener."), window.removeEventListener("storage", this.handleAccountCacheChange), this.listeningToStorageEvents = !1) : this.logger.verbose("No account storage listener registered."))
							}, i.prototype.emitEvent = function(e, t, s, c) {
								var u = this;
								if (typeof window < "u") {
									var h = {
										eventType: e,
										interactionType: t || null,
										payload: s || null,
										error: c || null,
										timestamp: Date.now()
									};
									this.logger.info("Emitting event: " + e), this.eventCallbacks.forEach(function(m, S) {
										u.logger.verbose("Emitting event to callback " + S + ": " + e), m.apply(null, [h])
									})
								}
							}, i.prototype.handleAccountCacheChange = function(e) {
								try {
									var t = e.newValue || e.oldValue;
									if (!t) return;
									var s = JSON.parse(t);
									if ("object" != typeof s || !v.isAccountEntity(s)) return;
									var u = re.toObject(new v, s).getAccountInfo();
									!e.oldValue && e.newValue ? (this.logger.info("Account was added to cache in a different window"), this.emitEvent(Zt.t.ACCOUNT_ADDED, void 0, u)) : !e.newValue && e.oldValue && (this.logger.info("Account was removed from cache in a different window"), this.emitEvent(Zt.t.ACCOUNT_REMOVED, void 0, u))
								} catch {
									return
								}
							}, i
						}(),
						bu = function() {
							function i() {}
							return i.generateThrottlingStorageKey = function(e) {
								return q.bb.THROTTLING_PREFIX + "." + JSON.stringify(e)
							}, i.preProcess = function(e, t) {
								var s, c = i.generateThrottlingStorageKey(t),
									u = e.getThrottlingCache(c);
								if (u) {
									if (u.throttleTime < Date.now()) return void e.removeItem(c, q.Xj.THROTTLING);
									throw new Ir((null === (s = u.errorCodes) || void 0 === s ? void 0 : s.join(" ")) || q.gT.EMPTY_STRING, u.errorMessage, u.subError)
								}
							}, i.postProcess = function(e, t, s) {
								if (i.checkResponseStatus(s) || i.checkResponseForRetryAfter(s)) {
									var c = {
										throttleTime: i.calculateThrottleTime(parseInt(s.headers[q.SZ.RETRY_AFTER])),
										error: s.body.error,
										errorCodes: s.body.error_codes,
										errorMessage: s.body.error_description,
										subError: s.body.suberror
									};
									e.setThrottlingCache(i.generateThrottlingStorageKey(t), c)
								}
							}, i.checkResponseStatus = function(e) {
								return 429 === e.status || e.status >= 500 && e.status < 600
							}, i.checkResponseForRetryAfter = function(e) {
								return !!e.headers && e.headers.hasOwnProperty(q.SZ.RETRY_AFTER) && (e.status < 200 || e.status >= 300)
							}, i.calculateThrottleTime = function(e) {
								var t = e <= 0 ? 0 : e,
									s = Date.now() / 1e3;
								return Math.floor(1e3 * Math.min(s + (t || q.bb.DEFAULT_THROTTLE_TIME_SECONDS), s + q.bb.DEFAULT_MAX_THROTTLE_TIME_SECONDS))
							}, i.removeThrottle = function(e, t, s, c) {
								var h = this.generateThrottlingStorageKey({
									clientId: t,
									authority: s.authority,
									scopes: s.scopes,
									homeAccountIdentifier: c,
									claims: s.claims,
									authenticationScheme: s.authenticationScheme,
									resourceRequestMethod: s.resourceRequestMethod,
									resourceRequestUri: s.resourceRequestUri,
									shrClaims: s.shrClaims,
									sshKid: s.sshKid
								});
								return e.removeItem(h, q.Xj.THROTTLING)
							}, i
						}(),
						mh = function() {
							function i(e, t) {
								this.networkClient = e, this.cacheManager = t
							}
							return i.prototype.sendPostRequest = function(e, t, s) {
								return (0, _t.mG)(this, void 0, void 0, function() {
									var c, u;
									return (0, _t.Jh)(this, function(h) {
										switch (h.label) {
											case 0:
												bu.preProcess(this.cacheManager, e), h.label = 1;
											case 1:
												return h.trys.push([1, 3, , 4]), [4, this.networkClient.sendPostRequestAsync(t, s)];
											case 2:
												return c = h.sent(), [3, 4];
											case 3:
												throw (u = h.sent()) instanceof vn.l ? u : zt.e.createNetworkError(t, u);
											case 4:
												return bu.postProcess(this.cacheManager, e, c), [2, c]
										}
									})
								})
							}, i
						}(),
						Oa = function() {
							function i() {}
							return i.validateRedirectUri = function(e) {
								if (_n.x.isEmpty(e)) throw g.r.createRedirectUriEmptyError()
							}, i.validatePrompt = function(e) {
								var t = [];
								for (var s in q.NJ) t.push(q.NJ[s]);
								if (t.indexOf(e) < 0) throw g.r.createInvalidPromptError(e)
							}, i.validateClaims = function(e) {
								try {
									JSON.parse(e)
								} catch {
									throw g.r.createInvalidClaimsRequestError()
								}
							}, i.validateCodeChallengeParams = function(e, t) {
								if (_n.x.isEmpty(e) || _n.x.isEmpty(t)) throw g.r.createInvalidCodeChallengeParamsError();
								this.validateCodeChallengeMethod(t)
							}, i.validateCodeChallengeMethod = function(e) {
								if ([q.VX.PLAIN, q.VX.S256].indexOf(e) < 0) throw g.r.createInvalidCodeChallengeMethodError()
							}, i.sanitizeEQParams = function(e, t) {
								return e ? (t.forEach(function(s, c) {
									e[c] && delete e[c]
								}), Object.fromEntries(Object.entries(e).filter(function(s) {
									return "" !== s[1]
								}))) : {}
							}, i
						}(),
						Oc = function() {
							function i() {
								this.parameters = new Map
							}
							return i.prototype.addResponseTypeCode = function() {
								this.parameters.set(q.Fo.RESPONSE_TYPE, encodeURIComponent(q.gT.CODE_RESPONSE_TYPE))
							}, i.prototype.addResponseTypeForTokenAndIdToken = function() {
								this.parameters.set(q.Fo.RESPONSE_TYPE, encodeURIComponent(q.gT.TOKEN_RESPONSE_TYPE + " " + q.gT.ID_TOKEN_RESPONSE_TYPE))
							}, i.prototype.addResponseMode = function(e) {
								this.parameters.set(q.Fo.RESPONSE_MODE, encodeURIComponent(e || q.vw.QUERY))
							}, i.prototype.addNativeBroker = function() {
								this.parameters.set(q.Fo.NATIVE_BROKER, encodeURIComponent("1"))
							}, i.prototype.addScopes = function(e, t) {
								void 0 === t && (t = !0);
								var s = t ? (0, _t.pr)(e || [], q.f_) : e || [],
									c = new b(s);
								this.parameters.set(q.Fo.SCOPE, encodeURIComponent(c.printScopes()))
							}, i.prototype.addClientId = function(e) {
								this.parameters.set(q.Fo.CLIENT_ID, encodeURIComponent(e))
							}, i.prototype.addRedirectUri = function(e) {
								Oa.validateRedirectUri(e), this.parameters.set(q.Fo.REDIRECT_URI, encodeURIComponent(e))
							}, i.prototype.addPostLogoutRedirectUri = function(e) {
								Oa.validateRedirectUri(e), this.parameters.set(q.Fo.POST_LOGOUT_URI, encodeURIComponent(e))
							}, i.prototype.addIdTokenHint = function(e) {
								this.parameters.set(q.Fo.ID_TOKEN_HINT, encodeURIComponent(e))
							}, i.prototype.addDomainHint = function(e) {
								this.parameters.set(q.VO.DOMAIN_HINT, encodeURIComponent(e))
							}, i.prototype.addLoginHint = function(e) {
								this.parameters.set(q.VO.LOGIN_HINT, encodeURIComponent(e))
							}, i.prototype.addCcsUpn = function(e) {
								this.parameters.set(q.SZ.CCS_HEADER, encodeURIComponent("UPN:" + e))
							}, i.prototype.addCcsOid = function(e) {
								this.parameters.set(q.SZ.CCS_HEADER, encodeURIComponent("Oid:" + e.uid + "@" + e.utid))
							}, i.prototype.addSid = function(e) {
								this.parameters.set(q.VO.SID, encodeURIComponent(e))
							}, i.prototype.addClaims = function(e, t) {
								var s = this.addClientCapabilitiesToClaims(e, t);
								Oa.validateClaims(s), this.parameters.set(q.Fo.CLAIMS, encodeURIComponent(s))
							}, i.prototype.addCorrelationId = function(e) {
								this.parameters.set(q.Fo.CLIENT_REQUEST_ID, encodeURIComponent(e))
							}, i.prototype.addLibraryInfo = function(e) {
								this.parameters.set(q.Fo.X_CLIENT_SKU, e.sku), this.parameters.set(q.Fo.X_CLIENT_VER, e.version), e.os && this.parameters.set(q.Fo.X_CLIENT_OS, e.os), e.cpu && this.parameters.set(q.Fo.X_CLIENT_CPU, e.cpu)
							}, i.prototype.addApplicationTelemetry = function(e) {
								e?.appName && this.parameters.set(q.Fo.X_APP_NAME, e.appName), e?.appVersion && this.parameters.set(q.Fo.X_APP_VER, e.appVersion)
							}, i.prototype.addPrompt = function(e) {
								Oa.validatePrompt(e), this.parameters.set("" + q.Fo.PROMPT, encodeURIComponent(e))
							}, i.prototype.addState = function(e) {
								_n.x.isEmpty(e) || this.parameters.set(q.Fo.STATE, encodeURIComponent(e))
							}, i.prototype.addNonce = function(e) {
								this.parameters.set(q.Fo.NONCE, encodeURIComponent(e))
							}, i.prototype.addCodeChallengeParams = function(e, t) {
								if (Oa.validateCodeChallengeParams(e, t), !e || !t) throw g.r.createInvalidCodeChallengeParamsError();
								this.parameters.set(q.Fo.CODE_CHALLENGE, encodeURIComponent(e)), this.parameters.set(q.Fo.CODE_CHALLENGE_METHOD, encodeURIComponent(t))
							}, i.prototype.addAuthorizationCode = function(e) {
								this.parameters.set(q.Fo.CODE, encodeURIComponent(e))
							}, i.prototype.addDeviceCode = function(e) {
								this.parameters.set(q.Fo.DEVICE_CODE, encodeURIComponent(e))
							}, i.prototype.addRefreshToken = function(e) {
								this.parameters.set(q.Fo.REFRESH_TOKEN, encodeURIComponent(e))
							}, i.prototype.addCodeVerifier = function(e) {
								this.parameters.set(q.Fo.CODE_VERIFIER, encodeURIComponent(e))
							}, i.prototype.addClientSecret = function(e) {
								this.parameters.set(q.Fo.CLIENT_SECRET, encodeURIComponent(e))
							}, i.prototype.addClientAssertion = function(e) {
								_n.x.isEmpty(e) || this.parameters.set(q.Fo.CLIENT_ASSERTION, encodeURIComponent(e))
							}, i.prototype.addClientAssertionType = function(e) {
								_n.x.isEmpty(e) || this.parameters.set(q.Fo.CLIENT_ASSERTION_TYPE, encodeURIComponent(e))
							}, i.prototype.addOboAssertion = function(e) {
								this.parameters.set(q.Fo.OBO_ASSERTION, encodeURIComponent(e))
							}, i.prototype.addRequestTokenUse = function(e) {
								this.parameters.set(q.Fo.REQUESTED_TOKEN_USE, encodeURIComponent(e))
							}, i.prototype.addGrantType = function(e) {
								this.parameters.set(q.Fo.GRANT_TYPE, encodeURIComponent(e))
							}, i.prototype.addClientInfo = function() {
								this.parameters.set(q.sR, "1")
							}, i.prototype.addExtraQueryParameters = function(e) {
								var t = this,
									s = Oa.sanitizeEQParams(e, this.parameters);
								Object.keys(s).forEach(function(c) {
									t.parameters.set(c, e[c])
								})
							}, i.prototype.addClientCapabilitiesToClaims = function(e, t) {
								var s;
								if (e) try {
									s = JSON.parse(e)
								} catch {
									throw g.r.createInvalidClaimsRequestError()
								} else s = {};
								return t && t.length > 0 && (s.hasOwnProperty(q.As.ACCESS_TOKEN) || (s[q.As.ACCESS_TOKEN] = {}), s[q.As.ACCESS_TOKEN][q.As.XMS_CC] = {
									values: t
								}), JSON.stringify(s)
							}, i.prototype.addUsername = function(e) {
								this.parameters.set(q.Ge.username, encodeURIComponent(e))
							}, i.prototype.addPassword = function(e) {
								this.parameters.set(q.Ge.password, encodeURIComponent(e))
							}, i.prototype.addPopToken = function(e) {
								_n.x.isEmpty(e) || (this.parameters.set(q.Fo.TOKEN_TYPE, q.hO.POP), this.parameters.set(q.Fo.REQ_CNF, encodeURIComponent(e)))
							}, i.prototype.addSshJwk = function(e) {
								_n.x.isEmpty(e) || (this.parameters.set(q.Fo.TOKEN_TYPE, q.hO.SSH), this.parameters.set(q.Fo.REQ_CNF, encodeURIComponent(e)))
							}, i.prototype.addServerTelemetry = function(e) {
								this.parameters.set(q.Fo.X_CLIENT_CURR_TELEM, e.generateCurrentRequestHeaderValue()), this.parameters.set(q.Fo.X_CLIENT_LAST_TELEM, e.generateLastRequestHeaderValue())
							}, i.prototype.addThrottling = function() {
								this.parameters.set(q.Fo.X_MS_LIB_CAPABILITY, q.bb.X_MS_LIB_CAPABILITY_VALUE)
							}, i.prototype.addLogoutHint = function(e) {
								this.parameters.set(q.Fo.LOGOUT_HINT, encodeURIComponent(e))
							}, i.prototype.createQueryString = function() {
								var e = new Array;
								return this.parameters.forEach(function(t, s) {
									e.push(s + "=" + t)
								}), e.join("&")
							}, i
						}(),
						Iu = function() {
							function i(e, t) {
								this.config = function Rc(i) {
									var e = i.authOptions,
										t = i.systemOptions,
										s = i.loggerOptions,
										c = i.storageInterface,
										u = i.networkInterface,
										h = i.cryptoInterface,
										m = i.clientCredentials,
										S = i.libraryInfo,
										O = i.telemetry,
										$ = i.serverTelemetryManager,
										le = i.persistencePlugin,
										Re = i.serializableCache,
										Ae = (0, _t.pi)((0, _t.pi)({}, Ac), s);
									return {
										authOptions: xp(e),
										systemOptions: (0, _t.pi)((0, _t.pi)({}, Tu), t),
										loggerOptions: Ae,
										storageInterface: c || new de(e.clientId, Ic),
										networkInterface: u || yl,
										cryptoInterface: h || Ic,
										clientCredentials: m || Np,
										libraryInfo: (0, _t.pi)((0, _t.pi)({}, ph), S),
										telemetry: (0, _t.pi)((0, _t.pi)({}, Ma), O),
										serverTelemetryManager: $ || null,
										persistencePlugin: le || null,
										serializableCache: Re || null
									}
								}(e), this.logger = new Eu(this.config.loggerOptions, fh, Ra), this.cryptoUtils = this.config.cryptoInterface, this.cacheManager = this.config.storageInterface, this.networkClient = this.config.networkInterface, this.networkManager = new mh(this.networkClient, this.cacheManager), this.serverTelemetryManager = this.config.serverTelemetryManager, this.authority = this.config.authOptions.authority, this.performanceClient = t
							}
							return i.prototype.createTokenRequestHeaders = function(e) {
								var t = {};
								if (t[q.SZ.CONTENT_TYPE] = q.gT.URL_FORM_CONTENT_TYPE, !this.config.systemOptions.preventCorsPreflight && e) switch (e.type) {
									case Cr.HOME_ACCOUNT_ID:
										try {
											var s = eo(e.credential);
											t[q.SZ.CCS_HEADER] = "Oid:" + s.uid + "@" + s.utid
										} catch (c) {
											this.logger.verbose("Could not parse home account ID for CCS Header: " + c)
										}
										break;
									case Cr.UPN:
										t[q.SZ.CCS_HEADER] = "UPN: " + e.credential
								}
								return t
							}, i.prototype.executePostToTokenEndpoint = function(e, t, s, c) {
								return (0, _t.mG)(this, void 0, void 0, function() {
									var u;
									return (0, _t.Jh)(this, function(h) {
										switch (h.label) {
											case 0:
												return [4, this.networkManager.sendPostRequest(c, e, {
													body: t,
													headers: s
												})];
											case 1:
												return u = h.sent(), this.config.serverTelemetryManager && u.status < 500 && 429 !== u.status && this.config.serverTelemetryManager.clearTelemetryCache(), [2, u]
										}
									})
								})
							}, i.prototype.updateAuthority = function(e) {
								if (!e.discoveryComplete()) throw zt.e.createEndpointDiscoveryIncompleteError("Updated authority has not completed endpoint discovery.");
								this.authority = e
							}, i.prototype.createTokenQueryParameters = function(e) {
								var t = new Oc;
								return e.tokenQueryParameters && t.addExtraQueryParameters(e.tokenQueryParameters), t.createQueryString()
							}, i
						}(),
						Pa = function i(e, t, s, c, u) {
							this.account = e || null, this.idToken = t || null, this.accessToken = s || null, this.refreshToken = c || null, this.appMetadata = u || null
						},
						Du = (() => {
							return (i = Du || (Du = {})).SW = "sw", i.UHW = "uhw", Du;
							var i
						})(),
						Pc = function() {
							function i(e, t) {
								this.cryptoUtils = e, this.performanceClient = t
							}
							return i.prototype.generateCnf = function(e) {
								var t, s;
								return (0, _t.mG)(this, void 0, void 0, function() {
									var c, u, h;
									return (0, _t.Jh)(this, function(m) {
										switch (m.label) {
											case 0:
												return null === (t = this.performanceClient) || void 0 === t || t.addQueueMeasurement(St.PopTokenGenerateCnf, e.correlationId), null === (s = this.performanceClient) || void 0 === s || s.setPreQueueTime(St.PopTokenGenerateKid, e.correlationId), [4, this.generateKid(e)];
											case 1:
												return c = m.sent(), u = this.cryptoUtils.base64Encode(JSON.stringify(c)), h = {
													kid: c.kid,
													reqCnfString: u
												}, [4, this.cryptoUtils.hashString(u)];
											case 2:
												return [2, (h.reqCnfHash = m.sent(), h)]
										}
									})
								})
							}, i.prototype.generateKid = function(e) {
								var t;
								return (0, _t.mG)(this, void 0, void 0, function() {
									return (0, _t.Jh)(this, function(c) {
										switch (c.label) {
											case 0:
												return null === (t = this.performanceClient) || void 0 === t || t.addQueueMeasurement(St.PopTokenGenerateKid, e.correlationId), [4, this.cryptoUtils.getPublicKeyThumbprint(e)];
											case 1:
												return [2, {
													kid: c.sent(),
													xms_ksl: Du.SW
												}]
										}
									})
								})
							}, i.prototype.signPopToken = function(e, t, s) {
								return (0, _t.mG)(this, void 0, void 0, function() {
									return (0, _t.Jh)(this, function(c) {
										return [2, this.signPayload(e, t, s)]
									})
								})
							}, i.prototype.signPayload = function(e, t, s, c) {
								return (0, _t.mG)(this, void 0, void 0, function() {
									var u, h, m, S, O, $;
									return (0, _t.Jh)(this, function(le) {
										switch (le.label) {
											case 0:
												return u = s.resourceRequestMethod, m = s.shrClaims, S = s.shrNonce, O = (h = s.resourceRequestUri) ? new Xn.G(h) : void 0, $ = O?.getUrlComponents(), [4, this.cryptoUtils.signJwt((0, _t.pi)({
													at: e,
													ts: bt.nowSeconds(),
													m: u?.toUpperCase(),
													u: $?.HostNameAndPort,
													nonce: S || this.cryptoUtils.createNewGuid(),
													p: $?.AbsolutePath,
													q: $?.QueryString ? [
														[], $.QueryString
													] : void 0,
													client_claims: m || void 0
												}, c), t, s.correlationId)];
											case 1:
												return [2, le.sent()]
										}
									})
								})
							}, i
						}(),
						Au = function() {
							function i(e, t) {
								this.cache = e, this.hasChanged = t
							}
							return Object.defineProperty(i.prototype, "cacheHasChanged", {
								get: function() {
									return this.hasChanged
								},
								enumerable: !1,
								configurable: !0
							}), Object.defineProperty(i.prototype, "tokenCache", {
								get: function() {
									return this.cache
								},
								enumerable: !1,
								configurable: !0
							}), i
						}(),
						Ru = function() {
							function i(e, t, s, c, u, h, m) {
								this.clientId = e, this.cacheStorage = t, this.cryptoObj = s, this.logger = c, this.serializableCache = u, this.persistencePlugin = h, this.performanceClient = m
							}
							return i.prototype.validateServerAuthorizationCodeResponse = function(e, t, s) {
								if (!e.state || !t) throw zt.e.createStateNotFoundError(e.state ? "Cached State" : "Server State");
								if (decodeURIComponent(e.state) !== decodeURIComponent(t)) throw zt.e.createStateMismatchError();
								if (e.error || e.error_description || e.suberror) throw Oi.isInteractionRequiredError(e.error, e.error_description, e.suberror) ? new Oi(e.error || q.gT.EMPTY_STRING, e.error_description, e.suberror, e.timestamp || q.gT.EMPTY_STRING, e.trace_id || q.gT.EMPTY_STRING, e.correlation_id || q.gT.EMPTY_STRING, e.claims || q.gT.EMPTY_STRING) : new Ir(e.error || q.gT.EMPTY_STRING, e.error_description, e.suberror);
								e.client_info && Bo(e.client_info, s)
							}, i.prototype.validateTokenResponse = function(e) {
								if (e.error || e.error_description || e.suberror) {
									if (Oi.isInteractionRequiredError(e.error, e.error_description, e.suberror)) throw new Oi(e.error, e.error_description, e.suberror, e.timestamp || q.gT.EMPTY_STRING, e.trace_id || q.gT.EMPTY_STRING, e.correlation_id || q.gT.EMPTY_STRING, e.claims || q.gT.EMPTY_STRING);
									throw new Ir(e.error, e.error_codes + " - [" + e.timestamp + "]: " + e.error_description + " - Correlation ID: " + e.correlation_id + " - Trace ID: " + e.trace_id, e.suberror)
								}
							}, i.prototype.handleServerTokenResponse = function(e, t, s, c, u, h, m, S, O) {
								var $;
								return (0, _t.mG)(this, void 0, void 0, function() {
									var le, Re, Ae, Ze, wt, Wt;
									return (0, _t.Jh)(this, function(sn) {
										switch (sn.label) {
											case 0:
												if (null === ($ = this.performanceClient) || void 0 === $ || $.addQueueMeasurement(St.HandleServerTokenResponse, e.correlation_id), e.id_token) {
													if (le = new x(e.id_token || q.gT.EMPTY_STRING, this.cryptoObj), u && !_n.x.isEmpty(u.nonce) && le.claims.nonce !== u.nonce) throw zt.e.createNonceMismatchError();
													if (c.maxAge || 0 === c.maxAge) {
														if (!(Re = le.claims.auth_time)) throw zt.e.createAuthTimeNotFoundError();
														x.checkMaxAge(Re, c.maxAge)
													}
												}
												this.homeAccountIdentifier = v.generateHomeAccountId(e.client_info || q.gT.EMPTY_STRING, t.authorityType, this.logger, this.cryptoObj, le), u && u.state && (Ae = gi.parseRequestState(this.cryptoObj, u.state)), e.key_id = e.key_id || c.sshKid || void 0, Ze = this.generateCacheRecord(e, t, s, c, le, h, u), sn.label = 1;
											case 1:
												return sn.trys.push([1, , 5, 8]), this.persistencePlugin && this.serializableCache ? (this.logger.verbose("Persistence enabled, calling beforeCacheAccess"), wt = new Au(this.serializableCache, !0), [4, this.persistencePlugin.beforeCacheAccess(wt)]) : [3, 3];
											case 2:
												sn.sent(), sn.label = 3;
											case 3:
												return m && !S && Ze.account && (Wt = Ze.account.generateAccountKey(), !this.cacheStorage.getAccount(Wt)) ? (this.logger.warning("Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache"), [2, i.generateAuthenticationResult(this.cryptoObj, t, Ze, !1, c, le, Ae, void 0, O)]) : [4, this.cacheStorage.saveCacheRecord(Ze)];
											case 4:
												return sn.sent(), [3, 8];
											case 5:
												return this.persistencePlugin && this.serializableCache && wt ? (this.logger.verbose("Persistence enabled, calling afterCacheAccess"), [4, this.persistencePlugin.afterCacheAccess(wt)]) : [3, 7];
											case 6:
												sn.sent(), sn.label = 7;
											case 7:
												return [7];
											case 8:
												return [2, i.generateAuthenticationResult(this.cryptoObj, t, Ze, !1, c, le, Ae, e, O)]
										}
									})
								})
							}, i.prototype.generateCacheRecord = function(e, t, s, c, u, h, m) {
								var O, $, S = t.getPreferredCache();
								if (_n.x.isEmpty(S)) throw zt.e.createInvalidCacheEnvironmentError();
								!_n.x.isEmpty(e.id_token) && u && (O = We.createIdTokenEntity(this.homeAccountIdentifier, S, e.id_token || q.gT.EMPTY_STRING, this.clientId, u.claims.tid || q.gT.EMPTY_STRING), $ = this.generateAccountEntity(e, u, t, m));
								var le = null;
								if (!_n.x.isEmpty(e.access_token)) {
									var Re = e.scope ? b.fromString(e.scope) : new b(c.scopes || []),
										Ae = ("string" == typeof e.expires_in ? parseInt(e.expires_in, 10) : e.expires_in) || 0,
										Ze = ("string" == typeof e.ext_expires_in ? parseInt(e.ext_expires_in, 10) : e.ext_expires_in) || 0,
										wt = ("string" == typeof e.refresh_in ? parseInt(e.refresh_in, 10) : e.refresh_in) || void 0,
										Wt = s + Ae,
										Yt = Wt + Ze,
										sn = wt && wt > 0 ? s + wt : void 0;
									le = Kt.createAccessTokenEntity(this.homeAccountIdentifier, S, e.access_token || q.gT.EMPTY_STRING, this.clientId, u ? u.claims.tid || q.gT.EMPTY_STRING : t.tenant, Re.printScopes(), Wt, Yt, this.cryptoObj, sn, e.token_type, h, e.key_id, c.claims, c.requestedClaimsHash)
								}
								var kn = null;
								_n.x.isEmpty(e.refresh_token) || (kn = on.createRefreshTokenEntity(this.homeAccountIdentifier, S, e.refresh_token || q.gT.EMPTY_STRING, this.clientId, e.foci, h));
								var fr = null;
								return _n.x.isEmpty(e.foci) || (fr = zn.createAppMetadataEntity(this.clientId, S, e.foci)), new Pa($, O, le, kn, fr)
							}, i.prototype.generateAccountEntity = function(e, t, s, c) {
								var h = c ? c.cloud_graph_host_name : q.gT.EMPTY_STRING,
									m = c ? c.msgraph_host : q.gT.EMPTY_STRING;
								if (s.authorityType === Pi.Adfs) return this.logger.verbose("Authority type is ADFS, creating ADFS account"), v.createGenericAccount(this.homeAccountIdentifier, t, s, h, m);
								if (_n.x.isEmpty(e.client_info) && "AAD" === s.protocolMode) throw zt.e.createClientInfoEmptyError();
								return e.client_info ? v.createAccount(e.client_info, this.homeAccountIdentifier, t, s, h, m) : v.createGenericAccount(this.homeAccountIdentifier, t, s, h, m)
							}, i.generateAuthenticationResult = function(e, t, s, c, u, h, m, S, O) {
								var $, le, Re;
								return (0, _t.mG)(this, void 0, void 0, function() {
									var Ae, Ze, wt, Wt, Yt, sn, kn, fr, ui, oi, Jr;
									return (0, _t.Jh)(this, function(wr) {
										switch (wr.label) {
											case 0:
												if (Ae = q.gT.EMPTY_STRING, Ze = [], wt = null, Yt = q.gT.EMPTY_STRING, !s.accessToken) return [3, 4];
												if (s.accessToken.tokenType !== q.hO.POP) return [3, 2];
												if (sn = new Pc(e), fr = (kn = s.accessToken).secret, !(ui = kn.keyId)) throw zt.e.createKeyIdMissingError();
												return [4, sn.signPopToken(fr, ui, u)];
											case 1:
												return Ae = wr.sent(), [3, 3];
											case 2:
												Ae = s.accessToken.secret, wr.label = 3;
											case 3:
												Ze = b.fromString(s.accessToken.target).asArray(), wt = new Date(1e3 * Number(s.accessToken.expiresOn)), Wt = new Date(1e3 * Number(s.accessToken.extendedExpiresOn)), wr.label = 4;
											case 4:
												return s.appMetadata && (Yt = s.appMetadata.familyId === q.ch ? q.ch : q.gT.EMPTY_STRING), oi = h?.claims.oid || h?.claims.sub || q.gT.EMPTY_STRING, Jr = h?.claims.tid || q.gT.EMPTY_STRING, S?.spa_accountid && s.account && (s.account.nativeAccountId = S?.spa_accountid), [2, {
													authority: t.canonicalAuthority,
													uniqueId: oi,
													tenantId: Jr,
													scopes: Ze,
													account: s.account ? s.account.getAccountInfo() : null,
													idToken: h ? h.rawToken : q.gT.EMPTY_STRING,
													idTokenClaims: h ? h.claims : {},
													accessToken: Ae,
													fromCache: c,
													expiresOn: wt,
													correlationId: u.correlationId,
													requestId: O || q.gT.EMPTY_STRING,
													extExpiresOn: Wt,
													familyId: Yt,
													tokenType: (null === ($ = s.accessToken) || void 0 === $ ? void 0 : $.tokenType) || q.gT.EMPTY_STRING,
													state: m ? m.userRequestState : q.gT.EMPTY_STRING,
													cloudGraphHostName: (null === (le = s.account) || void 0 === le ? void 0 : le.cloudGraphHostName) || q.gT.EMPTY_STRING,
													msGraphHost: (null === (Re = s.account) || void 0 === Re ? void 0 : Re.msGraphHost) || q.gT.EMPTY_STRING,
													code: S?.spa_code,
													fromNativeBroker: !1
												}]
										}
									})
								})
							}, i
						}(),
						Bp = function(i) {
							function e(t, s) {
								var c = i.call(this, t, s) || this;
								return c.includeRedirectUri = !0, c
							}
							return (0, _t.ZT)(e, i), e.prototype.getAuthCodeUrl = function(t) {
								var s, c;
								return (0, _t.mG)(this, void 0, void 0, function() {
									var u;
									return (0, _t.Jh)(this, function(h) {
										switch (h.label) {
											case 0:
												return null === (s = this.performanceClient) || void 0 === s || s.addQueueMeasurement(St.GetAuthCodeUrl, t.correlationId), null === (c = this.performanceClient) || void 0 === c || c.setPreQueueTime(St.AuthClientCreateQueryString, t.correlationId), [4, this.createAuthCodeUrlQueryString(t)];
											case 1:
												return u = h.sent(), [2, Xn.G.appendQueryString(this.authority.authorizationEndpoint, u)]
										}
									})
								})
							}, e.prototype.acquireToken = function(t, s) {
								var c, u, h, m, S, O;
								return (0, _t.mG)(this, void 0, void 0, function() {
									var $, le, Re, Ae, Ze, wt, Wt = this;
									return (0, _t.Jh)(this, function(Yt) {
										switch (Yt.label) {
											case 0:
												if (!t || !t.code) throw zt.e.createTokenRequestCannotBeMadeError();
												return null === (c = this.performanceClient) || void 0 === c || c.addQueueMeasurement(St.AuthClientAcquireToken, t.correlationId), $ = null === (u = this.performanceClient) || void 0 === u ? void 0 : u.startMeasurement("AuthCodeClientAcquireToken", t.correlationId), this.logger.info("in acquireToken call in auth-code client"), le = bt.nowSeconds(), null === (h = this.performanceClient) || void 0 === h || h.setPreQueueTime(St.AuthClientExecuteTokenRequest, t.correlationId), [4, this.executeTokenRequest(this.authority, t)];
											case 1:
												return Re = Yt.sent(), Ae = null === (m = Re.headers) || void 0 === m ? void 0 : m[q.SZ.X_MS_REQUEST_ID], (Ze = null === (S = Re.headers) || void 0 === S ? void 0 : S[q.SZ.X_MS_HTTP_VERSION]) && $?.addStaticFields({
													httpVerAuthority: Ze
												}), (wt = new Ru(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin, this.performanceClient)).validateTokenResponse(Re.body), null === (O = this.performanceClient) || void 0 === O || O.setPreQueueTime(St.HandleServerTokenResponse, t.correlationId), [2, wt.handleServerTokenResponse(Re.body, this.authority, le, t, s, void 0, void 0, void 0, Ae).then(function(sn) {
													return $?.endMeasurement({
														success: !0
													}), sn
												}).catch(function(sn) {
													throw Wt.logger.verbose("Error in fetching token in ACC", t.correlationId), $?.endMeasurement({
														errorCode: sn.errorCode,
														subErrorCode: sn.subError,
														success: !1
													}), sn
												})]
										}
									})
								})
							}, e.prototype.handleFragmentResponse = function(t, s) {
								var c = new Ru(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, null, null),
									u = new Xn.G(t),
									h = Xn.G.getDeserializedHash(u.getHash());
								if (c.validateServerAuthorizationCodeResponse(h, s, this.cryptoUtils), !h.code) throw zt.e.createNoAuthCodeInServerResponseError();
								return (0, _t.pi)((0, _t.pi)({}, h), {
									code: h.code
								})
							}, e.prototype.getLogoutUri = function(t) {
								if (!t) throw g.r.createEmptyLogoutRequestError();
								var s = this.createLogoutUrlQueryString(t);
								return Xn.G.appendQueryString(this.authority.endSessionEndpoint, s)
							}, e.prototype.executeTokenRequest = function(t, s) {
								var c, u;
								return (0, _t.mG)(this, void 0, void 0, function() {
									var h, m, S, O, $, le;
									return (0, _t.Jh)(this, function(Ae) {
										switch (Ae.label) {
											case 0:
												return null === (c = this.performanceClient) || void 0 === c || c.addQueueMeasurement(St.AuthClientExecuteTokenRequest, s.correlationId), null === (u = this.performanceClient) || void 0 === u || u.setPreQueueTime(St.AuthClientCreateTokenRequestBody, s.correlationId), h = this.createTokenQueryParameters(s), m = Xn.G.appendQueryString(t.tokenEndpoint, h), [4, this.createTokenRequestBody(s)];
											case 1:
												if (S = Ae.sent(), O = void 0, s.clientInfo) try {
													$ = Bo(s.clientInfo, this.cryptoUtils), O = {
														credential: "" + $.uid + q.Bv.CLIENT_INFO_SEPARATOR + $.utid,
														type: Cr.HOME_ACCOUNT_ID
													}
												} catch (Ze) {
													this.logger.verbose("Could not parse client info for CCS Header: " + Ze)
												}
												return le = this.createTokenRequestHeaders(O || s.ccsCredential), [2, this.executePostToTokenEndpoint(m, S, le, {
													clientId: this.config.authOptions.clientId,
													authority: t.canonicalAuthority,
													scopes: s.scopes,
													claims: s.claims,
													authenticationScheme: s.authenticationScheme,
													resourceRequestMethod: s.resourceRequestMethod,
													resourceRequestUri: s.resourceRequestUri,
													shrClaims: s.shrClaims,
													sshKid: s.sshKid
												})]
										}
									})
								})
							}, e.prototype.createTokenRequestBody = function(t) {
								var s, c;
								return (0, _t.mG)(this, void 0, void 0, function() {
									var u, h, m, S, O, $, le, Re;
									return (0, _t.Jh)(this, function(Ae) {
										switch (Ae.label) {
											case 0:
												return null === (s = this.performanceClient) || void 0 === s || s.addQueueMeasurement(St.AuthClientCreateTokenRequestBody, t.correlationId), (u = new Oc).addClientId(this.config.authOptions.clientId), this.includeRedirectUri ? u.addRedirectUri(t.redirectUri) : Oa.validateRedirectUri(t.redirectUri), u.addScopes(t.scopes), u.addAuthorizationCode(t.code), u.addLibraryInfo(this.config.libraryInfo), u.addApplicationTelemetry(this.config.telemetry.application), u.addThrottling(), this.serverTelemetryManager && u.addServerTelemetry(this.serverTelemetryManager), t.codeVerifier && u.addCodeVerifier(t.codeVerifier), this.config.clientCredentials.clientSecret && u.addClientSecret(this.config.clientCredentials.clientSecret), this.config.clientCredentials.clientAssertion && (u.addClientAssertion((h = this.config.clientCredentials.clientAssertion).assertion), u.addClientAssertionType(h.assertionType)), u.addGrantType(q.qJ.AUTHORIZATION_CODE_GRANT), u.addClientInfo(), t.authenticationScheme !== q.hO.POP ? [3, 2] : (m = new Pc(this.cryptoUtils, this.performanceClient), null === (c = this.performanceClient) || void 0 === c || c.setPreQueueTime(St.PopTokenGenerateCnf, t.correlationId), [4, m.generateCnf(t)]);
											case 1:
												return S = Ae.sent(), u.addPopToken(S.reqCnfString), [3, 3];
											case 2:
												if (t.authenticationScheme === q.hO.SSH) {
													if (!t.sshJwk) throw g.r.createMissingSshJwkError();
													u.addSshJwk(t.sshJwk)
												}
												Ae.label = 3;
											case 3:
												if (O = t.correlationId || this.config.cryptoInterface.createNewGuid(), u.addCorrelationId(O), (!_n.x.isEmptyObj(t.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) && u.addClaims(t.claims, this.config.authOptions.clientCapabilities), $ = void 0, t.clientInfo) try {
													le = Bo(t.clientInfo, this.cryptoUtils), $ = {
														credential: "" + le.uid + q.Bv.CLIENT_INFO_SEPARATOR + le.utid,
														type: Cr.HOME_ACCOUNT_ID
													}
												} catch (Ze) {
													this.logger.verbose("Could not parse client info for CCS Header: " + Ze)
												} else $ = t.ccsCredential;
												if (this.config.systemOptions.preventCorsPreflight && $) switch ($.type) {
													case Cr.HOME_ACCOUNT_ID:
														try {
															le = eo($.credential), u.addCcsOid(le)
														} catch (Ze) {
															this.logger.verbose("Could not parse home account ID for CCS Header: " + Ze)
														}
														break;
													case Cr.UPN:
														u.addCcsUpn($.credential)
												}
												return t.tokenBodyParameters && u.addExtraQueryParameters(t.tokenBodyParameters), t.enableSpaAuthorizationCode && (!t.tokenBodyParameters || !t.tokenBodyParameters[q.Fo.RETURN_SPA_CODE]) && u.addExtraQueryParameters(((Re = {})[q.Fo.RETURN_SPA_CODE] = "1", Re)), [2, u.createQueryString()]
										}
									})
								})
							}, e.prototype.createAuthCodeUrlQueryString = function(t) {
								var s;
								return (0, _t.mG)(this, void 0, void 0, function() {
									var c, u, h, m, S, O, le;
									return (0, _t.Jh)(this, function(Re) {
										switch (Re.label) {
											case 0:
												if (null === (s = this.performanceClient) || void 0 === s || s.addQueueMeasurement(St.AuthClientCreateQueryString, t.correlationId), (c = new Oc).addClientId(this.config.authOptions.clientId), u = (0, _t.pr)(t.scopes || [], t.extraScopesToConsent || []), c.addScopes(u), c.addRedirectUri(t.redirectUri), h = t.correlationId || this.config.cryptoInterface.createNewGuid(), c.addCorrelationId(h), c.addResponseMode(t.responseMode), c.addResponseTypeCode(), c.addLibraryInfo(this.config.libraryInfo), c.addApplicationTelemetry(this.config.telemetry.application), c.addClientInfo(), t.codeChallenge && t.codeChallengeMethod && c.addCodeChallengeParams(t.codeChallenge, t.codeChallengeMethod), t.prompt && c.addPrompt(t.prompt), t.domainHint && c.addDomainHint(t.domainHint), t.prompt !== q.NJ.SELECT_ACCOUNT)
													if (t.sid && t.prompt === q.NJ.NONE) this.logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from request"), c.addSid(t.sid);
													else if (t.account) {
													if (m = this.extractAccountSid(t.account), S = this.extractLoginHint(t.account)) {
														this.logger.verbose("createAuthCodeUrlQueryString: login_hint claim present on account"), c.addLoginHint(S);
														try {
															O = eo(t.account.homeAccountId), c.addCcsOid(O)
														} catch {
															this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header")
														}
													} else if (m && t.prompt === q.NJ.NONE) {
														this.logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from account"), c.addSid(m);
														try {
															O = eo(t.account.homeAccountId), c.addCcsOid(O)
														} catch {
															this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header")
														}
													} else if (t.loginHint) this.logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from request"), c.addLoginHint(t.loginHint), c.addCcsUpn(t.loginHint);
													else if (t.account.username) {
														this.logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from account"), c.addLoginHint(t.account.username);
														try {
															O = eo(t.account.homeAccountId), c.addCcsOid(O)
														} catch {
															this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header")
														}
													}
												} else t.loginHint && (this.logger.verbose("createAuthCodeUrlQueryString: No account, adding login_hint from request"), c.addLoginHint(t.loginHint), c.addCcsUpn(t.loginHint));
												else this.logger.verbose("createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints");
												return t.nonce && c.addNonce(t.nonce), t.state && c.addState(t.state), (!_n.x.isEmpty(t.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) && c.addClaims(t.claims, this.config.authOptions.clientCapabilities), t.extraQueryParameters && c.addExtraQueryParameters(t.extraQueryParameters), t.nativeBroker ? (c.addNativeBroker(), t.authenticationScheme !== q.hO.POP ? [3, 2] : [4, new Pc(this.cryptoUtils).generateCnf(t)]) : [3, 2];
											case 1:
												le = Re.sent(), c.addPopToken(le.reqCnfHash), Re.label = 2;
											case 2:
												return [2, c.createQueryString()]
										}
									})
								})
							}, e.prototype.createLogoutUrlQueryString = function(t) {
								var s = new Oc;
								return t.postLogoutRedirectUri && s.addPostLogoutRedirectUri(t.postLogoutRedirectUri), t.correlationId && s.addCorrelationId(t.correlationId), t.idTokenHint && s.addIdTokenHint(t.idTokenHint), t.state && s.addState(t.state), t.logoutHint && s.addLogoutHint(t.logoutHint), t.extraQueryParameters && s.addExtraQueryParameters(t.extraQueryParameters), s.createQueryString()
							}, e.prototype.extractAccountSid = function(t) {
								var s;
								return (null === (s = t.idTokenClaims) || void 0 === s ? void 0 : s.sid) || null
							}, e.prototype.extractLoginHint = function(t) {
								var s;
								return (null === (s = t.idTokenClaims) || void 0 === s ? void 0 : s.login_hint) || null
							}, e
						}(Iu);

					function E_(i) {
						return i.hasOwnProperty("authorization_endpoint") && i.hasOwnProperty("token_endpoint") && i.hasOwnProperty("issuer") && i.hasOwnProperty("jwks_uri")
					}
					var Gp = {
							"https://login.microsoftonline.com/common/": {
								token_endpoint: "https://login.microsoftonline.com/common/oauth2/v2.0/token",
								token_endpoint_auth_methods_supported: ["client_secret_post", "private_key_jwt", "client_secret_basic"],
								jwks_uri: "https://login.microsoftonline.com/common/discovery/v2.0/keys",
								response_modes_supported: ["query", "fragment", "form_post"],
								subject_types_supported: ["pairwise"],
								id_token_signing_alg_values_supported: ["RS256"],
								response_types_supported: ["code", "id_token", "code id_token", "id_token token"],
								scopes_supported: ["openid", "profile", "email", "offline_access"],
								issuer: "https://login.microsoftonline.com/{tenantid}/v2.0",
								request_uri_parameter_supported: !1,
								userinfo_endpoint: "https://graph.microsoft.com/oidc/userinfo",
								authorization_endpoint: "https://login.microsoftonline.com/common/oauth2/v2.0/authorize",
								device_authorization_endpoint: "https://login.microsoftonline.com/common/oauth2/v2.0/devicecode",
								http_logout_supported: !0,
								frontchannel_logout_supported: !0,
								end_session_endpoint: "https://login.microsoftonline.com/common/oauth2/v2.0/logout",
								claims_supported: ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"],
								kerberos_endpoint: "https://login.microsoftonline.com/common/kerberos",
								tenant_region_scope: null,
								cloud_instance_name: "microsoftonline.com",
								cloud_graph_host_name: "graph.windows.net",
								msgraph_host: "graph.microsoft.com",
								rbac_url: "https://pas.windows.net"
							},
							"https://login.chinacloudapi.cn/common/": {
								token_endpoint: "https://login.chinacloudapi.cn/common/oauth2/v2.0/token",
								token_endpoint_auth_methods_supported: ["client_secret_post", "private_key_jwt", "client_secret_basic"],
								jwks_uri: "https://login.chinacloudapi.cn/common/discovery/v2.0/keys",
								response_modes_supported: ["query", "fragment", "form_post"],
								subject_types_supported: ["pairwise"],
								id_token_signing_alg_values_supported: ["RS256"],
								response_types_supported: ["code", "id_token", "code id_token", "id_token token"],
								scopes_supported: ["openid", "profile", "email", "offline_access"],
								issuer: "https://login.partner.microsoftonline.cn/{tenantid}/v2.0",
								request_uri_parameter_supported: !1,
								userinfo_endpoint: "https://microsoftgraph.chinacloudapi.cn/oidc/userinfo",
								authorization_endpoint: "https://login.chinacloudapi.cn/common/oauth2/v2.0/authorize",
								device_authorization_endpoint: "https://login.chinacloudapi.cn/common/oauth2/v2.0/devicecode",
								http_logout_supported: !0,
								frontchannel_logout_supported: !0,
								end_session_endpoint: "https://login.chinacloudapi.cn/common/oauth2/v2.0/logout",
								claims_supported: ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"],
								kerberos_endpoint: "https://login.chinacloudapi.cn/common/kerberos",
								tenant_region_scope: null,
								cloud_instance_name: "partner.microsoftonline.cn",
								cloud_graph_host_name: "graph.chinacloudapi.cn",
								msgraph_host: "microsoftgraph.chinacloudapi.cn",
								rbac_url: "https://pas.chinacloudapi.cn"
							},
							"https://login.microsoftonline.us/common/": {
								token_endpoint: "https://login.microsoftonline.us/common/oauth2/v2.0/token",
								token_endpoint_auth_methods_supported: ["client_secret_post", "private_key_jwt", "client_secret_basic"],
								jwks_uri: "https://login.microsoftonline.us/common/discovery/v2.0/keys",
								response_modes_supported: ["query", "fragment", "form_post"],
								subject_types_supported: ["pairwise"],
								id_token_signing_alg_values_supported: ["RS256"],
								response_types_supported: ["code", "id_token", "code id_token", "id_token token"],
								scopes_supported: ["openid", "profile", "email", "offline_access"],
								issuer: "https://login.microsoftonline.us/{tenantid}/v2.0",
								request_uri_parameter_supported: !1,
								userinfo_endpoint: "https://graph.microsoft.com/oidc/userinfo",
								authorization_endpoint: "https://login.microsoftonline.us/common/oauth2/v2.0/authorize",
								device_authorization_endpoint: "https://login.microsoftonline.us/common/oauth2/v2.0/devicecode",
								http_logout_supported: !0,
								frontchannel_logout_supported: !0,
								end_session_endpoint: "https://login.microsoftonline.us/common/oauth2/v2.0/logout",
								claims_supported: ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"],
								kerberos_endpoint: "https://login.microsoftonline.us/common/kerberos",
								tenant_region_scope: null,
								cloud_instance_name: "microsoftonline.us",
								cloud_graph_host_name: "graph.windows.net",
								msgraph_host: "graph.microsoft.com",
								rbac_url: "https://pasff.usgovcloudapi.net"
							},
							"https://login.microsoftonline.com/consumers/": {
								token_endpoint: "https://login.microsoftonline.com/consumers/oauth2/v2.0/token",
								token_endpoint_auth_methods_supported: ["client_secret_post", "private_key_jwt", "client_secret_basic"],
								jwks_uri: "https://login.microsoftonline.com/consumers/discovery/v2.0/keys",
								response_modes_supported: ["query", "fragment", "form_post"],
								subject_types_supported: ["pairwise"],
								id_token_signing_alg_values_supported: ["RS256"],
								response_types_supported: ["code", "id_token", "code id_token", "id_token token"],
								scopes_supported: ["openid", "profile", "email", "offline_access"],
								issuer: "https://login.microsoftonline.com/9188040d-6c67-4c5b-b112-36a304b66dad/v2.0",
								request_uri_parameter_supported: !1,
								userinfo_endpoint: "https://graph.microsoft.com/oidc/userinfo",
								authorization_endpoint: "https://login.microsoftonline.com/consumers/oauth2/v2.0/authorize",
								device_authorization_endpoint: "https://login.microsoftonline.com/consumers/oauth2/v2.0/devicecode",
								http_logout_supported: !0,
								frontchannel_logout_supported: !0,
								end_session_endpoint: "https://login.microsoftonline.com/consumers/oauth2/v2.0/logout",
								claims_supported: ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"],
								kerberos_endpoint: "https://login.microsoftonline.com/consumers/kerberos",
								tenant_region_scope: null,
								cloud_instance_name: "microsoftonline.com",
								cloud_graph_host_name: "graph.windows.net",
								msgraph_host: "graph.microsoft.com",
								rbac_url: "https://pas.windows.net"
							},
							"https://login.chinacloudapi.cn/consumers/": {
								token_endpoint: "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/token",
								token_endpoint_auth_methods_supported: ["client_secret_post", "private_key_jwt", "client_secret_basic"],
								jwks_uri: "https://login.chinacloudapi.cn/consumers/discovery/v2.0/keys",
								response_modes_supported: ["query", "fragment", "form_post"],
								subject_types_supported: ["pairwise"],
								id_token_signing_alg_values_supported: ["RS256"],
								response_types_supported: ["code", "id_token", "code id_token", "id_token token"],
								scopes_supported: ["openid", "profile", "email", "offline_access"],
								issuer: "https://login.partner.microsoftonline.cn/9188040d-6c67-4c5b-b112-36a304b66dad/v2.0",
								request_uri_parameter_supported: !1,
								userinfo_endpoint: "https://microsoftgraph.chinacloudapi.cn/oidc/userinfo",
								authorization_endpoint: "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/authorize",
								device_authorization_endpoint: "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/devicecode",
								http_logout_supported: !0,
								frontchannel_logout_supported: !0,
								end_session_endpoint: "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/logout",
								claims_supported: ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"],
								kerberos_endpoint: "https://login.chinacloudapi.cn/consumers/kerberos",
								tenant_region_scope: null,
								cloud_instance_name: "partner.microsoftonline.cn",
								cloud_graph_host_name: "graph.chinacloudapi.cn",
								msgraph_host: "microsoftgraph.chinacloudapi.cn",
								rbac_url: "https://pas.chinacloudapi.cn"
							},
							"https://login.microsoftonline.us/consumers/": {
								token_endpoint: "https://login.microsoftonline.us/consumers/oauth2/v2.0/token",
								token_endpoint_auth_methods_supported: ["client_secret_post", "private_key_jwt", "client_secret_basic"],
								jwks_uri: "https://login.microsoftonline.us/consumers/discovery/v2.0/keys",
								response_modes_supported: ["query", "fragment", "form_post"],
								subject_types_supported: ["pairwise"],
								id_token_signing_alg_values_supported: ["RS256"],
								response_types_supported: ["code", "id_token", "code id_token", "id_token token"],
								scopes_supported: ["openid", "profile", "email", "offline_access"],
								issuer: "https://login.microsoftonline.us/9188040d-6c67-4c5b-b112-36a304b66dad/v2.0",
								request_uri_parameter_supported: !1,
								userinfo_endpoint: "https://graph.microsoft.com/oidc/userinfo",
								authorization_endpoint: "https://login.microsoftonline.us/consumers/oauth2/v2.0/authorize",
								device_authorization_endpoint: "https://login.microsoftonline.us/consumers/oauth2/v2.0/devicecode",
								http_logout_supported: !0,
								frontchannel_logout_supported: !0,
								end_session_endpoint: "https://login.microsoftonline.us/consumers/oauth2/v2.0/logout",
								claims_supported: ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"],
								kerberos_endpoint: "https://login.microsoftonline.us/consumers/kerberos",
								tenant_region_scope: null,
								cloud_instance_name: "microsoftonline.us",
								cloud_graph_host_name: "graph.windows.net",
								msgraph_host: "graph.microsoft.com",
								rbac_url: "https://pasff.usgovcloudapi.net"
							},
							"https://login.microsoftonline.com/organizations/": {
								token_endpoint: "https://login.microsoftonline.com/organizations/oauth2/v2.0/token",
								token_endpoint_auth_methods_supported: ["client_secret_post", "private_key_jwt", "client_secret_basic"],
								jwks_uri: "https://login.microsoftonline.com/organizations/discovery/v2.0/keys",
								response_modes_supported: ["query", "fragment", "form_post"],
								subject_types_supported: ["pairwise"],
								id_token_signing_alg_values_supported: ["RS256"],
								response_types_supported: ["code", "id_token", "code id_token", "id_token token"],
								scopes_supported: ["openid", "profile", "email", "offline_access"],
								issuer: "https://login.microsoftonline.com/{tenantid}/v2.0",
								request_uri_parameter_supported: !1,
								userinfo_endpoint: "https://graph.microsoft.com/oidc/userinfo",
								authorization_endpoint: "https://login.microsoftonline.com/organizations/oauth2/v2.0/authorize",
								device_authorization_endpoint: "https://login.microsoftonline.com/organizations/oauth2/v2.0/devicecode",
								http_logout_supported: !0,
								frontchannel_logout_supported: !0,
								end_session_endpoint: "https://login.microsoftonline.com/organizations/oauth2/v2.0/logout",
								claims_supported: ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"],
								kerberos_endpoint: "https://login.microsoftonline.com/organizations/kerberos",
								tenant_region_scope: null,
								cloud_instance_name: "microsoftonline.com",
								cloud_graph_host_name: "graph.windows.net",
								msgraph_host: "graph.microsoft.com",
								rbac_url: "https://pas.windows.net"
							},
							"https://login.chinacloudapi.cn/organizations/": {
								token_endpoint: "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/token",
								token_endpoint_auth_methods_supported: ["client_secret_post", "private_key_jwt", "client_secret_basic"],
								jwks_uri: "https://login.chinacloudapi.cn/organizations/discovery/v2.0/keys",
								response_modes_supported: ["query", "fragment", "form_post"],
								subject_types_supported: ["pairwise"],
								id_token_signing_alg_values_supported: ["RS256"],
								response_types_supported: ["code", "id_token", "code id_token", "id_token token"],
								scopes_supported: ["openid", "profile", "email", "offline_access"],
								issuer: "https://login.partner.microsoftonline.cn/{tenantid}/v2.0",
								request_uri_parameter_supported: !1,
								userinfo_endpoint: "https://microsoftgraph.chinacloudapi.cn/oidc/userinfo",
								authorization_endpoint: "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/authorize",
								device_authorization_endpoint: "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/devicecode",
								http_logout_supported: !0,
								frontchannel_logout_supported: !0,
								end_session_endpoint: "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/logout",
								claims_supported: ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"],
								kerberos_endpoint: "https://login.chinacloudapi.cn/organizations/kerberos",
								tenant_region_scope: null,
								cloud_instance_name: "partner.microsoftonline.cn",
								cloud_graph_host_name: "graph.chinacloudapi.cn",
								msgraph_host: "microsoftgraph.chinacloudapi.cn",
								rbac_url: "https://pas.chinacloudapi.cn"
							},
							"https://login.microsoftonline.us/organizations/": {
								token_endpoint: "https://login.microsoftonline.us/organizations/oauth2/v2.0/token",
								token_endpoint_auth_methods_supported: ["client_secret_post", "private_key_jwt", "client_secret_basic"],
								jwks_uri: "https://login.microsoftonline.us/organizations/discovery/v2.0/keys",
								response_modes_supported: ["query", "fragment", "form_post"],
								subject_types_supported: ["pairwise"],
								id_token_signing_alg_values_supported: ["RS256"],
								response_types_supported: ["code", "id_token", "code id_token", "id_token token"],
								scopes_supported: ["openid", "profile", "email", "offline_access"],
								issuer: "https://login.microsoftonline.us/{tenantid}/v2.0",
								request_uri_parameter_supported: !1,
								userinfo_endpoint: "https://graph.microsoft.com/oidc/userinfo",
								authorization_endpoint: "https://login.microsoftonline.us/organizations/oauth2/v2.0/authorize",
								device_authorization_endpoint: "https://login.microsoftonline.us/organizations/oauth2/v2.0/devicecode",
								http_logout_supported: !0,
								frontchannel_logout_supported: !0,
								end_session_endpoint: "https://login.microsoftonline.us/organizations/oauth2/v2.0/logout",
								claims_supported: ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"],
								kerberos_endpoint: "https://login.microsoftonline.us/organizations/kerberos",
								tenant_region_scope: null,
								cloud_instance_name: "microsoftonline.us",
								cloud_graph_host_name: "graph.windows.net",
								msgraph_host: "graph.microsoft.com",
								rbac_url: "https://pasff.usgovcloudapi.net"
							}
						},
						_h = {
							"https://login.microsoftonline.com/common/": {
								tenant_discovery_endpoint: "https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration",
								"api-version": "1.1",
								metadata: [{
									preferred_network: "login.microsoftonline.com",
									preferred_cache: "login.windows.net",
									aliases: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"]
								}, {
									preferred_network: "login.partner.microsoftonline.cn",
									preferred_cache: "login.partner.microsoftonline.cn",
									aliases: ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"]
								}, {
									preferred_network: "login.microsoftonline.de",
									preferred_cache: "login.microsoftonline.de",
									aliases: ["login.microsoftonline.de"]
								}, {
									preferred_network: "login.microsoftonline.us",
									preferred_cache: "login.microsoftonline.us",
									aliases: ["login.microsoftonline.us", "login.usgovcloudapi.net"]
								}, {
									preferred_network: "login-us.microsoftonline.com",
									preferred_cache: "login-us.microsoftonline.com",
									aliases: ["login-us.microsoftonline.com"]
								}]
							},
							"https://login.chinacloudapi.cn/common/": {
								tenant_discovery_endpoint: "https://login.chinacloudapi.cn/common/v2.0/.well-known/openid-configuration",
								"api-version": "1.1",
								metadata: [{
									preferred_network: "login.microsoftonline.com",
									preferred_cache: "login.windows.net",
									aliases: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"]
								}, {
									preferred_network: "login.partner.microsoftonline.cn",
									preferred_cache: "login.partner.microsoftonline.cn",
									aliases: ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"]
								}, {
									preferred_network: "login.microsoftonline.de",
									preferred_cache: "login.microsoftonline.de",
									aliases: ["login.microsoftonline.de"]
								}, {
									preferred_network: "login.microsoftonline.us",
									preferred_cache: "login.microsoftonline.us",
									aliases: ["login.microsoftonline.us", "login.usgovcloudapi.net"]
								}, {
									preferred_network: "login-us.microsoftonline.com",
									preferred_cache: "login-us.microsoftonline.com",
									aliases: ["login-us.microsoftonline.com"]
								}]
							},
							"https://login.microsoftonline.us/common/": {
								tenant_discovery_endpoint: "https://login.microsoftonline.us/common/v2.0/.well-known/openid-configuration",
								"api-version": "1.1",
								metadata: [{
									preferred_network: "login.microsoftonline.com",
									preferred_cache: "login.windows.net",
									aliases: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"]
								}, {
									preferred_network: "login.partner.microsoftonline.cn",
									preferred_cache: "login.partner.microsoftonline.cn",
									aliases: ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"]
								}, {
									preferred_network: "login.microsoftonline.de",
									preferred_cache: "login.microsoftonline.de",
									aliases: ["login.microsoftonline.de"]
								}, {
									preferred_network: "login.microsoftonline.us",
									preferred_cache: "login.microsoftonline.us",
									aliases: ["login.microsoftonline.us", "login.usgovcloudapi.net"]
								}, {
									preferred_network: "login-us.microsoftonline.com",
									preferred_cache: "login-us.microsoftonline.com",
									aliases: ["login-us.microsoftonline.com"]
								}]
							},
							"https://login.microsoftonline.com/consumers/": {
								tenant_discovery_endpoint: "https://login.microsoftonline.com/consumers/v2.0/.well-known/openid-configuration",
								"api-version": "1.1",
								metadata: [{
									preferred_network: "login.microsoftonline.com",
									preferred_cache: "login.windows.net",
									aliases: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"]
								}, {
									preferred_network: "login.partner.microsoftonline.cn",
									preferred_cache: "login.partner.microsoftonline.cn",
									aliases: ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"]
								}, {
									preferred_network: "login.microsoftonline.de",
									preferred_cache: "login.microsoftonline.de",
									aliases: ["login.microsoftonline.de"]
								}, {
									preferred_network: "login.microsoftonline.us",
									preferred_cache: "login.microsoftonline.us",
									aliases: ["login.microsoftonline.us", "login.usgovcloudapi.net"]
								}, {
									preferred_network: "login-us.microsoftonline.com",
									preferred_cache: "login-us.microsoftonline.com",
									aliases: ["login-us.microsoftonline.com"]
								}]
							},
							"https://login.chinacloudapi.cn/consumers/": {
								tenant_discovery_endpoint: "https://login.chinacloudapi.cn/consumers/v2.0/.well-known/openid-configuration",
								"api-version": "1.1",
								metadata: [{
									preferred_network: "login.microsoftonline.com",
									preferred_cache: "login.windows.net",
									aliases: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"]
								}, {
									preferred_network: "login.partner.microsoftonline.cn",
									preferred_cache: "login.partner.microsoftonline.cn",
									aliases: ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"]
								}, {
									preferred_network: "login.microsoftonline.de",
									preferred_cache: "login.microsoftonline.de",
									aliases: ["login.microsoftonline.de"]
								}, {
									preferred_network: "login.microsoftonline.us",
									preferred_cache: "login.microsoftonline.us",
									aliases: ["login.microsoftonline.us", "login.usgovcloudapi.net"]
								}, {
									preferred_network: "login-us.microsoftonline.com",
									preferred_cache: "login-us.microsoftonline.com",
									aliases: ["login-us.microsoftonline.com"]
								}]
							},
							"https://login.microsoftonline.us/consumers/": {
								tenant_discovery_endpoint: "https://login.microsoftonline.us/consumers/v2.0/.well-known/openid-configuration",
								"api-version": "1.1",
								metadata: [{
									preferred_network: "login.microsoftonline.com",
									preferred_cache: "login.windows.net",
									aliases: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"]
								}, {
									preferred_network: "login.partner.microsoftonline.cn",
									preferred_cache: "login.partner.microsoftonline.cn",
									aliases: ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"]
								}, {
									preferred_network: "login.microsoftonline.de",
									preferred_cache: "login.microsoftonline.de",
									aliases: ["login.microsoftonline.de"]
								}, {
									preferred_network: "login.microsoftonline.us",
									preferred_cache: "login.microsoftonline.us",
									aliases: ["login.microsoftonline.us", "login.usgovcloudapi.net"]
								}, {
									preferred_network: "login-us.microsoftonline.com",
									preferred_cache: "login-us.microsoftonline.com",
									aliases: ["login-us.microsoftonline.com"]
								}]
							},
							"https://login.microsoftonline.com/organizations/": {
								tenant_discovery_endpoint: "https://login.microsoftonline.com/organizations/v2.0/.well-known/openid-configuration",
								"api-version": "1.1",
								metadata: [{
									preferred_network: "login.microsoftonline.com",
									preferred_cache: "login.windows.net",
									aliases: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"]
								}, {
									preferred_network: "login.partner.microsoftonline.cn",
									preferred_cache: "login.partner.microsoftonline.cn",
									aliases: ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"]
								}, {
									preferred_network: "login.microsoftonline.de",
									preferred_cache: "login.microsoftonline.de",
									aliases: ["login.microsoftonline.de"]
								}, {
									preferred_network: "login.microsoftonline.us",
									preferred_cache: "login.microsoftonline.us",
									aliases: ["login.microsoftonline.us", "login.usgovcloudapi.net"]
								}, {
									preferred_network: "login-us.microsoftonline.com",
									preferred_cache: "login-us.microsoftonline.com",
									aliases: ["login-us.microsoftonline.com"]
								}]
							},
							"https://login.chinacloudapi.cn/organizations/": {
								tenant_discovery_endpoint: "https://login.chinacloudapi.cn/organizations/v2.0/.well-known/openid-configuration",
								"api-version": "1.1",
								metadata: [{
									preferred_network: "login.microsoftonline.com",
									preferred_cache: "login.windows.net",
									aliases: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"]
								}, {
									preferred_network: "login.partner.microsoftonline.cn",
									preferred_cache: "login.partner.microsoftonline.cn",
									aliases: ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"]
								}, {
									preferred_network: "login.microsoftonline.de",
									preferred_cache: "login.microsoftonline.de",
									aliases: ["login.microsoftonline.de"]
								}, {
									preferred_network: "login.microsoftonline.us",
									preferred_cache: "login.microsoftonline.us",
									aliases: ["login.microsoftonline.us", "login.usgovcloudapi.net"]
								}, {
									preferred_network: "login-us.microsoftonline.com",
									preferred_cache: "login-us.microsoftonline.com",
									aliases: ["login-us.microsoftonline.com"]
								}]
							},
							"https://login.microsoftonline.us/organizations/": {
								tenant_discovery_endpoint: "https://login.microsoftonline.us/organizations/v2.0/.well-known/openid-configuration",
								"api-version": "1.1",
								metadata: [{
									preferred_network: "login.microsoftonline.com",
									preferred_cache: "login.windows.net",
									aliases: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"]
								}, {
									preferred_network: "login.partner.microsoftonline.cn",
									preferred_cache: "login.partner.microsoftonline.cn",
									aliases: ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"]
								}, {
									preferred_network: "login.microsoftonline.de",
									preferred_cache: "login.microsoftonline.de",
									aliases: ["login.microsoftonline.de"]
								}, {
									preferred_network: "login.microsoftonline.us",
									preferred_cache: "login.microsoftonline.us",
									aliases: ["login.microsoftonline.us", "login.usgovcloudapi.net"]
								}, {
									preferred_network: "login-us.microsoftonline.com",
									preferred_cache: "login-us.microsoftonline.com",
									aliases: ["login-us.microsoftonline.com"]
								}]
							}
						},
						yh = function() {
							function i(e, t, s) {
								this.networkInterface = e, this.performanceClient = t, this.correlationId = s
							}
							return i.prototype.detectRegion = function(e, t) {
								var s, c, u, h;
								return (0, _t.mG)(this, void 0, void 0, function() {
									var m, S, O, $, le;
									return (0, _t.Jh)(this, function(Re) {
										switch (Re.label) {
											case 0:
												if (null === (s = this.performanceClient) || void 0 === s || s.addQueueMeasurement(St.RegionDiscoveryDetectRegion, this.correlationId), m = e) return [3, 8];
												S = i.IMDS_OPTIONS, Re.label = 1;
											case 1:
												return Re.trys.push([1, 6, , 7]), null === (c = this.performanceClient) || void 0 === c || c.setPreQueueTime(St.RegionDiscoveryGetRegionFromIMDS, this.correlationId), [4, this.getRegionFromIMDS(q.gT.IMDS_VERSION, S)];
											case 2:
												return (O = Re.sent()).status === q.YY.httpSuccess && (m = O.body, t.region_source = q.W.IMDS), O.status !== q.YY.httpBadRequest ? [3, 5] : (null === (u = this.performanceClient) || void 0 === u || u.setPreQueueTime(St.RegionDiscoveryGetCurrentVersion, this.correlationId), [4, this.getCurrentVersion(S)]);
											case 3:
												return ($ = Re.sent()) ? (null === (h = this.performanceClient) || void 0 === h || h.setPreQueueTime(St.RegionDiscoveryGetRegionFromIMDS, this.correlationId), [4, this.getRegionFromIMDS($, S)]) : (t.region_source = q.W.FAILED_AUTO_DETECTION, [2, null]);
											case 4:
												(le = Re.sent()).status === q.YY.httpSuccess && (m = le.body, t.region_source = q.W.IMDS), Re.label = 5;
											case 5:
												return [3, 7];
											case 6:
												return Re.sent(), t.region_source = q.W.FAILED_AUTO_DETECTION, [2, null];
											case 7:
												return [3, 9];
											case 8:
												t.region_source = q.W.ENVIRONMENT_VARIABLE, Re.label = 9;
											case 9:
												return m || (t.region_source = q.W.FAILED_AUTO_DETECTION), [2, m || null]
										}
									})
								})
							}, i.prototype.getRegionFromIMDS = function(e, t) {
								var s;
								return (0, _t.mG)(this, void 0, void 0, function() {
									return (0, _t.Jh)(this, function(c) {
										return null === (s = this.performanceClient) || void 0 === s || s.addQueueMeasurement(St.RegionDiscoveryGetRegionFromIMDS, this.correlationId), [2, this.networkInterface.sendGetRequestAsync(q.gT.IMDS_ENDPOINT + "?api-version=" + e + "&format=text", t, q.gT.IMDS_TIMEOUT)]
									})
								})
							}, i.prototype.getCurrentVersion = function(e) {
								var t;
								return (0, _t.mG)(this, void 0, void 0, function() {
									var s;
									return (0, _t.Jh)(this, function(c) {
										switch (c.label) {
											case 0:
												null === (t = this.performanceClient) || void 0 === t || t.addQueueMeasurement(St.RegionDiscoveryGetCurrentVersion, this.correlationId), c.label = 1;
											case 1:
												return c.trys.push([1, 3, , 4]), [4, this.networkInterface.sendGetRequestAsync(q.gT.IMDS_ENDPOINT + "?format=json", e)];
											case 2:
												return (s = c.sent()).status === q.YY.httpBadRequest && s.body && s.body["newest-versions"] && s.body["newest-versions"].length > 0 ? [2, s.body["newest-versions"][0]] : [2, null];
											case 3:
												return c.sent(), [2, null];
											case 4:
												return [2]
										}
									})
								})
							}, i.IMDS_OPTIONS = {
								headers: {
									Metadata: "true"
								}
							}, i
						}(),
						Nc = function() {
							function i(e, t, s, c, u, h, m) {
								this.canonicalAuthority = e, this._canonicalAuthority.validateAsUri(), this.networkInterface = t, this.cacheManager = s, this.authorityOptions = c, this.regionDiscoveryMetadata = {
									region_used: void 0,
									region_source: void 0,
									region_outcome: void 0
								}, this.logger = u, this.performanceClient = h, this.correlationId = m, this.regionDiscovery = new yh(t, this.performanceClient, this.correlationId)
							}
							return Object.defineProperty(i.prototype, "authorityType", {
								get: function() {
									var e = this.canonicalAuthorityUrlComponents.PathSegments;
									if (e.length) switch (e[0].toLowerCase()) {
										case q.gT.ADFS:
											return Pi.Adfs;
										case q.gT.DSTS:
											return Pi.Dsts
									}
									return Pi.Default
								},
								enumerable: !1,
								configurable: !0
							}), Object.defineProperty(i.prototype, "protocolMode", {
								get: function() {
									return this.authorityOptions.protocolMode
								},
								enumerable: !1,
								configurable: !0
							}), Object.defineProperty(i.prototype, "options", {
								get: function() {
									return this.authorityOptions
								},
								enumerable: !1,
								configurable: !0
							}), Object.defineProperty(i.prototype, "canonicalAuthority", {
								get: function() {
									return this._canonicalAuthority.urlString
								},
								set: function(e) {
									this._canonicalAuthority = new Xn.G(e), this._canonicalAuthority.validateAsUri(), this._canonicalAuthorityUrlComponents = null
								},
								enumerable: !1,
								configurable: !0
							}), Object.defineProperty(i.prototype, "canonicalAuthorityUrlComponents", {
								get: function() {
									return this._canonicalAuthorityUrlComponents || (this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents()), this._canonicalAuthorityUrlComponents
								},
								enumerable: !1,
								configurable: !0
							}), Object.defineProperty(i.prototype, "hostnameAndPort", {
								get: function() {
									return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase()
								},
								enumerable: !1,
								configurable: !0
							}), Object.defineProperty(i.prototype, "tenant", {
								get: function() {
									return this.canonicalAuthorityUrlComponents.PathSegments[0]
								},
								enumerable: !1,
								configurable: !0
							}), Object.defineProperty(i.prototype, "authorizationEndpoint", {
								get: function() {
									if (this.discoveryComplete()) {
										var e = this.replacePath(this.metadata.authorization_endpoint);
										return this.replaceTenant(e)
									}
									throw zt.e.createEndpointDiscoveryIncompleteError("Discovery incomplete.")
								},
								enumerable: !1,
								configurable: !0
							}), Object.defineProperty(i.prototype, "tokenEndpoint", {
								get: function() {
									if (this.discoveryComplete()) {
										var e = this.replacePath(this.metadata.token_endpoint);
										return this.replaceTenant(e)
									}
									throw zt.e.createEndpointDiscoveryIncompleteError("Discovery incomplete.")
								},
								enumerable: !1,
								configurable: !0
							}), Object.defineProperty(i.prototype, "deviceCodeEndpoint", {
								get: function() {
									if (this.discoveryComplete()) {
										var e = this.replacePath(this.metadata.token_endpoint.replace("/token", "/devicecode"));
										return this.replaceTenant(e)
									}
									throw zt.e.createEndpointDiscoveryIncompleteError("Discovery incomplete.")
								},
								enumerable: !1,
								configurable: !0
							}), Object.defineProperty(i.prototype, "endSessionEndpoint", {
								get: function() {
									if (this.discoveryComplete()) {
										if (!this.metadata.end_session_endpoint) throw zt.e.createLogoutNotSupportedError();
										var e = this.replacePath(this.metadata.end_session_endpoint);
										return this.replaceTenant(e)
									}
									throw zt.e.createEndpointDiscoveryIncompleteError("Discovery incomplete.")
								},
								enumerable: !1,
								configurable: !0
							}), Object.defineProperty(i.prototype, "selfSignedJwtAudience", {
								get: function() {
									if (this.discoveryComplete()) {
										var e = this.replacePath(this.metadata.issuer);
										return this.replaceTenant(e)
									}
									throw zt.e.createEndpointDiscoveryIncompleteError("Discovery incomplete.")
								},
								enumerable: !1,
								configurable: !0
							}), Object.defineProperty(i.prototype, "jwksUri", {
								get: function() {
									if (this.discoveryComplete()) {
										var e = this.replacePath(this.metadata.jwks_uri);
										return this.replaceTenant(e)
									}
									throw zt.e.createEndpointDiscoveryIncompleteError("Discovery incomplete.")
								},
								enumerable: !1,
								configurable: !0
							}), i.prototype.replaceTenant = function(e) {
								return e.replace(/{tenant}|{tenantid}/g, this.tenant)
							}, i.prototype.replacePath = function(e) {
								var t = e,
									c = new Xn.G(this.metadata.canonical_authority).getUrlComponents().PathSegments;
								return this.canonicalAuthorityUrlComponents.PathSegments.forEach(function(h, m) {
									var S = c[m];
									h !== S && (t = t.replace("/" + S + "/", "/" + h + "/"))
								}), t
							}, Object.defineProperty(i.prototype, "defaultOpenIdConfigurationEndpoint", {
								get: function() {
									return this.authorityType === Pi.Adfs || this.authorityType === Pi.Dsts || this.protocolMode === as.OIDC ? this.canonicalAuthority + ".well-known/openid-configuration" : this.canonicalAuthority + "v2.0/.well-known/openid-configuration"
								},
								enumerable: !1,
								configurable: !0
							}), i.prototype.discoveryComplete = function() {
								return !!this.metadata
							}, i.prototype.resolveEndpointsAsync = function() {
								var e, t, s;
								return (0, _t.mG)(this, void 0, void 0, function() {
									var c, u, h, m;
									return (0, _t.Jh)(this, function(S) {
										switch (S.label) {
											case 0:
												return null === (e = this.performanceClient) || void 0 === e || e.addQueueMeasurement(St.AuthorityResolveEndpointsAsync, this.correlationId), (c = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort)) || (c = new Gi).updateCanonicalAuthority(this.canonicalAuthority), null === (t = this.performanceClient) || void 0 === t || t.setPreQueueTime(St.AuthorityUpdateCloudDiscoveryMetadata, this.correlationId), [4, this.updateCloudDiscoveryMetadata(c)];
											case 1:
												return u = S.sent(), this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, c.preferred_network), null === (s = this.performanceClient) || void 0 === s || s.setPreQueueTime(St.AuthorityUpdateEndpointMetadata, this.correlationId), [4, this.updateEndpointMetadata(c)];
											case 2:
												return h = S.sent(), u !== q.pQ.CACHE && h !== q.pQ.CACHE && (c.resetExpiresAt(), c.updateCanonicalAuthority(this.canonicalAuthority)), m = this.cacheManager.generateAuthorityMetadataCacheKey(c.preferred_cache), this.cacheManager.setAuthorityMetadata(m, c), this.metadata = c, [2]
										}
									})
								})
							}, i.prototype.updateEndpointMetadata = function(e) {
								var t, s, c, u, h, m;
								return (0, _t.mG)(this, void 0, void 0, function() {
									var S, O;
									return (0, _t.Jh)(this, function($) {
										switch ($.label) {
											case 0:
												return null === (t = this.performanceClient) || void 0 === t || t.addQueueMeasurement(St.AuthorityUpdateEndpointMetadata, this.correlationId), (S = this.getEndpointMetadataFromConfig()) ? (e.updateEndpointMetadata(S, !1), [2, q.pQ.CONFIG]) : this.isAuthoritySameType(e) && e.endpointsFromNetwork && !e.isExpired() ? [2, q.pQ.CACHE] : (O = this.getEndpointMetadataFromHardcodedValues(), null === (s = this.performanceClient) || void 0 === s || s.setPreQueueTime(St.AuthorityGetEndpointMetadataFromNetwork, this.correlationId), [4, this.getEndpointMetadataFromNetwork()]);
											case 1:
												return (S = $.sent()) ? null !== (c = this.authorityOptions.azureRegionConfiguration) && void 0 !== c && c.azureRegion ? (null === (u = this.performanceClient) || void 0 === u || u.setPreQueueTime(St.AuthorityUpdateMetadataWithRegionalInformation, this.correlationId), [4, this.updateMetadataWithRegionalInformation(S)]) : [3, 3] : [3, 4];
											case 2:
												S = $.sent(), $.label = 3;
											case 3:
												return e.updateEndpointMetadata(S, !0), [2, q.pQ.NETWORK];
											case 4:
												return O && !this.authorityOptions.skipAuthorityMetadataCache ? null !== (h = this.authorityOptions.azureRegionConfiguration) && void 0 !== h && h.azureRegion ? (null === (m = this.performanceClient) || void 0 === m || m.setPreQueueTime(St.AuthorityUpdateMetadataWithRegionalInformation, this.correlationId), [4, this.updateMetadataWithRegionalInformation(O)]) : [3, 6] : [3, 7];
											case 5:
												O = $.sent(), $.label = 6;
											case 6:
												return e.updateEndpointMetadata(O, !1), [2, q.pQ.HARDCODED_VALUES];
											case 7:
												throw zt.e.createUnableToGetOpenidConfigError(this.defaultOpenIdConfigurationEndpoint)
										}
									})
								})
							}, i.prototype.isAuthoritySameType = function(e) {
								return new Xn.G(e.canonical_authority).getUrlComponents().PathSegments.length === this.canonicalAuthorityUrlComponents.PathSegments.length
							}, i.prototype.getEndpointMetadataFromConfig = function() {
								if (this.authorityOptions.authorityMetadata) try {
									return JSON.parse(this.authorityOptions.authorityMetadata)
								} catch {
									throw g.r.createInvalidAuthorityMetadataError()
								}
								return null
							}, i.prototype.getEndpointMetadataFromNetwork = function() {
								var e;
								return (0, _t.mG)(this, void 0, void 0, function() {
									var t, s;
									return (0, _t.Jh)(this, function(c) {
										switch (c.label) {
											case 0:
												null === (e = this.performanceClient) || void 0 === e || e.addQueueMeasurement(St.AuthorityGetEndpointMetadataFromNetwork, this.correlationId), t = {}, c.label = 1;
											case 1:
												return c.trys.push([1, 3, , 4]), [4, this.networkInterface.sendGetRequestAsync(this.defaultOpenIdConfigurationEndpoint, t)];
											case 2:
												return [2, E_((s = c.sent()).body) ? s.body : null];
											case 3:
												return c.sent(), [2, null];
											case 4:
												return [2]
										}
									})
								})
							}, i.prototype.getEndpointMetadataFromHardcodedValues = function() {
								return this.canonicalAuthority in Gp ? Gp[this.canonicalAuthority] : null
							}, i.prototype.updateMetadataWithRegionalInformation = function(e) {
								var t, s, c, u, h, m, S;
								return (0, _t.mG)(this, void 0, void 0, function() {
									var O, $;
									return (0, _t.Jh)(this, function(le) {
										switch (le.label) {
											case 0:
												return null === (t = this.performanceClient) || void 0 === t || t.addQueueMeasurement(St.AuthorityUpdateMetadataWithRegionalInformation, this.correlationId), null === (s = this.performanceClient) || void 0 === s || s.setPreQueueTime(St.RegionDiscoveryDetectRegion, this.correlationId), [4, this.regionDiscovery.detectRegion(null === (c = this.authorityOptions.azureRegionConfiguration) || void 0 === c ? void 0 : c.environmentRegion, this.regionDiscoveryMetadata)];
											case 1:
												return O = le.sent(), $ = (null === (u = this.authorityOptions.azureRegionConfiguration) || void 0 === u ? void 0 : u.azureRegion) === q.gT.AZURE_REGION_AUTO_DISCOVER_FLAG ? O : null === (h = this.authorityOptions.azureRegionConfiguration) || void 0 === h ? void 0 : h.azureRegion, this.regionDiscoveryMetadata.region_outcome = (null === (m = this.authorityOptions.azureRegionConfiguration) || void 0 === m ? void 0 : m.azureRegion) === q.gT.AZURE_REGION_AUTO_DISCOVER_FLAG ? O ? q.ki.AUTO_DETECTION_REQUESTED_SUCCESSFUL : q.ki.AUTO_DETECTION_REQUESTED_FAILED : O ? (null === (S = this.authorityOptions.azureRegionConfiguration) || void 0 === S ? void 0 : S.azureRegion) === O ? q.ki.CONFIGURED_MATCHES_DETECTED : q.ki.CONFIGURED_NOT_DETECTED : q.ki.CONFIGURED_NO_AUTO_DETECTION, $ ? (this.regionDiscoveryMetadata.region_used = $, [2, i.replaceWithRegionalInformation(e, $)]) : [2, e]
										}
									})
								})
							}, i.prototype.updateCloudDiscoveryMetadata = function(e) {
								var t, s;
								return (0, _t.mG)(this, void 0, void 0, function() {
									var c, u, h;
									return (0, _t.Jh)(this, function(m) {
										switch (m.label) {
											case 0:
												return null === (t = this.performanceClient) || void 0 === t || t.addQueueMeasurement(St.AuthorityUpdateCloudDiscoveryMetadata, this.correlationId), this.logger.verbose("Attempting to get cloud discovery metadata in the config"), this.logger.verbosePii("Known Authorities: " + (this.authorityOptions.knownAuthorities || q.gT.NOT_APPLICABLE)), this.logger.verbosePii("Authority Metadata: " + (this.authorityOptions.authorityMetadata || q.gT.NOT_APPLICABLE)), this.logger.verbosePii("Canonical Authority: " + (e.canonical_authority || q.gT.NOT_APPLICABLE)), (c = this.getCloudDiscoveryMetadataFromConfig()) ? (this.logger.verbose("Found cloud discovery metadata in the config."), e.updateCloudDiscoveryMetadata(c, !1), [2, q.pQ.CONFIG]) : (this.logger.verbose("Did not find cloud discovery metadata in the config... Attempting to get cloud discovery metadata from the cache."), u = e.isExpired(), this.isAuthoritySameType(e) && e.aliasesFromNetwork && !u ? (this.logger.verbose("Found metadata in the cache."), [2, q.pQ.CACHE]) : (u && this.logger.verbose("The metadata entity is expired."), this.logger.verbose("Did not find cloud discovery metadata in the cache... Attempting to get cloud discovery metadata from the network."), null === (s = this.performanceClient) || void 0 === s || s.setPreQueueTime(St.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.correlationId), [4, this.getCloudDiscoveryMetadataFromNetwork()]));
											case 1:
												if (c = m.sent()) return this.logger.verbose("cloud discovery metadata was successfully returned from getCloudDiscoveryMetadataFromNetwork()"), e.updateCloudDiscoveryMetadata(c, !0), [2, q.pQ.NETWORK];
												if (this.logger.verbose("Did not find cloud discovery metadata from the network... Attempting to get cloud discovery metadata from hardcoded values."), (h = this.getCloudDiscoveryMetadataFromHarcodedValues()) && !this.options.skipAuthorityMetadataCache) return this.logger.verbose("Found cloud discovery metadata from hardcoded values."), e.updateCloudDiscoveryMetadata(h, !1), [2, q.pQ.HARDCODED_VALUES];
												throw this.logger.error("Did not find cloud discovery metadata from hardcoded values... Metadata could not be obtained from config, cache, network or hardcoded values. Throwing Untrusted Authority Error."), g.r.createUntrustedAuthorityError()
										}
									})
								})
							}, i.prototype.getCloudDiscoveryMetadataFromConfig = function() {
								if (this.authorityOptions.cloudDiscoveryMetadata) {
									this.logger.verbose("The cloud discovery metadata has been provided as a network response, in the config.");
									try {
										this.logger.verbose("Attempting to parse the cloud discovery metadata.");
										var e = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata),
											t = i.getCloudDiscoveryMetadataFromNetworkResponse(e.metadata, this.hostnameAndPort);
										if (this.logger.verbose("Parsed the cloud discovery metadata."), t) return this.logger.verbose("There is returnable metadata attached to the parsed cloud discovery metadata."), t;
										this.logger.verbose("There is no metadata attached to the parsed cloud discovery metadata.")
									} catch {
										throw this.logger.verbose("Unable to parse the cloud discovery metadata. Throwing Invalid Cloud Discovery Metadata Error."), g.r.createInvalidCloudDiscoveryMetadataError()
									}
								}
								return this.isInKnownAuthorities() ? (this.logger.verbose("The host is included in knownAuthorities. Creating new cloud discovery metadata from the host."), i.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort)) : null
							}, i.prototype.getCloudDiscoveryMetadataFromNetwork = function() {
								var e;
								return (0, _t.mG)(this, void 0, void 0, function() {
									var t, s, c, u, h, m, S, O;
									return (0, _t.Jh)(this, function($) {
										switch ($.label) {
											case 0:
												null === (e = this.performanceClient) || void 0 === e || e.addQueueMeasurement(St.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.correlationId), t = "" + q.gT.AAD_INSTANCE_DISCOVERY_ENDPT + this.canonicalAuthority + "oauth2/v2.0/authorize", s = {}, c = null, $.label = 1;
											case 1:
												return $.trys.push([1, 3, , 4]), [4, this.networkInterface.sendGetRequestAsync(t, s)];
											case 2:
												if (u = $.sent(), h = void 0, m = void 0, function vh(i) {
														return i.hasOwnProperty("tenant_discovery_endpoint") && i.hasOwnProperty("metadata")
													}(u.body)) m = (h = u.body).metadata, this.logger.verbosePii("tenant_discovery_endpoint is: " + h.tenant_discovery_endpoint);
												else {
													if (! function Mu(i) {
															return i.hasOwnProperty("error") && i.hasOwnProperty("error_description")
														}(u.body)) return this.logger.error("AAD did not return a CloudInstanceDiscoveryResponse or CloudInstanceDiscoveryErrorResponse"), [2, null];
													if (this.logger.warning("A CloudInstanceDiscoveryErrorResponse was returned. The cloud instance discovery network request's status code is: " + u.status), (h = u.body).error === q.gT.INVALID_INSTANCE) return this.logger.error("The CloudInstanceDiscoveryErrorResponse error is invalid_instance."), [2, null];
													this.logger.warning("The CloudInstanceDiscoveryErrorResponse error is " + h.error), this.logger.warning("The CloudInstanceDiscoveryErrorResponse error description is " + h.error_description), this.logger.warning("Setting the value of the CloudInstanceDiscoveryMetadata (returned from the network) to []"), m = []
												}
												return this.logger.verbose("Attempting to find a match between the developer's authority and the CloudInstanceDiscoveryMetadata returned from the network request."), c = i.getCloudDiscoveryMetadataFromNetworkResponse(m, this.hostnameAndPort), [3, 4];
											case 3:
												return (S = $.sent()) instanceof vn.l ? this.logger.error("There was a network error while attempting to get the cloud discovery instance metadata.\nError: " + S.errorCode + "\nError Description: " + S.errorMessage) : this.logger.error("A non-MSALJS error was thrown while attempting to get the cloud instance discovery metadata.\nError: " + (O = S).name + "\nError Description: " + O.message), [2, null];
											case 4:
												return c || (this.logger.warning("The developer's authority was not found within the CloudInstanceDiscoveryMetadata returned from the network request."), this.logger.verbose("Creating custom Authority for custom domain scenario."), c = i.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort)), [2, c]
										}
									})
								})
							}, i.prototype.getCloudDiscoveryMetadataFromHarcodedValues = function() {
								return this.canonicalAuthority in _h ? _h[this.canonicalAuthority] : null
							}, i.prototype.isInKnownAuthorities = function() {
								var e = this;
								return this.authorityOptions.knownAuthorities.filter(function(s) {
									return Xn.G.getDomainFromUrl(s).toLowerCase() === e.hostnameAndPort
								}).length > 0
							}, i.generateAuthority = function(e, t) {
								var s;
								return t && t.azureCloudInstance !== Io.None && (s = t.azureCloudInstance + "/" + (t.tenant ? t.tenant : q.gT.DEFAULT_COMMON_TENANT) + "/"), s || e
							}, i.createCloudDiscoveryMetadataFromHost = function(e) {
								return {
									preferred_network: e,
									preferred_cache: e,
									aliases: [e]
								}
							}, i.getCloudDiscoveryMetadataFromNetworkResponse = function(e, t) {
								for (var s = 0; s < e.length; s++) {
									var c = e[s];
									if (c.aliases.indexOf(t) > -1) return c
								}
								return null
							}, i.prototype.getPreferredCache = function() {
								if (this.discoveryComplete()) return this.metadata.preferred_cache;
								throw zt.e.createEndpointDiscoveryIncompleteError("Discovery incomplete.")
							}, i.prototype.isAlias = function(e) {
								return this.metadata.aliases.indexOf(e) > -1
							}, i.isPublicCloudAuthority = function(e) {
								return q.gT.KNOWN_PUBLIC_CLOUDS.indexOf(e) >= 0
							}, i.buildRegionalAuthorityString = function(e, t, s) {
								var c = new Xn.G(e);
								c.validateAsUri();
								var u = c.getUrlComponents(),
									h = t + "." + u.HostNameAndPort;
								this.isPublicCloudAuthority(u.HostNameAndPort) && (h = t + "." + q.gT.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX);
								var m = Xn.G.constructAuthorityUriFromObject((0, _t.pi)((0, _t.pi)({}, c.getUrlComponents()), {
									HostNameAndPort: h
								})).urlString;
								return s ? m + "?" + s : m
							}, i.replaceWithRegionalInformation = function(e, t) {
								return e.authorization_endpoint = i.buildRegionalAuthorityString(e.authorization_endpoint, t), e.token_endpoint = i.buildRegionalAuthorityString(e.token_endpoint, t, q.gT.REGIONAL_AUTH_NON_MSI_QUERY_STRING), e.end_session_endpoint && (e.end_session_endpoint = i.buildRegionalAuthorityString(e.end_session_endpoint, t)), e
							}, i
						}(),
						kc = function() {
							function i() {}
							return i.createDiscoveredInstance = function(e, t, s, c, u, h, m) {
								return (0, _t.mG)(this, void 0, void 0, function() {
									var S, O;
									return (0, _t.Jh)(this, function($) {
										switch ($.label) {
											case 0:
												h?.addQueueMeasurement(St.AuthorityFactoryCreateDiscoveredInstance, m), S = i.createInstance(e, t, s, c, u, h, m), $.label = 1;
											case 1:
												return $.trys.push([1, 3, , 4]), h?.setPreQueueTime(St.AuthorityResolveEndpointsAsync, m), [4, S.resolveEndpointsAsync()];
											case 2:
												return $.sent(), [2, S];
											case 3:
												throw O = $.sent(), zt.e.createEndpointDiscoveryIncompleteError(O);
											case 4:
												return [2]
										}
									})
								})
							}, i.createInstance = function(e, t, s, c, u, h, m) {
								if (_n.x.isEmpty(e)) throw g.r.createUrlEmptyError();
								return new Nc(e, t, s, c, u, h, m)
							}, i
						}(),
						Do = function() {
							function i(e, t) {
								this.cacheOutcome = q.To.NO_CACHE_HIT, this.cacheManager = t, this.apiId = e.apiId, this.correlationId = e.correlationId, this.wrapperSKU = e.wrapperSKU || q.gT.EMPTY_STRING, this.wrapperVer = e.wrapperVer || q.gT.EMPTY_STRING, this.telemetryCacheKey = q.HN.CACHE_KEY + q.Bv.CACHE_KEY_SEPARATOR + e.clientId
							}
							return i.prototype.generateCurrentRequestHeaderValue = function() {
								var e = "" + this.apiId + q.HN.VALUE_SEPARATOR + this.cacheOutcome,
									t = [this.wrapperSKU, this.wrapperVer].join(q.HN.VALUE_SEPARATOR),
									c = [e, this.getRegionDiscoveryFields()].join(q.HN.VALUE_SEPARATOR);
								return [q.HN.SCHEMA_VERSION, c, t].join(q.HN.CATEGORY_SEPARATOR)
							}, i.prototype.generateLastRequestHeaderValue = function() {
								var e = this.getLastRequests(),
									t = i.maxErrorsToSend(e),
									s = e.failedRequests.slice(0, 2 * t).join(q.HN.VALUE_SEPARATOR),
									c = e.errors.slice(0, t).join(q.HN.VALUE_SEPARATOR),
									u = e.errors.length,
									m = [u, t < u ? q.HN.OVERFLOW_TRUE : q.HN.OVERFLOW_FALSE].join(q.HN.VALUE_SEPARATOR);
								return [q.HN.SCHEMA_VERSION, e.cacheHits, s, c, m].join(q.HN.CATEGORY_SEPARATOR)
							}, i.prototype.cacheFailedRequest = function(e) {
								var t = this.getLastRequests();
								t.errors.length >= q.HN.MAX_CACHED_ERRORS && (t.failedRequests.shift(), t.failedRequests.shift(), t.errors.shift()), t.failedRequests.push(this.apiId, this.correlationId), _n.x.isEmpty(e.subError) ? _n.x.isEmpty(e.errorCode) ? e && e.toString() ? t.errors.push(e.toString()) : t.errors.push(q.HN.UNKNOWN_ERROR) : t.errors.push(e.errorCode) : t.errors.push(e.subError), this.cacheManager.setServerTelemetry(this.telemetryCacheKey, t)
							}, i.prototype.incrementCacheHits = function() {
								var e = this.getLastRequests();
								return e.cacheHits += 1, this.cacheManager.setServerTelemetry(this.telemetryCacheKey, e), e.cacheHits
							}, i.prototype.getLastRequests = function() {
								var e = new xr;
								return this.cacheManager.getServerTelemetry(this.telemetryCacheKey) || e
							}, i.prototype.clearTelemetryCache = function() {
								var e = this.getLastRequests(),
									t = i.maxErrorsToSend(e);
								if (t === e.errors.length) this.cacheManager.removeItem(this.telemetryCacheKey);
								else {
									var c = new xr;
									c.failedRequests = e.failedRequests.slice(2 * t), c.errors = e.errors.slice(t), this.cacheManager.setServerTelemetry(this.telemetryCacheKey, c)
								}
							}, i.maxErrorsToSend = function(e) {
								var t, s = 0,
									c = 0,
									u = e.errors.length;
								for (t = 0; t < u; t++) {
									var m = e.failedRequests[2 * t + 1] || q.gT.EMPTY_STRING,
										S = e.errors[t] || q.gT.EMPTY_STRING;
									if (!((c += (e.failedRequests[2 * t] || q.gT.EMPTY_STRING).toString().length + m.toString().length + S.length + 3) < q.HN.MAX_LAST_HEADER_BYTES)) break;
									s += 1
								}
								return s
							}, i.prototype.getRegionDiscoveryFields = function() {
								var e = [];
								return e.push(this.regionUsed || q.gT.EMPTY_STRING), e.push(this.regionSource || q.gT.EMPTY_STRING), e.push(this.regionOutcome || q.gT.EMPTY_STRING), e.join(",")
							}, i.prototype.updateRegionDiscoveryMetadata = function(e) {
								this.regionUsed = e.region_used, this.regionSource = e.region_source, this.regionOutcome = e.region_outcome
							}, i.prototype.setCacheOutcome = function(e) {
								this.cacheOutcome = e
							}, i
						}(),
						Eh = function() {
							function i(e, t, s, c, u, h, m, S, O) {
								this.config = e, this.browserStorage = t, this.browserCrypto = s, this.networkClient = this.config.system.networkClient, this.eventHandler = u, this.navigationClient = h, this.nativeMessageHandler = S, this.correlationId = O || this.browserCrypto.createNewGuid(), this.logger = c.clone(Qe.qx.MSAL_SKU, Mc, this.correlationId), this.performanceClient = m
							}
							return i.prototype.clearCacheOnLogout = function(e) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(t) {
										switch (t.label) {
											case 0:
												if (!e) return [3, 5];
												v.accountInfoIsEqual(e, this.browserStorage.getActiveAccount(), !1) && (this.logger.verbose("Setting active account to null"), this.browserStorage.setActiveAccount(null)), t.label = 1;
											case 1:
												return t.trys.push([1, 3, , 4]), [4, this.browserStorage.removeAccount(v.generateAccountCacheKey(e))];
											case 2:
												return t.sent(), this.logger.verbose("Cleared cache items belonging to the account provided in the logout request."), [3, 4];
											case 3:
												return t.sent(), this.logger.error("Account provided in logout request was not found. Local cache unchanged."), [3, 4];
											case 4:
												return [3, 9];
											case 5:
												return t.trys.push([5, 8, , 9]), this.logger.verbose("No account provided in logout request, clearing all cache items.", this.correlationId), [4, this.browserStorage.clear()];
											case 6:
												return t.sent(), [4, this.browserCrypto.clearKeystore()];
											case 7:
												return t.sent(), [3, 9];
											case 8:
												return t.sent(), this.logger.error("Attempted to clear all MSAL cache items and failed. Local cache unchanged."), [3, 9];
											case 9:
												return [2]
										}
									})
								})
							}, i.prototype.initializeBaseRequest = function(e) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var t, s, c, u;
									return (0, _e.Jh)(this, function(h) {
										switch (h.label) {
											case 0:
												if (this.performanceClient.addQueueMeasurement(St.InitializeBaseRequest, e.correlationId), this.logger.verbose("Initializing BaseAuthRequest"), t = e.authority || this.config.auth.authority, s = (0, _e.fl)(e && e.scopes || []), (c = (0, _e.pi)((0, _e.pi)({}, e), {
														correlationId: this.correlationId,
														authority: t,
														scopes: s
													})).authenticationScheme) {
													if (c.authenticationScheme === q.hO.SSH) {
														if (!e.sshJwk) throw g.r.createMissingSshJwkError();
														if (!e.sshKid) throw g.r.createMissingSshKidError()
													}
													this.logger.verbose('Authentication Scheme set to "' + c.authenticationScheme + '" as configured in Auth request')
												} else c.authenticationScheme = q.hO.BEARER, this.logger.verbose('Authentication Scheme wasn\'t explicitly set in request, defaulting to "Bearer" request');
												return e.claims && !_n.x.isEmpty(e.claims) ? (u = c, [4, this.browserCrypto.hashString(e.claims)]) : [3, 2];
											case 1:
												u.requestedClaimsHash = h.sent(), h.label = 2;
											case 2:
												return [2, c]
										}
									})
								})
							}, i.prototype.getRedirectUri = function(e) {
								this.logger.verbose("getRedirectUri called");
								var t = e || this.config.auth.redirectUri || Mr.M.getCurrentUri();
								return Xn.G.getAbsoluteUrl(t, Mr.M.getCurrentUri())
							}, i.prototype.initializeServerTelemetryManager = function(e, t) {
								this.logger.verbose("initializeServerTelemetryManager called");
								var s = {
									clientId: this.config.auth.clientId,
									correlationId: this.correlationId,
									apiId: e,
									forceRefresh: t || !1,
									wrapperSKU: this.browserStorage.getWrapperMetadata()[0],
									wrapperVer: this.browserStorage.getWrapperMetadata()[1]
								};
								return new Do(s, this.browserStorage)
							}, i.prototype.getDiscoveredAuthority = function(e) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var t;
									return (0, _e.Jh)(this, function(s) {
										switch (s.label) {
											case 0:
												return this.logger.verbose("getDiscoveredAuthority called"), t = {
													protocolMode: this.config.auth.protocolMode,
													knownAuthorities: this.config.auth.knownAuthorities,
													cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,
													authorityMetadata: this.config.auth.authorityMetadata
												}, e ? (this.logger.verbose("Creating discovered authority with request authority"), [4, kc.createDiscoveredInstance(e, this.config.system.networkClient, this.browserStorage, t, this.logger)]) : [3, 2];
											case 1:
											case 3:
												return [2, s.sent()];
											case 2:
												return this.logger.verbose("Creating discovered authority with configured authority"), [4, kc.createDiscoveredInstance(this.config.auth.authority, this.config.system.networkClient, this.browserStorage, t, this.logger)]
										}
									})
								})
							}, i
						}(),
						Na = function(i) {
							function e() {
								return null !== i && i.apply(this, arguments) || this
							}
							return (0, _e.ZT)(e, i), e.prototype.initializeAuthorizationCodeRequest = function(t) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var s, c;
									return (0, _e.Jh)(this, function(u) {
										switch (u.label) {
											case 0:
												return this.performanceClient.addQueueMeasurement(St.StandardInteractionClientInitializeAuthorizationCodeRequest, t.correlationId), this.logger.verbose("initializeAuthorizationRequest called", t.correlationId), [4, this.browserCrypto.generatePkceCodes()];
											case 1:
												return s = u.sent(), c = (0, _e.pi)((0, _e.pi)({}, t), {
													redirectUri: t.redirectUri,
													code: q.gT.EMPTY_STRING,
													codeVerifier: s.verifier
												}), t.codeChallenge = s.challenge, t.codeChallengeMethod = q.gT.S256_CODE_CHALLENGE_METHOD, [2, c]
										}
									})
								})
							}, e.prototype.initializeLogoutRequest = function(t) {
								this.logger.verbose("initializeLogoutRequest called", t?.correlationId);
								var s = (0, _e.pi)({
									correlationId: this.correlationId || this.browserCrypto.createNewGuid()
								}, t);
								if (t)
									if (t.logoutHint) this.logger.verbose("logoutHint has already been set in logoutRequest");
									else if (t.account) {
									var c = this.getLogoutHintFromIdTokenClaims(t.account);
									c && (this.logger.verbose("Setting logoutHint to login_hint ID Token Claim value for the account provided"), s.logoutHint = c)
								} else this.logger.verbose("logoutHint was not set and account was not passed into logout request, logoutHint will not be set");
								else this.logger.verbose("logoutHint will not be set since no logout request was configured");
								return t && null === t.postLogoutRedirectUri ? this.logger.verbose("postLogoutRedirectUri passed as null, not setting post logout redirect uri", s.correlationId) : t && t.postLogoutRedirectUri ? (this.logger.verbose("Setting postLogoutRedirectUri to uri set on logout request", s.correlationId), s.postLogoutRedirectUri = Xn.G.getAbsoluteUrl(t.postLogoutRedirectUri, Mr.M.getCurrentUri())) : null === this.config.auth.postLogoutRedirectUri ? this.logger.verbose("postLogoutRedirectUri configured as null and no uri set on request, not passing post logout redirect", s.correlationId) : this.config.auth.postLogoutRedirectUri ? (this.logger.verbose("Setting postLogoutRedirectUri to configured uri", s.correlationId), s.postLogoutRedirectUri = Xn.G.getAbsoluteUrl(this.config.auth.postLogoutRedirectUri, Mr.M.getCurrentUri())) : (this.logger.verbose("Setting postLogoutRedirectUri to current page", s.correlationId), s.postLogoutRedirectUri = Xn.G.getAbsoluteUrl(Mr.M.getCurrentUri(), Mr.M.getCurrentUri())), s
							}, e.prototype.getLogoutHintFromIdTokenClaims = function(t) {
								var s = t.idTokenClaims;
								if (s) {
									if (s.login_hint) return s.login_hint;
									this.logger.verbose("The ID Token Claims tied to the provided account do not contain a login_hint claim, logoutHint will not be added to logout request")
								} else this.logger.verbose("The provided account does not contain ID Token Claims, logoutHint will not be added to logout request");
								return null
							}, e.prototype.createAuthCodeClient = function(t, s, c) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var u;
									return (0, _e.Jh)(this, function(h) {
										switch (h.label) {
											case 0:
												return this.performanceClient.addQueueMeasurement(St.StandardInteractionClientCreateAuthCodeClient, this.correlationId), this.performanceClient.setPreQueueTime(St.StandardInteractionClientGetClientConfiguration, this.correlationId), [4, this.getClientConfiguration(t, s, c)];
											case 1:
												return u = h.sent(), [2, new Bp(u, this.performanceClient)]
										}
									})
								})
							}, e.prototype.getClientConfiguration = function(t, s, c) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var u, h;
									return (0, _e.Jh)(this, function(m) {
										switch (m.label) {
											case 0:
												return this.performanceClient.addQueueMeasurement(St.StandardInteractionClientGetClientConfiguration, this.correlationId), this.logger.verbose("getClientConfiguration called", this.correlationId), this.performanceClient.setPreQueueTime(St.StandardInteractionClientGetDiscoveredAuthority, this.correlationId), [4, this.getDiscoveredAuthority(s, c)];
											case 1:
												return u = m.sent(), [2, {
													authOptions: {
														clientId: this.config.auth.clientId,
														authority: u,
														clientCapabilities: this.config.auth.clientCapabilities
													},
													systemOptions: {
														tokenRenewalOffsetSeconds: this.config.system.tokenRenewalOffsetSeconds,
														preventCorsPreflight: !0
													},
													loggerOptions: {
														loggerCallback: (h = this.config.system.loggerOptions).loggerCallback,
														piiLoggingEnabled: h.piiLoggingEnabled,
														logLevel: h.logLevel,
														correlationId: this.correlationId
													},
													cryptoInterface: this.browserCrypto,
													networkInterface: this.networkClient,
													storageInterface: this.browserStorage,
													serverTelemetryManager: t,
													libraryInfo: {
														sku: Qe.qx.MSAL_SKU,
														version: Mc,
														cpu: q.gT.EMPTY_STRING,
														os: q.gT.EMPTY_STRING
													},
													telemetry: this.config.telemetry
												}]
										}
									})
								})
							}, e.prototype.validateAndExtractStateFromHash = function(t, s, c) {
								if (this.logger.verbose("validateAndExtractStateFromHash called", c), !t.state) throw rn.U.createHashDoesNotContainStateError();
								var u = _l.extractBrowserRequestState(this.browserCrypto, t.state);
								if (!u) throw rn.U.createUnableToParseStateError();
								if (u.interactionType !== s) throw rn.U.createStateInteractionTypeMismatchError();
								return this.logger.verbose("Returning state from hash", c), t.state
							}, e.prototype.getDiscoveredAuthority = function(t, s) {
								var c;
								return (0, _e.mG)(this, void 0, void 0, function() {
									var u, h, S;
									return (0, _e.Jh)(this, function(O) {
										switch (O.label) {
											case 0:
												return this.performanceClient.addQueueMeasurement(St.StandardInteractionClientGetDiscoveredAuthority, this.correlationId), this.logger.verbose("getDiscoveredAuthority called", this.correlationId), u = null === (c = this.performanceClient) || void 0 === c ? void 0 : c.startMeasurement(St.StandardInteractionClientGetDiscoveredAuthority, this.correlationId), h = {
													protocolMode: this.config.auth.protocolMode,
													knownAuthorities: this.config.auth.knownAuthorities,
													cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,
													authorityMetadata: this.config.auth.authorityMetadata,
													skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache
												}, S = Nc.generateAuthority(t || this.config.auth.authority, s || this.config.auth.azureCloudOptions), this.logger.verbose("Creating discovered authority with configured authority", this.correlationId), this.performanceClient.setPreQueueTime(St.AuthorityFactoryCreateDiscoveredInstance, this.correlationId), [4, kc.createDiscoveredInstance(S, this.config.system.networkClient, this.browserStorage, h, this.logger, this.performanceClient, this.correlationId).then(function($) {
													return u.endMeasurement({
														success: !0
													}), $
												}).catch(function($) {
													throw u.endMeasurement({
														errorCode: $.errorCode,
														subErrorCode: $.subError,
														success: !1
													}), $
												})];
											case 1:
												return [2, O.sent()]
										}
									})
								})
							}, e.prototype.initializeAuthorizationRequest = function(t, s) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var c, h, m, S, O, $;
									return (0, _e.Jh)(this, function(le) {
										switch (le.label) {
											case 0:
												return this.performanceClient.addQueueMeasurement(St.StandardInteractionClientInitializeAuthorizationRequest, this.correlationId), this.logger.verbose("initializeAuthorizationRequest called", this.correlationId), c = this.getRedirectUri(t.redirectUri), h = gi.setRequestState(this.browserCrypto, t && t.state || q.gT.EMPTY_STRING, {
													interactionType: s
												}), this.performanceClient.setPreQueueTime(St.InitializeBaseRequest, this.correlationId), S = [{}], [4, this.initializeBaseRequest(t)];
											case 1:
												return m = _e.pi.apply(void 0, [_e.pi.apply(void 0, S.concat([le.sent()])), {
													redirectUri: c,
													state: h,
													nonce: t.nonce || this.browserCrypto.createNewGuid(),
													responseMode: q.vw.FRAGMENT
												}]), (O = t.account || this.browserStorage.getActiveAccount()) && (this.logger.verbose("Setting validated request account", this.correlationId), this.logger.verbosePii("Setting validated request account: " + O.homeAccountId, this.correlationId), m.account = O), _n.x.isEmpty(m.loginHint) && !O && ($ = this.browserStorage.getLegacyLoginHint()) && (m.loginHint = $), [2, m]
										}
									})
								})
							}, e
						}(Eh),
						Ho = (() => {
							return (i = Ho || (Ho = {})).USER_INTERACTION_REQUIRED = "USER_INTERACTION_REQUIRED", i.USER_CANCEL = "USER_CANCEL", i.NO_NETWORK = "NO_NETWORK", i.TRANSIENT_ERROR = "TRANSIENT_ERROR", i.PERSISTENT_ERROR = "PERSISTENT_ERROR", i.DISABLED = "DISABLED", i.ACCOUNT_UNAVAILABLE = "ACCOUNT_UNAVAILABLE", Ho;
							var i
						})(),
						ka_extensionError_code = "ContentError",
						ka_userSwitch_code = "user_switch",
						ka_userSwitch_desc = "User attempted to switch accounts in the native broker, which is not allowed. All new accounts must sign-in through the standard web flow first, please try again.",
						ka_tokensNotFoundInCache_code = "tokens_not_found_in_internal_memory_cache",
						ka_tokensNotFoundInCache_desc = "Tokens not cached in MSAL JS internal memory, please make the WAM request",
						ji = function(i) {
							function e(t, s, c) {
								var u = i.call(this, t, s) || this;
								return Object.setPrototypeOf(u, e.prototype), u.name = "NativeAuthError", u.ext = c, u
							}
							return (0, _e.ZT)(e, i), e.prototype.isFatal = function() {
								return !(!this.ext || !this.ext.status || this.ext.status !== Ho.PERSISTENT_ERROR && this.ext.status !== Ho.DISABLED) || this.errorCode === ka_extensionError_code
							}, e.createError = function(t, s, c) {
								if (c && c.status) switch (c.status) {
									case Ho.ACCOUNT_UNAVAILABLE:
										return Oi.createNativeAccountUnavailableError();
									case Ho.USER_INTERACTION_REQUIRED:
										return new Oi(t, s);
									case Ho.USER_CANCEL:
										return rn.U.createUserCancelledError();
									case Ho.NO_NETWORK:
										return rn.U.createNoNetworkConnectivityError()
								}
								return new e(t, s, c)
							}, e.createUserSwitchError = function() {
								return new e(ka_userSwitch_code, ka_userSwitch_desc)
							}, e.createTokensNotFoundInCacheError = function() {
								return new e(ka_tokensNotFoundInCache_code, ka_tokensNotFoundInCache_desc)
							}, e
						}(vn.l),
						Ch = function(i) {
							function e(t, s) {
								return i.call(this, t, s) || this
							}
							return (0, _t.ZT)(e, i), e.prototype.acquireToken = function(t) {
								var s, c, u, h, m, S, O;
								return (0, _t.mG)(this, void 0, void 0, function() {
									var $, le, Re, Ae, Ze, wt, Wt = this;
									return (0, _t.Jh)(this, function(Yt) {
										switch (Yt.label) {
											case 0:
												return null === (s = this.performanceClient) || void 0 === s || s.addQueueMeasurement(St.RefreshTokenClientAcquireToken, t.correlationId), $ = null === (c = this.performanceClient) || void 0 === c ? void 0 : c.startMeasurement(St.RefreshTokenClientAcquireToken, t.correlationId), this.logger.verbose("RefreshTokenClientAcquireToken called", t.correlationId), le = bt.nowSeconds(), null === (u = this.performanceClient) || void 0 === u || u.setPreQueueTime(St.RefreshTokenClientExecuteTokenRequest, t.correlationId), [4, this.executeTokenRequest(t, this.authority)];
											case 1:
												return Re = Yt.sent(), Ae = null === (h = Re.headers) || void 0 === h ? void 0 : h[q.SZ.X_MS_HTTP_VERSION], $?.addStaticFields({
													refreshTokenSize: (null === (m = Re.body.refresh_token) || void 0 === m ? void 0 : m.length) || 0
												}), Ae && $?.addStaticFields({
													httpVerToken: Ae
												}), Ze = null === (S = Re.headers) || void 0 === S ? void 0 : S[q.SZ.X_MS_REQUEST_ID], (wt = new Ru(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin)).validateTokenResponse(Re.body), null === (O = this.performanceClient) || void 0 === O || O.setPreQueueTime(St.HandleServerTokenResponse, t.correlationId), [2, wt.handleServerTokenResponse(Re.body, this.authority, le, t, void 0, void 0, !0, t.forceCache, Ze).then(function(sn) {
													return $?.endMeasurement({
														success: !0
													}), sn
												}).catch(function(sn) {
													throw Wt.logger.verbose("Error in fetching refresh token", t.correlationId), $?.endMeasurement({
														errorCode: sn.errorCode,
														subErrorCode: sn.subError,
														success: !1
													}), sn
												})]
										}
									})
								})
							}, e.prototype.acquireTokenByRefreshToken = function(t) {
								var s, c, u, h;
								return (0, _t.mG)(this, void 0, void 0, function() {
									var O;
									return (0, _t.Jh)(this, function($) {
										if (!t) throw g.r.createEmptyTokenRequestError();
										if (null === (s = this.performanceClient) || void 0 === s || s.addQueueMeasurement(St.RefreshTokenClientAcquireTokenByRefreshToken, t.correlationId), !t.account) throw zt.e.createNoAccountInSilentRequestError();
										if (this.cacheManager.isAppMetadataFOCI(t.account.environment, this.config.authOptions.clientId)) try {
											return null === (c = this.performanceClient) || void 0 === c || c.setPreQueueTime(St.RefreshTokenClientAcquireTokenWithCachedRefreshToken, t.correlationId), [2, this.acquireTokenWithCachedRefreshToken(t, !0)]
										} catch (le) {
											if (O = le instanceof Ir && le.errorCode === q.D1.INVALID_GRANT_ERROR && le.subError === q.D1.CLIENT_MISMATCH_ERROR, le instanceof Oi && le.errorCode === Fo_noTokensFoundError_code || O) return null === (u = this.performanceClient) || void 0 === u || u.setPreQueueTime(St.RefreshTokenClientAcquireTokenWithCachedRefreshToken, t.correlationId), [2, this.acquireTokenWithCachedRefreshToken(t, !1)];
											throw le
										}
										return null === (h = this.performanceClient) || void 0 === h || h.setPreQueueTime(St.RefreshTokenClientAcquireTokenWithCachedRefreshToken, t.correlationId), [2, this.acquireTokenWithCachedRefreshToken(t, !1)]
									})
								})
							}, e.prototype.acquireTokenWithCachedRefreshToken = function(t, s) {
								var c, u, h;
								return (0, _t.mG)(this, void 0, void 0, function() {
									var m, S, O;
									return (0, _t.Jh)(this, function($) {
										if (null === (c = this.performanceClient) || void 0 === c || c.addQueueMeasurement(St.RefreshTokenClientAcquireTokenWithCachedRefreshToken, t.correlationId), m = null === (u = this.performanceClient) || void 0 === u ? void 0 : u.startMeasurement(St.RefreshTokenClientAcquireTokenWithCachedRefreshToken, t.correlationId), this.logger.verbose("RefreshTokenClientAcquireTokenWithCachedRefreshToken called", t.correlationId), !(S = this.cacheManager.readRefreshTokenFromCache(this.config.authOptions.clientId, t.account, s))) throw m?.discardMeasurement(), Oi.createNoTokensFoundError();
										return m?.endMeasurement({
											success: !0
										}), O = (0, _t.pi)((0, _t.pi)({}, t), {
											refreshToken: S.secret,
											authenticationScheme: t.authenticationScheme || q.hO.BEARER,
											ccsCredential: {
												credential: t.account.homeAccountId,
												type: Cr.HOME_ACCOUNT_ID
											}
										}), null === (h = this.performanceClient) || void 0 === h || h.setPreQueueTime(St.RefreshTokenClientAcquireToken, t.correlationId), [2, this.acquireToken(O)]
									})
								})
							}, e.prototype.executeTokenRequest = function(t, s) {
								var c, u, h;
								return (0, _t.mG)(this, void 0, void 0, function() {
									var m, S, O, $, le;
									return (0, _t.Jh)(this, function(Ae) {
										switch (Ae.label) {
											case 0:
												return null === (c = this.performanceClient) || void 0 === c || c.addQueueMeasurement(St.RefreshTokenClientExecuteTokenRequest, t.correlationId), m = null === (u = this.performanceClient) || void 0 === u ? void 0 : u.startMeasurement(St.RefreshTokenClientExecuteTokenRequest, t.correlationId), null === (h = this.performanceClient) || void 0 === h || h.setPreQueueTime(St.RefreshTokenClientCreateTokenRequestBody, t.correlationId), S = this.createTokenQueryParameters(t), O = Xn.G.appendQueryString(s.tokenEndpoint, S), [4, this.createTokenRequestBody(t)];
											case 1:
												return $ = Ae.sent(), le = this.createTokenRequestHeaders(t.ccsCredential), [2, this.executePostToTokenEndpoint(O, $, le, {
													clientId: this.config.authOptions.clientId,
													authority: s.canonicalAuthority,
													scopes: t.scopes,
													claims: t.claims,
													authenticationScheme: t.authenticationScheme,
													resourceRequestMethod: t.resourceRequestMethod,
													resourceRequestUri: t.resourceRequestUri,
													shrClaims: t.shrClaims,
													sshKid: t.sshKid
												}).then(function(Ze) {
													return m?.endMeasurement({
														success: !0
													}), Ze
												}).catch(function(Ze) {
													throw m?.endMeasurement({
														success: !1
													}), Ze
												})]
										}
									})
								})
							}, e.prototype.createTokenRequestBody = function(t) {
								var s, c, u;
								return (0, _t.mG)(this, void 0, void 0, function() {
									var h, m, S, O, $, le, Re;
									return (0, _t.Jh)(this, function(Ae) {
										switch (Ae.label) {
											case 0:
												return null === (s = this.performanceClient) || void 0 === s || s.addQueueMeasurement(St.RefreshTokenClientCreateTokenRequestBody, t.correlationId), h = t.correlationId, m = null === (c = this.performanceClient) || void 0 === c ? void 0 : c.startMeasurement(St.BaseClientCreateTokenRequestHeaders, h), (S = new Oc).addClientId(this.config.authOptions.clientId), S.addScopes(t.scopes), S.addGrantType(q.qJ.REFRESH_TOKEN_GRANT), S.addClientInfo(), S.addLibraryInfo(this.config.libraryInfo), S.addApplicationTelemetry(this.config.telemetry.application), S.addThrottling(), this.serverTelemetryManager && S.addServerTelemetry(this.serverTelemetryManager), S.addCorrelationId(h), S.addRefreshToken(t.refreshToken), this.config.clientCredentials.clientSecret && S.addClientSecret(this.config.clientCredentials.clientSecret), this.config.clientCredentials.clientAssertion && (S.addClientAssertion((O = this.config.clientCredentials.clientAssertion).assertion), S.addClientAssertionType(O.assertionType)), t.authenticationScheme !== q.hO.POP ? [3, 2] : ($ = new Pc(this.cryptoUtils, this.performanceClient), null === (u = this.performanceClient) || void 0 === u || u.setPreQueueTime(St.PopTokenGenerateCnf, t.correlationId), [4, $.generateCnf(t)]);
											case 1:
												return le = Ae.sent(), S.addPopToken(le.reqCnfString), [3, 3];
											case 2:
												if (t.authenticationScheme === q.hO.SSH) {
													if (!t.sshJwk) throw m?.endMeasurement({
														success: !1
													}), g.r.createMissingSshJwkError();
													S.addSshJwk(t.sshJwk)
												}
												Ae.label = 3;
											case 3:
												if ((!_n.x.isEmptyObj(t.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) && S.addClaims(t.claims, this.config.authOptions.clientCapabilities), this.config.systemOptions.preventCorsPreflight && t.ccsCredential) switch (t.ccsCredential.type) {
													case Cr.HOME_ACCOUNT_ID:
														try {
															Re = eo(t.ccsCredential.credential), S.addCcsOid(Re)
														} catch (Ze) {
															this.logger.verbose("Could not parse home account ID for CCS Header: " + Ze)
														}
														break;
													case Cr.UPN:
														S.addCcsUpn(t.ccsCredential.credential)
												}
												return m?.endMeasurement({
													success: !0
												}), [2, S.createQueryString()]
										}
									})
								})
							}, e
						}(Iu),
						jp = function(i) {
							function e(t, s) {
								return i.call(this, t, s) || this
							}
							return (0, _t.ZT)(e, i), e.prototype.acquireToken = function(t) {
								return (0, _t.mG)(this, void 0, void 0, function() {
									var s;
									return (0, _t.Jh)(this, function(u) {
										switch (u.label) {
											case 0:
												return u.trys.push([0, 2, , 3]), [4, this.acquireCachedToken(t)];
											case 1:
												return [2, u.sent()];
											case 2:
												if ((s = u.sent()) instanceof zt.e && s.errorCode === zt.A.tokenRefreshRequired.code) return [2, new Ch(this.config, this.performanceClient).acquireTokenByRefreshToken(t)];
												throw s;
											case 3:
												return [2]
										}
									})
								})
							}, e.prototype.acquireCachedToken = function(t) {
								var s, c, u, h;
								return (0, _t.mG)(this, void 0, void 0, function() {
									var m, S;
									return (0, _t.Jh)(this, function(O) {
										switch (O.label) {
											case 0:
												if (!t) throw g.r.createEmptyTokenRequestError();
												if (t.forceRefresh) throw null === (s = this.serverTelemetryManager) || void 0 === s || s.setCacheOutcome(q.To.FORCE_REFRESH), this.logger.info("SilentFlowClient:acquireCachedToken - Skipping cache because forceRefresh is true."), zt.e.createRefreshRequiredError();
												if (!t.account) throw zt.e.createNoAccountInSilentRequestError();
												if (m = t.authority || this.authority.getPreferredCache(), !(S = this.cacheManager.readCacheRecord(t.account, this.config.authOptions.clientId, t, m)).accessToken) throw null === (c = this.serverTelemetryManager) || void 0 === c || c.setCacheOutcome(q.To.NO_CACHED_ACCESS_TOKEN), this.logger.info("SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties."), zt.e.createRefreshRequiredError();
												if (bt.wasClockTurnedBack(S.accessToken.cachedAt) || bt.isTokenExpired(S.accessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) throw null === (u = this.serverTelemetryManager) || void 0 === u || u.setCacheOutcome(q.To.CACHED_ACCESS_TOKEN_EXPIRED), this.logger.info("SilentFlowClient:acquireCachedToken - Cached access token is expired or will expire within " + this.config.systemOptions.tokenRenewalOffsetSeconds + " seconds."), zt.e.createRefreshRequiredError();
												if (S.accessToken.refreshOn && bt.isTokenExpired(S.accessToken.refreshOn, 0)) throw null === (h = this.serverTelemetryManager) || void 0 === h || h.setCacheOutcome(q.To.REFRESH_CACHED_ACCESS_TOKEN), this.logger.info("SilentFlowClient:acquireCachedToken - Cached access token's refreshOn property has been exceeded'."), zt.e.createRefreshRequiredError();
												return this.config.serverTelemetryManager && this.config.serverTelemetryManager.incrementCacheHits(), [4, this.generateResultFromCacheRecord(S, t)];
											case 1:
												return [2, O.sent()]
										}
									})
								})
							}, e.prototype.generateResultFromCacheRecord = function(t, s) {
								return (0, _t.mG)(this, void 0, void 0, function() {
									var c, u;
									return (0, _t.Jh)(this, function(h) {
										switch (h.label) {
											case 0:
												if (t.idToken && (c = new x(t.idToken.secret, this.config.cryptoInterface)), s.maxAge || 0 === s.maxAge) {
													if (u = c?.claims.auth_time, !u) throw zt.e.createAuthTimeNotFoundError();
													x.checkMaxAge(u, s.maxAge)
												}
												return [4, Ru.generateAuthenticationResult(this.cryptoUtils, this.authority, t, !0, s, c)];
											case 1:
												return [2, h.sent()]
										}
									})
								})
							}, e
						}(Iu),
						Sh = function(i) {
							function e() {
								return null !== i && i.apply(this, arguments) || this
							}
							return (0, _e.ZT)(e, i), e.prototype.acquireToken = function(t) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var s, c, u, h, m;
									return (0, _e.Jh)(this, function(S) {
										switch (S.label) {
											case 0:
												return s = this.performanceClient.startMeasurement(St.SilentCacheClientAcquireToken, t.correlationId), c = this.initializeServerTelemetryManager(Qe.WN.acquireTokenSilent_silentFlow), [4, this.createSilentFlowClient(c, t.authority, t.azureCloudOptions)];
											case 1:
												u = S.sent(), this.logger.verbose("Silent auth client created"), S.label = 2;
											case 2:
												return S.trys.push([2, 4, , 5]), [4, u.acquireCachedToken(t)];
											case 3:
												return h = S.sent(), s.endMeasurement({
													success: !0,
													fromCache: !0
												}), [2, h];
											case 4:
												throw (m = S.sent()) instanceof rn.U && m.errorCode === rn.n.signingKeyNotFoundInStorage.code && this.logger.verbose("Signing keypair for bound access token not found. Refreshing bound access token and generating a new crypto keypair."), s.endMeasurement({
													errorCode: m instanceof vn.l && m.errorCode || void 0,
													subErrorCode: m instanceof vn.l && m.subError || void 0,
													success: !1
												}), m;
											case 5:
												return [2]
										}
									})
								})
							}, e.prototype.logout = function() {
								return Promise.reject(rn.U.createSilentLogoutUnsupportedError())
							}, e.prototype.createSilentFlowClient = function(t, s, c) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var u;
									return (0, _e.Jh)(this, function(h) {
										switch (h.label) {
											case 0:
												return this.performanceClient.setPreQueueTime(St.StandardInteractionClientGetClientConfiguration, this.correlationId), [4, this.getClientConfiguration(t, s, c)];
											case 1:
												return u = h.sent(), [2, new jp(u, this.performanceClient)]
										}
									})
								})
							}, e.prototype.initializeSilentRequest = function(t, s) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var c;
									return (0, _e.Jh)(this, function(u) {
										switch (u.label) {
											case 0:
												return this.performanceClient.addQueueMeasurement(St.InitializeSilentRequest, this.correlationId), this.performanceClient.setPreQueueTime(St.InitializeBaseRequest, this.correlationId), c = [(0, _e.pi)({}, t)], [4, this.initializeBaseRequest(t)];
											case 1:
												return [2, _e.pi.apply(void 0, [_e.pi.apply(void 0, c.concat([u.sent()])), {
													account: s,
													forceRefresh: t.forceRefresh || !1
												}])]
										}
									})
								})
							}, e
						}(Na),
						Us = function(i) {
							function e(t, s, c, u, h, m, S, O, $, le, Re, Ae) {
								var Ze = i.call(this, t, s, c, u, h, m, O, $, Ae) || this;
								return Ze.apiId = S, Ze.accountId = le, Ze.nativeMessageHandler = $, Ze.nativeStorageManager = Re, Ze.silentCacheClient = new Sh(t, Ze.nativeStorageManager, c, u, h, m, O, $, Ae), Ze
							}
							return (0, _e.ZT)(e, i), e.prototype.acquireToken = function(t) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var s, c, u, h, S, O;
									return (0, _e.Jh)(this, function($) {
										switch ($.label) {
											case 0:
												return this.logger.trace("NativeInteractionClient - acquireToken called."), s = this.performanceClient.startMeasurement(St.NativeInteractionClientAcquireToken, t.correlationId), c = bt.nowSeconds(), [4, this.initializeNativeRequest(t)];
											case 1:
												u = $.sent(), $.label = 2;
											case 2:
												return $.trys.push([2, 4, , 5]), [4, this.acquireTokensFromCache(this.accountId, u)];
											case 3:
												return h = $.sent(), s.endMeasurement({
													success: !0,
													isNativeBroker: !1,
													fromCache: !0
												}), [2, h];
											case 4:
												return $.sent(), this.logger.info("MSAL internal Cache does not contain tokens, proceed to make a native call"), [3, 5];
											case 5:
												return [4, this.nativeMessageHandler.sendMessage({
													method: Qe.Ky.GetToken,
													request: u
												})];
											case 6:
												return S = $.sent(), O = this.validateNativeResponse(S), [2, this.handleNativeResponse(O, u, c).then(function(le) {
													return s.endMeasurement({
														success: !0,
														isNativeBroker: !0,
														requestId: le.requestId
													}), le
												}).catch(function(le) {
													throw s.endMeasurement({
														success: !1,
														errorCode: le.errorCode,
														subErrorCode: le.subError,
														isNativeBroker: !0
													}), le
												})]
										}
									})
								})
							}, e.prototype.createSilentCacheRequest = function(t, s) {
								return {
									authority: t.authority,
									correlationId: this.correlationId,
									scopes: b.fromString(t.scope).asArray(),
									account: s,
									forceRefresh: !1
								}
							}, e.prototype.acquireTokensFromCache = function(t, s) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var c, u, h;
									return (0, _e.Jh)(this, function(O) {
										switch (O.label) {
											case 0:
												if (!(c = this.browserStorage.readAccountFromCacheWithNativeAccountId(t))) throw zt.e.createNoAccountFoundError();
												u = c.getAccountInfo(), O.label = 1;
											case 1:
												return O.trys.push([1, 3, , 4]), h = this.createSilentCacheRequest(s, u), [4, this.silentCacheClient.acquireToken(h)];
											case 2:
												return [2, O.sent()];
											case 3:
												throw O.sent();
											case 4:
												return [2]
										}
									})
								})
							}, e.prototype.acquireTokenRedirect = function(t) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var s, c, u, h, m, S;
									return (0, _e.Jh)(this, function(O) {
										switch (O.label) {
											case 0:
												return this.logger.trace("NativeInteractionClient - acquireTokenRedirect called."), [4, this.initializeNativeRequest(t)];
											case 1:
												s = O.sent(), c = {
													method: Qe.Ky.GetToken,
													request: s
												}, O.label = 2;
											case 2:
												return O.trys.push([2, 4, , 5]), [4, this.nativeMessageHandler.sendMessage(c)];
											case 3:
												return u = O.sent(), this.validateNativeResponse(u), [3, 5];
											case 4:
												if ((h = O.sent()) instanceof ji && h.isFatal()) throw h;
												return [3, 5];
											case 5:
												return this.browserStorage.setTemporaryCache(Qe.c4.NATIVE_REQUEST, JSON.stringify(s), !0), m = {
													apiId: Qe.WN.acquireTokenRedirect,
													timeout: this.config.system.redirectNavigationTimeout,
													noHistory: !1
												}, S = this.config.auth.navigateToLoginRequestUrl ? window.location.href : this.getRedirectUri(t.redirectUri), [4, this.navigationClient.navigateExternal(S, m)];
											case 6:
												return O.sent(), [2]
										}
									})
								})
							}, e.prototype.handleRedirectPromise = function() {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var t, s, c, u, h, m, S, O;
									return (0, _e.Jh)(this, function($) {
										switch ($.label) {
											case 0:
												if (this.logger.trace("NativeInteractionClient - handleRedirectPromise called."), !this.browserStorage.isInteractionInProgress(!0)) return this.logger.info("handleRedirectPromise called but there is no interaction in progress, returning null."), [2, null];
												if (!(t = this.browserStorage.getCachedNativeRequest())) return this.logger.verbose("NativeInteractionClient - handleRedirectPromise called but there is no cached request, returning null."), [2, null];
												s = t.prompt, c = (0, _e._T)(t, ["prompt"]), s && this.logger.verbose("NativeInteractionClient - handleRedirectPromise called and prompt was included in the original request, removing prompt from cached request to prevent second interaction with native broker window."), this.browserStorage.removeItem(this.browserStorage.generateCacheKey(Qe.c4.NATIVE_REQUEST)), u = {
													method: Qe.Ky.GetToken,
													request: c
												}, h = bt.nowSeconds(), $.label = 1;
											case 1:
												return $.trys.push([1, 3, , 4]), this.logger.verbose("NativeInteractionClient - handleRedirectPromise sending message to native broker."), [4, this.nativeMessageHandler.sendMessage(u)];
											case 2:
												return m = $.sent(), this.validateNativeResponse(m), S = this.handleNativeResponse(m, c, h), this.browserStorage.setInteractionInProgress(!1), [2, S];
											case 3:
												throw O = $.sent(), this.browserStorage.setInteractionInProgress(!1), O;
											case 4:
												return [2]
										}
									})
								})
							}, e.prototype.logout = function() {
								return this.logger.trace("NativeInteractionClient - logout called."), Promise.reject("Logout not implemented yet")
							}, e.prototype.handleNativeResponse = function(t, s, c) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var u, h, m, S, O, $;
									return (0, _e.Jh)(this, function(le) {
										switch (le.label) {
											case 0:
												if (this.logger.trace("NativeInteractionClient - handleNativeResponse called."), t.account.id !== s.accountId || t.account.id !== s.accountId) throw ji.createUserSwitchError();
												return [4, this.getDiscoveredAuthority(s.authority)];
											case 1:
												return u = le.sent(), h = u.getPreferredCache(), m = this.createIdTokenObj(t), S = this.createHomeAccountIdentifier(t, m), O = this.createAccountEntity(t, S, m, h), [4, this.generateAuthenticationResult(t, s, m, O, u.canonicalAuthority, c)];
											case 2:
												return $ = le.sent(), this.cacheAccount(O), this.cacheNativeTokens(t, s, S, m, $.accessToken, $.tenantId, c), [2, $]
										}
									})
								})
							}, e.prototype.createIdTokenObj = function(t) {
								return new x(t.id_token || q.gT.EMPTY_STRING, this.browserCrypto)
							}, e.prototype.createHomeAccountIdentifier = function(t, s) {
								return v.generateHomeAccountId(t.client_info || q.gT.EMPTY_STRING, Pi.Default, this.logger, this.browserCrypto, s)
							}, e.prototype.createAccountEntity = function(t, s, c, u) {
								return v.createAccount(t.client_info, s, c, void 0, void 0, void 0, u, t.account.id)
							}, e.prototype.generateScopes = function(t, s) {
								return b.fromString(t.scope ? t.scope : s.scope)
							}, e.prototype.generatePopAccessToken = function(t, s) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var c, u;
									return (0, _e.Jh)(this, function(h) {
										switch (h.label) {
											case 0:
												if (s.tokenType !== q.hO.POP) return [3, 2];
												if (t.shr) return this.logger.trace("handleNativeServerResponse: SHR is enabled in native layer"), [2, t.shr];
												if (c = new Pc(this.browserCrypto), u = {
														resourceRequestMethod: s.resourceRequestMethod,
														resourceRequestUri: s.resourceRequestUri,
														shrClaims: s.shrClaims,
														shrNonce: s.shrNonce
													}, !s.keyId) throw zt.e.createKeyIdMissingError();
												return [4, c.signPopToken(t.access_token, s.keyId, u)];
											case 1:
												return [2, h.sent()];
											case 2:
												return [2, t.access_token]
										}
									})
								})
							}, e.prototype.generateAuthenticationResult = function(t, s, c, u, h, m) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var S, O, $, le, Re, Ae, Ze;
									return (0, _e.Jh)(this, function(Wt) {
										switch (Wt.label) {
											case 0:
												return S = this.addTelemetryFromNativeResponse(t), O = b.fromString(t.scope ? t.scope : s.scope), le = ($ = t.account.properties || {}).UID || c.claims.oid || c.claims.sub || q.gT.EMPTY_STRING, Re = $.TenantId || c.claims.tid || q.gT.EMPTY_STRING, [4, this.generatePopAccessToken(t, s)];
											case 1:
												return Ae = Wt.sent(), Ze = s.tokenType === q.hO.POP ? q.hO.POP : q.hO.BEARER, [2, {
													authority: h,
													uniqueId: le,
													tenantId: Re,
													scopes: O.asArray(),
													account: u.getAccountInfo(),
													idToken: t.id_token,
													idTokenClaims: c.claims,
													accessToken: Ae,
													fromCache: !!S && this.isResponseFromCache(S),
													expiresOn: new Date(1e3 * Number(m + t.expires_in)),
													tokenType: Ze,
													correlationId: this.correlationId,
													state: t.state,
													fromNativeBroker: !0
												}]
										}
									})
								})
							}, e.prototype.cacheAccount = function(t) {
								var s = this;
								this.browserStorage.setAccount(t), this.browserStorage.removeAccountContext(t).catch(function(c) {
									s.logger.error("Error occurred while removing account context from browser storage. " + c)
								})
							}, e.prototype.cacheNativeTokens = function(t, s, c, u, h, m, S) {
								var O = We.createIdTokenEntity(c, s.authority, t.id_token || q.gT.EMPTY_STRING, s.clientId, u.claims.tid || q.gT.EMPTY_STRING);
								this.nativeStorageManager.setIdTokenCredential(O);
								var le = S + (s.tokenType === q.hO.POP ? q.gT.SHR_NONCE_VALIDITY : ("string" == typeof t.expires_in ? parseInt(t.expires_in, 10) : t.expires_in) || 0),
									Re = this.generateScopes(t, s),
									Ae = Kt.createAccessTokenEntity(c, s.authority, h, s.clientId, m, Re.printScopes(), le, 0, this.browserCrypto);
								this.nativeStorageManager.setAccessTokenCredential(Ae)
							}, e.prototype.addTelemetryFromNativeResponse = function(t) {
								var s = this.getMATSFromResponse(t);
								return s ? (this.performanceClient.addStaticFields({
									extensionId: this.nativeMessageHandler.getExtensionId(),
									extensionVersion: this.nativeMessageHandler.getExtensionVersion(),
									matsBrokerVersion: s.broker_version,
									matsAccountJoinOnStart: s.account_join_on_start,
									matsAccountJoinOnEnd: s.account_join_on_end,
									matsDeviceJoin: s.device_join,
									matsPromptBehavior: s.prompt_behavior,
									matsApiErrorCode: s.api_error_code,
									matsUiVisible: s.ui_visible,
									matsSilentCode: s.silent_code,
									matsSilentBiSubCode: s.silent_bi_sub_code,
									matsSilentMessage: s.silent_message,
									matsSilentStatus: s.silent_status,
									matsHttpStatus: s.http_status,
									matsHttpEventCount: s.http_event_count
								}, this.correlationId), s) : null
							}, e.prototype.validateNativeResponse = function(t) {
								if (t.hasOwnProperty("access_token") && t.hasOwnProperty("id_token") && t.hasOwnProperty("client_info") && t.hasOwnProperty("account") && t.hasOwnProperty("scope") && t.hasOwnProperty("expires_in")) return t;
								throw ji.createUnexpectedError("Response missing expected properties.")
							}, e.prototype.getMATSFromResponse = function(t) {
								if (t.properties.MATS) try {
									return JSON.parse(t.properties.MATS)
								} catch {
									this.logger.error("NativeInteractionClient - Error parsing MATS telemetry, returning null instead")
								}
								return null
							}, e.prototype.isResponseFromCache = function(t) {
								return typeof t.is_cached > "u" ? (this.logger.verbose("NativeInteractionClient - MATS telemetry does not contain field indicating if response was served from cache. Returning false."), !1) : !!t.is_cached
							}, e.prototype.initializeNativeRequest = function(t) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var c, u, h, m, S, O, $, Re, Ae = this;
									return (0, _e.Jh)(this, function(Ze) {
										switch (Ze.label) {
											case 0:
												return this.logger.trace("NativeInteractionClient - initializeNativeRequest called"), (c = new Xn.G(t.authority || this.config.auth.authority)).validateAsUri(), u = t.scopes, h = (0, _e._T)(t, ["scopes"]), (m = new b(u || [])).appendScopes(q.f_), S = function() {
													switch (Ae.apiId) {
														case Qe.WN.ssoSilent:
														case Qe.WN.acquireTokenSilent_silentFlow:
															return Ae.logger.trace("initializeNativeRequest: silent request sets prompt to none"), q.NJ.NONE
													}
													if (t.prompt) switch (t.prompt) {
														case q.NJ.NONE:
														case q.NJ.CONSENT:
														case q.NJ.LOGIN:
															return Ae.logger.trace("initializeNativeRequest: prompt is compatible with native flow"), t.prompt;
														default:
															throw Ae.logger.trace("initializeNativeRequest: prompt = " + t.prompt + " is not compatible with native flow"), rn.U.createNativePromptParameterNotSupportedError()
													} else Ae.logger.trace("initializeNativeRequest: prompt was not provided")
												}, O = (0, _e.pi)((0, _e.pi)({}, h), {
													accountId: this.accountId,
													clientId: this.config.auth.clientId,
													authority: c.urlString,
													scope: m.printScopes(),
													redirectUri: this.getRedirectUri(t.redirectUri),
													prompt: S(),
													correlationId: this.correlationId,
													tokenType: t.authenticationScheme,
													windowTitleSubstring: document.title,
													extraParameters: (0, _e.pi)((0, _e.pi)((0, _e.pi)({}, t.extraQueryParameters), t.tokenQueryParameters), {
														telemetry: Qe.BD.MATS_TELEMETRY
													}),
													extendedExpiryToken: !1
												}), t.authenticationScheme !== q.hO.POP ? [3, 2] : ($ = {
													resourceRequestUri: t.resourceRequestUri,
													resourceRequestMethod: t.resourceRequestMethod,
													shrClaims: t.shrClaims,
													shrNonce: t.shrNonce
												}, [4, new Pc(this.browserCrypto).generateCnf($)]);
											case 1:
												Re = Ze.sent(), O.reqCnf = Re.reqCnfHash, O.keyId = Re.kid, Ze.label = 2;
											case 2:
												return [2, O]
										}
									})
								})
							}, e
						}(Eh),
						Bs = function() {
							function i(e, t, s, c) {
								this.logger = e, this.handshakeTimeoutMs = t, this.extensionId = c, this.resolvers = new Map, this.handshakeResolvers = new Map, this.responseId = 0, this.messageChannel = new MessageChannel, this.windowListener = this.onWindowMessage.bind(this), this.performanceClient = s, this.handshakeEvent = s.startMeasurement(St.NativeMessageHandlerHandshake)
							}
							return i.prototype.sendMessage = function(e) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var t, s = this;
									return (0, _e.Jh)(this, function(c) {
										return this.logger.trace("NativeMessageHandler - sendMessage called."), t = {
											channel: Qe.BD.CHANNEL_ID,
											extensionId: this.extensionId,
											responseId: this.responseId++,
											body: e
										}, this.logger.trace("NativeMessageHandler - Sending request to browser extension"), this.logger.tracePii("NativeMessageHandler - Sending request to browser extension: " + JSON.stringify(t)), this.messageChannel.port1.postMessage(t), [2, new Promise(function(u, h) {
											s.resolvers.set(t.responseId, {
												resolve: u,
												reject: h
											})
										})]
									})
								})
							}, i.createProvider = function(e, t, s) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var c, u;
									return (0, _e.Jh)(this, function(h) {
										switch (h.label) {
											case 0:
												e.trace("NativeMessageHandler - createProvider called."), h.label = 1;
											case 1:
												return h.trys.push([1, 3, , 5]), [4, (c = new i(e, t, s, Qe.BD.PREFERRED_EXTENSION_ID)).sendHandshakeRequest()];
											case 2:
												return h.sent(), [2, c];
											case 3:
												return h.sent(), [4, (u = new i(e, t, s)).sendHandshakeRequest()];
											case 4:
												return h.sent(), [2, u];
											case 5:
												return [2]
										}
									})
								})
							}, i.prototype.sendHandshakeRequest = function() {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var e, t = this;
									return (0, _e.Jh)(this, function(s) {
										return this.logger.trace("NativeMessageHandler - sendHandshakeRequest called."), window.addEventListener("message", this.windowListener, !1), e = {
											channel: Qe.BD.CHANNEL_ID,
											extensionId: this.extensionId,
											responseId: this.responseId++,
											body: {
												method: Qe.Ky.HandshakeRequest
											}
										}, this.handshakeEvent.addStaticFields({
											extensionId: this.extensionId,
											extensionHandshakeTimeoutMs: this.handshakeTimeoutMs
										}), this.messageChannel.port1.onmessage = function(c) {
											t.onChannelMessage(c)
										}, window.postMessage(e, window.origin, [this.messageChannel.port2]), [2, new Promise(function(c, u) {
											t.handshakeResolvers.set(e.responseId, {
												resolve: c,
												reject: u
											}), t.timeoutId = window.setTimeout(function() {
												window.removeEventListener("message", t.windowListener, !1), t.messageChannel.port1.close(), t.messageChannel.port2.close(), t.handshakeEvent.endMeasurement({
													extensionHandshakeTimedOut: !0,
													success: !1
												}), u(rn.U.createNativeHandshakeTimeoutError()), t.handshakeResolvers.delete(e.responseId)
											}, t.handshakeTimeoutMs)
										})]
									})
								})
							}, i.prototype.onWindowMessage = function(e) {
								if (this.logger.trace("NativeMessageHandler - onWindowMessage called"), e.source === window) {
									var t = e.data;
									if (t.channel && t.channel === Qe.BD.CHANNEL_ID && (!t.extensionId || t.extensionId === this.extensionId) && t.body.method === Qe.Ky.HandshakeRequest) {
										this.logger.verbose(t.extensionId ? "Extension with id: " + t.extensionId + " not installed" : "No extension installed"), clearTimeout(this.timeoutId), this.messageChannel.port1.close(), this.messageChannel.port2.close(), window.removeEventListener("message", this.windowListener, !1);
										var s = this.handshakeResolvers.get(t.responseId);
										s && (this.handshakeEvent.endMeasurement({
											success: !1,
											extensionInstalled: !1
										}), s.reject(rn.U.createNativeExtensionNotInstalledError()))
									}
								}
							}, i.prototype.onChannelMessage = function(e) {
								this.logger.trace("NativeMessageHandler - onChannelMessage called.");
								var t = e.data,
									s = this.resolvers.get(t.responseId),
									c = this.handshakeResolvers.get(t.responseId);
								try {
									var u = t.body.method;
									if (u === Qe.Ky.Response) {
										if (!s) return;
										var h = t.body.response;
										if (this.logger.trace("NativeMessageHandler - Received response from browser extension"), this.logger.tracePii("NativeMessageHandler - Received response from browser extension: " + JSON.stringify(h)), "Success" !== h.status) s.reject(ji.createError(h.code, h.description, h.ext));
										else {
											if (!h.result) throw vn.l.createUnexpectedError("Event does not contain result.");
											h.result.code && h.result.description ? s.reject(ji.createError(h.result.code, h.result.description, h.result.ext)) : s.resolve(h.result)
										}
										this.resolvers.delete(t.responseId)
									} else if (u === Qe.Ky.HandshakeResponse) {
										if (!c) return;
										clearTimeout(this.timeoutId), window.removeEventListener("message", this.windowListener, !1), this.extensionId = t.extensionId, this.extensionVersion = t.body.version, this.logger.verbose("NativeMessageHandler - Received HandshakeResponse from extension: " + this.extensionId), this.handshakeEvent.endMeasurement({
											extensionInstalled: !0,
											success: !0
										}), c.resolve(), this.handshakeResolvers.delete(t.responseId)
									}
								} catch (m) {
									this.logger.error("Error parsing response from WAM Extension"), this.logger.errorPii("Error parsing response from WAM Extension: " + m.toString()), this.logger.errorPii("Unable to parse " + e), s ? s.reject(m) : c && c.reject(m)
								}
							}, i.prototype.getExtensionId = function() {
								return this.extensionId
							}, i.prototype.getExtensionVersion = function() {
								return this.extensionVersion
							}, i.isNativeAvailable = function(e, t, s, c) {
								if (t.trace("isNativeAvailable called"), !e.system.allowNativeBroker) return t.trace("isNativeAvailable: allowNativeBroker is not enabled, returning false"), !1;
								if (!s) return t.trace("isNativeAvailable: WAM extension provider is not initialized, returning false"), !1;
								if (c) switch (c) {
									case q.hO.BEARER:
									case q.hO.POP:
										return t.trace("isNativeAvailable: authenticationScheme is supported, returning true"), !0;
									default:
										return t.trace("isNativeAvailable: authenticationScheme is not supported, returning false"), !1
								}
								return !0
							}, i
						}(),
						Ou = function() {
							function i(e, t, s, c, u) {
								this.authModule = e, this.browserStorage = t, this.authCodeRequest = s, this.logger = c, this.performanceClient = u
							}
							return i.prototype.handleCodeResponseFromHash = function(e, t, s, c) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var u, h, m;
									return (0, _e.Jh)(this, function(S) {
										if (this.performanceClient.addQueueMeasurement(St.HandleCodeResponseFromHash, this.authCodeRequest.correlationId), this.logger.verbose("InteractionHandler.handleCodeResponse called"), _n.x.isEmpty(e)) throw rn.U.createEmptyHashError(e);
										if (u = this.browserStorage.generateStateKey(t), !(h = this.browserStorage.getTemporaryCache(u))) throw zt.e.createStateNotFoundError("Cached State");
										try {
											m = this.authModule.handleFragmentResponse(e, h)
										} catch (O) {
											throw O instanceof Ir && O.subError === rn.n.userCancelledError.code ? rn.U.createUserCancelledError() : O
										}
										return this.performanceClient.setPreQueueTime(St.HandleCodeResponseFromServer, this.authCodeRequest.correlationId), [2, this.handleCodeResponseFromServer(m, t, s, c)]
									})
								})
							}, i.prototype.handleCodeResponseFromServer = function(e, t, s, c, u) {
								return void 0 === u && (u = !0), (0, _e.mG)(this, void 0, void 0, function() {
									var h, m, S, O, $, le;
									return (0, _e.Jh)(this, function(Re) {
										switch (Re.label) {
											case 0:
												if (this.performanceClient.addQueueMeasurement(St.HandleCodeResponseFromServer, this.authCodeRequest.correlationId), this.logger.trace("InteractionHandler.handleCodeResponseFromServer called"), h = this.browserStorage.generateStateKey(t), !(m = this.browserStorage.getTemporaryCache(h))) throw zt.e.createStateNotFoundError("Cached State");
												return S = this.browserStorage.generateNonceKey(m), O = this.browserStorage.getTemporaryCache(S), this.authCodeRequest.code = e.code, e.cloud_instance_host_name ? (this.performanceClient.setPreQueueTime(St.UpdateTokenEndpointAuthority, this.authCodeRequest.correlationId), [4, this.updateTokenEndpointAuthority(e.cloud_instance_host_name, s, c)]) : [3, 2];
											case 1:
												Re.sent(), Re.label = 2;
											case 2:
												return u && (e.nonce = O || void 0), e.state = m, e.client_info ? this.authCodeRequest.clientInfo = e.client_info : ($ = this.checkCcsCredentials()) && (this.authCodeRequest.ccsCredential = $), this.performanceClient.setPreQueueTime(St.AuthClientAcquireToken, this.authCodeRequest.correlationId), [4, this.authModule.acquireToken(this.authCodeRequest, e)];
											case 3:
												return le = Re.sent(), this.browserStorage.cleanRequestByState(t), [2, le]
										}
									})
								})
							}, i.prototype.updateTokenEndpointAuthority = function(e, t, s) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var u;
									return (0, _e.Jh)(this, function(h) {
										switch (h.label) {
											case 0:
												return this.performanceClient.addQueueMeasurement(St.UpdateTokenEndpointAuthority, this.authCodeRequest.correlationId), [4, kc.createDiscoveredInstance("https://" + e + "/" + t.tenant + "/", s, this.browserStorage, t.options, this.logger, this.performanceClient, this.authCodeRequest.correlationId)];
											case 1:
												return u = h.sent(), this.authModule.updateAuthority(u), [2]
										}
									})
								})
							}, i.prototype.checkCcsCredentials = function() {
								var e = this.browserStorage.getTemporaryCache(Qe.c4.CCS_CREDENTIAL, !0);
								if (e) try {
									return JSON.parse(e)
								} catch {
									this.authModule.logger.error("Cache credential could not be parsed"), this.authModule.logger.errorPii("Cache credential could not be parsed: " + e)
								}
								return null
							}, i
						}(),
						Ni = function(i) {
							function e(t, s, c, u, h, m, S, O, $, le) {
								var Re = i.call(this, t, s, c, u, h, m, S, $, le) || this;
								return Re.unloadWindow = Re.unloadWindow.bind(Re), Re.nativeStorage = O, Re
							}
							return (0, _e.ZT)(e, i), e.prototype.acquireToken = function(t) {
								try {
									var s = this.generatePopupName(t.scopes || q.f_, t.authority || this.config.auth.authority),
										c = t.popupWindowAttributes || {};
									if (this.config.system.asyncPopups) return this.logger.verbose("asyncPopups set to true, acquiring token"), this.acquireTokenPopupAsync(t, s, c);
									this.logger.verbose("asyncPopup set to false, opening popup before acquiring token");
									var u = this.openSizedPopup("about:blank", s, c);
									return this.acquireTokenPopupAsync(t, s, c, u)
								} catch (h) {
									return Promise.reject(h)
								}
							}, e.prototype.logout = function(t) {
								try {
									this.logger.verbose("logoutPopup called");
									var s = this.initializeLogoutRequest(t),
										c = this.generateLogoutPopupName(s),
										u = t && t.authority,
										h = t && t.mainWindowRedirectUri,
										m = t?.popupWindowAttributes || {};
									if (this.config.system.asyncPopups) return this.logger.verbose("asyncPopups set to true"), this.logoutPopupAsync(s, c, m, u, void 0, h);
									this.logger.verbose("asyncPopup set to false, opening popup");
									var S = this.openSizedPopup("about:blank", c, m);
									return this.logoutPopupAsync(s, c, m, u, S, h)
								} catch (O) {
									return Promise.reject(O)
								}
							}, e.prototype.acquireTokenPopupAsync = function(t, s, c, u) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var h, m, S, O, $, le, Re, Ae, wt, Wt, Yt, sn, kn, fr, oi, Jr = this;
									return (0, _e.Jh)(this, function(wr) {
										switch (wr.label) {
											case 0:
												return this.logger.verbose("acquireTokenPopupAsync called"), h = this.initializeServerTelemetryManager(Qe.WN.acquireTokenPopup), this.performanceClient.setPreQueueTime(St.StandardInteractionClientInitializeAuthorizationRequest, t.correlationId), [4, this.initializeAuthorizationRequest(t, Qe.s_.Popup)];
											case 1:
												m = wr.sent(), this.browserStorage.updateCacheEntries(m.state, m.nonce, m.authority, m.loginHint || q.gT.EMPTY_STRING, m.account || null), wr.label = 2;
											case 2:
												return wr.trys.push([2, 8, , 9]), this.performanceClient.setPreQueueTime(St.StandardInteractionClientInitializeAuthorizationCodeRequest, t.correlationId), [4, this.initializeAuthorizationCodeRequest(m)];
											case 3:
												return S = wr.sent(), this.performanceClient.setPreQueueTime(St.StandardInteractionClientCreateAuthCodeClient, t.correlationId), [4, this.createAuthCodeClient(h, m.authority, m.azureCloudOptions)];
											case 4:
												return O = wr.sent(), this.logger.verbose("Auth code client created"), $ = Bs.isNativeAvailable(this.config, this.logger, this.nativeMessageHandler, t.authenticationScheme), le = void 0, $ && (le = this.performanceClient.startMeasurement(St.FetchAccountIdWithNativeBroker, t.correlationId)), [4, O.getAuthCodeUrl((0, _e.pi)((0, _e.pi)({}, m), {
													nativeBroker: $
												}))];
											case 5:
												return Re = wr.sent(), Ae = new Ou(O, this.browserStorage, S, this.logger, this.performanceClient), wt = this.initiateAuthRequest(Re, {
													popup: u,
													popupName: s,
													popupWindowAttributes: c
												}), this.eventHandler.emitEvent(Zt.t.POPUP_OPENED, Qe.s_.Popup, {
													popupWindow: wt
												}, null), [4, this.monitorPopupForHash(wt)];
											case 6:
												if (Wt = wr.sent(), Yt = Xn.G.getDeserializedHash(Wt), sn = this.validateAndExtractStateFromHash(Yt, Qe.s_.Popup, m.correlationId), bu.removeThrottle(this.browserStorage, this.config.auth.clientId, S), Yt.accountId) {
													if (this.logger.verbose("Account id found in hash, calling WAM for token"), le && le.endMeasurement({
															success: !0,
															isNativeBroker: !0
														}), !this.nativeMessageHandler) throw rn.U.createNativeConnectionNotEstablishedError();
													return kn = new Us(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, Qe.WN.acquireTokenPopup, this.performanceClient, this.nativeMessageHandler, Yt.accountId, this.nativeStorage, m.correlationId), fr = gi.parseRequestState(this.browserCrypto, sn).userRequestState, [2, kn.acquireToken((0, _e.pi)((0, _e.pi)({}, m), {
														state: fr,
														prompt: void 0
													})).finally(function() {
														Jr.browserStorage.cleanRequestByState(sn)
													})]
												}
												return [4, Ae.handleCodeResponseFromHash(Wt, sn, O.authority, this.networkClient)];
											case 7:
												return [2, wr.sent()];
											case 8:
												throw oi = wr.sent(), u && u.close(), oi instanceof vn.l && oi.setCorrelationId(this.correlationId), h.cacheFailedRequest(oi), this.browserStorage.cleanRequestByState(m.state), oi;
											case 9:
												return [2]
										}
									})
								})
							}, e.prototype.logoutPopupAsync = function(t, s, c, u, h, m) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var S, O, $, le, Re, Ae, Ze;
									return (0, _e.Jh)(this, function(wt) {
										switch (wt.label) {
											case 0:
												this.logger.verbose("logoutPopupAsync called"), this.eventHandler.emitEvent(Zt.t.LOGOUT_START, Qe.s_.Popup, t), S = this.initializeServerTelemetryManager(Qe.WN.logoutPopup), wt.label = 1;
											case 1:
												return wt.trys.push([1, 5, , 6]), [4, this.clearCacheOnLogout(t.account)];
											case 2:
												return wt.sent(), this.performanceClient.setPreQueueTime(St.StandardInteractionClientCreateAuthCodeClient, t.correlationId), [4, this.createAuthCodeClient(S, u)];
											case 3:
												return O = wt.sent(), this.logger.verbose("Auth code client created"), $ = O.getLogoutUri(t), this.eventHandler.emitEvent(Zt.t.LOGOUT_SUCCESS, Qe.s_.Popup, t), le = this.openPopup($, {
													popupName: s,
													popupWindowAttributes: c,
													popup: h
												}), this.eventHandler.emitEvent(Zt.t.POPUP_OPENED, Qe.s_.Popup, {
													popupWindow: le
												}, null), [4, this.waitForLogoutPopup(le)];
											case 4:
												return wt.sent(), m ? (Re = {
													apiId: Qe.WN.logoutPopup,
													timeout: this.config.system.redirectNavigationTimeout,
													noHistory: !1
												}, Ae = Xn.G.getAbsoluteUrl(m, Mr.M.getCurrentUri()), this.logger.verbose("Redirecting main window to url specified in the request"), this.logger.verbosePii("Redirecting main window to: " + Ae), this.navigationClient.navigateInternal(Ae, Re)) : this.logger.verbose("No main window navigation requested"), [3, 6];
											case 5:
												throw Ze = wt.sent(), h && h.close(), Ze instanceof vn.l && Ze.setCorrelationId(this.correlationId), this.browserStorage.setInteractionInProgress(!1), this.eventHandler.emitEvent(Zt.t.LOGOUT_FAILURE, Qe.s_.Popup, null, Ze), this.eventHandler.emitEvent(Zt.t.LOGOUT_END, Qe.s_.Popup), S.cacheFailedRequest(Ze), Ze;
											case 6:
												return this.eventHandler.emitEvent(Zt.t.LOGOUT_END, Qe.s_.Popup), [2]
										}
									})
								})
							}, e.prototype.initiateAuthRequest = function(t, s) {
								if (_n.x.isEmpty(t)) throw this.logger.error("Navigate url is empty"), rn.U.createEmptyNavigationUriError();
								return this.logger.infoPii("Navigate to: " + t), this.openPopup(t, s)
							}, e.prototype.monitorPopupForHash = function(t) {
								var s = this;
								return new Promise(function(c, u) {
									var h = s.config.system.windowHashTimeout / s.config.system.pollIntervalMilliseconds,
										m = 0;
									s.logger.verbose("PopupHandler.monitorPopupForHash - polling started");
									var S = setInterval(function() {
										if (t.closed) return s.logger.error("PopupHandler.monitorPopupForHash - window closed"), s.cleanPopup(), clearInterval(S), void u(rn.U.createUserCancelledError());
										var O = q.gT.EMPTY_STRING,
											$ = q.gT.EMPTY_STRING;
										try {
											O = t.location.href, $ = t.location.hash
										} catch {}
										_n.x.isEmpty(O) || "about:blank" === O || (s.logger.verbose("PopupHandler.monitorPopupForHash - popup window is on same origin as caller"), m++, $ ? (s.logger.verbose("PopupHandler.monitorPopupForHash - found hash in url"), clearInterval(S), s.cleanPopup(t), Xn.G.hashContainsKnownProperties($) ? (s.logger.verbose("PopupHandler.monitorPopupForHash - hash contains known properties, returning."), c($)) : (s.logger.error("PopupHandler.monitorPopupForHash - found hash in url but it does not contain known properties. Check that your router is not changing the hash prematurely."), s.logger.errorPii("PopupHandler.monitorPopupForHash - hash found: " + $), u(rn.U.createHashDoesNotContainKnownPropertiesError()))) : m > h && (s.logger.error("PopupHandler.monitorPopupForHash - unable to find hash in url, timing out"), clearInterval(S), u(rn.U.createMonitorPopupTimeoutError())))
									}, s.config.system.pollIntervalMilliseconds)
								})
							}, e.prototype.waitForLogoutPopup = function(t) {
								var s = this;
								return new Promise(function(c) {
									s.logger.verbose("PopupHandler.waitForLogoutPopup - polling started");
									var u = setInterval(function() {
										t.closed && (s.logger.error("PopupHandler.waitForLogoutPopup - window closed"), s.cleanPopup(), clearInterval(u), c());
										var h = q.gT.EMPTY_STRING;
										try {
											h = t.location.href
										} catch {}
										_n.x.isEmpty(h) || "about:blank" === h || (s.logger.verbose("PopupHandler.waitForLogoutPopup - popup window is on same origin as caller, closing."), clearInterval(u), s.cleanPopup(t), c())
									}, s.config.system.pollIntervalMilliseconds)
								})
							}, e.prototype.openPopup = function(t, s) {
								try {
									var c = void 0;
									if (s.popup ? (c = s.popup, this.logger.verbosePii("Navigating popup window to: " + t), c.location.assign(t)) : typeof s.popup > "u" && (this.logger.verbosePii("Opening popup window to: " + t), c = this.openSizedPopup(t, s.popupName, s.popupWindowAttributes)), !c) throw rn.U.createEmptyWindowCreatedError();
									return c.focus && c.focus(), this.currentWindow = c, window.addEventListener("beforeunload", this.unloadWindow), c
								} catch (u) {
									throw this.logger.error("error opening popup " + u.message), this.browserStorage.setInteractionInProgress(!1), rn.U.createPopupWindowError(u.toString())
								}
							}, e.prototype.openSizedPopup = function(t, s, c) {
								var u, h, m, S, O = window.screenLeft ? window.screenLeft : window.screenX,
									$ = window.screenTop ? window.screenTop : window.screenY,
									le = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth,
									Re = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight,
									Ae = null === (u = c.popupSize) || void 0 === u ? void 0 : u.width,
									Ze = null === (h = c.popupSize) || void 0 === h ? void 0 : h.height,
									wt = null === (m = c.popupPosition) || void 0 === m ? void 0 : m.top,
									Wt = null === (S = c.popupPosition) || void 0 === S ? void 0 : S.left;
								return (!Ae || Ae < 0 || Ae > le) && (this.logger.verbose("Default popup window width used. Window width not configured or invalid."), Ae = Qe.qx.POPUP_WIDTH), (!Ze || Ze < 0 || Ze > Re) && (this.logger.verbose("Default popup window height used. Window height not configured or invalid."), Ze = Qe.qx.POPUP_HEIGHT), (!wt || wt < 0 || wt > Re) && (this.logger.verbose("Default popup window top position used. Window top not configured or invalid."), wt = Math.max(0, Re / 2 - Qe.qx.POPUP_HEIGHT / 2 + $)), (!Wt || Wt < 0 || Wt > le) && (this.logger.verbose("Default popup window left position used. Window left not configured or invalid."), Wt = Math.max(0, le / 2 - Qe.qx.POPUP_WIDTH / 2 + O)), window.open(t, s, "width=" + Ae + ", height=" + Ze + ", top=" + wt + ", left=" + Wt + ", scrollbars=yes")
							}, e.prototype.unloadWindow = function(t) {
								this.browserStorage.cleanRequestByInteractionType(Qe.s_.Popup), this.currentWindow && this.currentWindow.close(), t.preventDefault()
							}, e.prototype.cleanPopup = function(t) {
								t && t.close(), window.removeEventListener("beforeunload", this.unloadWindow), this.browserStorage.setInteractionInProgress(!1)
							}, e.prototype.generatePopupName = function(t, s) {
								return Qe.qx.POPUP_NAME_PREFIX + "." + this.config.auth.clientId + "." + t.join("-") + "." + s + "." + this.correlationId
							}, e.prototype.generateLogoutPopupName = function(t) {
								return Qe.qx.POPUP_NAME_PREFIX + "." + this.config.auth.clientId + "." + (t.account && t.account.homeAccountId) + "." + this.correlationId
							}, e
						}(Na),
						Sl = function(i) {
							function e(t, s, c, u, h, m) {
								var S = i.call(this, t, s, c, u, m) || this;
								return S.browserCrypto = h, S
							}
							return (0, _e.ZT)(e, i), e.prototype.initiateAuthRequest = function(t, s) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var c;
									return (0, _e.Jh)(this, function(h) {
										switch (h.label) {
											case 0:
												return this.logger.verbose("RedirectHandler.initiateAuthRequest called"), _n.x.isEmpty(t) ? [3, 7] : (s.redirectStartPage && (this.logger.verbose("RedirectHandler.initiateAuthRequest: redirectStartPage set, caching start page"), this.browserStorage.setTemporaryCache(Qe.c4.ORIGIN_URI, s.redirectStartPage, !0)), this.browserStorage.setTemporaryCache(Qe.c4.CORRELATION_ID, this.authCodeRequest.correlationId, !0), this.browserStorage.cacheCodeRequest(this.authCodeRequest, this.browserCrypto), this.logger.infoPii("RedirectHandler.initiateAuthRequest: Navigate to: " + t), c = {
													apiId: Qe.WN.acquireTokenRedirect,
													timeout: s.redirectTimeout,
													noHistory: !1
												}, "function" != typeof s.onRedirectNavigate ? [3, 4] : (this.logger.verbose("RedirectHandler.initiateAuthRequest: Invoking onRedirectNavigate callback"), !1 === s.onRedirectNavigate(t) ? [3, 2] : (this.logger.verbose("RedirectHandler.initiateAuthRequest: onRedirectNavigate did not return false, navigating"), [4, s.navigationClient.navigateExternal(t, c)])));
											case 1:
											case 5:
												return h.sent(), [2];
											case 2:
												return this.logger.verbose("RedirectHandler.initiateAuthRequest: onRedirectNavigate returned false, stopping navigation"), [2];
											case 3:
												return [3, 6];
											case 4:
												return this.logger.verbose("RedirectHandler.initiateAuthRequest: Navigating window to navigate url"), [4, s.navigationClient.navigateExternal(t, c)];
											case 6:
												return [3, 8];
											case 7:
												throw this.logger.info("RedirectHandler.initiateAuthRequest: Navigate url is empty"), rn.U.createEmptyNavigationUriError();
											case 8:
												return [2]
										}
									})
								})
							}, e.prototype.handleCodeResponseFromHash = function(t, s, c, u) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var h, m, S, O, $, le, Re;
									return (0, _e.Jh)(this, function(Ae) {
										switch (Ae.label) {
											case 0:
												if (this.logger.verbose("RedirectHandler.handleCodeResponse called"), _n.x.isEmpty(t)) throw rn.U.createEmptyHashError(t);
												if (this.browserStorage.setInteractionInProgress(!1), h = this.browserStorage.generateStateKey(s), !(m = this.browserStorage.getTemporaryCache(h))) throw zt.e.createStateNotFoundError("Cached State");
												try {
													S = this.authModule.handleFragmentResponse(t, m)
												} catch (Ze) {
													throw Ze instanceof Ir && Ze.subError === rn.n.userCancelledError.code ? rn.U.createUserCancelledError() : Ze
												}
												return O = this.browserStorage.generateNonceKey(m), $ = this.browserStorage.getTemporaryCache(O), this.authCodeRequest.code = S.code, S.cloud_instance_host_name ? [4, this.updateTokenEndpointAuthority(S.cloud_instance_host_name, c, u)] : [3, 2];
											case 1:
												Ae.sent(), Ae.label = 2;
											case 2:
												return S.nonce = $ || void 0, S.state = m, S.client_info ? this.authCodeRequest.clientInfo = S.client_info : (le = this.checkCcsCredentials()) && (this.authCodeRequest.ccsCredential = le), [4, this.authModule.acquireToken(this.authCodeRequest, S)];
											case 3:
												return Re = Ae.sent(), this.browserStorage.cleanRequestByState(s), [2, Re]
										}
									})
								})
							}, e
						}(Ou),
						Th = function(i) {
							function e(t, s, c, u, h, m, S, O, $, le) {
								var Re = i.call(this, t, s, c, u, h, m, S, $, le) || this;
								return Re.nativeStorage = O, Re
							}
							return (0, _e.ZT)(e, i), e.prototype.acquireToken = function(t) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var s, c, u, h, m, S, O, $, le, Re = this;
									return (0, _e.Jh)(this, function(Ae) {
										switch (Ae.label) {
											case 0:
												return this.performanceClient.setPreQueueTime(St.StandardInteractionClientInitializeAuthorizationRequest, t.correlationId), [4, this.initializeAuthorizationRequest(t, Qe.s_.Redirect)];
											case 1:
												s = Ae.sent(), this.browserStorage.updateCacheEntries(s.state, s.nonce, s.authority, s.loginHint || q.gT.EMPTY_STRING, s.account || null), c = this.initializeServerTelemetryManager(Qe.WN.acquireTokenRedirect), u = function(Ze) {
													Ze.persisted && (Re.logger.verbose("Page was restored from back/forward cache. Clearing temporary cache."), Re.browserStorage.cleanRequestByState(s.state))
												}, Ae.label = 2;
											case 2:
												return Ae.trys.push([2, 7, , 8]), this.performanceClient.setPreQueueTime(St.StandardInteractionClientInitializeAuthorizationCodeRequest, t.correlationId), [4, this.initializeAuthorizationCodeRequest(s)];
											case 3:
												return h = Ae.sent(), this.performanceClient.setPreQueueTime(St.StandardInteractionClientCreateAuthCodeClient, t.correlationId), [4, this.createAuthCodeClient(c, s.authority, s.azureCloudOptions)];
											case 4:
												return m = Ae.sent(), this.logger.verbose("Auth code client created"), S = new Sl(m, this.browserStorage, h, this.logger, this.browserCrypto, this.performanceClient), [4, m.getAuthCodeUrl((0, _e.pi)((0, _e.pi)({}, s), {
													nativeBroker: Bs.isNativeAvailable(this.config, this.logger, this.nativeMessageHandler, t.authenticationScheme)
												}))];
											case 5:
												return O = Ae.sent(), $ = this.getRedirectStartPage(t.redirectStartPage), this.logger.verbosePii("Redirect start page: " + $), window.addEventListener("pageshow", u), [4, S.initiateAuthRequest(O, {
													navigationClient: this.navigationClient,
													redirectTimeout: this.config.system.redirectNavigationTimeout,
													redirectStartPage: $,
													onRedirectNavigate: t.onRedirectNavigate
												})];
											case 6:
												return [2, Ae.sent()];
											case 7:
												throw (le = Ae.sent()) instanceof vn.l && le.setCorrelationId(this.correlationId), window.removeEventListener("pageshow", u), c.cacheFailedRequest(le), this.browserStorage.cleanRequestByState(s.state), le;
											case 8:
												return [2]
										}
									})
								})
							}, e.prototype.handleRedirectPromise = function(t) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var s, c, u, h, m, S, O, $, le, Re, Ae, Ze;
									return (0, _e.Jh)(this, function(wt) {
										switch (wt.label) {
											case 0:
												s = this.initializeServerTelemetryManager(Qe.WN.handleRedirectPromise), wt.label = 1;
											case 1:
												if (wt.trys.push([1, 10, , 11]), !this.browserStorage.isInteractionInProgress(!0)) return this.logger.info("handleRedirectPromise called but there is no interaction in progress, returning null."), [2, null];
												if (!(c = this.getRedirectResponseHash(t || window.location.hash))) return this.logger.info("handleRedirectPromise did not detect a response hash as a result of a redirect. Cleaning temporary cache."), this.browserStorage.cleanRequestByInteractionType(Qe.s_.Redirect), [2, null];
												u = void 0;
												try {
													h = Xn.G.getDeserializedHash(c), u = this.validateAndExtractStateFromHash(h, Qe.s_.Redirect), this.logger.verbose("State extracted from hash")
												} catch (Wt) {
													return this.logger.info("handleRedirectPromise was unable to extract state due to: " + Wt), this.browserStorage.cleanRequestByInteractionType(Qe.s_.Redirect), [2, null]
												}
												return m = this.browserStorage.getTemporaryCache(Qe.c4.ORIGIN_URI, !0) || q.gT.EMPTY_STRING, S = Xn.G.removeHashFromUrl(m), O = Xn.G.removeHashFromUrl(window.location.href), S === O && this.config.auth.navigateToLoginRequestUrl ? (this.logger.verbose("Current page is loginRequestUrl, handling hash"), [4, this.handleHash(c, u, s)]) : [3, 3];
											case 2:
												return $ = wt.sent(), m.indexOf("#") > -1 && Mr.M.replaceHash(m), [2, $];
											case 3:
												return this.config.auth.navigateToLoginRequestUrl ? [3, 4] : (this.logger.verbose("NavigateToLoginRequestUrl set to false, handling hash"), [2, this.handleHash(c, u, s)]);
											case 4:
												return !Mr.M.isInIframe() || this.config.system.allowRedirectInIframe ? (this.browserStorage.setTemporaryCache(Qe.c4.URL_HASH, c, !0), le = {
													apiId: Qe.WN.handleRedirectPromise,
													timeout: this.config.system.redirectNavigationTimeout,
													noHistory: !0
												}, Re = !0, m && "null" !== m ? [3, 6] : (Ae = Mr.M.getHomepage(), this.browserStorage.setTemporaryCache(Qe.c4.ORIGIN_URI, Ae, !0), this.logger.warning("Unable to get valid login request url from cache, redirecting to home page"), [4, this.navigationClient.navigateInternal(Ae, le)])) : [3, 9];
											case 5:
												return Re = wt.sent(), [3, 8];
											case 6:
												return this.logger.verbose("Navigating to loginRequestUrl: " + m), [4, this.navigationClient.navigateInternal(m, le)];
											case 7:
												Re = wt.sent(), wt.label = 8;
											case 8:
												if (!Re) return [2, this.handleHash(c, u, s)];
												wt.label = 9;
											case 9:
												return [2, null];
											case 10:
												throw (Ze = wt.sent()) instanceof vn.l && Ze.setCorrelationId(this.correlationId), s.cacheFailedRequest(Ze), this.browserStorage.cleanRequestByInteractionType(Qe.s_.Redirect), Ze;
											case 11:
												return [2]
										}
									})
								})
							}, e.prototype.getRedirectResponseHash = function(t) {
								if (this.logger.verbose("getRedirectResponseHash called"), Xn.G.hashContainsKnownProperties(t)) return Mr.M.clearHash(window), this.logger.verbose("Hash contains known properties, returning response hash"), t;
								var c = this.browserStorage.getTemporaryCache(Qe.c4.URL_HASH, !0);
								return this.browserStorage.removeItem(this.browserStorage.generateCacheKey(Qe.c4.URL_HASH)), this.logger.verbose("Hash does not contain known properties, returning cached hash"), c
							}, e.prototype.handleHash = function(t, s, c) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var u, h, m, S, O, $, Re = this;
									return (0, _e.Jh)(this, function(Ae) {
										switch (Ae.label) {
											case 0:
												if (u = this.browserStorage.getCachedRequest(s, this.browserCrypto), this.logger.verbose("handleHash called, retrieved cached request"), (h = Xn.G.getDeserializedHash(t)).accountId) {
													if (this.logger.verbose("Account id found in hash, calling WAM for token"), !this.nativeMessageHandler) throw rn.U.createNativeConnectionNotEstablishedError();
													return m = new Us(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, Qe.WN.acquireTokenPopup, this.performanceClient, this.nativeMessageHandler, h.accountId, this.browserStorage, u.correlationId), S = gi.parseRequestState(this.browserCrypto, s).userRequestState, [2, m.acquireToken((0, _e.pi)((0, _e.pi)({}, u), {
														state: S,
														prompt: void 0
													})).finally(function() {
														Re.browserStorage.cleanRequestByState(s)
													})]
												}
												if (!(O = this.browserStorage.getCachedAuthority(s))) throw rn.U.createNoCachedAuthorityError();
												return this.performanceClient.setPreQueueTime(St.StandardInteractionClientCreateAuthCodeClient, u.correlationId), [4, this.createAuthCodeClient(c, O)];
											case 1:
												return $ = Ae.sent(), this.logger.verbose("Auth code client created"), bu.removeThrottle(this.browserStorage, this.config.auth.clientId, u), [4, new Sl($, this.browserStorage, u, this.logger, this.browserCrypto, this.performanceClient).handleCodeResponseFromHash(t, s, $.authority, this.networkClient)];
											case 2:
												return [2, Ae.sent()]
										}
									})
								})
							}, e.prototype.logout = function(t) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var s, c, u, h, m, O;
									return (0, _e.Jh)(this, function($) {
										switch ($.label) {
											case 0:
												this.logger.verbose("logoutRedirect called"), s = this.initializeLogoutRequest(t), c = this.initializeServerTelemetryManager(Qe.WN.logout), $.label = 1;
											case 1:
												return $.trys.push([1, 10, , 11]), this.eventHandler.emitEvent(Zt.t.LOGOUT_START, Qe.s_.Redirect, t), [4, this.clearCacheOnLogout(s.account)];
											case 2:
												return $.sent(), u = {
													apiId: Qe.WN.logout,
													timeout: this.config.system.redirectNavigationTimeout,
													noHistory: !1
												}, this.performanceClient.setPreQueueTime(St.StandardInteractionClientCreateAuthCodeClient, s.correlationId), [4, this.createAuthCodeClient(c, t && t.authority)];
											case 3:
												return h = $.sent(), this.logger.verbose("Auth code client created"), m = h.getLogoutUri(s), this.eventHandler.emitEvent(Zt.t.LOGOUT_SUCCESS, Qe.s_.Redirect, s), t && "function" == typeof t.onRedirectNavigate ? !1 === t.onRedirectNavigate(m) ? [3, 5] : (this.logger.verbose("Logout onRedirectNavigate did not return false, navigating"), this.browserStorage.getInteractionInProgress() || this.browserStorage.setInteractionInProgress(!0), [4, this.navigationClient.navigateExternal(m, u)]) : [3, 7];
											case 4:
												return $.sent(), [2];
											case 5:
												this.browserStorage.setInteractionInProgress(!1), this.logger.verbose("Logout onRedirectNavigate returned false, stopping navigation"), $.label = 6;
											case 6:
												return [3, 9];
											case 7:
												return this.browserStorage.getInteractionInProgress() || this.browserStorage.setInteractionInProgress(!0), [4, this.navigationClient.navigateExternal(m, u)];
											case 8:
												return $.sent(), [2];
											case 9:
												return [3, 11];
											case 10:
												throw (O = $.sent()) instanceof vn.l && O.setCorrelationId(this.correlationId), c.cacheFailedRequest(O), this.eventHandler.emitEvent(Zt.t.LOGOUT_FAILURE, Qe.s_.Redirect, null, O), this.eventHandler.emitEvent(Zt.t.LOGOUT_END, Qe.s_.Redirect), O;
											case 11:
												return this.eventHandler.emitEvent(Zt.t.LOGOUT_END, Qe.s_.Redirect), [2]
										}
									})
								})
							}, e.prototype.getRedirectStartPage = function(t) {
								var s = t || window.location.href;
								return Xn.G.getAbsoluteUrl(s, Mr.M.getCurrentUri())
							}, e
						}(Na),
						Tl = function(i) {
							function e(t, s, c, u, h, m) {
								var S = i.call(this, t, s, c, u, m) || this;
								return S.navigateFrameWait = h.navigateFrameWait, S.pollIntervalMilliseconds = h.pollIntervalMilliseconds, S
							}
							return (0, _e.ZT)(e, i), e.prototype.initiateAuthRequest = function(t) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(s) {
										switch (s.label) {
											case 0:
												if (this.performanceClient.addQueueMeasurement(St.SilentHandlerInitiateAuthRequest, this.authCodeRequest.correlationId), _n.x.isEmpty(t)) throw this.logger.info("Navigate url is empty"), rn.U.createEmptyNavigationUriError();
												return this.navigateFrameWait ? (this.performanceClient.setPreQueueTime(St.SilentHandlerLoadFrame, this.authCodeRequest.correlationId), [4, this.loadFrame(t)]) : [3, 2];
											case 1:
												return [2, s.sent()];
											case 2:
												return [2, this.loadFrameSync(t)]
										}
									})
								})
							}, e.prototype.monitorIframeForHash = function(t, s) {
								var c = this;
								return this.performanceClient.addQueueMeasurement(St.SilentHandlerMonitorIframeForHash, this.authCodeRequest.correlationId), new Promise(function(u, h) {
									s < wu && c.logger.warning("system.loadFrameTimeout or system.iframeHashTimeout set to lower (" + s + "ms) than the default (" + wu + "ms). This may result in timeouts.");
									var S = window.performance.now() + s,
										O = setInterval(function() {
											if (window.performance.now() > S) return c.removeHiddenIframe(t), clearInterval(O), void h(rn.U.createMonitorIframeTimeoutError());
											var $ = q.gT.EMPTY_STRING,
												le = t.contentWindow;
											try {
												$ = le ? le.location.href : q.gT.EMPTY_STRING
											} catch {}
											if (!_n.x.isEmpty($)) {
												var Re = le ? le.location.hash : q.gT.EMPTY_STRING;
												if (Xn.G.hashContainsKnownProperties(Re)) return c.removeHiddenIframe(t), clearInterval(O), void u(Re)
											}
										}, c.pollIntervalMilliseconds)
								})
							}, e.prototype.loadFrame = function(t) {
								var s = this;
								return this.performanceClient.addQueueMeasurement(St.SilentHandlerLoadFrame, this.authCodeRequest.correlationId), new Promise(function(c, u) {
									var h = s.createHiddenIframe();
									setTimeout(function() {
										h ? (h.src = t, c(h)) : u("Unable to load iframe")
									}, s.navigateFrameWait)
								})
							}, e.prototype.loadFrameSync = function(t) {
								var s = this.createHiddenIframe();
								return s.src = t, s
							}, e.prototype.createHiddenIframe = function() {
								var t = document.createElement("iframe");
								return t.style.visibility = "hidden", t.style.position = "absolute", t.style.width = t.style.height = "0", t.style.border = "0", t.setAttribute("sandbox", "allow-scripts allow-same-origin allow-forms"), document.getElementsByTagName("body")[0].appendChild(t), t
							}, e.prototype.removeHiddenIframe = function(t) {
								document.body === t.parentNode && document.body.removeChild(t)
							}, e
						}(Ou),
						Ei = function(i) {
							function e(t, s, c, u, h, m, S, O, $, le, Re) {
								var Ae = i.call(this, t, s, c, u, h, m, O, le, Re) || this;
								return Ae.apiId = S, Ae.nativeStorage = $, Ae
							}
							return (0, _e.ZT)(e, i), e.prototype.acquireToken = function(t) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var s, c, u, h, m;
									return (0, _e.Jh)(this, function(S) {
										switch (S.label) {
											case 0:
												if (this.performanceClient.addQueueMeasurement(St.SilentIframeClientAcquireToken, t.correlationId), this.logger.verbose("acquireTokenByIframe called"), s = this.performanceClient.startMeasurement(St.SilentIframeClientAcquireToken, t.correlationId), _n.x.isEmpty(t.loginHint) && _n.x.isEmpty(t.sid) && (!t.account || _n.x.isEmpty(t.account.username)) && this.logger.warning("No user hint provided. The authorization server may need more information to complete this request."), t.prompt && t.prompt !== q.NJ.NONE && t.prompt !== q.NJ.NO_SESSION) throw s.endMeasurement({
													success: !1
												}), rn.U.createSilentPromptValueError(t.prompt);
												return this.performanceClient.setPreQueueTime(St.StandardInteractionClientInitializeAuthorizationRequest, t.correlationId), [4, this.initializeAuthorizationRequest((0, _e.pi)((0, _e.pi)({}, t), {
													prompt: t.prompt || q.NJ.NONE
												}), Qe.s_.Silent)];
											case 1:
												c = S.sent(), this.browserStorage.updateCacheEntries(c.state, c.nonce, c.authority, c.loginHint || q.gT.EMPTY_STRING, c.account || null), u = this.initializeServerTelemetryManager(this.apiId), S.label = 2;
											case 2:
												return S.trys.push([2, 5, , 6]), this.performanceClient.setPreQueueTime(St.StandardInteractionClientCreateAuthCodeClient, t.correlationId), [4, this.createAuthCodeClient(u, c.authority, c.azureCloudOptions)];
											case 3:
												return h = S.sent(), this.logger.verbose("Auth code client created"), this.performanceClient.setPreQueueTime(St.SilentIframeClientTokenHelper, t.correlationId), [4, this.silentTokenHelper(h, c).then(function(O) {
													return s.endMeasurement({
														success: !0,
														fromCache: !1,
														requestId: O.requestId
													}), O
												})];
											case 4:
												return [2, S.sent()];
											case 5:
												throw (m = S.sent()) instanceof vn.l && m.setCorrelationId(this.correlationId), u.cacheFailedRequest(m), this.browserStorage.cleanRequestByState(c.state), s.endMeasurement({
													errorCode: m instanceof vn.l && m.errorCode || void 0,
													subErrorCode: m instanceof vn.l && m.subError || void 0,
													success: !1
												}), m;
											case 6:
												return [2]
										}
									})
								})
							}, e.prototype.logout = function() {
								return Promise.reject(rn.U.createSilentLogoutUnsupportedError())
							}, e.prototype.silentTokenHelper = function(t, s) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var c, u, h, m, S, O, $, le, Re, Ae = this;
									return (0, _e.Jh)(this, function(Ze) {
										switch (Ze.label) {
											case 0:
												return this.performanceClient.addQueueMeasurement(St.SilentIframeClientTokenHelper, s.correlationId), this.performanceClient.setPreQueueTime(St.StandardInteractionClientInitializeAuthorizationCodeRequest, s.correlationId), [4, this.initializeAuthorizationCodeRequest(s)];
											case 1:
												return c = Ze.sent(), this.performanceClient.setPreQueueTime(St.GetAuthCodeUrl, s.correlationId), [4, t.getAuthCodeUrl((0, _e.pi)((0, _e.pi)({}, s), {
													nativeBroker: Bs.isNativeAvailable(this.config, this.logger, this.nativeMessageHandler, s.authenticationScheme)
												}))];
											case 2:
												return u = Ze.sent(), h = new Tl(t, this.browserStorage, c, this.logger, this.config.system, this.performanceClient), this.performanceClient.setPreQueueTime(St.SilentHandlerInitiateAuthRequest, s.correlationId), [4, h.initiateAuthRequest(u)];
											case 3:
												return m = Ze.sent(), this.performanceClient.setPreQueueTime(St.SilentHandlerMonitorIframeForHash, s.correlationId), [4, h.monitorIframeForHash(m, this.config.system.iframeHashTimeout)];
											case 4:
												if (S = Ze.sent(), O = Xn.G.getDeserializedHash(S), $ = this.validateAndExtractStateFromHash(O, Qe.s_.Silent, c.correlationId), O.accountId) {
													if (this.logger.verbose("Account id found in hash, calling WAM for token"), !this.nativeMessageHandler) throw rn.U.createNativeConnectionNotEstablishedError();
													return le = new Us(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.apiId, this.performanceClient, this.nativeMessageHandler, O.accountId, this.browserStorage, this.correlationId), Re = gi.parseRequestState(this.browserCrypto, $).userRequestState, [2, le.acquireToken((0, _e.pi)((0, _e.pi)({}, s), {
														state: Re,
														prompt: s.prompt || q.NJ.NONE
													})).finally(function() {
														Ae.browserStorage.cleanRequestByState($)
													})]
												}
												return this.performanceClient.setPreQueueTime(St.HandleCodeResponseFromHash, s.correlationId), [2, h.handleCodeResponseFromHash(S, $, t.authority, this.networkClient)]
										}
									})
								})
							}, e
						}(Na),
						xc = function(i) {
							function e() {
								return null !== i && i.apply(this, arguments) || this
							}
							return (0, _e.ZT)(e, i), e.prototype.acquireToken = function(t) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var s, c, u, h, m, S = this;
									return (0, _e.Jh)(this, function(O) {
										switch (O.label) {
											case 0:
												return this.performanceClient.addQueueMeasurement(St.SilentRefreshClientAcquireToken, t.correlationId), this.performanceClient.setPreQueueTime(St.InitializeBaseRequest, t.correlationId), c = [(0, _e.pi)({}, t)], [4, this.initializeBaseRequest(t)];
											case 1:
												return s = _e.pi.apply(void 0, c.concat([O.sent()])), u = this.performanceClient.startMeasurement(St.SilentRefreshClientAcquireToken, s.correlationId), h = this.initializeServerTelemetryManager(Qe.WN.acquireTokenSilent_silentFlow), [4, this.createRefreshTokenClient(h, s.authority, s.azureCloudOptions)];
											case 2:
												return m = O.sent(), this.logger.verbose("Refresh token client created"), this.performanceClient.setPreQueueTime(St.RefreshTokenClientAcquireTokenByRefreshToken, t.correlationId), [2, m.acquireTokenByRefreshToken(s).then(function($) {
													return u.endMeasurement({
														success: !0,
														fromCache: $.fromCache,
														requestId: $.requestId
													}), $
												}).catch(function($) {
													throw $ instanceof vn.l && $.setCorrelationId(S.correlationId), h.cacheFailedRequest($), u.endMeasurement({
														errorCode: $.errorCode,
														subErrorCode: $.subError,
														success: !1
													}), $
												})]
										}
									})
								})
							}, e.prototype.logout = function() {
								return Promise.reject(rn.U.createSilentLogoutUnsupportedError())
							}, e.prototype.createRefreshTokenClient = function(t, s, c) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var u;
									return (0, _e.Jh)(this, function(h) {
										switch (h.label) {
											case 0:
												return this.performanceClient.setPreQueueTime(St.StandardInteractionClientGetClientConfiguration, this.correlationId), [4, this.getClientConfiguration(t, s, c)];
											case 1:
												return u = h.sent(), [2, new Ch(u, this.performanceClient)]
										}
									})
								})
							}, e
						}(Na),
						wh = function() {
							function i(e, t, s, c) {
								this.isBrowserEnvironment = typeof window < "u", this.config = e, this.storage = t, this.logger = s, this.cryptoObj = c
							}
							return i.prototype.loadExternalTokens = function(e, t, s) {
								if (this.logger.info("TokenCache - loadExternalTokens called"), !t.id_token) throw rn.U.createUnableToLoadTokenError("Please ensure server response includes id token.");
								var u, h, c = new x(t.id_token, this.cryptoObj);
								if (e.account) {
									var m = this.loadAccount(c, e.account.environment, void 0, void 0, e.account.homeAccountId);
									u = new Pa(m, this.loadIdToken(c, m.homeAccountId, e.account.environment, e.account.tenantId), this.loadAccessToken(e, t, m.homeAccountId, e.account.environment, e.account.tenantId, s), this.loadRefreshToken(e, t, m.homeAccountId, e.account.environment))
								} else {
									if (!e.authority) throw rn.U.createUnableToLoadTokenError("Please provide a request with an account or a request with authority.");
									var S = Nc.generateAuthority(e.authority, e.azureCloudOptions);
									if (h = new Nc(S, this.config.system.networkClient, this.storage, {
											protocolMode: this.config.auth.protocolMode,
											knownAuthorities: this.config.auth.knownAuthorities,
											cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,
											authorityMetadata: this.config.auth.authorityMetadata,
											skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache
										}, this.logger), s.clientInfo) this.logger.trace("TokenCache - homeAccountId from options"), m = this.loadAccount(c, h.hostnameAndPort, s.clientInfo, h.authorityType), u = new Pa(m, this.loadIdToken(c, m.homeAccountId, h.hostnameAndPort, h.tenant), this.loadAccessToken(e, t, m.homeAccountId, h.hostnameAndPort, h.tenant, s), this.loadRefreshToken(e, t, m.homeAccountId, h.hostnameAndPort));
									else {
										if (!t.client_info) throw rn.U.createUnableToLoadTokenError("Please provide clientInfo in the response or options.");
										this.logger.trace("TokenCache - homeAccountId from response"), m = this.loadAccount(c, h.hostnameAndPort, t.client_info, h.authorityType), u = new Pa(m, this.loadIdToken(c, m.homeAccountId, h.hostnameAndPort, h.tenant), this.loadAccessToken(e, t, m.homeAccountId, h.hostnameAndPort, h.tenant, s), this.loadRefreshToken(e, t, m.homeAccountId, h.hostnameAndPort))
									}
								}
								return this.generateAuthenticationResult(e, c, u, h)
							}, i.prototype.loadAccount = function(e, t, s, c, u) {
								var h;
								if (u ? h = u : void 0 !== c && s && (h = v.generateHomeAccountId(s, c, this.logger, this.cryptoObj, e)), !h) throw rn.U.createUnableToLoadTokenError("Unexpected missing homeAccountId");
								var m = s ? v.createAccount(s, h, e, void 0, void 0, void 0, t) : v.createGenericAccount(h, e, void 0, void 0, void 0, t);
								if (this.isBrowserEnvironment) return this.logger.verbose("TokenCache - loading account"), this.storage.setAccount(m), m;
								throw rn.U.createUnableToLoadTokenError("loadExternalTokens is designed to work in browser environments only.")
							}, i.prototype.loadIdToken = function(e, t, s, c) {
								var u = We.createIdTokenEntity(t, s, e.rawToken, this.config.auth.clientId, c);
								if (this.isBrowserEnvironment) return this.logger.verbose("TokenCache - loading id token"), this.storage.setIdTokenCredential(u), u;
								throw rn.U.createUnableToLoadTokenError("loadExternalTokens is designed to work in browser environments only.")
							}, i.prototype.loadAccessToken = function(e, t, s, c, u, h) {
								if (!t.access_token) return this.logger.verbose("TokenCache - No access token provided for caching"), null;
								if (!t.expires_in) throw rn.U.createUnableToLoadTokenError("Please ensure server response includes expires_in value.");
								if (!h.extendedExpiresOn) throw rn.U.createUnableToLoadTokenError("Please provide an extendedExpiresOn value in the options.");
								var m = new b(e.scopes).printScopes(),
									S = h.expiresOn || t.expires_in + (new Date).getTime() / 1e3,
									$ = Kt.createAccessTokenEntity(s, c, t.access_token, this.config.auth.clientId, u, m, S, h.extendedExpiresOn, this.cryptoObj);
								if (this.isBrowserEnvironment) return this.logger.verbose("TokenCache - loading access token"), this.storage.setAccessTokenCredential($), $;
								throw rn.U.createUnableToLoadTokenError("loadExternalTokens is designed to work in browser environments only.")
							}, i.prototype.loadRefreshToken = function(e, t, s, c) {
								if (!t.refresh_token) return this.logger.verbose("TokenCache - No refresh token provided for caching"), null;
								var u = on.createRefreshTokenEntity(s, c, t.refresh_token, this.config.auth.clientId);
								if (this.isBrowserEnvironment) return this.logger.verbose("TokenCache - loading refresh token"), this.storage.setRefreshTokenCredential(u), u;
								throw rn.U.createUnableToLoadTokenError("loadExternalTokens is designed to work in browser environments only.")
							}, i.prototype.generateAuthenticationResult = function(e, t, s, c) {
								var u, h, m, le, S = q.gT.EMPTY_STRING,
									O = [],
									$ = null;
								return s?.accessToken && (S = s.accessToken.secret, O = b.fromString(s.accessToken.target).asArray(), $ = new Date(1e3 * Number(s.accessToken.expiresOn)), le = new Date(1e3 * Number(s.accessToken.extendedExpiresOn))), {
									authority: c ? c.canonicalAuthority : q.gT.EMPTY_STRING,
									uniqueId: t?.claims.oid || t?.claims.sub || q.gT.EMPTY_STRING,
									tenantId: t?.claims.tid || q.gT.EMPTY_STRING,
									scopes: O,
									account: s?.account ? s.account.getAccountInfo() : null,
									idToken: t ? t.rawToken : q.gT.EMPTY_STRING,
									idTokenClaims: t ? t.claims : {},
									accessToken: S,
									fromCache: !0,
									expiresOn: $,
									correlationId: e.correlationId || q.gT.EMPTY_STRING,
									requestId: q.gT.EMPTY_STRING,
									extExpiresOn: le,
									familyId: q.gT.EMPTY_STRING,
									tokenType: (null === (u = s?.accessToken) || void 0 === u ? void 0 : u.tokenType) || q.gT.EMPTY_STRING,
									state: q.gT.EMPTY_STRING,
									cloudGraphHostName: (null === (h = s?.account) || void 0 === h ? void 0 : h.cloudGraphHostName) || q.gT.EMPTY_STRING,
									msGraphHost: (null === (m = s?.account) || void 0 === m ? void 0 : m.msGraphHost) || q.gT.EMPTY_STRING,
									code: void 0,
									fromNativeBroker: !1
								}
							}, i
						}(),
						bh = function(i) {
							function e(t) {
								var s = i.call(this, t) || this;
								return s.includeRedirectUri = !1, s
							}
							return (0, _e.ZT)(e, i), e
						}(Bp),
						Vp = function(i) {
							function e(t, s, c, u, h, m, S, O, $, le) {
								var Re = i.call(this, t, s, c, u, h, m, O, $, le) || this;
								return Re.apiId = S, Re
							}
							return (0, _e.ZT)(e, i), e.prototype.acquireToken = function(t) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var s, c, u, h, m, O;
									return (0, _e.Jh)(this, function($) {
										switch ($.label) {
											case 0:
												if (this.logger.trace("SilentAuthCodeClient.acquireToken called"), !t.code) throw rn.U.createAuthCodeRequiredError();
												return this.performanceClient.setPreQueueTime(St.StandardInteractionClientInitializeAuthorizationRequest, t.correlationId), [4, this.initializeAuthorizationRequest(t, Qe.s_.Silent)];
											case 1:
												s = $.sent(), this.browserStorage.updateCacheEntries(s.state, s.nonce, s.authority, s.loginHint || q.gT.EMPTY_STRING, s.account || null), c = this.initializeServerTelemetryManager(this.apiId), $.label = 2;
											case 2:
												return $.trys.push([2, 4, , 5]), u = (0, _e.pi)((0, _e.pi)({}, s), {
													code: t.code
												}), this.performanceClient.setPreQueueTime(St.StandardInteractionClientGetClientConfiguration, t.correlationId), [4, this.getClientConfiguration(c, s.authority)];
											case 3:
												return h = $.sent(), m = new bh(h), this.logger.verbose("Auth code client created"), [2, new Tl(m, this.browserStorage, u, this.logger, this.config.system, this.performanceClient).handleCodeResponseFromServer({
													code: t.code,
													msgraph_host: t.msGraphHost,
													cloud_graph_host_name: t.cloudGraphHostName,
													cloud_instance_host_name: t.cloudInstanceHostName
												}, s.state, m.authority, this.networkClient, !1)];
											case 4:
												throw (O = $.sent()) instanceof vn.l && O.setCorrelationId(this.correlationId), c.cacheFailedRequest(O), this.browserStorage.cleanRequestByState(s.state), O;
											case 5:
												return [2]
										}
									})
								})
							}, e.prototype.logout = function() {
								return Promise.reject(rn.U.createSilentLogoutUnsupportedError())
							}, e
						}(Na),
						Pu = function() {
							function i(e, t) {
								this.correlationId = t, this.measureName = i.makeMeasureName(e, t), this.startMark = i.makeStartMark(e, t), this.endMark = i.makeEndMark(e, t)
							}
							return i.makeMeasureName = function(e, t) {
								return "msal.measure." + e + "." + t
							}, i.makeStartMark = function(e, t) {
								return "msal.start." + e + "." + t
							}, i.makeEndMark = function(e, t) {
								return "msal.end." + e + "." + t
							}, i.supportsBrowserPerformance = function() {
								return typeof window < "u" && typeof window.performance < "u" && "function" == typeof window.performance.mark && "function" == typeof window.performance.measure && "function" == typeof window.performance.clearMarks && "function" == typeof window.performance.clearMeasures && "function" == typeof window.performance.getEntriesByName
							}, i.flushMeasurements = function(e, t) {
								if (i.supportsBrowserPerformance()) try {
									t.forEach(function(s) {
										var c = i.makeMeasureName(s.name, e);
										window.performance.getEntriesByName(c, "measure").length > 0 && (window.performance.clearMeasures(c), window.performance.clearMarks(i.makeStartMark(c, e)), window.performance.clearMarks(i.makeEndMark(c, e)))
									})
								} catch {}
							}, i.prototype.startMeasurement = function() {
								if (i.supportsBrowserPerformance()) try {
									window.performance.mark(this.startMark)
								} catch {}
							}, i.prototype.endMeasurement = function() {
								if (i.supportsBrowserPerformance()) try {
									window.performance.mark(this.endMark), window.performance.measure(this.measureName, this.startMark, this.endMark)
								} catch {}
							}, i.prototype.flushMeasurement = function() {
								if (i.supportsBrowserPerformance()) try {
									var e = window.performance.getEntriesByName(this.measureName, "measure");
									if (e.length > 0) {
										var t = e[0].duration;
										return window.performance.clearMeasures(this.measureName), window.performance.clearMarks(this.startMark), window.performance.clearMarks(this.endMark), t
									}
								} catch {}
								return null
							}, i
						}(),
						$p = function(i) {
							function e(t, s, c, u, h, m, S) {
								var O = i.call(this, t, s, c, u, h, m) || this;
								return O.browserCrypto = new wo(O.logger, S), O.guidGenerator = new Tc(O.browserCrypto), O
							}
							return (0, _e.ZT)(e, i), e.prototype.startPerformanceMeasuremeant = function(t, s) {
								return new Pu(t, s)
							}, e.prototype.generateId = function() {
								return this.guidGenerator.generateGuid()
							}, e.prototype.getPageVisibility = function() {
								var t;
								return (null === (t = document.visibilityState) || void 0 === t ? void 0 : t.toString()) || null
							}, e.prototype.deleteIncompleteSubMeasurements = function(t) {
								var s = this.eventsByCorrelationId.get(t.event.correlationId),
									u = [];
								s && s.eventId === t.event.eventId && s?.incompleteSubMeasurements && s.incompleteSubMeasurements.forEach(function(h) {
									u.push((0, _e.pi)({}, h))
								}), u.length > 0 && Pu.flushMeasurements(t.event.correlationId, u)
							}, e.prototype.supportsBrowserPerformanceNow = function() {
								return typeof window < "u" && typeof window.performance < "u" && "function" == typeof window.performance.now
							}, e.prototype.startMeasurement = function(t, s) {
								var c = this,
									u = this.getPageVisibility(),
									h = i.prototype.startMeasurement.call(this, t, s);
								return (0, _e.pi)((0, _e.pi)({}, h), {
									endMeasurement: function(m) {
										var S = h.endMeasurement((0, _e.pi)({
											startPageVisibility: u,
											endPageVisibility: c.getPageVisibility()
										}, m));
										return c.deleteIncompleteSubMeasurements(h), S
									},
									discardMeasurement: function() {
										h.discardMeasurement(), c.deleteIncompleteSubMeasurements(h), h.measurement.flushMeasurement()
									}
								})
							}, e.prototype.setPreQueueTime = function(t, s) {
								if (this.supportsBrowserPerformanceNow())
									if (s) {
										var c = this.preQueueTimeByCorrelationId.get(s);
										c && (this.logger.trace("BrowserPerformanceClient: Incomplete pre-queue " + c.name + " found", s), this.addQueueMeasurement(c.name, s, void 0, !0)), this.preQueueTimeByCorrelationId.set(t, {
											name: t,
											time: window.performance.now()
										})
									} else this.logger.trace("BrowserPerformanceClient: correlationId for " + t + " not provided, unable to set telemetry queue time");
								else this.logger.trace("BrowserPerformanceClient: window performance API not available, unable to set telemetry queue time for " + t)
							}, e.prototype.addQueueMeasurement = function(t, s, c, u) {
								if (this.supportsBrowserPerformanceNow())
									if (s) {
										var h = i.prototype.getPreQueueTime.call(this, t, s);
										if (h) {
											var m = window.performance.now(),
												S = c || i.prototype.calculateQueuedTime.call(this, h, m);
											return i.prototype.addQueueMeasurement.call(this, t, s, S, u)
										}
									} else this.logger.trace("BrowserPerformanceClient: correlationId for " + t + " not provided, unable to add queue measurement");
								else this.logger.trace("BrowserPerformanceClient: window performance API not available, unable to add queue measurement for " + t)
							}, e
						}(Cu),
						zp = function(i) {
							function e(t) {
								var s = i.call(this, t) || this;
								return s.astsAsyncMeasurement = void 0, s.activeSilentTokenRequests = new Map, s.trackPageVisibility = s.trackPageVisibility.bind(s), s
							}
							return (0, _e.ZT)(e, i), e.prototype.loginRedirect = function(t) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var s;
									return (0, _e.Jh)(this, function(c) {
										return s = this.getRequestCorrelationId(t), this.logger.verbose("loginRedirect called", s), [2, this.acquireTokenRedirect((0, _e.pi)({
											correlationId: s
										}, t || Qe.yo))]
									})
								})
							}, e.prototype.loginPopup = function(t) {
								var s = this.getRequestCorrelationId(t);
								return this.logger.verbose("loginPopup called", s), this.acquireTokenPopup((0, _e.pi)({
									correlationId: s
								}, t || Qe.yo))
							}, e.prototype.acquireTokenSilent = function(t) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var s, c, u, m, S, O, $ = this;
									return (0, _e.Jh)(this, function(le) {
										if (s = this.getRequestCorrelationId(t), (c = this.performanceClient.startMeasurement(St.AcquireTokenSilent, s)).addStaticFields({
												cacheLookupPolicy: t.cacheLookupPolicy
											}), this.preflightBrowserEnvironmentCheck(Qe.s_.Silent), this.logger.verbose("acquireTokenSilent called", s), !(u = t.account || this.getActiveAccount())) throw rn.U.createNoAccountError();
										return m = JSON.stringify({
											clientId: this.config.auth.clientId,
											authority: t.authority || q.gT.EMPTY_STRING,
											scopes: t.scopes,
											homeAccountIdentifier: u.homeAccountId,
											claims: t.claims,
											authenticationScheme: t.authenticationScheme,
											resourceRequestMethod: t.resourceRequestMethod,
											resourceRequestUri: t.resourceRequestUri,
											shrClaims: t.shrClaims,
											sshKid: t.sshKid
										}), typeof(S = this.activeSilentTokenRequests.get(m)) > "u" ? (this.logger.verbose("acquireTokenSilent called for the first time, storing active request", s), this.performanceClient.setPreQueueTime(St.AcquireTokenSilentAsync, s), O = this.acquireTokenSilentAsync((0, _e.pi)((0, _e.pi)({}, t), {
											correlationId: s
										}), u).then(function(Re) {
											return $.activeSilentTokenRequests.delete(m), c.addStaticFields({
												accessTokenSize: Re.accessToken.length,
												idTokenSize: Re.idToken.length
											}), c.endMeasurement({
												success: !0,
												fromCache: Re.fromCache,
												isNativeBroker: Re.fromNativeBroker,
												cacheLookupPolicy: t.cacheLookupPolicy,
												requestId: Re.requestId
											}), Re
										}).catch(function(Re) {
											throw $.activeSilentTokenRequests.delete(m), c.endMeasurement({
												errorCode: Re.errorCode,
												subErrorCode: Re.subError,
												success: !1
											}), Re
										}), this.activeSilentTokenRequests.set(m, O), [2, O]) : (this.logger.verbose("acquireTokenSilent has been called previously, returning the result from the first call", s), c.discardMeasurement(), [2, S])
									})
								})
							}, e.prototype.trackPageVisibility = function() {
								this.astsAsyncMeasurement && (this.logger.info("Perf: Visibility change detected"), this.astsAsyncMeasurement.increment({
									visibilityChangeCount: 1
								}))
							}, e.prototype.acquireTokenSilentAsync = function(t, s) {
								var c;
								return (0, _e.mG)(this, void 0, void 0, function() {
									var u, h, m, S, O, $ = this;
									return (0, _e.Jh)(this, function(le) {
										switch (le.label) {
											case 0:
												return this.performanceClient.addQueueMeasurement(St.AcquireTokenSilentAsync, t.correlationId), this.eventHandler.emitEvent(Zt.t.ACQUIRE_TOKEN_START, Qe.s_.Silent, t), this.astsAsyncMeasurement = this.performanceClient.startMeasurement(St.AcquireTokenSilentAsync, t.correlationId), null === (c = this.astsAsyncMeasurement) || void 0 === c || c.increment({
													visibilityChangeCount: 0
												}), document.addEventListener("visibilitychange", this.trackPageVisibility), Bs.isNativeAvailable(this.config, this.logger, this.nativeExtensionProvider, t.authenticationScheme) && s.nativeAccountId ? (this.logger.verbose("acquireTokenSilent - attempting to acquire token from native platform"), h = (0, _e.pi)((0, _e.pi)({}, t), {
													account: s
												}), u = this.acquireTokenNative(h, Qe.WN.acquireTokenSilent_silentFlow).catch(function(Re) {
													return (0, _e.mG)($, void 0, void 0, function() {
														return (0, _e.Jh)(this, function(Ze) {
															if (Re instanceof ji && Re.isFatal()) return this.logger.verbose("acquireTokenSilent - native platform unavailable, falling back to web flow"), this.nativeExtensionProvider = void 0, [2, this.createSilentIframeClient(t.correlationId).acquireToken(t)];
															throw Re
														})
													})
												}), [3, 3]) : [3, 1];
											case 1:
												return this.logger.verbose("acquireTokenSilent - attempting to acquire token from web flow"), m = this.createSilentCacheClient(t.correlationId), this.performanceClient.setPreQueueTime(St.InitializeSilentRequest, t.correlationId), [4, m.initializeSilentRequest(t, s)];
											case 2:
												S = le.sent(), O = (0, _e.pi)((0, _e.pi)({}, t), {
													cacheLookupPolicy: t.cacheLookupPolicy || Qe.lu.Default
												}), this.performanceClient.setPreQueueTime(St.AcquireTokenFromCache, S.correlationId), u = this.acquireTokenFromCache(m, S, O).catch(function(Re) {
													if (O.cacheLookupPolicy === Qe.lu.AccessToken) throw Re;
													return Mr.M.blockReloadInHiddenIframes(), $.eventHandler.emitEvent(Zt.t.ACQUIRE_TOKEN_NETWORK_START, Qe.s_.Silent, S), $.performanceClient.setPreQueueTime(St.AcquireTokenByRefreshToken, S.correlationId), $.acquireTokenByRefreshToken(S, O).catch(function(Ae) {
														if ((!(Ae instanceof Ir) || Ae.errorCode !== Qe.qx.INVALID_GRANT_ERROR || Ae instanceof Oi || O.cacheLookupPolicy === Qe.lu.AccessTokenAndRefreshToken || O.cacheLookupPolicy === Qe.lu.RefreshToken) && O.cacheLookupPolicy !== Qe.lu.Skip) throw Ae;
														return $.logger.verbose("Refresh token expired/invalid or CacheLookupPolicy is set to Skip, attempting acquire token by iframe.", t.correlationId), $.performanceClient.setPreQueueTime(St.AcquireTokenBySilentIframe, S.correlationId), $.acquireTokenBySilentIframe(S)
													})
												}), le.label = 3;
											case 3:
												return [2, u.then(function(Re) {
													var Ae;
													return $.eventHandler.emitEvent(Zt.t.ACQUIRE_TOKEN_SUCCESS, Qe.s_.Silent, Re), null === (Ae = $.astsAsyncMeasurement) || void 0 === Ae || Ae.endMeasurement({
														success: !0,
														fromCache: Re.fromCache,
														isNativeBroker: Re.fromNativeBroker,
														requestId: Re.requestId
													}), Re
												}).catch(function(Re) {
													var Ae;
													throw $.eventHandler.emitEvent(Zt.t.ACQUIRE_TOKEN_FAILURE, Qe.s_.Silent, null, Re), null === (Ae = $.astsAsyncMeasurement) || void 0 === Ae || Ae.endMeasurement({
														errorCode: Re.errorCode,
														subErrorCode: Re.subError,
														success: !1
													}), Re
												}).finally(function() {
													document.removeEventListener("visibilitychange", $.trackPageVisibility)
												})]
										}
									})
								})
							}, e
						}(function() {
							function i(e) {
								this.isBrowserEnvironment = typeof window < "u", this.config = function El(i, e) {
									var t = i.auth,
										s = i.cache,
										c = i.system,
										u = i.telemetry,
										h = {
											clientId: q.gT.EMPTY_STRING,
											authority: "" + q.gT.DEFAULT_AUTHORITY,
											knownAuthorities: [],
											cloudDiscoveryMetadata: q.gT.EMPTY_STRING,
											authorityMetadata: q.gT.EMPTY_STRING,
											redirectUri: q.gT.EMPTY_STRING,
											postLogoutRedirectUri: q.gT.EMPTY_STRING,
											navigateToLoginRequestUrl: !0,
											clientCapabilities: [],
											protocolMode: as.AAD,
											azureCloudOptions: {
												azureCloudInstance: Io.None,
												tenant: q.gT.EMPTY_STRING
											},
											skipAuthorityMetadataCache: !1
										},
										m = {
											cacheLocation: Qe.Ix.SessionStorage,
											storeAuthStateInCookie: !1,
											secureCookies: !1
										},
										S = {
											loggerCallback: function() {},
											logLevel: Wr.Info,
											piiLoggingEnabled: !1
										},
										O = (0, _e.pi)((0, _e.pi)({}, Tu), {
											loggerOptions: S,
											networkClient: e ? Mr.M.getBrowserNetworkClient() : v_,
											navigationClient: new Fp,
											loadFrameTimeout: 0,
											windowHashTimeout: c?.loadFrameTimeout || y_,
											iframeHashTimeout: c?.loadFrameTimeout || wu,
											navigateFrameWait: e && Mr.M.detectIEOrEdge() ? 500 : 0,
											redirectNavigationTimeout: Lp,
											asyncPopups: !1,
											allowRedirectInIframe: !1,
											allowNativeBroker: !1,
											nativeBrokerHandshakeTimeout: c?.nativeBrokerHandshakeTimeout || Up,
											pollIntervalMilliseconds: Qe.qx.DEFAULT_POLL_INTERVAL_MS,
											cryptoOptions: {
												useMsrCrypto: !1,
												entropy: void 0
											}
										}),
										$ = (0, _e.pi)((0, _e.pi)({}, c), {
											loggerOptions: c?.loggerOptions || S
										}),
										le = {
											application: {
												appName: q.gT.EMPTY_STRING,
												appVersion: q.gT.EMPTY_STRING
											}
										};
									return {
										auth: (0, _e.pi)((0, _e.pi)({}, h), t),
										cache: (0, _e.pi)((0, _e.pi)({}, m), s),
										system: (0, _e.pi)((0, _e.pi)({}, O), $),
										telemetry: (0, _e.pi)((0, _e.pi)({}, le), u)
									}
								}(e, this.isBrowserEnvironment), this.initialized = !1, this.logger = new Eu(this.config.system.loggerOptions, Cl, Mc), this.networkClient = this.config.system.networkClient, this.navigationClient = this.config.system.navigationClient, this.redirectResponse = new Map, this.hybridAuthCodeResponses = new Map, this.performanceClient = this.isBrowserEnvironment ? new $p(this.config.auth.clientId, this.config.auth.authority, this.logger, Cl, Mc, this.config.telemetry.application, this.config.system.cryptoOptions) : new hh(this.config.auth.clientId, this.config.auth.authority, this.logger, Cl, Mc, this.config.telemetry.application), this.browserCrypto = this.isBrowserEnvironment ? new yu(this.logger, this.performanceClient, this.config.system.cryptoOptions) : Ic, this.eventHandler = new gh(this.logger, this.browserCrypto), this.browserStorage = this.isBrowserEnvironment ? new Dc(this.config.auth.clientId, this.config.cache, this.browserCrypto, this.logger) : vl(this.config.auth.clientId, this.logger), this.nativeInternalStorage = new Dc(this.config.auth.clientId, {
									cacheLocation: Qe.Ix.MemoryStorage,
									storeAuthStateInCookie: !1,
									secureCookies: !1
								}, this.browserCrypto, this.logger), this.tokenCache = new wh(this.config, this.browserStorage, this.logger, this.browserCrypto), this.trackPageVisibilityWithMeasurement = this.trackPageVisibilityWithMeasurement.bind(this)
							}
							return i.prototype.initialize = function() {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var e, t, s, c;
									return (0, _e.Jh)(this, function(u) {
										switch (u.label) {
											case 0:
												if (this.logger.trace("initialize called"), this.initialized) return this.logger.info("initialize has already been called, exiting early."), [2];
												if (e = this.config.system.allowNativeBroker, t = this.performanceClient.startMeasurement(St.InitializeClientApplication), this.eventHandler.emitEvent(Zt.t.INITIALIZE_START), !e) return [3, 4];
												u.label = 1;
											case 1:
												return u.trys.push([1, 3, , 4]), s = this, [4, Bs.createProvider(this.logger, this.config.system.nativeBrokerHandshakeTimeout, this.performanceClient)];
											case 2:
												return s.nativeExtensionProvider = u.sent(), [3, 4];
											case 3:
												return c = u.sent(), this.logger.verbose(c), [3, 4];
											case 4:
												return this.initialized = !0, this.eventHandler.emitEvent(Zt.t.INITIALIZE_END), t.endMeasurement({
													allowNativeBroker: e,
													success: !0
												}), [2]
										}
									})
								})
							}, i.prototype.handleRedirectPromise = function(e) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var t, s, c, u, h, m, S, O, $ = this;
									return (0, _e.Jh)(this, function(le) {
										return this.logger.verbose("handleRedirectPromise called"), Mr.M.blockNativeBrokerCalledBeforeInitialized(this.config.system.allowNativeBroker, this.initialized), t = this.getAllAccounts(), this.isBrowserEnvironment ? (typeof(c = this.redirectResponse.get(s = e || q.gT.EMPTY_STRING)) > "u" ? (this.eventHandler.emitEvent(Zt.t.HANDLE_REDIRECT_START, Qe.s_.Redirect), this.logger.verbose("handleRedirectPromise has been called for the first time, storing the promise"), u = this.browserStorage.getCachedNativeRequest(), h = void 0, u && Bs.isNativeAvailable(this.config, this.logger, this.nativeExtensionProvider) && this.nativeExtensionProvider && !e ? (this.logger.trace("handleRedirectPromise - acquiring token from native platform"), m = new Us(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, Qe.WN.handleRedirectPromise, this.performanceClient, this.nativeExtensionProvider, u.accountId, this.nativeInternalStorage, u.correlationId), h = m.handleRedirectPromise()) : (this.logger.trace("handleRedirectPromise - acquiring token from web flow"), S = this.browserStorage.getTemporaryCache(Qe.c4.CORRELATION_ID, !0) || q.gT.EMPTY_STRING, O = this.createRedirectClient(S), h = O.handleRedirectPromise(e)), c = h.then(function(Re) {
											return Re && (t.length < $.getAllAccounts().length ? ($.eventHandler.emitEvent(Zt.t.LOGIN_SUCCESS, Qe.s_.Redirect, Re), $.logger.verbose("handleRedirectResponse returned result, login success")) : ($.eventHandler.emitEvent(Zt.t.ACQUIRE_TOKEN_SUCCESS, Qe.s_.Redirect, Re), $.logger.verbose("handleRedirectResponse returned result, acquire token success"))), $.eventHandler.emitEvent(Zt.t.HANDLE_REDIRECT_END, Qe.s_.Redirect), Re
										}).catch(function(Re) {
											throw $.eventHandler.emitEvent(t.length > 0 ? Zt.t.ACQUIRE_TOKEN_FAILURE : Zt.t.LOGIN_FAILURE, Qe.s_.Redirect, null, Re), $.eventHandler.emitEvent(Zt.t.HANDLE_REDIRECT_END, Qe.s_.Redirect), Re
										}), this.redirectResponse.set(s, c)) : this.logger.verbose("handleRedirectPromise has been called previously, returning the result from the first call"), [2, c]) : (this.logger.verbose("handleRedirectPromise returns null, not browser environment"), [2, null])
									})
								})
							}, i.prototype.acquireTokenRedirect = function(e) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var t, s, c, u, h, m = this;
									return (0, _e.Jh)(this, function(S) {
										return t = this.getRequestCorrelationId(e), this.logger.verbose("acquireTokenRedirect called", t), this.preflightBrowserEnvironmentCheck(Qe.s_.Redirect), s = this.getAllAccounts().length > 0, this.eventHandler.emitEvent(s ? Zt.t.ACQUIRE_TOKEN_START : Zt.t.LOGIN_START, Qe.s_.Redirect, e), this.nativeExtensionProvider && this.canUseNative(e) ? (u = new Us(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, Qe.WN.acquireTokenRedirect, this.performanceClient, this.nativeExtensionProvider, this.getNativeAccountId(e), this.nativeInternalStorage, e.correlationId), c = u.acquireTokenRedirect(e).catch(function(O) {
											if (O instanceof ji && O.isFatal()) return m.nativeExtensionProvider = void 0, m.createRedirectClient(e.correlationId).acquireToken(e);
											if (O instanceof Oi) return m.logger.verbose("acquireTokenRedirect - Resolving interaction required error thrown by native broker by falling back to web flow"), m.createRedirectClient(e.correlationId).acquireToken(e);
											throw m.browserStorage.setInteractionInProgress(!1), O
										})) : (h = this.createRedirectClient(e.correlationId), c = h.acquireToken(e)), [2, c.catch(function(O) {
											throw m.eventHandler.emitEvent(s ? Zt.t.ACQUIRE_TOKEN_FAILURE : Zt.t.LOGIN_FAILURE, Qe.s_.Redirect, null, O), O
										})]
									})
								})
							}, i.prototype.acquireTokenPopup = function(e) {
								var t = this,
									s = this.getRequestCorrelationId(e),
									c = this.performanceClient.startMeasurement(St.AcquireTokenPopup, s);
								try {
									this.logger.verbose("acquireTokenPopup called", s), this.preflightBrowserEnvironmentCheck(Qe.s_.Popup)
								} catch (S) {
									return Promise.reject(S)
								}
								var u = this.getAllAccounts();
								return this.eventHandler.emitEvent(u.length > 0 ? Zt.t.ACQUIRE_TOKEN_START : Zt.t.LOGIN_START, Qe.s_.Popup, e), (this.canUseNative(e) ? this.acquireTokenNative(e, Qe.WN.acquireTokenPopup).then(function(S) {
									return t.browserStorage.setInteractionInProgress(!1), c.endMeasurement({
										success: !0,
										isNativeBroker: !0,
										requestId: S.requestId
									}), S
								}).catch(function(S) {
									if (S instanceof ji && S.isFatal()) return t.nativeExtensionProvider = void 0, t.createPopupClient(e.correlationId).acquireToken(e);
									if (S instanceof Oi) return t.logger.verbose("acquireTokenPopup - Resolving interaction required error thrown by native broker by falling back to web flow"), t.createPopupClient(e.correlationId).acquireToken(e);
									throw t.browserStorage.setInteractionInProgress(!1), S
								}) : this.createPopupClient(e.correlationId).acquireToken(e)).then(function(S) {
									var O = u.length < t.getAllAccounts().length;
									return t.eventHandler.emitEvent(O ? Zt.t.LOGIN_SUCCESS : Zt.t.ACQUIRE_TOKEN_SUCCESS, Qe.s_.Popup, S), c.addStaticFields({
										accessTokenSize: S.accessToken.length,
										idTokenSize: S.idToken.length
									}), c.endMeasurement({
										success: !0,
										requestId: S.requestId
									}), S
								}).catch(function(S) {
									return t.eventHandler.emitEvent(u.length > 0 ? Zt.t.ACQUIRE_TOKEN_FAILURE : Zt.t.LOGIN_FAILURE, Qe.s_.Popup, null, S), c.endMeasurement({
										errorCode: S.errorCode,
										subErrorCode: S.subError,
										success: !1
									}), Promise.reject(S)
								})
							}, i.prototype.trackPageVisibilityWithMeasurement = function() {
								var e = this.ssoSilentMeasurement || this.acquireTokenByCodeAsyncMeasurement;
								e && (this.logger.info("Perf: Visibility change detected in ", e.event.name), e.increment({
									visibilityChangeCount: 1
								}))
							}, i.prototype.ssoSilent = function(e) {
								var t;
								return (0, _e.mG)(this, void 0, void 0, function() {
									var s, c, u, h, m = this;
									return (0, _e.Jh)(this, function(S) {
										return s = this.getRequestCorrelationId(e), c = (0, _e.pi)((0, _e.pi)({}, e), {
											prompt: e.prompt,
											correlationId: s
										}), this.preflightBrowserEnvironmentCheck(Qe.s_.Silent), this.ssoSilentMeasurement = this.performanceClient.startMeasurement(St.SsoSilent, s), null === (t = this.ssoSilentMeasurement) || void 0 === t || t.increment({
											visibilityChangeCount: 0
										}), document.addEventListener("visibilitychange", this.trackPageVisibilityWithMeasurement), this.logger.verbose("ssoSilent called", s), this.eventHandler.emitEvent(Zt.t.SSO_SILENT_START, Qe.s_.Silent, c), this.canUseNative(c) ? u = this.acquireTokenNative(c, Qe.WN.ssoSilent).catch(function(O) {
											if (O instanceof ji && O.isFatal()) return m.nativeExtensionProvider = void 0, m.createSilentIframeClient(c.correlationId).acquireToken(c);
											throw O
										}) : (h = this.createSilentIframeClient(c.correlationId), u = h.acquireToken(c)), [2, u.then(function(O) {
											var $, le;
											return m.eventHandler.emitEvent(Zt.t.SSO_SILENT_SUCCESS, Qe.s_.Silent, O), null === ($ = m.ssoSilentMeasurement) || void 0 === $ || $.addStaticFields({
												accessTokenSize: O.accessToken.length,
												idTokenSize: O.idToken.length
											}), null === (le = m.ssoSilentMeasurement) || void 0 === le || le.endMeasurement({
												success: !0,
												isNativeBroker: O.fromNativeBroker,
												requestId: O.requestId
											}), O
										}).catch(function(O) {
											var $;
											throw m.eventHandler.emitEvent(Zt.t.SSO_SILENT_FAILURE, Qe.s_.Silent, null, O), null === ($ = m.ssoSilentMeasurement) || void 0 === $ || $.endMeasurement({
												errorCode: O.errorCode,
												subErrorCode: O.subError,
												success: !1
											}), O
										}).finally(function() {
											document.removeEventListener("visibilitychange", m.trackPageVisibilityWithMeasurement)
										})]
									})
								})
							}, i.prototype.acquireTokenByCode = function(e) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var t, s, c, u, h = this;
									return (0, _e.Jh)(this, function(m) {
										t = this.getRequestCorrelationId(e), this.preflightBrowserEnvironmentCheck(Qe.s_.Silent), this.logger.trace("acquireTokenByCode called", t), this.eventHandler.emitEvent(Zt.t.ACQUIRE_TOKEN_BY_CODE_START, Qe.s_.Silent, e), s = this.performanceClient.startMeasurement(St.AcquireTokenByCode, e.correlationId);
										try {
											if (e.code && e.nativeAccountId) throw rn.U.createSpaCodeAndNativeAccountIdPresentError();
											if (e.code) return (u = this.hybridAuthCodeResponses.get(c = e.code)) ? (this.logger.verbose("Existing acquireTokenByCode request found", e.correlationId), s.discardMeasurement()) : (this.logger.verbose("Initiating new acquireTokenByCode request", t), u = this.acquireTokenByCodeAsync((0, _e.pi)((0, _e.pi)({}, e), {
												correlationId: t
											})).then(function(S) {
												return h.eventHandler.emitEvent(Zt.t.ACQUIRE_TOKEN_BY_CODE_SUCCESS, Qe.s_.Silent, S), h.hybridAuthCodeResponses.delete(c), s.addStaticFields({
													accessTokenSize: S.accessToken.length,
													idTokenSize: S.idToken.length
												}), s.endMeasurement({
													success: !0,
													isNativeBroker: S.fromNativeBroker,
													requestId: S.requestId
												}), S
											}).catch(function(S) {
												throw h.hybridAuthCodeResponses.delete(c), h.eventHandler.emitEvent(Zt.t.ACQUIRE_TOKEN_BY_CODE_FAILURE, Qe.s_.Silent, null, S), s.endMeasurement({
													errorCode: S.errorCode,
													subErrorCode: S.subError,
													success: !1
												}), S
											}), this.hybridAuthCodeResponses.set(c, u)), [2, u];
											if (e.nativeAccountId) {
												if (this.canUseNative(e, e.nativeAccountId)) return [2, this.acquireTokenNative(e, Qe.WN.acquireTokenByCode, e.nativeAccountId).catch(function(S) {
													throw S instanceof ji && S.isFatal() && (h.nativeExtensionProvider = void 0), S
												})];
												throw rn.U.createUnableToAcquireTokenFromNativePlatformError()
											}
											throw rn.U.createAuthCodeOrNativeAccountIdRequiredError()
										} catch (S) {
											throw this.eventHandler.emitEvent(Zt.t.ACQUIRE_TOKEN_BY_CODE_FAILURE, Qe.s_.Silent, null, S), s.endMeasurement({
												errorCode: S instanceof vn.l && S.errorCode || void 0,
												subErrorCode: S instanceof vn.l && S.subError || void 0,
												success: !1
											}), S
										}
										return [2]
									})
								})
							}, i.prototype.acquireTokenByCodeAsync = function(e) {
								var t;
								return (0, _e.mG)(this, void 0, void 0, function() {
									var u = this;
									return (0, _e.Jh)(this, function(h) {
										switch (h.label) {
											case 0:
												return this.logger.trace("acquireTokenByCodeAsync called", e.correlationId), this.acquireTokenByCodeAsyncMeasurement = this.performanceClient.startMeasurement(St.AcquireTokenByCodeAsync, e.correlationId), null === (t = this.acquireTokenByCodeAsyncMeasurement) || void 0 === t || t.increment({
													visibilityChangeCount: 0
												}), document.addEventListener("visibilitychange", this.trackPageVisibilityWithMeasurement), [4, this.createSilentAuthCodeClient(e.correlationId).acquireToken(e).then(function(m) {
													var S;
													return null === (S = u.acquireTokenByCodeAsyncMeasurement) || void 0 === S || S.endMeasurement({
														success: !0,
														fromCache: m.fromCache,
														isNativeBroker: m.fromNativeBroker,
														requestId: m.requestId
													}), m
												}).catch(function(m) {
													var S;
													throw null === (S = u.acquireTokenByCodeAsyncMeasurement) || void 0 === S || S.endMeasurement({
														errorCode: m.errorCode,
														subErrorCode: m.subError,
														success: !1
													}), m
												}).finally(function() {
													document.removeEventListener("visibilitychange", u.trackPageVisibilityWithMeasurement)
												})];
											case 1:
												return [2, h.sent()]
										}
									})
								})
							}, i.prototype.acquireTokenFromCache = function(e, t, s) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(c) {
										switch (this.performanceClient.addQueueMeasurement(St.AcquireTokenFromCache, t.correlationId), s.cacheLookupPolicy) {
											case Qe.lu.Default:
											case Qe.lu.AccessToken:
											case Qe.lu.AccessTokenAndRefreshToken:
												return [2, e.acquireToken(t)];
											default:
												throw zt.e.createRefreshRequiredError()
										}
										return [2]
									})
								})
							}, i.prototype.acquireTokenByRefreshToken = function(e, t) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var s;
									return (0, _e.Jh)(this, function(c) {
										switch (this.performanceClient.addQueueMeasurement(St.AcquireTokenByRefreshToken, e.correlationId), t.cacheLookupPolicy) {
											case Qe.lu.Default:
											case Qe.lu.AccessTokenAndRefreshToken:
											case Qe.lu.RefreshToken:
											case Qe.lu.RefreshTokenAndNetwork:
												return s = this.createSilentRefreshClient(e.correlationId), this.performanceClient.setPreQueueTime(St.SilentRefreshClientAcquireToken, e.correlationId), [2, s.acquireToken(e)];
											default:
												throw zt.e.createRefreshRequiredError()
										}
										return [2]
									})
								})
							}, i.prototype.acquireTokenBySilentIframe = function(e) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var t;
									return (0, _e.Jh)(this, function(s) {
										return this.performanceClient.addQueueMeasurement(St.AcquireTokenBySilentIframe, e.correlationId), t = this.createSilentIframeClient(e.correlationId), this.performanceClient.setPreQueueTime(St.SilentIframeClientAcquireToken, e.correlationId), [2, t.acquireToken(e)]
									})
								})
							}, i.prototype.logout = function(e) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var t;
									return (0, _e.Jh)(this, function(s) {
										return t = this.getRequestCorrelationId(e), this.logger.warning("logout API is deprecated and will be removed in msal-browser v3.0.0. Use logoutRedirect instead.", t), [2, this.logoutRedirect((0, _e.pi)({
											correlationId: t
										}, e))]
									})
								})
							}, i.prototype.logoutRedirect = function(e) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									var t;
									return (0, _e.Jh)(this, function(c) {
										return t = this.getRequestCorrelationId(e), this.preflightBrowserEnvironmentCheck(Qe.s_.Redirect), [2, this.createRedirectClient(t).logout(e)]
									})
								})
							}, i.prototype.logoutPopup = function(e) {
								try {
									var t = this.getRequestCorrelationId(e);
									return this.preflightBrowserEnvironmentCheck(Qe.s_.Popup), this.createPopupClient(t).logout(e)
								} catch (c) {
									return Promise.reject(c)
								}
							}, i.prototype.getAllAccounts = function() {
								return this.logger.verbose("getAllAccounts called"), this.isBrowserEnvironment ? this.browserStorage.getAllAccounts() : []
							}, i.prototype.getAccountByUsername = function(e) {
								var t = this.getAllAccounts();
								return !_n.x.isEmpty(e) && t && t.length ? (this.logger.verbose("Account matching username found, returning"), this.logger.verbosePii("Returning signed-in accounts matching username: " + e), t.filter(function(s) {
									return s.username.toLowerCase() === e.toLowerCase()
								})[0] || null) : (this.logger.verbose("getAccountByUsername: No matching account found, returning null"), null)
							}, i.prototype.getAccountByHomeId = function(e) {
								var t = this.getAllAccounts();
								return !_n.x.isEmpty(e) && t && t.length ? (this.logger.verbose("Account matching homeAccountId found, returning"), this.logger.verbosePii("Returning signed-in accounts matching homeAccountId: " + e), t.filter(function(s) {
									return s.homeAccountId === e
								})[0] || null) : (this.logger.verbose("getAccountByHomeId: No matching account found, returning null"), null)
							}, i.prototype.getAccountByLocalId = function(e) {
								var t = this.getAllAccounts();
								return !_n.x.isEmpty(e) && t && t.length ? (this.logger.verbose("Account matching localAccountId found, returning"), this.logger.verbosePii("Returning signed-in accounts matching localAccountId: " + e), t.filter(function(s) {
									return s.localAccountId === e
								})[0] || null) : (this.logger.verbose("getAccountByLocalId: No matching account found, returning null"), null)
							}, i.prototype.setActiveAccount = function(e) {
								this.browserStorage.setActiveAccount(e)
							}, i.prototype.getActiveAccount = function() {
								return this.browserStorage.getActiveAccount()
							}, i.prototype.preflightBrowserEnvironmentCheck = function(e, t) {
								if (void 0 === t && (t = !0), this.logger.verbose("preflightBrowserEnvironmentCheck started"), Mr.M.blockNonBrowserEnvironment(this.isBrowserEnvironment), Mr.M.blockRedirectInIframe(e, this.config.system.allowRedirectInIframe), Mr.M.blockReloadInHiddenIframes(), Mr.M.blockAcquireTokenInPopups(), Mr.M.blockNativeBrokerCalledBeforeInitialized(this.config.system.allowNativeBroker, this.initialized), e === Qe.s_.Redirect && this.config.cache.cacheLocation === Qe.Ix.MemoryStorage && !this.config.cache.storeAuthStateInCookie) throw Zi.W.createInMemoryRedirectUnavailableError();
								(e === Qe.s_.Redirect || e === Qe.s_.Popup) && this.preflightInteractiveRequest(t)
							}, i.prototype.preflightInteractiveRequest = function(e) {
								this.logger.verbose("preflightInteractiveRequest called, validating app environment"), Mr.M.blockReloadInHiddenIframes(), e && this.browserStorage.setInteractionInProgress(!0)
							}, i.prototype.acquireTokenNative = function(e, t, s) {
								return (0, _e.mG)(this, void 0, void 0, function() {
									return (0, _e.Jh)(this, function(u) {
										if (this.logger.trace("acquireTokenNative called"), !this.nativeExtensionProvider) throw rn.U.createNativeConnectionNotEstablishedError();
										return [2, new Us(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, t, this.performanceClient, this.nativeExtensionProvider, s || this.getNativeAccountId(e), this.nativeInternalStorage, e.correlationId).acquireToken(e)]
									})
								})
							}, i.prototype.canUseNative = function(e, t) {
								if (this.logger.trace("canUseNative called"), !Bs.isNativeAvailable(this.config, this.logger, this.nativeExtensionProvider, e.authenticationScheme)) return this.logger.trace("canUseNative: isNativeAvailable returned false, returning false"), !1;
								if (e.prompt) switch (e.prompt) {
									case q.NJ.NONE:
									case q.NJ.CONSENT:
									case q.NJ.LOGIN:
										this.logger.trace("canUseNative: prompt is compatible with native flow");
										break;
									default:
										return this.logger.trace("canUseNative: prompt = " + e.prompt + " is not compatible with native flow, returning false"), !1
								}
								return !(!t && !this.getNativeAccountId(e) && (this.logger.trace("canUseNative: nativeAccountId is not available, returning false"), 1))
							}, i.prototype.getNativeAccountId = function(e) {
								var t = e.account || this.browserStorage.getAccountInfoByHints(e.loginHint, e.sid) || this.getActiveAccount();
								return t && t.nativeAccountId || ""
							}, i.prototype.createPopupClient = function(e) {
								return new Ni(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeInternalStorage, this.nativeExtensionProvider, e)
							}, i.prototype.createRedirectClient = function(e) {
								return new Th(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeInternalStorage, this.nativeExtensionProvider, e)
							}, i.prototype.createSilentIframeClient = function(e) {
								return new Ei(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, Qe.WN.ssoSilent, this.performanceClient, this.nativeInternalStorage, this.nativeExtensionProvider, e)
							}, i.prototype.createSilentCacheClient = function(e) {
								return new Sh(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeExtensionProvider, e)
							}, i.prototype.createSilentRefreshClient = function(e) {
								return new xc(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeExtensionProvider, e)
							}, i.prototype.createSilentAuthCodeClient = function(e) {
								return new Vp(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, Qe.WN.acquireTokenByCode, this.performanceClient, this.nativeExtensionProvider, e)
							}, i.prototype.addEventCallback = function(e) {
								return this.eventHandler.addEventCallback(e)
							}, i.prototype.removeEventCallback = function(e) {
								this.eventHandler.removeEventCallback(e)
							}, i.prototype.addPerformanceCallback = function(e) {
								return this.performanceClient.addPerformanceCallback(e)
							}, i.prototype.removePerformanceCallback = function(e) {
								return this.performanceClient.removePerformanceCallback(e)
							}, i.prototype.enableAccountStorageEvents = function() {
								this.eventHandler.enableAccountStorageEvents()
							}, i.prototype.disableAccountStorageEvents = function() {
								this.eventHandler.disableAccountStorageEvents()
							}, i.prototype.getTokenCache = function() {
								return this.tokenCache
							}, i.prototype.getLogger = function() {
								return this.logger
							}, i.prototype.setLogger = function(e) {
								this.logger = e
							}, i.prototype.initializeWrapperLibrary = function(e, t) {
								this.browserStorage.setWrapperMetadata(e, t)
							}, i.prototype.setNavigationClient = function(e) {
								this.navigationClient = e
							}, i.prototype.getConfiguration = function() {
								return this.config
							}, i.prototype.getRequestCorrelationId = function(e) {
								return e?.correlationId ? e.correlationId : this.isBrowserEnvironment ? this.browserCrypto.createNewGuid() : q.gT.EMPTY_STRING
							}, i
						}());
					const Dh = window.navigator.userAgent.indexOf("MSIE ") > -1 || window.navigator.userAgent.indexOf("Trident/") > -1,
						Kp = {
							auth: {
								clientId: qt.N.auth.clientId,
								authority: qt.N.auth.authority,
								knownAuthorities: qt.N.auth.knownAuthorities,
								redirectUri: qt.N.auth.redirectUri
							},
							cache: {
								cacheLocation: Qe.Ix.SessionStorage,
								storeAuthStateInCookie: Dh
							}
						},
						Fc = {
							backend: {
								endpoint: qt.N.apiUrl,
								scopes: qt.N.auth.scope
							},
							graph: {
								endpoint: "https://graph.microsoft.com/v1.0/me",
								scopes: ["user.read"]
							}
						};

					function Nu() {
						return new zp(Kp)
					}

					function ku() {
						const i = new Map;
						return i.set(Fc.graph.endpoint, Fc.graph.scopes), i.set(Fc.backend.endpoint, Fc.backend.scopes), {
							interactionType: Qe.s_.Redirect,
							protectedResourceMap: i
						}
					}

					function Yp() {
						return {
							interactionType: Qe.s_.Redirect,
							authRequest: {
								scopes: Fc.backend.scopes
							}
						}
					}
					let Lc = (() => {
						class i {}
						return i.\u0275fac = function(t) {
							return new(t || i)
						}, i.\u0275mod = y.oAB({
							type: i,
							bootstrap: [ee.c$]
						}), i.\u0275inj = y.cJS({
							providers: [{
								provide: D.TP,
								useClass: Ls,
								multi: !0
							}, {
								provide: D.TP,
								useClass: ee.CH,
								multi: !0
							}, {
								provide: ee.sK,
								useFactory: Nu
							}, {
								provide: ee.ge,
								useFactory: ku
							}, {
								provide: ee.S9,
								useFactory: Yp
							}, ee.RQ, ee.W2, ee.J$],
							imports: [te.ez]
						}), i
					})();
					const Ah = Object.prototype.toString;

					function Rh(i) {
						switch (Ah.call(i)) {
							case "[object Error]":
							case "[object Exception]":
							case "[object DOMException]":
								return !0;
							default:
								return ls(i, Error)
						}
					}

					function cs(i, e) {
						return Ah.call(i) === `[object ${e}]`
					}

					function wl(i) {
						return cs(i, "ErrorEvent")
					}

					function xu(i) {
						return cs(i, "DOMError")
					}

					function ki(i) {
						return cs(i, "String")
					}

					function Fu(i) {
						return null === i || "object" != typeof i && "function" != typeof i
					}

					function Fa(i) {
						return cs(i, "Object")
					}

					function Uc(i) {
						return typeof Event < "u" && ls(i, Event)
					}

					function Lu(i) {
						return Boolean(i && i.then && "function" == typeof i.then)
					}

					function Mh(i) {
						return "number" == typeof i && i != i
					}

					function ls(i, e) {
						try {
							return i instanceof e
						} catch {
							return !1
						}
					}
					var qr = E(3693);
					const La = (0, qr.Rf)(),
						Oh = 80;

					function us(i, e = {}) {
						try {
							let t = i;
							const s = 5,
								c = [];
							let u = 0,
								h = 0;
							const m = " > ",
								S = m.length;
							let O;
							const $ = Array.isArray(e) ? e : e.keyAttrs,
								le = !Array.isArray(e) && e.maxStringLength || Oh;
							for (; t && u++ < s && (O = Jp(t, $), !("html" === O || u > 1 && h + c.length * S + O.length >= le));) c.push(O), h += O.length, t = t.parentNode;
							return c.reverse().join(m)
						} catch {
							return "<unknown>"
						}
					}

					function Jp(i, e) {
						const t = i,
							s = [];
						let c, u, h, m, S;
						if (!t || !t.tagName) return "";
						s.push(t.tagName.toLowerCase());
						const O = e && e.length ? e.filter(le => t.getAttribute(le)).map(le => [le, t.getAttribute(le)]) : null;
						if (O && O.length) O.forEach(le => {
							s.push(`[${le[0]}="${le[1]}"]`)
						});
						else if (t.id && s.push(`#${t.id}`), c = t.className, c && ki(c))
							for (u = c.split(/\s+/), S = 0; S < u.length; S++) s.push(`.${u[S]}`);
						const $ = ["aria-label", "type", "name", "title", "alt"];
						for (S = 0; S < $.length; S++) h = $[S], m = t.getAttribute(h), m && s.push(`[${h}="${m}"]`);
						return s.join("")
					}

					function Ua(i, e = 0) {
						return "string" != typeof i || 0 === e || i.length <= e ? i : `${i.slice(0,e)}...`
					}

					function Uu(i, e) {
						if (!Array.isArray(i)) return "";
						const t = [];
						for (let s = 0; s < i.length; s++) {
							const c = i[s];
							try {
								t.push(String(c))
							} catch {
								t.push("[value cannot be serialized]")
							}
						}
						return t.join(e)
					}

					function Bc(i, e = [], t = !1) {
						return e.some(s => function Nh(i, e, t = !1) {
							return !!ki(i) && (function qp(i) {
								return cs(i, "RegExp")
							}(e) ? e.test(i) : !!ki(e) && (t ? i === e : i.includes(e)))
						}(i, s, t))
					}

					function Ci(i, e, t) {
						if (!(e in i)) return;
						const s = i[e],
							c = t(s);
						if ("function" == typeof c) try {
							kh(c, s)
						} catch {}
						i[e] = c
					}

					function Ha(i, e, t) {
						Object.defineProperty(i, e, {
							value: t,
							writable: !0,
							configurable: !0
						})
					}

					function kh(i, e) {
						i.prototype = e.prototype = e.prototype || {}, Ha(i, "__sentry_original__", e)
					}

					function bl(i) {
						return i.__sentry_original__
					}

					function Bu(i) {
						if (Rh(i)) return {
							message: i.message,
							name: i.name,
							stack: i.stack,
							...Hu(i)
						};
						if (Uc(i)) {
							const e = {
								type: i.type,
								target: Il(i.target),
								currentTarget: Il(i.currentTarget),
								...Hu(i)
							};
							return typeof CustomEvent < "u" && ls(i, CustomEvent) && (e.detail = i.detail), e
						}
						return i
					}

					function Il(i) {
						try {
							return function Wp(i) {
								return typeof Element < "u" && ls(i, Element)
							}(i) ? us(i) : Object.prototype.toString.call(i)
						} catch {
							return "<unknown>"
						}
					}

					function Hu(i) {
						if ("object" == typeof i && null !== i) {
							const e = {};
							for (const t in i) Object.prototype.hasOwnProperty.call(i, t) && (e[t] = i[t]);
							return e
						}
						return {}
					}

					function Dl(i, e = 40) {
						const t = Object.keys(Bu(i));
						if (t.sort(), !t.length) return "[object has no keys]";
						if (t[0].length >= e) return Ua(t[0], e);
						for (let s = t.length; s > 0; s--) {
							const c = t.slice(0, s).join(", ");
							if (!(c.length > e)) return s === t.length ? c : Ua(c, e)
						}
						return ""
					}

					function go(i) {
						return Al(i, new Map)
					}

					function Al(i, e) {
						if (Fa(i)) {
							const t = e.get(i);
							if (void 0 !== t) return t;
							const s = {};
							e.set(i, s);
							for (const c of Object.keys(i)) typeof i[c] < "u" && (s[c] = Al(i[c], e));
							return s
						}
						if (Array.isArray(i)) {
							const t = e.get(i);
							if (void 0 !== t) return t;
							const s = [];
							return e.set(i, s), i.forEach(c => {
								s.push(Al(c, e))
							}), s
						}
						return i
					}

					function Ao() {
						const i = qr.n2,
							e = i.crypto || i.msCrypto;
						if (e && e.randomUUID) return e.randomUUID().replace(/-/g, "");
						const t = e && e.getRandomValues ? () => e.getRandomValues(new Uint8Array(1))[0] : () => 16 * Math.random();
						return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, s => (s ^ (15 & t()) >> s / 4).toString(16))
					}

					function Rl(i) {
						return i.exception && i.exception.values ? i.exception.values[0] : void 0
					}

					function no(i) {
						const {
							message: e,
							event_id: t
						} = i;
						if (e) return e;
						const s = Rl(i);
						return s ? s.type && s.value ? `${s.type}: ${s.value}` : s.type || s.value || t || "<unknown>" : t || "<unknown>"
					}

					function Gu(i, e, t) {
						const s = i.exception = i.exception || {},
							c = s.values = s.values || [],
							u = c[0] = c[0] || {};
						u.value || (u.value = e || ""), u.type || (u.type = t || "Error")
					}

					function ds(i, e) {
						const t = Rl(i);
						if (!t) return;
						const c = t.mechanism;
						if (t.mechanism = {
								type: "generic",
								handled: !0,
								...c,
								...e
							}, e && "data" in e) {
							const u = {
								...c && c.data,
								...e.data
							};
							t.mechanism.data = u
						}
					}

					function ju(i) {
						if (i && i.__sentry_captured__) return !0;
						try {
							Ha(i, "__sentry_captured__", !0)
						} catch {}
						return !1
					}

					function Vu(i) {
						return Array.isArray(i) ? i : [i]
					}
					var Fr = E(6852);
					const $u = "Sentry Logger ",
						Ro = ["debug", "info", "warn", "error", "log", "assert", "trace"];

					function Lh(i) {
						if (!("console" in qr.n2)) return i();
						const e = qr.n2.console,
							t = {};
						Ro.forEach(s => {
							const c = e[s] && e[s].__sentry_original__;
							s in e && c && (t[s] = e[s], e[s] = c)
						});
						try {
							return i()
						} finally {
							Object.keys(t).forEach(s => {
								e[s] = t[s]
							})
						}
					}

					function Uh() {
						let i = !1;
						const e = {
							enable: () => {
								i = !0
							},
							disable: () => {
								i = !1
							}
						};
						return typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__ ? Ro.forEach(t => {
							e[t] = (...s) => {
								i && Lh(() => {
									qr.n2.console[t](`${$u}[${t}]:`, ...s)
								})
							}
						}) : Ro.forEach(t => {
							e[t] = () => {}
						}), e
					}
					let Ut;
					Ut = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__ ? (0, qr.YO)("logger", Uh) : Uh();
					const zu = "production";
					var mo;

					function Hs(i) {
						return new ai(e => {
							e(i)
						})
					}

					function Hc(i) {
						return new ai((e, t) => {
							t(i)
						})
					}! function(i) {
						i[i.PENDING = 0] = "PENDING", i[i.RESOLVED = 1] = "RESOLVED", i[i.REJECTED = 2] = "REJECTED"
					}(mo || (mo = {}));
					class ai {
						__init() {
							this._state = mo.PENDING
						}
						__init2() {
							this._handlers = []
						}
						constructor(e) {
							ai.prototype.__init.call(this), ai.prototype.__init2.call(this), ai.prototype.__init3.call(this), ai.prototype.__init4.call(this), ai.prototype.__init5.call(this), ai.prototype.__init6.call(this);
							try {
								e(this._resolve, this._reject)
							} catch (t) {
								this._reject(t)
							}
						}
						then(e, t) {
							return new ai((s, c) => {
								this._handlers.push([!1, u => {
									if (e) try {
										s(e(u))
									} catch (h) {
										c(h)
									} else s(u)
								}, u => {
									if (t) try {
										s(t(u))
									} catch (h) {
										c(h)
									} else c(u)
								}]), this._executeHandlers()
							})
						} catch (e) {
							return this.then(t => t, e)
						} finally(e) {
							return new ai((t, s) => {
								let c, u;
								return this.then(h => {
									u = !1, c = h, e && e()
								}, h => {
									u = !0, c = h, e && e()
								}).then(() => {
									u ? s(c) : t(c)
								})
							})
						}
						__init3() {
							this._resolve = e => {
								this._setResult(mo.RESOLVED, e)
							}
						}
						__init4() {
							this._reject = e => {
								this._setResult(mo.REJECTED, e)
							}
						}
						__init5() {
							this._setResult = (e, t) => {
								if (this._state === mo.PENDING) {
									if (Lu(t)) return void t.then(this._resolve, this._reject);
									this._state = e, this._value = t, this._executeHandlers()
								}
							}
						}
						__init6() {
							this._executeHandlers = () => {
								if (this._state === mo.PENDING) return;
								const e = this._handlers.slice();
								this._handlers = [], e.forEach(t => {
									t[0] || (this._state === mo.RESOLVED && t[1](this._value), this._state === mo.REJECTED && t[2](this._value), t[0] = !0)
								})
							}
						}
					}

					function Gs(i, e = {}) {
						if (e.user && (!i.ipAddress && e.user.ip_address && (i.ipAddress = e.user.ip_address), !i.did && !e.did && (i.did = e.user.id || e.user.email || e.user.username)), i.timestamp = e.timestamp || (0, Fr.ph)(), e.ignoreDuration && (i.ignoreDuration = e.ignoreDuration), e.sid && (i.sid = 32 === e.sid.length ? e.sid : Ao()), void 0 !== e.init && (i.init = e.init), !i.did && e.did && (i.did = `${e.did}`), "number" == typeof e.started && (i.started = e.started), i.ignoreDuration) i.duration = void 0;
						else if ("number" == typeof e.duration) i.duration = e.duration;
						else {
							const t = i.timestamp - i.started;
							i.duration = t >= 0 ? t : 0
						}
						e.release && (i.release = e.release), e.environment && (i.environment = e.environment), !i.ipAddress && e.ipAddress && (i.ipAddress = e.ipAddress), !i.userAgent && e.userAgent && (i.userAgent = e.userAgent), "number" == typeof e.errors && (i.errors = e.errors), e.status && (i.status = e.status)
					}
					class Vs {
						constructor() {
							this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}
						}
						static clone(e) {
							const t = new Vs;
							return e && (t._breadcrumbs = [...e._breadcrumbs], t._tags = {
								...e._tags
							}, t._extra = {
								...e._extra
							}, t._contexts = {
								...e._contexts
							}, t._user = e._user, t._level = e._level, t._span = e._span, t._session = e._session, t._transactionName = e._transactionName, t._fingerprint = e._fingerprint, t._eventProcessors = [...e._eventProcessors], t._requestSession = e._requestSession, t._attachments = [...e._attachments], t._sdkProcessingMetadata = {
								...e._sdkProcessingMetadata
							}), t
						}
						addScopeListener(e) {
							this._scopeListeners.push(e)
						}
						addEventProcessor(e) {
							return this._eventProcessors.push(e), this
						}
						setUser(e) {
							return this._user = e || {}, this._session && Gs(this._session, {
								user: e
							}), this._notifyScopeListeners(), this
						}
						getUser() {
							return this._user
						}
						getRequestSession() {
							return this._requestSession
						}
						setRequestSession(e) {
							return this._requestSession = e, this
						}
						setTags(e) {
							return this._tags = {
								...this._tags,
								...e
							}, this._notifyScopeListeners(), this
						}
						setTag(e, t) {
							return this._tags = {
								...this._tags,
								[e]: t
							}, this._notifyScopeListeners(), this
						}
						setExtras(e) {
							return this._extra = {
								...this._extra,
								...e
							}, this._notifyScopeListeners(), this
						}
						setExtra(e, t) {
							return this._extra = {
								...this._extra,
								[e]: t
							}, this._notifyScopeListeners(), this
						}
						setFingerprint(e) {
							return this._fingerprint = e, this._notifyScopeListeners(), this
						}
						setLevel(e) {
							return this._level = e, this._notifyScopeListeners(), this
						}
						setTransactionName(e) {
							return this._transactionName = e, this._notifyScopeListeners(), this
						}
						setContext(e, t) {
							return null === t ? delete this._contexts[e] : this._contexts[e] = t, this._notifyScopeListeners(), this
						}
						setSpan(e) {
							return this._span = e, this._notifyScopeListeners(), this
						}
						getSpan() {
							return this._span
						}
						getTransaction() {
							const e = this.getSpan();
							return e && e.transaction
						}
						setSession(e) {
							return e ? this._session = e : delete this._session, this._notifyScopeListeners(), this
						}
						getSession() {
							return this._session
						}
						update(e) {
							if (!e) return this;
							if ("function" == typeof e) {
								const t = e(this);
								return t instanceof Vs ? t : this
							}
							return e instanceof Vs ? (this._tags = {
								...this._tags,
								...e._tags
							}, this._extra = {
								...this._extra,
								...e._extra
							}, this._contexts = {
								...this._contexts,
								...e._contexts
							}, e._user && Object.keys(e._user).length && (this._user = e._user), e._level && (this._level = e._level), e._fingerprint && (this._fingerprint = e._fingerprint), e._requestSession && (this._requestSession = e._requestSession)) : Fa(e) && (this._tags = {
								...this._tags,
								...e.tags
							}, this._extra = {
								...this._extra,
								...e.extra
							}, this._contexts = {
								...this._contexts,
								...e.contexts
							}, e.user && (this._user = e.user), e.level && (this._level = e.level), e.fingerprint && (this._fingerprint = e.fingerprint), e.requestSession && (this._requestSession = e.requestSession)), this
						}
						clear() {
							return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._span = void 0, this._session = void 0, this._notifyScopeListeners(), this._attachments = [], this
						}
						addBreadcrumb(e, t) {
							const s = "number" == typeof t ? t : 100;
							if (s <= 0) return this;
							const c = {
								timestamp: (0, Fr.yW)(),
								...e
							};
							return this._breadcrumbs = [...this._breadcrumbs, c].slice(-s), this._notifyScopeListeners(), this
						}
						getLastBreadcrumb() {
							return this._breadcrumbs[this._breadcrumbs.length - 1]
						}
						clearBreadcrumbs() {
							return this._breadcrumbs = [], this._notifyScopeListeners(), this
						}
						addAttachment(e) {
							return this._attachments.push(e), this
						}
						getAttachments() {
							return this._attachments
						}
						clearAttachments() {
							return this._attachments = [], this
						}
						applyToEvent(e, t = {}) {
							if (this._extra && Object.keys(this._extra).length && (e.extra = {
									...this._extra,
									...e.extra
								}), this._tags && Object.keys(this._tags).length && (e.tags = {
									...this._tags,
									...e.tags
								}), this._user && Object.keys(this._user).length && (e.user = {
									...this._user,
									...e.user
								}), this._contexts && Object.keys(this._contexts).length && (e.contexts = {
									...this._contexts,
									...e.contexts
								}), this._level && (e.level = this._level), this._transactionName && (e.transaction = this._transactionName), this._span) {
								e.contexts = {
									trace: this._span.getTraceContext(),
									...e.contexts
								};
								const s = this._span.transaction;
								if (s) {
									e.sdkProcessingMetadata = {
										dynamicSamplingContext: s.getDynamicSamplingContext(),
										...e.sdkProcessingMetadata
									};
									const c = s.name;
									c && (e.tags = {
										transaction: c,
										...e.tags
									})
								}
							}
							return this._applyFingerprint(e), e.breadcrumbs = [...e.breadcrumbs || [], ...this._breadcrumbs], e.breadcrumbs = e.breadcrumbs.length > 0 ? e.breadcrumbs : void 0, e.sdkProcessingMetadata = {
								...e.sdkProcessingMetadata,
								...this._sdkProcessingMetadata
							}, this._notifyEventProcessors([...Gh(), ...this._eventProcessors], e, t)
						}
						setSDKProcessingMetadata(e) {
							return this._sdkProcessingMetadata = {
								...this._sdkProcessingMetadata,
								...e
							}, this
						}
						_notifyEventProcessors(e, t, s, c = 0) {
							return new ai((u, h) => {
								const m = e[c];
								if (null === t || "function" != typeof m) u(t);
								else {
									const S = m({
										...t
									}, s);
									(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && m.id && null === S && Ut.log(`Event processor "${m.id}" dropped event`), Lu(S) ? S.then(O => this._notifyEventProcessors(e, O, s, c + 1).then(u)).then(null, h) : this._notifyEventProcessors(e, S, s, c + 1).then(u).then(null, h)
								}
							})
						}
						_notifyScopeListeners() {
							this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach(e => {
								e(this)
							}), this._notifyingListeners = !1)
						}
						_applyFingerprint(e) {
							e.fingerprint = e.fingerprint ? Vu(e.fingerprint) : [], this._fingerprint && (e.fingerprint = e.fingerprint.concat(this._fingerprint)), e.fingerprint && !e.fingerprint.length && delete e.fingerprint
						}
					}

					function Gh() {
						return (0, qr.YO)("globalEventProcessors", () => [])
					}

					function Yu(i) {
						Gh().push(i)
					}
					const Wu = 4,
						eg = 100;
					class _o {
						constructor(e, t = new Vs, s = Wu) {
							this._version = s, this._stack = [{
								scope: t
							}], e && this.bindClient(e)
						}
						isOlderThan(e) {
							return this._version < e
						}
						bindClient(e) {
							this.getStackTop().client = e, e && e.setupIntegrations && e.setupIntegrations()
						}
						pushScope() {
							const e = Vs.clone(this.getScope());
							return this.getStack().push({
								client: this.getClient(),
								scope: e
							}), e
						}
						popScope() {
							return !(this.getStack().length <= 1 || !this.getStack().pop())
						}
						withScope(e) {
							const t = this.pushScope();
							try {
								e(t)
							} finally {
								this.popScope()
							}
						}
						getClient() {
							return this.getStackTop().client
						}
						getScope() {
							return this.getStackTop().scope
						}
						getStack() {
							return this._stack
						}
						getStackTop() {
							return this._stack[this._stack.length - 1]
						}
						captureException(e, t) {
							const s = this._lastEventId = t && t.event_id ? t.event_id : Ao(),
								c = new Error("Sentry syntheticException");
							return this._withClient((u, h) => {
								u.captureException(e, {
									originalException: e,
									syntheticException: c,
									...t,
									event_id: s
								}, h)
							}), s
						}
						captureMessage(e, t, s) {
							const c = this._lastEventId = s && s.event_id ? s.event_id : Ao(),
								u = new Error(e);
							return this._withClient((h, m) => {
								h.captureMessage(e, t, {
									originalException: e,
									syntheticException: u,
									...s,
									event_id: c
								}, m)
							}), c
						}
						captureEvent(e, t) {
							const s = t && t.event_id ? t.event_id : Ao();
							return e.type || (this._lastEventId = s), this._withClient((c, u) => {
								c.captureEvent(e, {
									...t,
									event_id: s
								}, u)
							}), s
						}
						lastEventId() {
							return this._lastEventId
						}
						addBreadcrumb(e, t) {
							const {
								scope: s,
								client: c
							} = this.getStackTop();
							if (!c) return;
							const {
								beforeBreadcrumb: u = null,
								maxBreadcrumbs: h = eg
							} = c.getOptions && c.getOptions() || {};
							if (h <= 0) return;
							const S = {
									timestamp: (0, Fr.yW)(),
									...e
								},
								O = u ? Lh(() => u(S, t)) : S;
							null !== O && (c.emit && c.emit("beforeAddBreadcrumb", O, t), s.addBreadcrumb(O, h))
						}
						setUser(e) {
							this.getScope().setUser(e)
						}
						setTags(e) {
							this.getScope().setTags(e)
						}
						setExtras(e) {
							this.getScope().setExtras(e)
						}
						setTag(e, t) {
							this.getScope().setTag(e, t)
						}
						setExtra(e, t) {
							this.getScope().setExtra(e, t)
						}
						setContext(e, t) {
							this.getScope().setContext(e, t)
						}
						configureScope(e) {
							const {
								scope: t,
								client: s
							} = this.getStackTop();
							s && e(t)
						}
						run(e) {
							const t = jh(this);
							try {
								e(this)
							} finally {
								jh(t)
							}
						}
						getIntegration(e) {
							const t = this.getClient();
							if (!t) return null;
							try {
								return t.getIntegration(e)
							} catch {
								return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn(`Cannot retrieve integration ${e.id} from the current Hub`), null
							}
						}
						startTransaction(e, t) {
							const s = this._callExtensionMethod("startTransaction", e, t);
							return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && !s && console.warn("Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':\nSentry.addTracingExtensions();\nSentry.init({...});\n"), s
						}
						traceHeaders() {
							return this._callExtensionMethod("traceHeaders")
						}
						captureSession(e = !1) {
							if (e) return this.endSession();
							this._sendSessionUpdate()
						}
						endSession() {
							const t = this.getStackTop().scope,
								s = t.getSession();
							s && function Bh(i, e) {
								let t = {};
								e ? t = {
									status: e
								} : "ok" === i.status && (t = {
									status: "exited"
								}), Gs(i, t)
							}(s), this._sendSessionUpdate(), t.setSession()
						}
						startSession(e) {
							const {
								scope: t,
								client: s
							} = this.getStackTop(), {
								release: c,
								environment: u = zu
							} = s && s.getOptions() || {}, {
								userAgent: h
							} = qr.n2.navigator || {}, m = function Ku(i) {
								const e = (0, Fr.ph)(),
									t = {
										sid: Ao(),
										init: !0,
										timestamp: e,
										started: e,
										duration: 0,
										status: "ok",
										errors: 0,
										ignoreDuration: !1,
										toJSON: () => function Hh(i) {
											return go({
												sid: `${i.sid}`,
												init: i.init,
												started: new Date(1e3 * i.started).toISOString(),
												timestamp: new Date(1e3 * i.timestamp).toISOString(),
												status: i.status,
												errors: i.errors,
												did: "number" == typeof i.did || "string" == typeof i.did ? `${i.did}` : void 0,
												duration: i.duration,
												attrs: {
													release: i.release,
													environment: i.environment,
													ip_address: i.ipAddress,
													user_agent: i.userAgent
												}
											})
										}(t)
									};
								return i && Gs(t, i), t
							}({
								release: c,
								environment: u,
								user: t.getUser(),
								...h && {
									userAgent: h
								},
								...e
							}), S = t.getSession && t.getSession();
							return S && "ok" === S.status && Gs(S, {
								status: "exited"
							}), this.endSession(), t.setSession(m), m
						}
						shouldSendDefaultPii() {
							const e = this.getClient(),
								t = e && e.getOptions();
							return Boolean(t && t.sendDefaultPii)
						}
						_sendSessionUpdate() {
							const {
								scope: e,
								client: t
							} = this.getStackTop(), s = e.getSession();
							s && t && t.captureSession && t.captureSession(s)
						}
						_withClient(e) {
							const {
								scope: t,
								client: s
							} = this.getStackTop();
							s && e(s, t)
						}
						_callExtensionMethod(e, ...t) {
							const c = ro().__SENTRY__;
							if (c && c.extensions && "function" == typeof c.extensions[e]) return c.extensions[e].apply(this, t);
							(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn(`Extension method ${e} couldn't be found, doing nothing.`)
						}
					}

					function ro() {
						return qr.n2.__SENTRY__ = qr.n2.__SENTRY__ || {
							extensions: {},
							hub: void 0
						}, qr.n2
					}

					function jh(i) {
						const e = ro(),
							t = Ml(e);
						return Qu(e, i), t
					}

					function _r() {
						const i = ro();
						if (i.__SENTRY__ && i.__SENTRY__.acs) {
							const e = i.__SENTRY__.acs.getCurrentHub();
							if (e) return e
						}
						return function Vh(i = ro()) {
							return (! function qu(i) {
								return !!(i && i.__SENTRY__ && i.__SENTRY__.hub)
							}(i) || Ml(i).isOlderThan(Wu)) && Qu(i, new _o), Ml(i)
						}(i)
					}

					function Ml(i) {
						return (0, qr.YO)("hub", () => new _o, i)
					}

					function Qu(i, e) {
						return !!i && ((i.__SENTRY__ = i.__SENTRY__ || {}).hub = e, !0)
					}
					const tg = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];
					class Ga {
						static __initStatic() {
							this.id = "InboundFilters"
						}
						__init() {
							this.name = Ga.id
						}
						constructor(e = {}) {
							this._options = e, Ga.prototype.__init.call(this)
						}
						setupOnce(e, t) {
							const s = c => {
								const u = t();
								if (u) {
									const h = u.getIntegration(Ga);
									if (h) {
										const m = u.getClient(),
											S = m ? m.getOptions() : {},
											O = function Ol(i = {}, e = {}) {
												return {
													allowUrls: [...i.allowUrls || [], ...e.allowUrls || []],
													denyUrls: [...i.denyUrls || [], ...e.denyUrls || []],
													ignoreErrors: [...i.ignoreErrors || [], ...e.ignoreErrors || [], ...tg],
													ignoreTransactions: [...i.ignoreTransactions || [], ...e.ignoreTransactions || []],
													ignoreInternal: void 0 === i.ignoreInternal || i.ignoreInternal
												}
											}(h._options, S);
										return function Go(i, e) {
											return e.ignoreInternal && function D_(i) {
												try {
													return "SentryError" === i.exception.values[0].type
												} catch {}
												return !1
											}(i) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn(`Event dropped due to being internal Sentry Error.\nEvent: ${no(i)}`), !0) : function Gc(i, e) {
												return !(i.type || !e || !e.length) && function I_(i) {
													if (i.message) return [i.message];
													if (i.exception) try {
														const {
															type: e = "",
															value: t = ""
														} = i.exception.values && i.exception.values[0] || {};
														return [`${t}`, `${e}: ${t}`]
													} catch {
														return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.error(`Cannot extract message for event ${no(i)}`), []
													}
													return []
												}(i).some(t => Bc(t, e))
											}(i, e.ignoreErrors) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn(`Event dropped due to being matched by \`ignoreErrors\` option.\nEvent: ${no(i)}`), !0) : function $h(i, e) {
												if ("transaction" !== i.type || !e || !e.length) return !1;
												const t = i.transaction;
												return !!t && Bc(t, e)
											}(i, e.ignoreTransactions) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.\nEvent: ${no(i)}`), !0) : function zh(i, e) {
												if (!e || !e.length) return !1;
												const t = ja(i);
												return !!t && Bc(t, e)
											}(i, e.denyUrls) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn(`Event dropped due to being matched by \`denyUrls\` option.\nEvent: ${no(i)}.\nUrl: ${ja(i)}`), !0) : ! function Kh(i, e) {
												if (!e || !e.length) return !0;
												const t = ja(i);
												return !t || Bc(t, e)
											}(i, e.allowUrls) && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn(`Event dropped due to not being matched by \`allowUrls\` option.\nEvent: ${no(i)}.\nUrl: ${ja(i)}`), !0)
										}(c, O) ? null : c
									}
								}
								return c
							};
							s.id = this.name, e(s)
						}
					}

					function ja(i) {
						try {
							let e;
							try {
								e = i.exception.values[0].stacktrace.frames
							} catch {}
							return e ? function A_(i = []) {
								for (let e = i.length - 1; e >= 0; e--) {
									const t = i[e];
									if (t && "<anonymous>" !== t.filename && "[native code]" !== t.filename) return t.filename || null
								}
								return null
							}(e) : null
						} catch {
							return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.error(`Cannot extract url for event ${no(i)}`), null
						}
					}
					let Pl;
					Ga.__initStatic();
					class Nl {
						constructor() {
							Nl.prototype.__init.call(this)
						}
						static __initStatic() {
							this.id = "FunctionToString"
						}
						__init() {
							this.name = Nl.id
						}
						setupOnce() {
							Pl = Function.prototype.toString;
							try {
								Function.prototype.toString = function(...e) {
									const t = bl(this) || this;
									return Pl.apply(t, e)
								}
							} catch {}
						}
					}
					Nl.__initStatic();
					const ng = [];

					function rg(i) {
						const e = i.defaultIntegrations || [],
							t = i.integrations;
						let s;
						e.forEach(h => {
							h.isDefaultInstance = !0
						}), s = Array.isArray(t) ? [...e, ...t] : "function" == typeof t ? Vu(t(e)) : e;
						const c = function Yh(i) {
								const e = {};
								return i.forEach(t => {
									const {
										name: s
									} = t, c = e[s];
									c && !c.isDefaultInstance && t.isDefaultInstance || (e[s] = t)
								}), Object.keys(e).map(t => e[t])
							}(s),
							u = function og(i, e) {
								for (let t = 0; t < i.length; t++)
									if (!0 === e(i[t])) return t;
								return -1
							}(c, h => "Debug" === h.name);
						if (-1 !== u) {
							const [h] = c.splice(u, 1);
							c.push(h)
						}
						return c
					}

					function Wh(i, e) {
						e[i.name] = i, -1 === ng.indexOf(i.name) && (i.setupOnce(Yu, _r), ng.push(i.name), (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log(`Integration installed: ${i.name}`))
					}
					class ii extends Error {
						constructor(e, t = "warn") {
							super(e), this.message = e, this.name = new.target.prototype.constructor.name, Object.setPrototypeOf(this, new.target.prototype), this.logLevel = t
						}
					}
					const Qh = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;

					function jc(i, e = !1) {
						const {
							host: t,
							path: s,
							pass: c,
							port: u,
							projectId: h,
							protocol: m,
							publicKey: S
						} = i;
						return `${m}://${S}${e&&c?`:${c}`:""}@${t}${u?`:${u}`:""}/${s&&`${s}/`}${h}`
					}

					function Xu(i) {
						return {
							protocol: i.protocol,
							publicKey: i.publicKey || "",
							pass: i.pass || "",
							host: i.host,
							port: i.port || "",
							path: i.path || "",
							projectId: i.projectId
						}
					}

					function kl(i) {
						const e = "string" == typeof i ? function Gr(i) {
							const e = Qh.exec(i);
							if (!e) throw new ii(`Invalid Sentry Dsn: ${i}`);
							const [t, s, c = "", u, h = "", m] = e.slice(1);
							let S = "",
								O = m;
							const $ = O.split("/");
							if ($.length > 1 && (S = $.slice(0, -1).join("/"), O = $.pop()), O) {
								const le = O.match(/^\d+/);
								le && (O = le[0])
							}
							return Xu({
								host: u,
								pass: c,
								path: S,
								projectId: O,
								port: h,
								protocol: t,
								publicKey: s
							})
						}(i) : Xu(i);
						return function sg(i) {
							if (!(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__)) return;
							const {
								port: e,
								projectId: t,
								protocol: s
							} = i;
							if (["protocol", "publicKey", "host", "projectId"].forEach(u => {
									if (!i[u]) throw new ii(`Invalid Sentry Dsn: ${u} missing`)
								}), !t.match(/^\d+$/)) throw new ii(`Invalid Sentry Dsn: Invalid projectId ${t}`);
							if (! function Ju(i) {
									return "http" === i || "https" === i
								}(s)) throw new ii(`Invalid Sentry Dsn: Invalid protocol ${s}`);
							if (e && isNaN(parseInt(e, 10))) throw new ii(`Invalid Sentry Dsn: Invalid port ${e}`)
						}(e), e
					}
					const Jh = "7";

					function Xh(i) {
						return `${i.protocol?`${i.protocol}:`:""}//${i.host}${i.port?`:${i.port}`:""}${i.path?`/${i.path}`:""}/api/`
					}

					function lg(i, e = {}) {
						const s = "string" != typeof e && e._metadata ? e._metadata.sdk : void 0;
						return ("string" == typeof e ? e : e.tunnel) || `${function ag(i){return`${Xh(i)}${i.projectId}/envelope/`}(i)}?${function cg(i,e){return function xh(i){return Object.keys(i).map(e=>`${encodeURIComponent(e)}=${encodeURIComponent(i[e])}`).join("&")}({sentry_key:i.publicKey,sentry_version:Jh,...e&&{sentry_client:`
						$ {
							e.name
						}
						/${e.version}`}})}(i,s)}`}const ug=50,dg=/\(error: (.*)\) / ;

						function Va(...i) {
							const e = i.sort((t, s) => t[0] - s[0]).map(t => t[1]);
							return (t, s = 0) => {
								const c = [],
									u = t.split("\n");
								for (let h = s; h < u.length; h++) {
									const m = u[h];
									if (m.length > 1024) continue;
									const S = dg.test(m) ? m.replace(dg, "$1") : m;
									if (!S.match(/\S*Error: /)) {
										for (const O of e) {
											const $ = O(S);
											if ($) {
												c.push($);
												break
											}
										}
										if (c.length >= ug) break
									}
								}
								return function ef(i) {
									if (!i.length) return [];
									const e = i.slice(0, ug),
										t = e[e.length - 1].function;
									t && /sentryWrapped/.test(t) && e.pop(), e.reverse();
									const s = e[e.length - 1].function;
									return s && /captureMessage|captureException/.test(s) && e.pop(), e.map(c => ({
										...c,
										filename: c.filename || e[e.length - 1].filename,
										function: c.function || "?"
									}))
								}(c)
							}
						}

						function Zu(i) {
							return Array.isArray(i) ? Va(...i) : i
						}
						const xl = "<anonymous>";

						function jo(i) {
							try {
								return i && "function" == typeof i && i.name || xl
							} catch {
								return xl
							}
						}
						const Fl = (0, qr.Rf)();

						function nf() {
							if (!("fetch" in Fl)) return !1;
							try {
								return new Headers, new Request("http://www.example.com"), new Response, !0
							} catch {
								return !1
							}
						}

						function Vc(i) {
							return i && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(i.toString())
						}

						function rf() {
							if (!nf()) return !1;
							if (Vc(Fl.fetch)) return !0;
							let i = !1;
							const e = Fl.document;
							if (e && "function" == typeof e.createElement) try {
								const t = e.createElement("iframe");
								t.hidden = !0, e.head.appendChild(t), t.contentWindow && t.contentWindow.fetch && (i = Vc(t.contentWindow.fetch)), e.head.removeChild(t)
							} catch (t) {
								(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", t)
							}
							return i
						}
						const $c = (0, qr.Rf)(),
							Dr = (0, qr.Rf)(),
							Vo = "__sentry_xhr_v2__",
							hs = {},
							af = {};

						function ci(i, e) {
							hs[i] = hs[i] || [], hs[i].push(e),
								function ed(i) {
									if (!af[i]) switch (af[i] = !0, i) {
										case "console":
											! function cf() {
												"console" in Dr && Ro.forEach(function(i) {
													i in Dr.console && Ci(Dr.console, i, function(e) {
														return function(...t) {
															mi("console", {
																args: t,
																level: i
															}), e && e.apply(Dr.console, t)
														}
													})
												})
											}();
											break;
										case "dom":
											! function M_() {
												if (!("document" in Dr)) return;
												const i = mi.bind(null, "dom"),
													e = rd(i, !0);
												Dr.document.addEventListener("click", e, !1), Dr.document.addEventListener("keypress", e, !1), ["EventTarget", "Node"].forEach(t => {
													const s = Dr[t] && Dr[t].prototype;
													!s || !s.hasOwnProperty || !s.hasOwnProperty("addEventListener") || (Ci(s, "addEventListener", function(c) {
														return function(u, h, m) {
															if ("click" === u || "keypress" == u) try {
																const S = this,
																	O = S.__sentry_instrumentation_handlers__ = S.__sentry_instrumentation_handlers__ || {},
																	$ = O[u] = O[u] || {
																		refCount: 0
																	};
																if (!$.handler) {
																	const le = rd(i);
																	$.handler = le, c.call(this, u, le, m)
																}
																$.refCount++
															} catch {}
															return c.call(this, u, h, m)
														}
													}), Ci(s, "removeEventListener", function(c) {
														return function(u, h, m) {
															if ("click" === u || "keypress" == u) try {
																const S = this,
																	O = S.__sentry_instrumentation_handlers__ || {},
																	$ = O[u];
																$ && ($.refCount--, $.refCount <= 0 && (c.call(this, u, $.handler, m), $.handler = void 0, delete O[u]), 0 === Object.keys(O).length && delete S.__sentry_instrumentation_handlers__)
															} catch {}
															return c.call(this, u, h, m)
														}
													}))
												})
											}();
											break;
										case "xhr":
											! function $a() {
												if (!("XMLHttpRequest" in Dr)) return;
												const i = XMLHttpRequest.prototype;
												Ci(i, "open", function(e) {
													return function(...t) {
														const s = t[1],
															c = this[Vo] = {
																method: ki(t[0]) ? t[0].toUpperCase() : t[0],
																url: t[1],
																request_headers: {}
															};
														ki(s) && "POST" === c.method && s.match(/sentry_key/) && (this.__sentry_own_request__ = !0);
														const u = () => {
															const h = this[Vo];
															if (h && 4 === this.readyState) {
																try {
																	h.status_code = this.status
																} catch {}
																mi("xhr", {
																	args: t,
																	endTimestamp: Date.now(),
																	startTimestamp: Date.now(),
																	xhr: this
																})
															}
														};
														return "onreadystatechange" in this && "function" == typeof this.onreadystatechange ? Ci(this, "onreadystatechange", function(h) {
															return function(...m) {
																return u(), h.apply(this, m)
															}
														}) : this.addEventListener("readystatechange", u), Ci(this, "setRequestHeader", function(h) {
															return function(...m) {
																const [S, O] = m, $ = this[Vo];
																return $ && ($.request_headers[S.toLowerCase()] = O), h.apply(this, m)
															}
														}), e.apply(this, t)
													}
												}), Ci(i, "send", function(e) {
													return function(...t) {
														const s = this[Vo];
														return s && void 0 !== t[0] && (s.body = t[0]), mi("xhr", {
															args: t,
															startTimestamp: Date.now(),
															xhr: this
														}), e.apply(this, t)
													}
												})
											}();
											break;
										case "fetch":
											! function td() {
												rf() && Ci(Dr, "fetch", function(i) {
													return function(...e) {
														const {
															method: t,
															url: s
														} = function uf(i) {
															if (0 === i.length) return {
																method: "GET",
																url: ""
															};
															if (2 === i.length) {
																const [t, s] = i;
																return {
																	url: lf(t),
																	method: nd(s, "method") ? String(s.method).toUpperCase() : "GET"
																}
															}
															const e = i[0];
															return {
																url: lf(e),
																method: nd(e, "method") ? String(e.method).toUpperCase() : "GET"
															}
														}(e), c = {
															args: e,
															fetchData: {
																method: t,
																url: s
															},
															startTimestamp: Date.now()
														};
														return mi("fetch", {
															...c
														}), i.apply(Dr, e).then(u => (mi("fetch", {
															...c,
															endTimestamp: Date.now(),
															response: u
														}), u), u => {
															throw mi("fetch", {
																...c,
																endTimestamp: Date.now(),
																error: u
															}), u
														})
													}
												})
											}();
											break;
										case "history":
											! function gg() {
												if (! function $s() {
														const i = $c.chrome;
														return !(i && i.app && i.app.runtime || !("history" in $c) || !$c.history.pushState || !$c.history.replaceState)
													}()) return;
												const i = Dr.onpopstate;

												function e(t) {
													return function(...s) {
														const c = s.length > 2 ? s[2] : void 0;
														if (c) {
															const u = Ll,
																h = String(c);
															Ll = h, mi("history", {
																from: u,
																to: h
															})
														}
														return t.apply(this, s)
													}
												}
												Dr.onpopstate = function(...t) {
													const s = Dr.location.href,
														c = Ll;
													if (Ll = s, mi("history", {
															from: c,
															to: s
														}), i) try {
														return i.apply(this, t)
													} catch {}
												}, Ci(Dr.history, "pushState", e), Ci(Dr.history, "replaceState", e)
											}();
											break;
										case "error":
											! function zc() {
												Bl = Dr.onerror, Dr.onerror = function(i, e, t, s, c) {
													return mi("error", {
														column: s,
														error: c,
														line: t,
														msg: i,
														url: e
													}), !(!Bl || Bl.__SENTRY_LOADER__) && Bl.apply(this, arguments)
												}, Dr.onerror.__SENTRY_INSTRUMENTED__ = !0
											}();
											break;
										case "unhandledrejection":
											! function Ka() {
												Hl = Dr.onunhandledrejection, Dr.onunhandledrejection = function(i) {
													return mi("unhandledrejection", i), !(Hl && !Hl.__SENTRY_LOADER__) || Hl.apply(this, arguments)
												}, Dr.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0
											}();
											break;
										default:
											return void((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn("unknown instrumentation type:", i))
									}
								}(i)
						}

						function mi(i, e) {
							if (i && hs[i])
								for (const t of hs[i] || []) try {
									t(e)
								} catch (s) {
									(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.error(`Error while triggering instrumentation handler.\nType: ${i}\nName: ${jo(t)}\nError:`, s)
								}
						}

						function nd(i, e) {
							return !!i && "object" == typeof i && !!i[e]
						}

						function lf(i) {
							return "string" == typeof i ? i : i ? nd(i, "url") ? i.url : i.toString ? i.toString() : "" : ""
						}
						let Ll;
						const mg = 1e3;
						let za, Ul;

						function rd(i, e = !1) {
							return t => {
								if (!t || Ul === t || function _g(i) {
										if ("keypress" !== i.type) return !1;
										try {
											const e = i.target;
											if (!e || !e.tagName) return !0;
											if ("INPUT" === e.tagName || "TEXTAREA" === e.tagName || e.isContentEditable) return !1
										} catch {}
										return !0
									}(t)) return;
								const s = "keypress" === t.type ? "input" : t.type;
								(void 0 === za || function df(i, e) {
									if (!i || i.type !== e.type) return !0;
									try {
										if (i.target !== e.target) return !0
									} catch {}
									return !1
								}(Ul, t)) && (i({
									event: t,
									name: s,
									global: e
								}), Ul = t), clearTimeout(za), za = Dr.setTimeout(() => {
									za = void 0
								}, mg)
							}
						}
						let Bl = null,
							Hl = null;

						function fs(i, e = 100, t = 1 / 0) {
							try {
								return od("", i, e, t)
							} catch (s) {
								return {
									ERROR: `**non-serializable** (${s})`
								}
							}
						}

						function id(i, e = 3, t = 102400) {
							const s = fs(i, e);
							return function ff(i) {
								return function hf(i) {
									return ~-encodeURI(i).split(/%..|./).length
								}(JSON.stringify(i))
							}(s) > t ? id(i, e - 1, t) : s
						}

						function od(i, e, t = 1 / 0, s = 1 / 0, c = function Kc() {
							const i = "function" == typeof WeakSet,
								e = i ? new WeakSet : [];
							return [function t(c) {
								if (i) return !!e.has(c) || (e.add(c), !1);
								for (let u = 0; u < e.length; u++)
									if (e[u] === c) return !0;
								return e.push(c), !1
							}, function s(c) {
								if (i) e.delete(c);
								else
									for (let u = 0; u < e.length; u++)
										if (e[u] === c) {
											e.splice(u, 1);
											break
										}
							}]
						}()) {
							const [u, h] = c;
							if (null === e || ["number", "boolean", "string"].includes(typeof e) && !Mh(e)) return e;
							const m = function vg(i, e) {
								try {
									if ("domain" === i && e && "object" == typeof e && e._events) return "[Domain]";
									if ("domainEmitter" === i) return "[DomainEmitter]";
									if (typeof global < "u" && e === global) return "[Global]";
									if (typeof window < "u" && e === window) return "[Window]";
									if (typeof document < "u" && e === document) return "[Document]";
									if (function Qp(i) {
											return Fa(i) && "nativeEvent" in i && "preventDefault" in i && "stopPropagation" in i
										}(e)) return "[SyntheticEvent]";
									if ("number" == typeof e && e != e) return "[NaN]";
									if (void 0 === e) return "[undefined]";
									if ("function" == typeof e) return `[Function: ${jo(e)}]`;
									if ("symbol" == typeof e) return `[${String(e)}]`;
									if ("bigint" == typeof e) return `[BigInt: ${String(e)}]`;
									const t = function yg(i) {
										const e = Object.getPrototypeOf(i);
										return e ? e.constructor.name : "null prototype"
									}(e);
									return /^HTML(\w*)Element$/.test(t) ? `[HTMLElement: ${t}]` : `[object ${t}]`
								} catch (t) {
									return `**non-serializable** (${t})`
								}
							}(i, e);
							if (!m.startsWith("[object ")) return m;
							if (e.__sentry_skip_normalization__) return e;
							const S = "number" == typeof e.__sentry_override_normalization_depth__ ? e.__sentry_override_normalization_depth__ : t;
							if (0 === S) return m.replace("object ", "");
							if (u(e)) return "[Circular ~]";
							const O = e;
							if (O && "function" == typeof O.toJSON) try {
								return od("", O.toJSON(), S - 1, s, c)
							} catch {}
							const $ = Array.isArray(e) ? [] : {};
							let le = 0;
							const Re = Bu(e);
							for (const Ae in Re)
								if (Object.prototype.hasOwnProperty.call(Re, Ae)) {
									if (le >= s) {
										$[Ae] = "[MaxProperties ~]";
										break
									}
									$[Ae] = od(Ae, Re[Ae], S - 1, s, c), le++
								} return h(e), $
						}

						function zs(i, e = []) {
							return [i, e]
						}

						function sd(i, e) {
							const [t, s] = i;
							return [t, [...s, e]]
						}

						function ad(i, e) {
							const t = i[1];
							for (const s of t)
								if (e(s, s[0].type)) return !0;
							return !1
						}

						function Ks(i, e) {
							return (e || new TextEncoder).encode(i)
						}

						function Eg(i, e) {
							const [t, s] = i;
							let c = JSON.stringify(t);

							function u(h) {
								"string" == typeof c ? c = "string" == typeof h ? c + h : [Ks(c, e), h] : c.push("string" == typeof h ? Ks(h, e) : h)
							}
							for (const h of s) {
								const [m, S] = h;
								if (u(`\n${JSON.stringify(m)}\n`), "string" == typeof S || S instanceof Uint8Array) u(S);
								else {
									let O;
									try {
										O = JSON.stringify(S)
									} catch {
										O = JSON.stringify(fs(S))
									}
									u(O)
								}
							}
							return "string" == typeof c ? c : function Cg(i) {
								const e = i.reduce((c, u) => c + u.length, 0),
									t = new Uint8Array(e);
								let s = 0;
								for (const c of i) t.set(c, s), s += c.length;
								return t
							}(c)
						}

						function Sg(i, e) {
							const t = "string" == typeof i.data ? Ks(i.data, e) : i.data;
							return [go({
								type: "attachment",
								length: t.length,
								filename: i.filename,
								content_type: i.contentType,
								attachment_type: i.attachmentType
							}), t]
						}
						const gf = {
							session: "session",
							sessions: "session",
							attachment: "attachment",
							transaction: "transaction",
							event: "error",
							client_report: "internal",
							user_report: "default",
							profile: "profile",
							replay_event: "replay",
							replay_recording: "replay",
							check_in: "monitor"
						};

						function cd(i) {
							return gf[i]
						}

						function mf(i) {
							if (!i || !i.sdk) return;
							const {
								name: e,
								version: t
							} = i.sdk;
							return {
								name: e,
								version: t
							}
						}
						const ld = new WeakMap,
							yf = "Not capturing exception because it's already been captured.";
						class ps {
							__init() {
								this._integrations = {}
							}
							__init2() {
								this._integrationsInitialized = !1
							}
							__init3() {
								this._numProcessing = 0
							}
							__init4() {
								this._outcomes = {}
							}
							__init5() {
								this._hooks = {}
							}
							constructor(e) {
								if (ps.prototype.__init.call(this), ps.prototype.__init2.call(this), ps.prototype.__init3.call(this), ps.prototype.__init4.call(this), ps.prototype.__init5.call(this), this._options = e, e.dsn) {
									this._dsn = kl(e.dsn);
									const t = lg(this._dsn, e);
									this._transport = e.transport({
										recordDroppedEvent: this.recordDroppedEvent.bind(this),
										...e.transportOptions,
										url: t
									})
								} else(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn("No DSN provided, client will not do anything.")
							}
							captureException(e, t, s) {
								if (ju(e)) return void((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log(yf));
								let c = t && t.event_id;
								return this._process(this.eventFromException(e, t).then(u => this._captureEvent(u, t, s)).then(u => {
									c = u
								})), c
							}
							captureMessage(e, t, s, c) {
								let u = s && s.event_id;
								const h = Fu(e) ? this.eventFromMessage(String(e), t, s) : this.eventFromException(e, s);
								return this._process(h.then(m => this._captureEvent(m, s, c)).then(m => {
									u = m
								})), u
							}
							captureEvent(e, t, s) {
								if (t && t.originalException && ju(t.originalException)) return void((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log(yf));
								let c = t && t.event_id;
								return this._process(this._captureEvent(e, t, s).then(u => {
									c = u
								})), c
							}
							captureSession(e) {
								this._isEnabled() ? "string" != typeof e.release ? (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn("Discarded session because of missing or non-string release") : (this.sendSession(e), Gs(e, {
									init: !1
								})) : (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn("SDK not enabled, will not capture session.")
							}
							getDsn() {
								return this._dsn
							}
							getOptions() {
								return this._options
							}
							getSdkMetadata() {
								return this._options._metadata
							}
							getTransport() {
								return this._transport
							}
							flush(e) {
								const t = this._transport;
								return t ? this._isClientDoneProcessing(e).then(s => t.flush(e).then(c => s && c)) : Hs(!0)
							}
							close(e) {
								return this.flush(e).then(t => (this.getOptions().enabled = !1, t))
							}
							setupIntegrations() {
								this._isEnabled() && !this._integrationsInitialized && (this._integrations = function ig(i) {
									const e = {};
									return i.forEach(t => {
										t && Wh(t, e)
									}), e
								}(this._options.integrations), this._integrationsInitialized = !0)
							}
							getIntegrationById(e) {
								return this._integrations[e]
							}
							getIntegration(e) {
								try {
									return this._integrations[e.id] || null
								} catch {
									return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn(`Cannot retrieve integration ${e.id} from the current Client`), null
								}
							}
							addIntegration(e) {
								Wh(e, this._integrations)
							}
							sendEvent(e, t = {}) {
								if (this._dsn) {
									let s = function wg(i, e, t, s) {
										const c = mf(t),
											u = i.type && "replay_event" !== i.type ? i.type : "event";
										! function $o(i, e) {
											e && (i.sdk = i.sdk || {}, i.sdk.name = i.sdk.name || e.name, i.sdk.version = i.sdk.version || e.version, i.sdk.integrations = [...i.sdk.integrations || [], ...e.integrations || []], i.sdk.packages = [...i.sdk.packages || [], ...e.packages || []])
										}(i, t && t.sdk);
										const h = function Ya(i, e, t, s) {
											const c = i.sdkProcessingMetadata && i.sdkProcessingMetadata.dynamicSamplingContext;
											return {
												event_id: i.event_id,
												sent_at: (new Date).toISOString(),
												...e && {
													sdk: e
												},
												...!!t && {
													dsn: jc(s)
												},
												...c && {
													trace: go({
														...c
													})
												}
											}
										}(i, c, s, e);
										return delete i.sdkProcessingMetadata, zs(h, [
											[{
												type: u
											}, i]
										])
									}(e, this._dsn, this._options._metadata, this._options.tunnel);
									for (const u of t.attachments || []) s = sd(s, Sg(u, this._options.transportOptions && this._options.transportOptions.textEncoder));
									const c = this._sendEnvelope(s);
									c && c.then(u => this.emit("afterSendEvent", e, u), null)
								}
							}
							sendSession(e) {
								if (this._dsn) {
									const t = function Tg(i, e, t, s) {
										const c = mf(t);
										return zs({
											sent_at: (new Date).toISOString(),
											...c && {
												sdk: c
											},
											...!!s && {
												dsn: jc(e)
											}
										}, ["aggregates" in i ? [{
											type: "sessions"
										}, i] : [{
											type: "session"
										}, i]])
									}(e, this._dsn, this._options._metadata, this._options.tunnel);
									this._sendEnvelope(t)
								}
							}
							recordDroppedEvent(e, t, s) {
								if (this._options.sendClientReports) {
									const c = `${e}:${t}`;
									(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log(`Adding outcome: "${c}"`), this._outcomes[c] = this._outcomes[c] + 1 || 1
								}
							}
							on(e, t) {
								this._hooks[e] || (this._hooks[e] = []), this._hooks[e].push(t)
							}
							emit(e, ...t) {
								this._hooks[e] && this._hooks[e].forEach(s => s(...t))
							}
							_updateSessionFromEvent(e, t) {
								let s = !1,
									c = !1;
								const u = t.exception && t.exception.values;
								if (u) {
									c = !0;
									for (const S of u) {
										const O = S.mechanism;
										if (O && !1 === O.handled) {
											s = !0;
											break
										}
									}
								}
								const h = "ok" === e.status;
								(h && 0 === e.errors || h && s) && (Gs(e, {
									...s && {
										status: "crashed"
									},
									errors: e.errors || Number(c || s)
								}), this.captureSession(e))
							}
							_isClientDoneProcessing(e) {
								return new ai(t => {
									let s = 0;
									const u = setInterval(() => {
										0 == this._numProcessing ? (clearInterval(u), t(!0)) : (s += 1, e && s >= e && (clearInterval(u), t(!1)))
									}, 1)
								})
							}
							_isEnabled() {
								return !1 !== this.getOptions().enabled && void 0 !== this._dsn
							}
							_prepareEvent(e, t, s) {
								const c = this.getOptions(),
									u = Object.keys(this._integrations);
								return !t.integrations && u.length > 0 && (t.integrations = u),
									function P_(i, e, t, s) {
										const {
											normalizeDepth: c = 3,
											normalizeMaxBreadth: u = 1e3
										} = i, h = {
											...e,
											event_id: e.event_id || t.event_id || Ao(),
											timestamp: e.timestamp || (0, Fr.yW)()
										}, m = t.integrations || i.integrations.map($ => $.name);
										(function N_(i, e) {
											const {
												environment: t,
												release: s,
												dist: c,
												maxValueLength: u = 250
											} = e;
											"environment" in i || (i.environment = "environment" in e ? t : zu), void 0 === i.release && void 0 !== s && (i.release = s), void 0 === i.dist && void 0 !== c && (i.dist = c), i.message && (i.message = Ua(i.message, u));
											const h = i.exception && i.exception.values && i.exception.values[0];
											h && h.value && (h.value = Ua(h.value, u));
											const m = i.request;
											m && m.url && (m.url = Ua(m.url, u))
										})(h, i),
										function _f(i, e) {
											e.length > 0 && (i.sdk = i.sdk || {}, i.sdk.integrations = [...i.sdk.integrations || [], ...e])
										}(h, m), void 0 === e.type && function k_(i, e) {
											const t = qr.n2._sentryDebugIds;
											if (!t) return;
											let s;
											const c = ld.get(e);
											c ? s = c : (s = new Map, ld.set(e, s));
											const u = Object.keys(t).reduce((S, O) => {
													let $;
													const le = s.get(O);
													le ? $ = le : ($ = e(O), s.set(O, $));
													for (let Re = $.length - 1; Re >= 0; Re--) {
														const Ae = $[Re];
														if (Ae.filename) {
															S[Ae.filename] = t[O];
															break
														}
													}
													return S
												}, {}),
												h = new Set;
											try {
												i.exception.values.forEach(S => {
													S.stacktrace.frames.forEach(O => {
														O.filename && h.add(O.filename)
													})
												})
											} catch {}
											i.debug_meta = i.debug_meta || {}, i.debug_meta.images = i.debug_meta.images || [];
											const m = i.debug_meta.images;
											h.forEach(S => {
												u[S] && m.push({
													type: "sourcemap",
													code_file: S,
													debug_id: u[S]
												})
											})
										}(h, i.stackParser);
										let S = s;
										t.captureContext && (S = Vs.clone(S).update(t.captureContext));
										let O = Hs(h);
										if (S) {
											if (S.getAttachments) {
												const $ = [...t.attachments || [], ...S.getAttachments()];
												$.length && (t.attachments = $)
											}
											O = S.applyToEvent(h, t)
										}
										return O.then($ => "number" == typeof c && c > 0 ? function vf(i, e, t) {
											if (!i) return null;
											const s = {
												...i,
												...i.breadcrumbs && {
													breadcrumbs: i.breadcrumbs.map(c => ({
														...c,
														...c.data && {
															data: fs(c.data, e, t)
														}
													}))
												},
												...i.user && {
													user: fs(i.user, e, t)
												},
												...i.contexts && {
													contexts: fs(i.contexts, e, t)
												},
												...i.extra && {
													extra: fs(i.extra, e, t)
												}
											};
											return i.contexts && i.contexts.trace && s.contexts && (s.contexts.trace = i.contexts.trace, i.contexts.trace.data && (s.contexts.trace.data = fs(i.contexts.trace.data, e, t))), i.spans && (s.spans = i.spans.map(c => (c.data && (c.data = fs(c.data, e, t)), c))), s
										}($, c, u) : $)
									}(c, e, t, s)
							}
							_captureEvent(e, t = {}, s) {
								return this._processEvent(e, t, s).then(c => c.event_id, c => {
									if (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) {
										const u = c;
										"log" === u.logLevel ? Ut.log(u.message) : Ut.warn(u)
									}
								})
							}
							_processEvent(e, t, s) {
								const c = this.getOptions(),
									{
										sampleRate: u
									} = c;
								if (!this._isEnabled()) return Hc(new ii("SDK not enabled, will not capture event.", "log"));
								const h = Ef(e),
									m = io(e),
									S = e.type || "error",
									O = `before send for type \`${S}\``;
								if (m && "number" == typeof u && Math.random() > u) return this.recordDroppedEvent("sample_rate", "error", e), Hc(new ii(`Discarding event because it's not included in the random sample (sampling rate = ${u})`, "log"));
								const $ = "replay_event" === S ? "replay" : S;
								return this._prepareEvent(e, t, s).then(le => {
									if (null === le) throw this.recordDroppedEvent("event_processor", $, e), new ii("An event processor returned `null`, will not send event.", "log");
									if (t.data && !0 === t.data.__sentry__) return le;
									const Ae = function Ig(i, e, t) {
										const {
											beforeSend: s,
											beforeSendTransaction: c
										} = i;
										return io(e) && s ? s(e, t) : Ef(e) && c ? c(e, t) : e
									}(c, le, t);
									return function bg(i, e) {
										const t = `${e} must return \`null\` or a valid event.`;
										if (Lu(i)) return i.then(s => {
											if (!Fa(s) && null !== s) throw new ii(t);
											return s
										}, s => {
											throw new ii(`${e} rejected with ${s}`)
										});
										if (!Fa(i) && null !== i) throw new ii(t);
										return i
									}(Ae, O)
								}).then(le => {
									if (null === le) throw this.recordDroppedEvent("before_send", $, e), new ii(`${O} returned \`null\`, will not send event.`, "log");
									const Re = s && s.getSession();
									!h && Re && this._updateSessionFromEvent(Re, le);
									const Ae = le.transaction_info;
									if (h && Ae && le.transaction !== e.transaction) {
										const Ze = "custom";
										le.transaction_info = {
											...Ae,
											source: Ze
										}
									}
									return this.sendEvent(le, t), le
								}).then(null, le => {
									throw le instanceof ii ? le : (this.captureException(le, {
										data: {
											__sentry__: !0
										},
										originalException: le
									}), new ii(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: ${le}`))
								})
							}
							_process(e) {
								this._numProcessing++, e.then(t => (this._numProcessing--, t), t => (this._numProcessing--, t))
							}
							_sendEnvelope(e) {
								if (this._transport && this._dsn) return this.emit("beforeEnvelope", e), this._transport.send(e).then(null, t => {
									(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.error("Error while sending event:", t)
								});
								(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.error("Transport disabled")
							}
							_clearOutcomes() {
								const e = this._outcomes;
								return this._outcomes = {}, Object.keys(e).map(t => {
									const [s, c] = t.split(":");
									return {
										reason: s,
										category: c,
										quantity: e[t]
									}
								})
							}
						}

						function io(i) {
							return void 0 === i.type
						}

						function Ef(i) {
							return "transaction" === i.type
						}
						const Yc = "7.50.0";
						var Dg = E(4033);

						function Cf(i, e) {
							const t = ud(i, e),
								s = {
									type: e && e.name,
									value: Ln(e)
								};
							return t.length && (s.stacktrace = {
								frames: t
							}), void 0 === s.type && "" === s.value && (s.value = "Unrecoverable error caught"), s
						}

						function Gl(i, e) {
							return {
								exception: {
									values: [Cf(i, e)]
								}
							}
						}

						function ud(i, e) {
							const t = e.stacktrace || e.stack || "",
								s = function Og(i) {
									if (i) {
										if ("number" == typeof i.framesToPop) return i.framesToPop;
										if (Mg.test(i.message)) return 1
									}
									return 0
								}(e);
							try {
								return i(t, s)
							} catch {}
							return []
						}
						const Mg = /Minified React error #\d+;/i;

						function Ln(i) {
							const e = i && i.message;
							return e ? e.error && "string" == typeof e.error.message ? e.error.message : e : "No error message"
						}

						function jl(i, e, t, s, c) {
							let u;
							if (wl(e) && e.error) return Gl(i, e.error);
							if (xu(e) || function xa(i) {
									return cs(i, "DOMException")
								}(e)) {
								const h = e;
								if ("stack" in e) u = Gl(i, e);
								else {
									const m = h.name || (xu(h) ? "DOMError" : "DOMException"),
										S = h.message ? `${m}: ${h.message}` : m;
									u = dd(i, S, t, s), Gu(u, S)
								}
								return "code" in h && (u.tags = {
									...u.tags,
									"DOMException.code": `${h.code}`
								}), u
							}
							return Rh(e) ? Gl(i, e) : Fa(e) || Uc(e) ? (u = function Rg(i, e, t, s) {
								const u = _r().getClient(),
									h = u && u.getOptions().normalizeDepth,
									m = {
										exception: {
											values: [{
												type: Uc(e) ? e.constructor.name : s ? "UnhandledRejection" : "Error",
												value: `Non-Error ${s?"promise rejection":"exception"} captured with keys: ${Dl(e)}`
											}]
										},
										extra: {
											__serialized__: id(e, h)
										}
									};
								if (t) {
									const S = ud(i, t);
									S.length && (m.exception.values[0].stacktrace = {
										frames: S
									})
								}
								return m
							}(i, e, t, c), ds(u, {
								synthetic: !0
							}), u) : (u = dd(i, e, t, s), Gu(u, `${e}`, void 0), ds(u, {
								synthetic: !0
							}), u)
						}

						function dd(i, e, t, s) {
							const c = {
								message: e
							};
							if (s && t) {
								const u = ud(i, t);
								u.length && (c.exception = {
									values: [{
										value: e,
										stacktrace: {
											frames: u
										}
									}]
								})
							}
							return c
						}

						function wf(i, e) {
							return _r().captureException(i, {
								captureContext: e
							})
						}
						const er = qr.n2;
						let If = 0;

						function Lg() {
							return If > 0
						}

						function qa(i, e = {}, t) {
							if ("function" != typeof i) return i;
							try {
								const c = i.__sentry_wrapped__;
								if (c) return c;
								if (bl(i)) return i
							} catch {
								return i
							}
							const s = function() {
								const c = Array.prototype.slice.call(arguments);
								try {
									t && "function" == typeof t && t.apply(this, arguments);
									const u = c.map(h => qa(h, e));
									return i.apply(this, u)
								} catch (u) {
									throw function U_() {
											If++, setTimeout(() => {
												If--
											})
										}(),
										function hd(i) {
											_r().withScope(i)
										}(h => {
											h.addEventProcessor(m => (e.mechanism && (Gu(m, void 0, void 0), ds(m, e.mechanism)), m.extra = {
												...m.extra,
												arguments: c
											}, m)), wf(u)
										}), u
								}
							};
							try {
								for (const c in i) Object.prototype.hasOwnProperty.call(i, c) && (s[c] = i[c])
							} catch {}
							kh(s, i), Ha(i, "__sentry_wrapped__", s);
							try {
								Object.getOwnPropertyDescriptor(s, "name").configurable && Object.defineProperty(s, "name", {
									get: () => i.name
								})
							} catch {}
							return s
						}
						const Df = ["fatal", "error", "warning", "log", "info", "debug"];

						function Af(i) {
							return "warn" === i ? "warning" : Df.includes(i) ? i : "log"
						}

						function gs(i) {
							if (!i) return {};
							const e = i.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
							if (!e) return {};
							const t = e[6] || "",
								s = e[8] || "";
							return {
								host: e[4],
								path: e[5],
								protocol: e[2],
								search: t,
								hash: s,
								relative: e[5] + t + s
							}
						}
						const Vl = 1024,
							pd = "Breadcrumbs";
						class Wc {
							static __initStatic() {
								this.id = pd
							}
							__init() {
								this.name = Wc.id
							}
							constructor(e) {
								Wc.prototype.__init.call(this), this.options = {
									console: !0,
									dom: !0,
									fetch: !0,
									history: !0,
									sentry: !0,
									xhr: !0,
									...e
								}
							}
							setupOnce() {
								this.options.console && ci("console", Gg), this.options.dom && ci("dom", function Hg(i) {
									return function e(t) {
										let s, c = "object" == typeof i ? i.serializeAttribute : void 0,
											u = "object" == typeof i && "number" == typeof i.maxStringLength ? i.maxStringLength : void 0;
										u && u > Vl && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn(`\`dom.maxStringLength\` cannot exceed ${Vl}, but a value of ${u} was configured. Sentry will use ${Vl} instead.`), u = Vl), "string" == typeof c && (c = [c]);
										try {
											const h = t.event;
											s = function $g(i) {
												return i && !!i.target
											}(h) ? us(h.target, {
												keyAttrs: c,
												maxStringLength: u
											}) : us(h, {
												keyAttrs: c,
												maxStringLength: u
											})
										} catch {
											s = "<unknown>"
										}
										0 !== s.length && _r().addBreadcrumb({
											category: `ui.${t.name}`,
											message: s
										}, {
											event: t.event,
											name: t.name,
											global: t.global
										})
									}
								}(this.options.dom)), this.options.xhr && ci("xhr", jg), this.options.fetch && ci("fetch", Vg), this.options.history && ci("history", Rf)
							}
							addSentryBreadcrumb(e) {
								this.options.sentry && _r().addBreadcrumb({
									category: "sentry." + ("transaction" === e.type ? "transaction" : "event"),
									event_id: e.event_id,
									level: e.level,
									message: no(e)
								}, {
									event: e
								})
							}
						}

						function Gg(i) {
							for (let t = 0; t < i.args.length; t++)
								if ("ref=Ref<" === i.args[t]) {
									i.args[t + 1] = "viewRef";
									break
								} const e = {
								category: "console",
								data: {
									arguments: i.args,
									logger: "console"
								},
								level: Af(i.level),
								message: Uu(i.args, " ")
							};
							if ("assert" === i.level) {
								if (!1 !== i.args[0]) return;
								e.message = `Assertion failed: ${Uu(i.args.slice(1)," ")||"console.assert"}`, e.data.arguments = i.args.slice(1)
							}
							_r().addBreadcrumb(e, {
								input: i.args,
								level: i.level
							})
						}

						function jg(i) {
							const {
								startTimestamp: e,
								endTimestamp: t
							} = i, s = i.xhr[Vo];
							if (!e || !t || !s) return;
							const {
								method: c,
								url: u,
								status_code: h,
								body: m
							} = s, S = {
								method: c,
								url: u,
								status_code: h
							}, O = {
								xhr: i.xhr,
								input: m,
								startTimestamp: e,
								endTimestamp: t
							};
							_r().addBreadcrumb({
								category: "xhr",
								data: S,
								type: "http"
							}, O)
						}

						function Vg(i) {
							const {
								startTimestamp: e,
								endTimestamp: t
							} = i;
							if (t && (!i.fetchData.url.match(/sentry_key/) || "POST" !== i.fetchData.method))
								if (i.error) {
									const s = i.fetchData,
										c = {
											data: i.error,
											input: i.args,
											startTimestamp: e,
											endTimestamp: t
										};
									_r().addBreadcrumb({
										category: "fetch",
										data: s,
										level: "error",
										type: "http"
									}, c)
								} else {
									const s = {
											...i.fetchData,
											status_code: i.response && i.response.status
										},
										c = {
											input: i.args,
											response: i.response,
											startTimestamp: e,
											endTimestamp: t
										};
									_r().addBreadcrumb({
										category: "fetch",
										data: s,
										type: "http"
									}, c)
								}
						}

						function Rf(i) {
							let e = i.from,
								t = i.to;
							const s = gs(er.location.href);
							let c = gs(e);
							const u = gs(t);
							c.path || (c = s), s.protocol === u.protocol && s.host === u.host && (t = u.relative), s.protocol === c.protocol && s.host === c.host && (e = c.relative), _r().addBreadcrumb({
								category: "navigation",
								data: {
									from: e,
									to: t
								}
							})
						}
						Wc.__initStatic();
						class gd extends ps {
							constructor(e) {
								const t = er.SENTRY_SDK_SOURCE || (0, Dg.S)();
								e._metadata = e._metadata || {}, e._metadata.sdk = e._metadata.sdk || {
									name: "sentry.javascript.browser",
									packages: [{
										name: `${t}:@sentry/browser`,
										version: Yc
									}],
									version: Yc
								}, super(e), e.sendClientReports && er.document && er.document.addEventListener("visibilitychange", () => {
									"hidden" === er.document.visibilityState && this._flushOutcomes()
								})
							}
							eventFromException(e, t) {
								return function Sf(i, e, t, s) {
									const u = jl(i, e, t && t.syntheticException || void 0, s);
									return ds(u), u.level = "error", t && t.event_id && (u.event_id = t.event_id), Hs(u)
								}(this._options.stackParser, e, t, this._options.attachStacktrace)
							}
							eventFromMessage(e, t = "info", s) {
								return function Tf(i, e, t = "info", s, c) {
									const h = dd(i, e, s && s.syntheticException || void 0, c);
									return h.level = t, s && s.event_id && (h.event_id = s.event_id), Hs(h)
								}(this._options.stackParser, e, t, s, this._options.attachStacktrace)
							}
							sendEvent(e, t) {
								const s = this.getIntegrationById(pd);
								s && s.addSentryBreadcrumb && s.addSentryBreadcrumb(e), super.sendEvent(e, t)
							}
							captureUserFeedback(e) {
								if (!this._isEnabled()) return void((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn("SDK not enabled, will not capture user feedback."));
								const t = function Mf(i, {
									metadata: e,
									tunnel: t,
									dsn: s
								}) {
									const c = {
											event_id: i.event_id,
											sent_at: (new Date).toISOString(),
											...e && e.sdk && {
												sdk: {
													name: e.sdk.name,
													version: e.sdk.version
												}
											},
											...!!t && !!s && {
												dsn: jc(s)
											}
										},
										u = function Of(i) {
											return [{
												type: "user_report"
											}, i]
										}(i);
									return zs(c, [u])
								}(e, {
									metadata: this.getSdkMetadata(),
									dsn: this.getDsn(),
									tunnel: this.getOptions().tunnel
								});
								this._sendEnvelope(t)
							}
							_prepareEvent(e, t, s) {
								return e.platform = e.platform || "javascript", super._prepareEvent(e, t, s)
							}
							_flushOutcomes() {
								const e = this._clearOutcomes();
								if (0 === e.length) return void((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("No outcomes to send"));
								if (!this._dsn) return void((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("No dsn provided, will not send outcomes"));
								(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("Sending outcomes:", e);
								const t = function Ag(i, e, t) {
									return zs(e ? {
										dsn: e
									} : {}, [
										[{
											type: "client_report"
										}, {
											timestamp: t || (0, Fr.yW)(),
											discarded_events: i
										}]
									])
								}(e, this._options.tunnel && jc(this._dsn));
								this._sendEnvelope(t)
							}
						}
						class Ys {
							static __initStatic() {
								this.id = "GlobalHandlers"
							}
							__init() {
								this.name = Ys.id
							}
							__init2() {
								this._installFunc = {
									onerror: md,
									onunhandledrejection: zg
								}
							}
							constructor(e) {
								Ys.prototype.__init.call(this), Ys.prototype.__init2.call(this), this._options = {
									onerror: !0,
									onunhandledrejection: !0,
									...e
								}
							}
							setupOnce() {
								Error.stackTraceLimit = 50;
								const e = this._options;
								for (const t in e) {
									const s = this._installFunc[t];
									s && e[t] && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log(`Global Handler attached: ${t}`), s(), this._installFunc[t] = void 0)
								}
							}
						}

						function md() {
							ci("error", i => {
								const [e, t, s] = Pf();
								if (!e.getIntegration(Ys)) return;
								const {
									msg: c,
									url: u,
									line: h,
									column: m,
									error: S
								} = i;
								if (Lg() || S && S.__sentry_own_request__) return;
								const O = void 0 === S && ki(c) ? function Qa(i, e, t, s) {
									let u = wl(i) ? i.message : i,
										h = "Error";
									const m = u.match(/^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i);
									return m && (h = m[1], u = m[2]), _d({
										exception: {
											values: [{
												type: h,
												value: u
											}]
										}
									}, e, t, s)
								}(c, u, h, m) : _d(jl(t, S || c, void 0, s, !1), u, h, m);
								O.level = "error", vd(e, S, O, "onerror")
							})
						}

						function zg() {
							ci("unhandledrejection", i => {
								const [e, t, s] = Pf();
								if (!e.getIntegration(Ys)) return;
								let c = i;
								try {
									"reason" in i ? c = i.reason : "detail" in i && "reason" in i.detail && (c = i.detail.reason)
								} catch {}
								if (Lg() || c && c.__sentry_own_request__) return !0;
								const u = Fu(c) ? function B_(i) {
									return {
										exception: {
											values: [{
												type: "UnhandledRejection",
												value: `Non-Error promise rejection captured with value: ${String(i)}`
											}]
										}
									}
								}(c) : jl(t, c, void 0, s, !0);
								u.level = "error", vd(e, c, u, "onunhandledrejection")
							})
						}

						function _d(i, e, t, s) {
							const c = i.exception = i.exception || {},
								u = c.values = c.values || [],
								h = u[0] = u[0] || {},
								m = h.stacktrace = h.stacktrace || {},
								S = m.frames = m.frames || [],
								O = isNaN(parseInt(s, 10)) ? void 0 : s,
								$ = isNaN(parseInt(t, 10)) ? void 0 : t,
								le = ki(e) && e.length > 0 ? e : function Xp() {
									try {
										return La.document.location.href
									} catch {
										return ""
									}
								}();
							return 0 === S.length && S.push({
								colno: O,
								filename: le,
								function: "?",
								in_app: !0,
								lineno: $
							}), i
						}

						function vd(i, e, t, s) {
							ds(t, {
								handled: !1,
								type: s
							}), i.captureEvent(t, {
								originalException: e
							})
						}

						function Pf() {
							const i = _r(),
								e = i.getClient(),
								t = e && e.getOptions() || {
									stackParser: () => [],
									attachStacktrace: !1
								};
							return [i, t.stackParser, t.attachStacktrace]
						}
						Ys.__initStatic();
						const Yg = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"];
						class ms {
							static __initStatic() {
								this.id = "TryCatch"
							}
							__init() {
								this.name = ms.id
							}
							constructor(e) {
								ms.prototype.__init.call(this), this._options = {
									XMLHttpRequest: !0,
									eventTarget: !0,
									requestAnimationFrame: !0,
									setInterval: !0,
									setTimeout: !0,
									...e
								}
							}
							setupOnce() {
								this._options.setTimeout && Ci(er, "setTimeout", Ws), this._options.setInterval && Ci(er, "setInterval", Ws), this._options.requestAnimationFrame && Ci(er, "requestAnimationFrame", yd), this._options.XMLHttpRequest && "XMLHttpRequest" in er && Ci(XMLHttpRequest.prototype, "send", qc);
								const e = this._options.eventTarget;
								e && (Array.isArray(e) ? e : Yg).forEach(Ed)
							}
						}

						function Ws(i) {
							return function(...e) {
								return e[0] = qa(e[0], {
									mechanism: {
										data: {
											function: jo(i)
										},
										handled: !0,
										type: "instrument"
									}
								}), i.apply(this, e)
							}
						}

						function yd(i) {
							return function(e) {
								return i.apply(this, [qa(e, {
									mechanism: {
										data: {
											function: "requestAnimationFrame",
											handler: jo(i)
										},
										handled: !0,
										type: "instrument"
									}
								})])
							}
						}

						function qc(i) {
							return function(...e) {
								const t = this;
								return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach(c => {
									c in t && "function" == typeof t[c] && Ci(t, c, function(u) {
										const h = {
												mechanism: {
													data: {
														function: c,
														handler: jo(u)
													},
													handled: !0,
													type: "instrument"
												}
											},
											m = bl(u);
										return m && (h.mechanism.data.handler = jo(m)), qa(u, h)
									})
								}), i.apply(this, e)
							}
						}

						function Ed(i) {
							const t = er[i] && er[i].prototype;
							!t || !t.hasOwnProperty || !t.hasOwnProperty("addEventListener") || (Ci(t, "addEventListener", function(s) {
								return function(c, u, h) {
									try {
										"function" == typeof u.handleEvent && (u.handleEvent = qa(u.handleEvent, {
											mechanism: {
												data: {
													function: "handleEvent",
													handler: jo(u),
													target: i
												},
												handled: !0,
												type: "instrument"
											}
										}))
									} catch {}
									return s.apply(this, [c, qa(u, {
										mechanism: {
											data: {
												function: "addEventListener",
												handler: jo(u),
												target: i
											},
											handled: !0,
											type: "instrument"
										}
									}), h])
								}
							}), Ci(t, "removeEventListener", function(s) {
								return function(c, u, h) {
									const m = u;
									try {
										const S = m && m.__sentry_wrapped__;
										S && s.call(this, c, S, h)
									} catch {}
									return s.call(this, c, m, h)
								}
							}))
						}
						ms.__initStatic();
						class _s {
							static __initStatic() {
								this.id = "LinkedErrors"
							}
							__init() {
								this.name = _s.id
							}
							constructor(e = {}) {
								_s.prototype.__init.call(this), this._key = e.key || "cause", this._limit = e.limit || 5
							}
							setupOnce() {
								const e = _r().getClient();
								e && Yu((t, s) => {
									const c = _r().getIntegration(_s);
									return c ? function Cd(i, e, t, s, c) {
										if (!(s.exception && s.exception.values && c && ls(c.originalException, Error))) return s;
										const u = zl(i, t, c.originalException, e);
										return s.exception.values = [...u, ...s.exception.values], s
									}(e.getOptions().stackParser, c._key, c._limit, t, s) : t
								})
							}
						}

						function zl(i, e, t, s, c = []) {
							if (!ls(t[s], Error) || c.length + 1 >= e) return c;
							const u = Cf(i, t[s]);
							return zl(i, e, t[s], s, [u, ...c])
						}
						_s.__initStatic();
						class qs {
							constructor() {
								qs.prototype.__init.call(this)
							}
							static __initStatic() {
								this.id = "HttpContext"
							}
							__init() {
								this.name = qs.id
							}
							setupOnce() {
								Yu(e => {
									if (_r().getIntegration(qs)) {
										if (!er.navigator && !er.location && !er.document) return e;
										const t = e.request && e.request.url || er.location && er.location.href,
											{
												referrer: s
											} = er.document || {},
											{
												userAgent: c
											} = er.navigator || {},
											u = {
												...e.request && e.request.headers,
												...s && {
													Referer: s
												},
												...c && {
													"User-Agent": c
												}
											},
											h = {
												...e.request,
												...t && {
													url: t
												},
												headers: u
											};
										return {
											...e,
											request: h
										}
									}
									return e
								})
							}
						}
						qs.__initStatic();
						class vs {
							constructor() {
								vs.prototype.__init.call(this)
							}
							static __initStatic() {
								this.id = "Dedupe"
							}
							__init() {
								this.name = vs.id
							}
							setupOnce(e, t) {
								const s = c => {
									if (c.type) return c;
									const u = t().getIntegration(vs);
									if (u) {
										try {
											if (function Wg(i, e) {
													return !(!e || ! function qg(i, e) {
														const t = i.message,
															s = e.message;
														return !(!t && !s || t && !s || !t && s || t !== s || !Sd(i, e) || !xf(i, e))
													}(i, e) && ! function kf(i, e) {
														const t = Td(e),
															s = Td(i);
														return !!(t && s && t.type === s.type && t.value === s.value && Sd(i, e) && xf(i, e))
													}(i, e))
												}(c, u._previousEvent)) return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn("Event dropped due to being a duplicate of previously captured event."), null
										} catch {
											return u._previousEvent = c
										}
										return u._previousEvent = c
									}
									return c
								};
								s.id = this.name, e(s)
							}
						}

						function xf(i, e) {
							let t = Ff(i),
								s = Ff(e);
							if (!t && !s) return !0;
							if (t && !s || !t && s || s.length !== t.length) return !1;
							for (let c = 0; c < s.length; c++) {
								const u = s[c],
									h = t[c];
								if (u.filename !== h.filename || u.lineno !== h.lineno || u.colno !== h.colno || u.function !== h.function) return !1
							}
							return !0
						}

						function Sd(i, e) {
							let t = i.fingerprint,
								s = e.fingerprint;
							if (!t && !s) return !0;
							if (t && !s || !t && s) return !1;
							try {
								return t.join("") === s.join("")
							} catch {
								return !1
							}
						}

						function Td(i) {
							return i.exception && i.exception.values && i.exception.values[0]
						}

						function Ff(i) {
							const e = i.exception;
							if (e) try {
								return e.values[0].stacktrace.frames
							} catch {
								return
							}
						}

						function Xa(i, e, t, s) {
							const c = {
								filename: i,
								function: e,
								in_app: !0
							};
							return void 0 !== t && (c.lineno = t), void 0 !== s && (c.colno = s), c
						}
						vs.__initStatic();
						const Jg = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
							Xg = /\((\S*)(?::(\d+))(?::(\d+))\)/,
							Zg = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i,
							em = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i,
							nm = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:[-a-z]+):.*?):(\d+)(?::(\d+))?\)?\s*$/i,
							am = Va([30, i => {
								const e = Jg.exec(i);
								if (e) {
									if (e[2] && 0 === e[2].indexOf("eval")) {
										const u = Xg.exec(e[2]);
										u && (e[2] = u[1], e[3] = u[2], e[4] = u[3])
									}
									const [s, c] = Gf(e[1] || "?", e[2]);
									return Xa(c, s, e[3] ? +e[3] : void 0, e[4] ? +e[4] : void 0)
								}
							}], [50, i => {
								const e = Zg.exec(i);
								if (e) {
									if (e[3] && e[3].indexOf(" > eval") > -1) {
										const u = em.exec(e[3]);
										u && (e[1] = e[1] || "eval", e[3] = u[1], e[4] = u[2], e[5] = "")
									}
									let s = e[3],
										c = e[1] || "?";
									return [c, s] = Gf(c, s), Xa(s, c, e[4] ? +e[4] : void 0, e[5] ? +e[5] : void 0)
								}
							}], [40, i => {
								const e = nm.exec(i);
								return e ? Xa(e[2], e[1] || "?", +e[3], e[4] ? +e[4] : void 0) : void 0
							}]),
							Gf = (i, e) => {
								const t = -1 !== i.indexOf("safari-extension"),
									s = -1 !== i.indexOf("safari-web-extension");
								return t || s ? [-1 !== i.indexOf("@") ? i.split("@")[0] : "?", t ? `safari-extension:${e}` : `safari-web-extension:${e}`] : [i, e]
							};
						const cm = 6e4;
						const z_ = 30;

						function Wl(i, e, t = function bd(i) {
							const e = [];

							function s(h) {
								return e.splice(e.indexOf(h), 1)[0]
							}
							return {
								$: e,
								add: function c(h) {
									if (! function t() {
											return void 0 === i || e.length < i
										}()) return Hc(new ii("Not adding Promise because buffer limit was reached."));
									const m = h();
									return -1 === e.indexOf(m) && e.push(m), m.then(() => s(m)).then(null, () => s(m).then(null, () => {})), m
								},
								drain: function u(h) {
									return new ai((m, S) => {
										let O = e.length;
										if (!O) return m(!0);
										const $ = setTimeout(() => {
											h && h > 0 && m(!1)
										}, h);
										e.forEach(le => {
											Hs(le).then(() => {
												--O || (clearTimeout($), m(!0))
											}, S)
										})
									})
								}
							}
						}(i.bufferSize || z_)) {
							let s = {};

							function u(h) {
								const m = [];
								if (ad(h, (le, Re) => {
										const Ae = cd(Re);
										if (function Id(i, e, t = Date.now()) {
												return function Kl(i, e) {
													return i[e] || i.all || 0
												}(i, e) > t
											}(s, Ae)) {
											const Ze = um(le, Re);
											i.recordDroppedEvent("ratelimit_backoff", Ae, Ze)
										} else m.push(le)
									}), 0 === m.length) return Hs();
								const S = zs(h[0], m),
									O = le => {
										ad(S, (Re, Ae) => {
											const Ze = um(Re, Ae);
											i.recordDroppedEvent(le, cd(Ae), Ze)
										})
									};
								return t.add(() => e({
									body: Eg(S, i.textEncoder)
								}).then(le => (void 0 !== le.statusCode && (le.statusCode < 200 || le.statusCode >= 300) && (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn(`Sentry responded with status code ${le.statusCode} to sent event.`), s = function Yl(i, {
									statusCode: e,
									headers: t
								}, s = Date.now()) {
									const c = {
											...i
										},
										u = t && t["x-sentry-rate-limits"],
										h = t && t["retry-after"];
									if (u)
										for (const m of u.trim().split(",")) {
											const [S, O] = m.split(":", 2), $ = parseInt(S, 10), le = 1e3 * (isNaN($) ? 60 : $);
											if (O)
												for (const Re of O.split(";")) c[Re] = s + le;
											else c.all = s + le
										} else h ? c.all = s + function lm(i, e = Date.now()) {
											const t = parseInt(`${i}`, 10);
											if (!isNaN(t)) return 1e3 * t;
											const s = Date.parse(`${i}`);
											return isNaN(s) ? cm : s - e
										}(h, s) : 429 === e && (c.all = s + 6e4);
									return c
								}(s, le), le), le => {
									throw O("network_error"), le
								})).then(le => le, le => {
									if (le instanceof ii) return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.error("Skipped sending event because buffer is full."), O("queue_overflow"), Hs();
									throw le
								})
							}
							return u.__sentry__baseTransport__ = !0, {
								send: u,
								flush: h => t.drain(h)
							}
						}

						function um(i, e) {
							if ("event" === e || "transaction" === e) return Array.isArray(i) ? i[1] : void 0
						}
						let Za;

						function $f(i, e = function jf() {
							if (Za) return Za;
							if (Vc(er.fetch)) return Za = er.fetch.bind(er);
							const i = er.document;
							let e = er.fetch;
							if (i && "function" == typeof i.createElement) try {
								const t = i.createElement("iframe");
								t.hidden = !0, i.head.appendChild(t);
								const s = t.contentWindow;
								s && s.fetch && (e = s.fetch), i.head.removeChild(t)
							} catch (t) {
								(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", t)
							}
							return Za = e.bind(er)
						}()) {
							let t = 0,
								s = 0;
							return Wl(i, function c(u) {
								const h = u.body.length;
								t += h, s++;
								const m = {
									body: u.body,
									method: "POST",
									referrerPolicy: "origin",
									headers: i.headers,
									keepalive: t <= 6e4 && s < 15,
									...i.fetchOptions
								};
								try {
									return e(i.url, m).then(S => (t -= h, s--, {
										statusCode: S.status,
										headers: {
											"x-sentry-rate-limits": S.headers.get("X-Sentry-Rate-Limits"),
											"retry-after": S.headers.get("Retry-After")
										}
									}))
								} catch (S) {
									return function Vf() {
										Za = void 0
									}(), t -= h, s--, Hc(S)
								}
							})
						}
						const Dd = 4;

						function Ko(i) {
							return Wl(i, function e(t) {
								return new ai((s, c) => {
									const u = new XMLHttpRequest;
									u.onerror = c, u.onreadystatechange = () => {
										u.readyState === Dd && s({
											statusCode: u.status,
											headers: {
												"x-sentry-rate-limits": u.getResponseHeader("X-Sentry-Rate-Limits"),
												"retry-after": u.getResponseHeader("Retry-After")
											}
										})
									}, u.open("POST", i.url);
									for (const h in i.headers) Object.prototype.hasOwnProperty.call(i.headers, h) && u.setRequestHeader(h, i.headers[h]);
									u.send(t.body)
								})
							})
						}
						const ql = [new Ga, new Nl, new ms, new Wc, new Ys, new _s, new vs, new qs];

						function ec(i = {}, e = _r()) {
							if (!er.document) return void((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.error("Global document not defined in showReportDialog call"));
							const {
								client: t,
								scope: s
							} = e.getStackTop(), c = i.dsn || t && t.getDsn();
							if (!c) return void((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.error("DSN not configured for showReportDialog call"));
							s && (i.user = {
								...s.getUser(),
								...i.user
							}), i.eventId || (i.eventId = e.lastEventId());
							const u = er.document.createElement("script");
							u.async = !0, u.src = function Zh(i, e) {
								const t = kl(i),
									s = `${Xh(t)}embed/error-page/`;
								let c = `dsn=${jc(t)}`;
								for (const u in e)
									if ("dsn" !== u)
										if ("user" === u) {
											const h = e.user;
											if (!h) continue;
											h.name && (c += `&name=${encodeURIComponent(h.name)}`), h.email && (c += `&email=${encodeURIComponent(h.email)}`)
										} else c += `&${encodeURIComponent(u)}=${encodeURIComponent(e[u])}`;
								return `${s}?${c}`
							}(c, i), i.onLoad && (u.onload = i.onLoad);
							const h = er.document.head || er.document.body;
							h ? h.appendChild(u) : (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.error("Not injecting report dialog. No injection point found in HTML")
						}

						function zf(i) {
							i.startSession({
								ignoreDuration: !0
							}), i.captureSession()
						}
						var fm = E(2292),
							Ad = E(7374);
						const Kf = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__,
							mm = typeof Zone < "u" && !!Zone.current;

						function Rd(i) {
							return mm ? Zone.root.run(i) : i()
						}

						function Xl(i) {
							if (i instanceof Error) return !0;
							if (null === i || "object" != typeof i) return !1;
							const e = i;
							return ki(e.name) && ki(e.name) && ki(e.message) && (void 0 === e.stack || ki(e.stack))
						}
						let Yf, Wf, Od, vm = (() => {
							class i {
								constructor(t) {
									this._registeredAfterSendEventHandler = !1, this._options = Object.assign({
										logErrors: !0
									}, t)
								}
								handleError(t) {
									const s = this._extractError(t) || "Handled unknown error",
										c = Rd(() => wf(s, u => (u.addEventProcessor(h => (ds(h, {
											type: "angular",
											handled: !1
										}), h)), u)));
									if (this._options.logErrors && console.error(s), this._options.showDialog) {
										const u = _r().getClient();
										u && u.on && !this._registeredAfterSendEventHandler ? (u.on("afterSendEvent", h => {
											h.type || ec(Object.assign(Object.assign({}, this._options.dialogOptions), {
												eventId: h.event_id
											}))
										}), this._registeredAfterSendEventHandler = !0) : (!u || !u.on) && ec(Object.assign(Object.assign({}, this._options.dialogOptions), {
											eventId: c
										}))
									}
								}
								_extractError(t) {
									if (this._options.extractor) {
										const s = this._defaultExtractor.bind(this);
										return this._options.extractor(t, s)
									}
									return this._defaultExtractor(t)
								}
								_defaultExtractor(t) {
									const s = function Md(i) {
										return i && i.ngOriginalError ? i.ngOriginalError : i
									}(t);
									return s instanceof D.UA ? function _m(i) {
										return Xl(i.error) ? i.error : i.error instanceof ErrorEvent && i.error.message ? i.error.message : "string" == typeof i.error ? `Server returned code ${i.status} with body "${i.error}"` : i.message
									}(s) : "string" == typeof s || Xl(s) ? s : null
								}
							}
							return i.\u0275fac = function(t) {
								return new(t || i)(y.LFG("errorHandlerOptions"))
							}, i.\u0275prov = y.Yz7({
								token: i,
								factory: i.\u0275fac,
								providedIn: "root"
							}), i
						})();

						function ym(i) {
							return new vm(i)
						}

						function Pd() {
							const i = _r();
							if (i) {
								const e = i.getScope();
								if (e) return e.getTransaction()
							}
						}
						let Nd = (() => {
								class i {
									constructor(t) {
										this._router = t, this.navStart$ = this._router.events.pipe((0, G.h)(s => s instanceof z.OD), (0, Ad.b)(s => {
											if (!Yf) return void(Kf && Ut.error("Angular integration has tracing enabled, but Tracing integration is not configured"));
											const c = function Ug(i) {
												return i.split(/[\?#]/, 1)[0]
											}(s.url);
											let u = Pd();
											!u && Od && (u = Wf({
												name: c,
												op: "navigation",
												metadata: {
													source: "url"
												}
											})), u && (this._routingSpan && this._routingSpan.finish(), this._routingSpan = u.startChild({
												description: `${s.url}`,
												op: "ui.angular.routing",
												tags: Object.assign({
													"routing.instrumentation": "@sentry/angular",
													url: c
												}, s.navigationTrigger && {
													navigationTrigger: s.navigationTrigger
												})
											}))
										})), this.resEnd$ = this._router.events.pipe((0, G.h)(s => s instanceof z.Av), (0, Ad.b)(s => {
											const c = function Tm(i) {
													const e = [];
													let t = i && i.firstChild;
													for (; t;) {
														const c = t && t.routeConfig && t.routeConfig.path;
														if (null == c) break;
														e.push(c), t = t.firstChild
													}
													const s = e.filter(c => c).join("/");
													return s ? `/${s}/` : "/"
												}(s.state.root),
												u = Pd();
											u && "url" === u.metadata.source && u.setName(c, "route")
										})), this.navEnd$ = this._router.events.pipe((0, G.h)(s => s instanceof z.m2), (0, Ad.b)(() => {
											this._routingSpan && (Rd(() => {
												this._routingSpan.finish()
											}), this._routingSpan = null)
										})), this._routingSpan = null, this._subscription = new fm.w0, this._subscription.add(this.navStart$.subscribe()), this._subscription.add(this.resEnd$.subscribe()), this._subscription.add(this.navEnd$.subscribe())
									}
									ngOnDestroy() {
										this._subscription.unsubscribe()
									}
								}
								return i.\u0275fac = function(t) {
									return new(t || i)(y.LFG(z.F0))
								}, i.\u0275prov = y.Yz7({
									token: i,
									factory: i.\u0275fac,
									providedIn: "root"
								}), i
							})(),
							Fd = (() => {
								class i {}
								return i.\u0275fac = function(t) {
									return new(t || i)
								}, i.\u0275mod = y.oAB({
									type: i,
									bootstrap: [Qn]
								}), i.\u0275inj = y.cJS({
									providers: [{
										provide: y.qLn,
										useValue: ym({
											showDialog: !1
										})
									}, {
										provide: Nd,
										deps: [z.F0]
									}, {
										provide: y.ip1,
										useFactory: () => () => {},
										deps: [Nd],
										multi: !0
									}],
									imports: [p.b2, Vn, un, Lc, D.JF, P.zQ, So, X.Is]
								}), i
							})();
						class Zl {
							__init() {
								this.spans = []
							}
							constructor(e = 1e3) {
								Zl.prototype.__init.call(this), this._maxlen = e
							}
							add(e) {
								this.spans.length > this._maxlen ? e.spanRecorder = void 0 : this.spans.push(e)
							}
						}
						class li {
							__init2() {
								this.traceId = Ao()
							}
							__init3() {
								this.spanId = Ao().substring(16)
							}
							__init4() {
								this.startTimestamp = (0, Fr.ph)()
							}
							__init5() {
								this.tags = {}
							}
							__init6() {
								this.data = {}
							}
							__init7() {
								this.instrumenter = "sentry"
							}
							constructor(e) {
								if (li.prototype.__init2.call(this), li.prototype.__init3.call(this), li.prototype.__init4.call(this), li.prototype.__init5.call(this), li.prototype.__init6.call(this), li.prototype.__init7.call(this), !e) return this;
								e.traceId && (this.traceId = e.traceId), e.spanId && (this.spanId = e.spanId), e.parentSpanId && (this.parentSpanId = e.parentSpanId), "sampled" in e && (this.sampled = e.sampled), e.op && (this.op = e.op), e.description && (this.description = e.description), e.data && (this.data = e.data), e.tags && (this.tags = e.tags), e.status && (this.status = e.status), e.startTimestamp && (this.startTimestamp = e.startTimestamp), e.endTimestamp && (this.endTimestamp = e.endTimestamp), e.instrumenter && (this.instrumenter = e.instrumenter)
							}
							startChild(e) {
								const t = new li({
									...e,
									parentSpanId: this.spanId,
									sampled: this.sampled,
									traceId: this.traceId
								});
								if (t.spanRecorder = this.spanRecorder, t.spanRecorder && t.spanRecorder.add(t), t.transaction = this.transaction, (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && t.transaction) {
									const h = `[Tracing] Starting '${e&&e.op||"< unknown op >"}' span on transaction '${t.transaction.name||"< unknown name >"}' (${t.transaction.spanId}).`;
									t.transaction.metadata.spanMetadata[t.spanId] = {
										logMessage: h
									}, Ut.log(h)
								}
								return t
							}
							setTag(e, t) {
								return this.tags = {
									...this.tags,
									[e]: t
								}, this
							}
							setData(e, t) {
								return this.data = {
									...this.data,
									[e]: t
								}, this
							}
							setStatus(e) {
								return this.status = e, this
							}
							setHttpStatus(e) {
								this.setTag("http.status_code", String(e));
								const t = function Qc(i) {
									if (i < 400 && i >= 100) return "ok";
									if (i >= 400 && i < 500) switch (i) {
										case 401:
											return "unauthenticated";
										case 403:
											return "permission_denied";
										case 404:
											return "not_found";
										case 409:
											return "already_exists";
										case 413:
											return "failed_precondition";
										case 429:
											return "resource_exhausted";
										default:
											return "invalid_argument"
									}
									if (i >= 500 && i < 600) switch (i) {
										case 501:
											return "unimplemented";
										case 503:
											return "unavailable";
										case 504:
											return "deadline_exceeded";
										default:
											return "internal_error"
									}
									return "unknown_error"
								}(e);
								return "unknown_error" !== t && this.setStatus(t), this
							}
							isSuccess() {
								return "ok" === this.status
							}
							finish(e) {
								if ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && this.transaction && this.transaction.spanId !== this.spanId) {
									const {
										logMessage: t
									} = this.transaction.metadata.spanMetadata[this.spanId];
									t && Ut.log(t.replace("Starting", "Finishing"))
								}
								this.endTimestamp = "number" == typeof e ? e : (0, Fr.ph)()
							}
							toTraceparent() {
								let e = "";
								return void 0 !== this.sampled && (e = this.sampled ? "-1" : "-0"), `${this.traceId}-${this.spanId}${e}`
							}
							toContext() {
								return go({
									data: this.data,
									description: this.description,
									endTimestamp: this.endTimestamp,
									op: this.op,
									parentSpanId: this.parentSpanId,
									sampled: this.sampled,
									spanId: this.spanId,
									startTimestamp: this.startTimestamp,
									status: this.status,
									tags: this.tags,
									traceId: this.traceId
								})
							}
							updateWithContext(e) {
								return this.data = e.data || {}, this.description = e.description, this.endTimestamp = e.endTimestamp, this.op = e.op, this.parentSpanId = e.parentSpanId, this.sampled = e.sampled, this.spanId = e.spanId || this.spanId, this.startTimestamp = e.startTimestamp || this.startTimestamp, this.status = e.status, this.tags = e.tags || {}, this.traceId = e.traceId || this.traceId, this
							}
							getTraceContext() {
								return go({
									data: Object.keys(this.data).length > 0 ? this.data : void 0,
									description: this.description,
									op: this.op,
									parent_span_id: this.parentSpanId,
									span_id: this.spanId,
									status: this.status,
									tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
									trace_id: this.traceId
								})
							}
							toJSON() {
								return go({
									data: Object.keys(this.data).length > 0 ? this.data : void 0,
									description: this.description,
									op: this.op,
									parent_span_id: this.parentSpanId,
									span_id: this.spanId,
									start_timestamp: this.startTimestamp,
									status: this.status,
									tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
									timestamp: this.endTimestamp,
									trace_id: this.traceId
								})
							}
						}
						class jr extends li {
							__init() {
								this._measurements = {}
							}
							__init2() {
								this._contexts = {}
							}
							__init3() {
								this._frozenDynamicSamplingContext = void 0
							}
							constructor(e, t) {
								super(e), jr.prototype.__init.call(this), jr.prototype.__init2.call(this), jr.prototype.__init3.call(this), this._hub = t || _r(), this._name = e.name || "", this.metadata = {
									source: "custom",
									...e.metadata,
									spanMetadata: {}
								}, this._trimEnd = e.trimEnd, this.transaction = this;
								const s = this.metadata.dynamicSamplingContext;
								s && (this._frozenDynamicSamplingContext = {
									...s
								})
							}
							get name() {
								return this._name
							}
							set name(e) {
								this.setName(e)
							}
							setName(e, t = "custom") {
								this._name = e, this.metadata.source = t
							}
							initSpanRecorder(e = 1e3) {
								this.spanRecorder || (this.spanRecorder = new Zl(e)), this.spanRecorder.add(this)
							}
							setContext(e, t) {
								null === t ? delete this._contexts[e] : this._contexts[e] = t
							}
							setMeasurement(e, t, s = "") {
								this._measurements[e] = {
									value: t,
									unit: s
								}
							}
							setMetadata(e) {
								this.metadata = {
									...this.metadata,
									...e
								}
							}
							finish(e) {
								if (void 0 !== this.endTimestamp) return;
								this.name || ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn("Transaction has no name, falling back to `<unlabeled transaction>`."), this.name = "<unlabeled transaction>"), super.finish(e);
								const t = this._hub.getClient();
								if (t && t.emit && t.emit("finishTransaction", this), !0 !== this.sampled) return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled."), void(t && t.recordDroppedEvent("sample_rate", "transaction"));
								const s = this.spanRecorder ? this.spanRecorder.spans.filter(m => m !== this && m.endTimestamp) : [];
								this._trimEnd && s.length > 0 && (this.endTimestamp = s.reduce((m, S) => m.endTimestamp && S.endTimestamp ? m.endTimestamp > S.endTimestamp ? m : S : m).endTimestamp);
								const c = this.metadata,
									u = {
										contexts: {
											...this._contexts,
											trace: this.getTraceContext()
										},
										spans: s,
										start_timestamp: this.startTimestamp,
										tags: this.tags,
										timestamp: this.endTimestamp,
										transaction: this.name,
										type: "transaction",
										sdkProcessingMetadata: {
											...c,
											dynamicSamplingContext: this.getDynamicSamplingContext()
										},
										...c.source && {
											transaction_info: {
												source: c.source
											}
										}
									};
								return Object.keys(this._measurements).length > 0 && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("[Measurements] Adding measurements to transaction", JSON.stringify(this._measurements, void 0, 2)), u.measurements = this._measurements), (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log(`[Tracing] Finishing ${this.op} transaction: ${this.name}.`), this._hub.captureEvent(u)
							}
							toContext() {
								return go({
									...super.toContext(),
									name: this.name,
									trimEnd: this._trimEnd
								})
							}
							updateWithContext(e) {
								return super.updateWithContext(e), this.name = e.name || "", this._trimEnd = e.trimEnd, this
							}
							getDynamicSamplingContext() {
								if (this._frozenDynamicSamplingContext) return this._frozenDynamicSamplingContext;
								const e = this._hub || _r(),
									t = e && e.getClient();
								if (!t) return {};
								const {
									environment: s,
									release: c
								} = t.getOptions() || {}, {
									publicKey: u
								} = t.getDsn() || {}, h = this.metadata.sampleRate, m = void 0 !== h ? h.toString() : void 0, {
									segment: S
								} = e.getScope().getUser() || {}, O = this.metadata.source, le = go({
									environment: s || zu,
									release: c,
									transaction: O && "url" !== O ? this.name : void 0,
									user_segment: S,
									public_key: u,
									trace_id: this.traceId,
									sample_rate: m
								});
								return t.emit && t.emit("createDsc", le), le
							}
							setHub(e) {
								this._hub = e
							}
						}
						const Mo = {
								idleTimeout: 1e3,
								finalTimeout: 3e4,
								heartbeatInterval: 5e3
							},
							_i = ["heartbeatFailed", "idleTimeout", "documentHidden", "finalTimeout", "externalFinish", "cancelled"];
						class Ld extends Zl {
							constructor(e, t, s, c) {
								super(c), this._pushActivity = e, this._popActivity = t, this.transactionSpanId = s
							}
							add(e) {
								e.spanId !== this.transactionSpanId && (e.finish = t => {
									e.endTimestamp = "number" == typeof t ? t : (0, Fr.ph)(), this._popActivity(e.spanId)
								}, void 0 === e.endTimestamp && this._pushActivity(e.spanId)), super.add(e)
							}
						}
						class $i extends jr {
							__init() {
								this.activities = {}
							}
							__init2() {
								this._heartbeatCounter = 0
							}
							__init3() {
								this._finished = !1
							}
							__init4() {
								this._idleTimeoutCanceledPermanently = !1
							}
							__init5() {
								this._beforeFinishCallbacks = []
							}
							__init6() {
								this._finishReason = _i[4]
							}
							constructor(e, t, s = Mo.idleTimeout, c = Mo.finalTimeout, u = Mo.heartbeatInterval, h = !1) {
								super(e, t), this._idleHub = t, this._idleTimeout = s, this._finalTimeout = c, this._heartbeatInterval = u, this._onScope = h, $i.prototype.__init.call(this), $i.prototype.__init2.call(this), $i.prototype.__init3.call(this), $i.prototype.__init4.call(this), $i.prototype.__init5.call(this), $i.prototype.__init6.call(this), h && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log(`Setting idle transaction on scope. Span ID: ${this.spanId}`), t.configureScope(m => m.setSpan(this))), this._restartIdleTimeout(), setTimeout(() => {
									this._finished || (this.setStatus("deadline_exceeded"), this._finishReason = _i[3], this.finish())
								}, this._finalTimeout)
							}
							finish(e = (0, Fr.ph)()) {
								if (this._finished = !0, this.activities = {}, "ui.action.click" === this.op && this.setTag("finishReason", this._finishReason), this.spanRecorder) {
									(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("[Tracing] finishing IdleTransaction", new Date(1e3 * e).toISOString(), this.op);
									for (const t of this._beforeFinishCallbacks) t(this, e);
									this.spanRecorder.spans = this.spanRecorder.spans.filter(t => {
										if (t.spanId === this.spanId) return !0;
										t.endTimestamp || (t.endTimestamp = e, t.setStatus("cancelled"), (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("[Tracing] cancelling span since transaction ended early", JSON.stringify(t, void 0, 2)));
										const s = t.startTimestamp < e;
										return s || (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("[Tracing] discarding Span since it happened after Transaction was finished", JSON.stringify(t, void 0, 2)), s
									}), (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("[Tracing] flushing IdleTransaction")
								} else(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("[Tracing] No active IdleTransaction");
								if (this._onScope) {
									const t = this._idleHub.getScope();
									t.getTransaction() === this && t.setSpan(void 0)
								}
								return super.finish(e)
							}
							registerBeforeFinishCallback(e) {
								this._beforeFinishCallbacks.push(e)
							}
							initSpanRecorder(e) {
								this.spanRecorder || (this.spanRecorder = new Ld(c => {
									this._finished || this._pushActivity(c)
								}, c => {
									this._finished || this._popActivity(c)
								}, this.spanId, e), (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("Starting heartbeat"), this._pingHeartbeat()), this.spanRecorder.add(this)
							}
							cancelIdleTimeout(e, {
								restartOnChildSpanChange: t
							} = {
								restartOnChildSpanChange: !0
							}) {
								this._idleTimeoutCanceledPermanently = !1 === t, this._idleTimeoutID && (clearTimeout(this._idleTimeoutID), this._idleTimeoutID = void 0, 0 === Object.keys(this.activities).length && this._idleTimeoutCanceledPermanently && (this._finishReason = _i[5], this.finish(e)))
							}
							setFinishReason(e) {
								this._finishReason = e
							}
							_restartIdleTimeout(e) {
								this.cancelIdleTimeout(), this._idleTimeoutID = setTimeout(() => {
									!this._finished && 0 === Object.keys(this.activities).length && (this._finishReason = _i[1], this.finish(e))
								}, this._idleTimeout)
							}
							_pushActivity(e) {
								this.cancelIdleTimeout(void 0, {
									restartOnChildSpanChange: !this._idleTimeoutCanceledPermanently
								}), (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log(`[Tracing] pushActivity: ${e}`), this.activities[e] = !0, (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("[Tracing] new activities count", Object.keys(this.activities).length)
							}
							_popActivity(e) {
								if (this.activities[e] && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log(`[Tracing] popActivity ${e}`), delete this.activities[e], (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("[Tracing] new activities count", Object.keys(this.activities).length)), 0 === Object.keys(this.activities).length) {
									const t = (0, Fr.ph)();
									this._idleTimeoutCanceledPermanently ? (this._finishReason = _i[5], this.finish(t)) : this._restartIdleTimeout(t + this._idleTimeout / 1e3)
								}
							}
							_beat() {
								if (this._finished) return;
								const e = Object.keys(this.activities).join("");
								e === this._prevHeartbeatString ? this._heartbeatCounter++ : this._heartbeatCounter = 1, this._prevHeartbeatString = e, this._heartbeatCounter >= 3 ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("[Tracing] Transaction finished because of no change for 3 heart beats"), this.setStatus("deadline_exceeded"), this._finishReason = _i[0], this.finish()) : this._pingHeartbeat()
							}
							_pingHeartbeat() {
								(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`), setTimeout(() => {
									this._beat()
								}, this._heartbeatInterval)
							}
						}

						function ys(i) {
							if ("boolean" == typeof __SENTRY_TRACING__ && !__SENTRY_TRACING__) return !1;
							const e = _r().getClient(),
								t = i || e && e.getOptions();
							return !!t && (t.enableTracing || "tracesSampleRate" in t || "tracesSampler" in t)
						}

						function Oo(i) {
							return (i || _r()).getScope().getTransaction()
						}
						let Qs = !1;

						function Es() {
							const i = Oo();
							if (i) {
								const e = "internal_error";
								(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log(`[Tracing] Transaction: ${e} -> Global error occured`), i.setStatus(e)
							}
						}

						function rc() {
							const e = this.getScope().getSpan();
							return e ? {
								"sentry-trace": e.toTraceparent()
							} : {}
						}

						function Js(i, e, t) {
							if (!ys(e)) return i.sampled = !1, i;
							if (void 0 !== i.sampled) return i.setMetadata({
								sampleRate: Number(i.sampled)
							}), i;
							let s;
							return "function" == typeof e.tracesSampler ? (s = e.tracesSampler(t), i.setMetadata({
									sampleRate: Number(s)
								})) : void 0 !== t.parentSampled ? s = t.parentSampled : typeof e.tracesSampleRate < "u" ? (s = e.tracesSampleRate, i.setMetadata({
									sampleRate: Number(s)
								})) : (s = 1, i.setMetadata({
									sampleRate: s
								})),
								function ic(i) {
									return Mh(i) || "number" != typeof i && "boolean" != typeof i ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn(`[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(i)} of type ${JSON.stringify(typeof i)}.`), !1) : !(i < 0 || i > 1) || ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn(`[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got ${i}.`), !1)
								}(s) ? s ? (i.sampled = Math.random() < s, i.sampled ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log(`[Tracing] starting ${i.op} transaction - ${i.name}`), i) : ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log(`[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(s)})`), i)) : ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("[Tracing] Discarding transaction because " + ("function" == typeof e.tracesSampler ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0")), i.sampled = !1, i) : ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn("[Tracing] Discarding transaction because of invalid sample rate."), i.sampled = !1, i)
						}

						function Qf(i, e) {
							const t = this.getClient(),
								s = t && t.getOptions() || {},
								c = s.instrumenter || "sentry",
								u = i.instrumenter || "sentry";
							c !== u && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.error(`A transaction was started with instrumenter=\`${u}\`, but the SDK is configured with the \`${c}\` instrumenter.\nThe transaction will not be sampled. Please use the ${c} instrumentation to start transactions.`), i.sampled = !1);
							let h = new jr(i, this);
							return h = Js(h, s, {
								parentSampled: i.parentSampled,
								transactionContext: i,
								...e
							}), h.sampled && h.initSpanRecorder(s._experiments && s._experiments.maxSpans), t && t.emit && t.emit("startTransaction", h), h
						}

						function Ud(i, e, t, s, c, u, h) {
							const m = i.getClient(),
								S = m && m.getOptions() || {};
							let O = new $i(e, i, t, s, h, c);
							return O = Js(O, S, {
								parentSampled: e.parentSampled,
								transactionContext: e,
								...u
							}), O.sampled && O.initSpanRecorder(S._experiments && S._experiments.maxSpans), m && m.emit && m.emit("startTransaction", O), O
						}
						Es.tag = "sentry_tracingErrorCallback";
						const Xf = new RegExp("^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$"),
							tu = "baggage",
							Bd = "sentry-",
							ep = /^sentry-/,
							tp = 8192;

						function np(i) {
							return function bm(i) {
								if (0 !== Object.keys(i).length) return Object.entries(i).reduce((e, [t, s], c) => {
									const u = `${encodeURIComponent(t)}=${encodeURIComponent(s)}`,
										h = 0 === c ? u : `${e},${u}`;
									return h.length > tp ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn(`Not adding key: ${t} with val: ${s} to baggage header due to exceeding baggage size limits.`), e) : h
								}, "")
							}(Object.entries(i).reduce((t, [s, c]) => (c && (t[`${Bd}${s}`] = c), t), {}))
						}

						function Hd(i) {
							return i.split(",").map(e => e.split("=").map(t => decodeURIComponent(t.trim()))).reduce((e, [t, s]) => (e[t] = s, e), {})
						}
						const vr = qr.n2,
							Jc = (i, e, t) => {
								let s, c;
								return u => {
									e.value >= 0 && (u || t) && (c = e.value - (s || 0), (c || void 0 === s) && (s = e.value, e.delta = c, i(e)))
								}
							},
							Xc = () => vr.__WEB_VITALS_POLYFILL__ ? vr.performance && (performance.getEntriesByType && performance.getEntriesByType("navigation")[0] || (() => {
								const i = vr.performance.timing,
									e = vr.performance.navigation.type,
									t = {
										entryType: "navigation",
										startTime: 0,
										type: 2 == e ? "back_forward" : 1 === e ? "reload" : "navigate"
									};
								for (const s in i) "navigationStart" !== s && "toJSON" !== s && (t[s] = Math.max(i[s] - i.navigationStart, 0));
								return t
							})()) : vr.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0],
							ru = () => {
								const i = Xc();
								return i && i.activationStart || 0
							},
							jd = (i, e) => {
								const t = Xc();
								let s = "navigate";
								return t && (s = vr.document.prerendering || ru() > 0 ? "prerender" : t.type.replace(/_/g, "-")), {
									name: i,
									value: typeof e > "u" ? -1 : e,
									rating: "good",
									delta: 0,
									entries: [],
									id: `v3-${Date.now()}-${Math.floor(8999999999999*Math.random())+1e12}`,
									navigationType: s
								}
							},
							Cs = (i, e, t) => {
								try {
									if (PerformanceObserver.supportedEntryTypes.includes(i)) {
										const s = new PerformanceObserver(c => {
											e(c.getEntries())
										});
										return s.observe(Object.assign({
											type: i,
											buffered: !0
										}, t || {})), s
									}
								} catch {}
							},
							Xs = (i, e) => {
								const t = s => {
									("pagehide" === s.type || "hidden" === vr.document.visibilityState) && (i(s), e && (removeEventListener("visibilitychange", t, !0), removeEventListener("pagehide", t, !0)))
								};
								addEventListener("visibilitychange", t, !0), addEventListener("pagehide", t, !0)
							},
							rp = i => {
								const e = jd("CLS", 0);
								let t, s = 0,
									c = [];
								const u = m => {
										m.forEach(S => {
											S.hadRecentInput || (s && 0 !== c.length && S.startTime - c[c.length - 1].startTime < 1e3 && S.startTime - c[0].startTime < 5e3 ? (s += S.value, c.push(S)) : (s = S.value, c = [S]), s > e.value && (e.value = s, e.entries = c, t && t()))
										})
									},
									h = Cs("layout-shift", u);
								if (h) {
									t = Jc(i, e);
									const m = () => {
										u(h.takeRecords()), t(!0)
									};
									return Xs(m), m
								}
							};
						let Zc = -1;
						const iu = () => (Zc < 0 && (Zc = "hidden" !== vr.document.visibilityState || vr.document.prerendering ? 1 / 0 : 0, Xs(({
								timeStamp: i
							}) => {
								Zc = i
							}, !0)), {
								get firstHiddenTime() {
									return Zc
								}
							}),
							$d = i => {
								const e = iu(),
									t = jd("FID");
								let s;
								const c = m => {
										m.startTime < e.firstHiddenTime && (t.value = m.processingStart - m.startTime, t.entries.push(m), s(!0))
									},
									u = m => {
										m.forEach(c)
									},
									h = Cs("first-input", u);
								s = Jc(i, t), h && Xs(() => {
									u(h.takeRecords()), h.disconnect()
								}, !0)
							},
							ou = {},
							Dm = i => {
								const e = iu(),
									t = jd("LCP");
								let s;
								const c = h => {
										const m = h[h.length - 1];
										if (m) {
											const S = Math.max(m.startTime - ru(), 0);
											S < e.firstHiddenTime && (t.value = S, t.entries = [m], s())
										}
									},
									u = Cs("largest-contentful-paint", c);
								if (u) {
									s = Jc(i, t);
									const h = () => {
										ou[t.id] || (c(u.takeRecords()), u.disconnect(), ou[t.id] = !0, s(!0))
									};
									return ["keydown", "click"].forEach(m => {
										addEventListener(m, h, {
											once: !0,
											capture: !0
										})
									}), Xs(h, !0), h
								}
							};

						function su(i) {
							return "number" == typeof i && isFinite(i)
						}

						function Zs(i, {
							startTimestamp: e,
							...t
						}) {
							return e && i.startTimestamp > e && (i.startTimestamp = e), i.startChild({
								startTimestamp: e,
								...t
							})
						}

						function Qr(i) {
							return i / 1e3
						}

						function zd() {
							return vr && vr.addEventListener && vr.performance
						}
						let vo, ea, op = 0,
							Or = {};

						function ta(i, e, t, s, c, u) {
							const h = u ? e[u] : e[`${t}End`],
								m = e[`${t}Start`];
							!m || !h || Zs(i, {
								op: "browser",
								description: c || t,
								startTimestamp: s + Qr(m),
								endTimestamp: s + Qr(h)
							})
						}
						const Yo = ["localhost", /^\//],
							el = {
								traceFetch: !0,
								traceXHR: !0,
								tracingOrigins: Yo,
								tracePropagationTargets: Yo
							};
						const Nm = {
							...Mo,
							markBackgroundTransactions: !0,
							routingInstrumentation: function Pm(i, e = !0, t = !0) {
								if (!vr || !vr.location) return void((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn("Could not initialize routing instrumentation due to invalid location"));
								let c, s = vr.location.href;
								e && (c = i({
									name: vr.location.pathname,
									startTimestamp: Fr.Z1 ? Fr.Z1 / 1e3 : void 0,
									op: "pageload",
									metadata: {
										source: "url"
									}
								})), t && ci("history", ({
									to: u,
									from: h
								}) => {
									void 0 === h && s && -1 !== s.indexOf(u) ? s = void 0 : h !== u && (s = void 0, c && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log(`[Tracing] Finishing current transaction with op: ${c.op}`), c.finish()), c = i({
										name: vr.location.pathname,
										op: "navigation",
										metadata: {
											source: "url"
										}
									}))
								})
							},
							startTransactionOnLocationChange: !0,
							startTransactionOnPageLoad: !0,
							enableLongTask: !0,
							_experiments: {},
							...el
						};
						class Vr {
							__init() {
								this.name = "BrowserTracing"
							}
							constructor(e) {
								Vr.prototype.__init.call(this),
									function Jf() {
										const i = ro();
										i.__SENTRY__ && (i.__SENTRY__.extensions = i.__SENTRY__.extensions || {}, i.__SENTRY__.extensions.startTransaction || (i.__SENTRY__.extensions.startTransaction = Qf), i.__SENTRY__.extensions.traceHeaders || (i.__SENTRY__.extensions.traceHeaders = rc), function nc() {
											Qs || (Qs = !0, ci("error", Es), ci("unhandledrejection", Es))
										}())
									}(), this.options = {
										...Nm,
										...e
									}, void 0 !== this.options._experiments.enableLongTask && (this.options.enableLongTask = this.options._experiments.enableLongTask), e && !e.tracePropagationTargets && e.tracingOrigins && (this.options.tracePropagationTargets = e.tracingOrigins), this._collectWebVitals = function au() {
										const i = zd();
										if (i && Fr.Z1) {
											i.mark && vr.performance.mark("sentry-tracing-init"),
												function up() {
													$d(i => {
														const e = i.entries.pop();
														if (!e) return;
														const t = Qr(Fr.Z1),
															s = Qr(e.startTime);
														(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("[Measurements] Adding FID"), Or.fid = {
															value: i.value,
															unit: "millisecond"
														}, Or["mark.fid"] = {
															value: t + s,
															unit: "second"
														}
													})
												}();
											const e = function cp() {
													return rp(i => {
														const e = i.entries.pop();
														e && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("[Measurements] Adding CLS"), Or.cls = {
															value: i.value,
															unit: ""
														}, ea = e)
													})
												}(),
												t = function lp() {
													return Dm(i => {
														const e = i.entries.pop();
														e && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("[Measurements] Adding LCP"), Or.lcp = {
															value: i.value,
															unit: "millisecond"
														}, vo = e)
													})
												}();
											return () => {
												e && e(), t && t()
											}
										}
										return () => {}
									}(), this.options.enableLongTask && function sp() {
										Cs("longtask", e => {
											for (const t of e) {
												const s = Oo();
												if (!s) return;
												const c = Qr(Fr.Z1 + t.startTime),
													u = Qr(t.duration);
												s.startChild({
													description: "Main UI thread blocked",
													op: "ui.long-task",
													startTimestamp: c,
													endTimestamp: c + u
												})
											}
										})
									}(), this.options._experiments.enableInteractions && function ap() {
										Cs("event", e => {
											for (const t of e) {
												const s = Oo();
												if (!s) return;
												if ("click" === t.name) {
													const c = Qr(Fr.Z1 + t.startTime),
														u = Qr(t.duration);
													s.startChild({
														description: us(t.target),
														op: `ui.interaction.${t.name}`,
														startTimestamp: c,
														endTimestamp: c + u
													})
												}
											}
										}, {
											durationThreshold: 0
										})
									}()
							}
							setupOnce(e, t) {
								this._getCurrentHub = t;
								const {
									routingInstrumentation: s,
									startTransactionOnLocationChange: c,
									startTransactionOnPageLoad: u,
									markBackgroundTransactions: h,
									traceFetch: m,
									traceXHR: S,
									tracePropagationTargets: O,
									shouldCreateSpanForRequest: $,
									_experiments: le
								} = this.options;
								s(Re => {
										const Ae = this._createRouteTransaction(Re);
										return this.options._experiments.onStartRouteTransaction && this.options._experiments.onStartRouteTransaction(Ae, Re, t), Ae
									}, u, c), h && function Gd() {
										vr && vr.document ? vr.document.addEventListener("visibilitychange", () => {
											const i = Oo();
											if (vr.document.hidden && i) {
												const e = "cancelled";
												(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log(`[Tracing] Transaction: ${e} -> since tab moved to the background, op: ${i.op}`), i.status || i.setStatus(e), i.setTag("visibilitychange", "document.hidden"), i.finish()
											}
										}) : (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn("[Tracing] Could not set up background tab detection due to lack of global document")
									}(), le.enableInteractions && this._registerInteractionListener(),
									function Mm(i) {
										const {
											traceFetch: e,
											traceXHR: t,
											tracePropagationTargets: s,
											tracingOrigins: c,
											shouldCreateSpanForRequest: u
										} = {
											traceFetch: el.traceFetch,
											traceXHR: el.traceXHR,
											...i
										}, h = "function" == typeof u ? u : O => !0, m = O => function Yd(i, e) {
											return Bc(i, e || Yo)
										}(O, s || c), S = {};
										e && ci("fetch", O => {
											! function Z_(i, e, t, s) {
												if (!ys() || !i.fetchData || !e(i.fetchData.url)) return;
												if (i.endTimestamp) {
													const m = i.fetchData.__span;
													if (!m) return;
													const S = s[m];
													return void(S && (i.response ? S.setHttpStatus(i.response.status) : i.error && S.setStatus("internal_error"), S.finish(), delete s[m]))
												}
												const c = _r().getScope(),
													u = c && c.getSpan(),
													h = u && u.transaction;
												if (u && h) {
													const m = u.startChild({
														data: {
															...i.fetchData,
															type: "fetch"
														},
														description: `${i.fetchData.method} ${i.fetchData.url}`,
														op: "http.client"
													});
													i.fetchData.__span = m.spanId, s[m.spanId] = m;
													const S = i.args[0];
													i.args[1] = i.args[1] || {};
													const O = i.args[1];
													t(i.fetchData.url) && (O.headers = function ev(i, e, t, s) {
														const c = np(e),
															u = t.toTraceparent(),
															h = typeof Request < "u" && ls(i, Request) ? i.headers : s.headers;
														if (h) {
															if (typeof Headers < "u" && ls(h, Headers)) {
																const m = new Headers(h);
																return m.append("sentry-trace", u), c && m.append(tu, c), m
															}
															if (Array.isArray(h)) {
																const m = [...h, ["sentry-trace", u]];
																return c && m.push([tu, c]), m
															} {
																const m = "baggage" in h ? h.baggage : void 0,
																	S = [];
																return Array.isArray(m) ? S.push(...m) : m && S.push(m), c && S.push(c), {
																	...h,
																	"sentry-trace": u,
																	baggage: S.length > 0 ? S.join(",") : void 0
																}
															}
														}
														return {
															"sentry-trace": u,
															baggage: c
														}
													}(S, h.getDynamicSamplingContext(), m, O))
												}
											}(O, h, m, S)
										}), t && ci("xhr", O => {
											! function Om(i, e, t, s) {
												const c = i.xhr,
													u = c && c[Vo];
												if (!ys() || c && c.__sentry_own_request__ || !(c && u && e(u.url))) return;
												if (i.endTimestamp) {
													const O = c.__sentry_xhr_span_id__;
													if (!O) return;
													const $ = s[O];
													return void($ && ($.setHttpStatus(u.status_code), $.finish(), delete s[O]))
												}
												const h = _r().getScope(),
													m = h && h.getSpan(),
													S = m && m.transaction;
												if (m && S) {
													const O = m.startChild({
														data: {
															...u.data,
															type: "xhr",
															method: u.method,
															url: u.url
														},
														description: `${u.method} ${u.url}`,
														op: "http.client"
													});
													if (c.__sentry_xhr_span_id__ = O.spanId, s[c.__sentry_xhr_span_id__] = O, c.setRequestHeader && t(u.url)) try {
														c.setRequestHeader("sentry-trace", O.toTraceparent());
														const le = np(S.getDynamicSamplingContext());
														le && c.setRequestHeader(tu, le)
													} catch {}
												}
											}(O, h, m, S)
										})
									}({
										traceFetch: m,
										traceXHR: S,
										tracePropagationTargets: O,
										shouldCreateSpanForRequest: $
									})
							}
							_createRouteTransaction(e) {
								if (!this._getCurrentHub) return void((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn(`[Tracing] Did not create ${e.op} transaction because _getCurrentHub is invalid.`));
								const {
									beforeNavigate: t,
									idleTimeout: s,
									finalTimeout: c,
									heartbeatInterval: u
								} = this.options, h = "pageload" === e.op, m = h ? Wd("sentry-trace") : null, S = h ? Wd("baggage") : null, O = m ? function Zf(i) {
									const e = i.match(Xf);
									if (!i || !e) return;
									let t;
									return "1" === e[3] ? t = !0 : "0" === e[3] && (t = !1), {
										traceId: e[1],
										parentSampled: t,
										parentSpanId: e[2]
									}
								}(m) : void 0, $ = S ? function wm(i) {
									if (!ki(i) && !Array.isArray(i)) return;
									let e = {};
									if (Array.isArray(i)) e = i.reduce((s, c) => ({
										...s,
										...Hd(c)
									}), {});
									else {
										if (!i) return;
										e = Hd(i)
									}
									const t = Object.entries(e).reduce((s, [c, u]) => (c.match(ep) && (s[c.slice(Bd.length)] = u), s), {});
									return Object.keys(t).length > 0 ? t : void 0
								}(S) : void 0, le = {
									...e,
									...O,
									metadata: {
										...e.metadata,
										dynamicSamplingContext: O && !$ ? {} : $
									},
									trimEnd: !0
								}, Re = "function" == typeof t ? t(le) : le, Ae = void 0 === Re ? {
									...le,
									sampled: !1
								} : Re;
								Ae.metadata = Ae.name !== le.name ? {
									...Ae.metadata,
									source: "custom"
								} : Ae.metadata, this._latestRouteName = Ae.name, this._latestRouteSource = Ae.metadata && Ae.metadata.source, !1 === Ae.sampled && (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log(`[Tracing] Will not send ${Ae.op} transaction because of beforeNavigate.`), (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log(`[Tracing] Starting ${Ae.op} transaction on scope`);
								const Ze = this._getCurrentHub(),
									{
										location: wt
									} = vr,
									Wt = Ud(Ze, Ae, s, c, !0, {
										location: wt
									}, u);
								return Wt.registerBeforeFinishCallback(Yt => {
									this._collectWebVitals(),
										function dp(i) {
											const e = zd();
											if (!e || !vr.performance.getEntries || !Fr.Z1) return;
											(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("[Tracing] Adding & adjusting spans using Performance API");
											const t = Qr(Fr.Z1),
												s = e.getEntries();
											let c, u;
											if (s.slice(op).forEach(h => {
													const m = Qr(h.startTime),
														S = Qr(h.duration);
													if (!("navigation" === i.op && t + m < i.startTimestamp)) switch (h.entryType) {
														case "navigation":
															(function fp(i, e, t) {
																["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach(s => {
																		ta(i, e, s, t)
																	}), ta(i, e, "secureConnection", t, "TLS/SSL", "connectEnd"), ta(i, e, "fetch", t, "cache", "domainLookupStart"), ta(i, e, "domainLookup", t, "DNS"),
																	function Ss(i, e, t) {
																		Zs(i, {
																			op: "browser",
																			description: "request",
																			startTimestamp: t + Qr(e.requestStart),
																			endTimestamp: t + Qr(e.responseEnd)
																		}), Zs(i, {
																			op: "browser",
																			description: "response",
																			startTimestamp: t + Qr(e.responseStart),
																			endTimestamp: t + Qr(e.responseEnd)
																		})
																	}(i, e, t)
															})(i, h, t), c = t + Qr(h.responseStart), u = t + Qr(h.requestStart);
															break;
														case "mark":
														case "paint":
														case "measure": {
															! function hp(i, e, t, s, c) {
																const u = c + t;
																Zs(i, {
																	description: e.name,
																	endTimestamp: u + s,
																	op: e.entryType,
																	startTimestamp: u
																})
															}(i, h, m, S, t);
															const O = iu(),
																$ = h.startTime < O.firstHiddenTime;
															"first-paint" === h.name && $ && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("[Measurements] Adding FP"), Or.fp = {
																value: h.startTime,
																unit: "millisecond"
															}), "first-contentful-paint" === h.name && $ && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("[Measurements] Adding FCP"), Or.fcp = {
																value: h.startTime,
																unit: "millisecond"
															});
															break
														}
														case "resource": {
															const O = h.name.replace(vr.location.origin, "");
															! function Am(i, e, t, s, c, u) {
																if ("xmlhttprequest" === e.initiatorType || "fetch" === e.initiatorType) return;
																const h = {};
																"transferSize" in e && (h["Transfer Size"] = e.transferSize), "encodedBodySize" in e && (h["Encoded Body Size"] = e.encodedBodySize), "decodedBodySize" in e && (h["Decoded Body Size"] = e.decodedBodySize), "renderBlockingStatus" in e && (h["resource.render_blocking_status"] = e.renderBlockingStatus);
																const m = u + s;
																Zs(i, {
																	description: t,
																	endTimestamp: m + c,
																	op: e.initiatorType ? `resource.${e.initiatorType}` : "resource.other",
																	startTimestamp: m,
																	data: h
																})
															}(i, h, O, m, S, t);
															break
														}
													}
												}), op = Math.max(s.length - 1, 0), function Rm(i) {
													const e = vr.navigator;
													if (!e) return;
													const t = e.connection;
													t && (t.effectiveType && i.setTag("effectiveConnectionType", t.effectiveType), t.type && i.setTag("connectionType", t.type), su(t.rtt) && (Or["connection.rtt"] = {
														value: t.rtt,
														unit: "millisecond"
													})), su(e.deviceMemory) && i.setTag("deviceMemory", `${e.deviceMemory} GB`), su(e.hardwareConcurrency) && i.setTag("hardwareConcurrency", String(e.hardwareConcurrency))
												}(i), "pageload" === i.op) {
												"number" == typeof c && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("[Measurements] Adding TTFB"), Or.ttfb = {
													value: 1e3 * (c - i.startTimestamp),
													unit: "millisecond"
												}, "number" == typeof u && u <= c && (Or["ttfb.requestTime"] = {
													value: 1e3 * (c - u),
													unit: "millisecond"
												})), ["fcp", "fp", "lcp"].forEach(m => {
													if (!Or[m] || t >= i.startTimestamp) return;
													const S = Or[m].value,
														O = t + Qr(S),
														$ = Math.abs(1e3 * (O - i.startTimestamp));
													(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log(`[Measurements] Normalized ${m} from ${S} to ${$} (${$-S})`), Or[m].value = $
												});
												const h = Or["mark.fid"];
												h && Or.fid && (Zs(i, {
														description: "first input delay",
														endTimestamp: h.value + Qr(Or.fid.value),
														op: "ui.action",
														startTimestamp: h.value
													}), delete Or["mark.fid"]), "fcp" in Or || delete Or.cls, Object.keys(Or).forEach(m => {
														i.setMeasurement(m, Or[m].value, Or[m].unit)
													}),
													function Kd(i) {
														vo && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("[Measurements] Adding LCP Data"), vo.element && i.setTag("lcp.element", us(vo.element)), vo.id && i.setTag("lcp.id", vo.id), vo.url && i.setTag("lcp.url", vo.url.trim().slice(0, 200)), i.setTag("lcp.size", vo.size)), ea && ea.sources && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("[Measurements] Adding CLS Data"), ea.sources.forEach((e, t) => i.setTag(`cls.source.${t+1}`, us(e.node))))
													}(i)
											}
											vo = void 0, ea = void 0, Or = {}
										}(Yt)
								}), Wt
							}
							_registerInteractionListener() {
								let e;
								const t = () => {
									const {
										idleTimeout: s,
										finalTimeout: c,
										heartbeatInterval: u
									} = this.options, h = "ui.action.click", m = Oo();
									if (m && m.op && ["navigation", "pageload"].includes(m.op)) return void((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn(`[Tracing] Did not create ${h} transaction because a pageload or navigation transaction is in progress.`));
									if (e && (e.setFinishReason("interactionInterrupted"), e.finish(), e = void 0), !this._getCurrentHub) return void((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn(`[Tracing] Did not create ${h} transaction because _getCurrentHub is invalid.`));
									if (!this._latestRouteName) return void((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn(`[Tracing] Did not create ${h} transaction because _latestRouteName is missing.`));
									const S = this._getCurrentHub(),
										{
											location: O
										} = vr;
									e = Ud(S, {
										name: this._latestRouteName,
										op: h,
										trimEnd: !0,
										metadata: {
											source: this._latestRouteSource || "url"
										}
									}, s, c, !0, {
										location: O
									}, u)
								};
								["click"].forEach(s => {
									addEventListener(s, t, {
										once: !1,
										capture: !0
									})
								})
							}
						}

						function Wd(i) {
							const e = function Ph(i) {
								return La.document && La.document.querySelector ? La.document.querySelector(i) : null
							}(`meta[name=${i}]`);
							return e ? e.getAttribute("content") : null
						}
						class tl {
							static __initStatic() {
								this.id = "HttpClient"
							}
							__init() {
								this.name = tl.id
							}
							constructor(e) {
								tl.prototype.__init.call(this), this._options = {
									failedRequestStatusCodes: [
										[500, 599]
									],
									failedRequestTargets: [/.*/],
									...e
								}
							}
							setupOnce(e, t) {
								this._getCurrentHub = t, this._wrapFetch(), this._wrapXHR()
							}
							_fetchResponseHandler(e, t, s) {
								if (this._getCurrentHub && this._shouldCaptureResponse(t.status, t.url)) {
									const c = function km(i, e) {
											return !e && i instanceof Request || i instanceof Request && i.bodyUsed ? i : new Request(i, e)
										}(e, s),
										u = this._getCurrentHub();
									let h, m, S, O;
									u.shouldSendDefaultPii() && ([{
										headers: h,
										cookies: S
									}, {
										headers: m,
										cookies: O
									}] = [{
										cookieHeader: "Cookie",
										obj: c
									}, {
										cookieHeader: "Set-Cookie",
										obj: t
									}].map(({
										cookieHeader: le,
										obj: Re
									}) => {
										const Ae = this._extractFetchHeaders(Re.headers);
										let Ze;
										try {
											const wt = Ae[le] || Ae[le.toLowerCase()] || void 0;
											wt && (Ze = this._parseCookieString(wt))
										} catch {
											(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log(`Could not extract cookies from header ${le}`)
										}
										return {
											headers: Ae,
											cookies: Ze
										}
									}));
									const $ = this._createEvent({
										url: c.url,
										method: c.method,
										status: t.status,
										requestHeaders: h,
										responseHeaders: m,
										requestCookies: S,
										responseCookies: O
									});
									u.captureEvent($)
								}
							}
							_xhrResponseHandler(e, t, s) {
								if (this._getCurrentHub && this._shouldCaptureResponse(e.status, e.responseURL)) {
									let c, u, h;
									const m = this._getCurrentHub();
									if (m.shouldSendDefaultPii()) {
										try {
											const O = e.getResponseHeader("Set-Cookie") || e.getResponseHeader("set-cookie") || void 0;
											O && (u = this._parseCookieString(O))
										} catch {
											(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("Could not extract cookies from response headers")
										}
										try {
											h = this._getXHRResponseHeaders(e)
										} catch {
											(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.log("Could not extract headers from response")
										}
										c = s
									}
									const S = this._createEvent({
										url: e.responseURL,
										method: t,
										status: e.status,
										requestHeaders: c,
										responseHeaders: h,
										responseCookies: u
									});
									m.captureEvent(S)
								}
							}
							_getResponseSizeFromHeaders(e) {
								if (e) {
									const t = e["Content-Length"] || e["content-length"];
									if (t) return parseInt(t, 10)
								}
							}
							_parseCookieString(e) {
								return e.split("; ").reduce((t, s) => {
									const [c, u] = s.split("=");
									return t[c] = u, t
								}, {})
							}
							_extractFetchHeaders(e) {
								const t = {};
								return e.forEach((s, c) => {
									t[c] = s
								}), t
							}
							_getXHRResponseHeaders(e) {
								const t = e.getAllResponseHeaders();
								return t ? t.split("\r\n").reduce((s, c) => {
									const [u, h] = c.split(": ");
									return s[u] = h, s
								}, {}) : {}
							}
							_isInGivenRequestTargets(e) {
								return !!this._options.failedRequestTargets && this._options.failedRequestTargets.some(t => "string" == typeof t ? e.includes(t) : t.test(e))
							}
							_isInGivenStatusRanges(e) {
								return !!this._options.failedRequestStatusCodes && this._options.failedRequestStatusCodes.some(t => "number" == typeof t ? t === e : e >= t[0] && e <= t[1])
							}
							_wrapFetch() {
								rf() && ci("fetch", e => {
									const {
										response: t,
										args: s
									} = e, [c, u] = s;
									t && this._fetchResponseHandler(c, t, u)
								})
							}
							_wrapXHR() {
								"XMLHttpRequest" in qr.n2 && ci("xhr", e => {
									const {
										xhr: t
									} = e, s = t[Vo];
									if (!s) return;
									const {
										method: c,
										request_headers: u
									} = s;
									if (c) try {
										this._xhrResponseHandler(t, c, u)
									} catch (h) {
										(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn("Error while extracting response event form XHR response", h)
									}
								})
							}
							_isSentryRequest(e) {
								const t = this._getCurrentHub && this._getCurrentHub().getClient();
								if (!t) return !1;
								const s = t.getDsn();
								return !!s && e.includes(s.host)
							}
							_shouldCaptureResponse(e, t) {
								return this._isInGivenStatusRanges(e) && this._isInGivenRequestTargets(t) && !this._isSentryRequest(t)
							}
							_createEvent(e) {
								const t = `HTTP Client Error with status code: ${e.status}`,
									s = {
										message: t,
										exception: {
											values: [{
												type: "Error",
												value: t
											}]
										},
										request: {
											url: e.url,
											method: e.method,
											headers: e.requestHeaders,
											cookies: e.requestCookies
										},
										contexts: {
											response: {
												status_code: e.status,
												headers: e.responseHeaders,
												cookies: e.responseCookies,
												body_size: this._getResponseSizeFromHeaders(e.responseHeaders)
											}
										}
									};
								return ds(s, {
									type: "http.client"
								}), s
							}
						}
						tl.__initStatic(),
							function pm(i) {
								i._metadata = i._metadata || {}, i._metadata.sdk = {
										name: "sentry.javascript.angular-ivy",
										packages: [{
											name: "npm:@sentry/angular-ivy",
											version: Yc
										}],
										version: Yc
									},
									function gm() {
										const e = y.q4F && y.q4F.major ? parseInt(y.q4F.major, 10) : void 0;
										e && (e < 12 && Kf && Ut.warn(`This Sentry SDK does not officially support Angular ${e}.`, "This SDK only supports Angular 12 and above.", "If you're using Angular 10 or 11, please use `@sentry/angular` instead.", "Otherwise, please consider upgrading your Angular version."), function kg(i, e) {
											_r().setContext(i, e)
										}("angular", {
											version: e
										}))
									}(),
									function Ql(i = {}) {
										void 0 === i.defaultIntegrations && (i.defaultIntegrations = ql), void 0 === i.release && ("string" == typeof __SENTRY_RELEASE__ && (i.release = __SENTRY_RELEASE__), er.SENTRY_RELEASE && er.SENTRY_RELEASE.id && (i.release = er.SENTRY_RELEASE.id)), void 0 === i.autoSessionTracking && (i.autoSessionTracking = !0), void 0 === i.sendClientReports && (i.sendClientReports = !0);
										const e = {
											...i,
											stackParser: Zu(i.stackParser || am),
											integrations: rg(i),
											transport: i.transport || (nf() ? $f : Ko)
										};
										(function qh(i, e) {
											!0 === e.debug && (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__ ? Ut.enable() : console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle."));
											const t = _r();
											t.getScope().update(e.initialScope);
											const c = new i(e);
											t.bindClient(c)
										})(gd, e), i.autoSessionTracking && function q_() {
											if (typeof er.document > "u") return void((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ut.warn("Session tracking in non-browser environment with @sentry/browser is not supported."));
											const i = _r();
											i.captureSession && (zf(i), ci("history", ({
												from: e,
												to: t
											}) => {
												void 0 === e || e === t || zf(_r())
											}))
										}()
									}(i)
							}({
								environment: qt.N.name,
								enabled: qt.N.enableSentry,
								dsn: qt.N.sentryDSN,
								integrations: [new Vr({
									tracePropagationTargets: [qt.N.apiUrl],
									routingInstrumentation: function qf(i, e = !0, t = !0) {
										Yf = !0, Wf = i, Od = t, e && er && er.location && i({
											name: er.location.pathname,
											op: "pageload",
											metadata: {
												source: "url"
											}
										})
									}
								}), new tl({
									failedRequestStatusCodes: [
										[500, 599]
									],
									failedRequestTargets: [qt.N.apiUrl]
								})],
								tracesSampleRate: qt.N.tracingSampleRate,
								sendDefaultPii: !0
							}), p.q6().bootstrapModule(Fd).catch(i => console.error(i))
					}, 4747: (be, ue, E) => {
						E.d(ue, {
							S9: () => ke,
							sK: () => Ue,
							ge: () => Ge,
							J$: () => lt,
							RQ: () => et,
							CH: () => Se,
							c$: () => Be,
							W2: () => at
						});
						var p = E(3991),
							y = E(7774),
							D = E(4857),
							z = E(4337),
							ee = function() {
								function ce() {}
								return ce.getInteractionStatusFromEvent = function(ht, Pe) {
									switch (ht.eventType) {
										case z.t.LOGIN_START:
											return D.$H.Login;
										case z.t.SSO_SILENT_START:
											return D.$H.SsoSilent;
										case z.t.ACQUIRE_TOKEN_START:
											if (ht.interactionType === D.s_.Redirect || ht.interactionType === D.s_.Popup) return D.$H.AcquireToken;
											break;
										case z.t.HANDLE_REDIRECT_START:
											return D.$H.HandleRedirect;
										case z.t.LOGOUT_START:
											return D.$H.Logout;
										case z.t.SSO_SILENT_SUCCESS:
										case z.t.SSO_SILENT_FAILURE:
											if (Pe && Pe !== D.$H.SsoSilent) break;
											return D.$H.None;
										case z.t.LOGOUT_END:
											if (Pe && Pe !== D.$H.Logout) break;
											return D.$H.None;
										case z.t.HANDLE_REDIRECT_END:
											if (Pe && Pe !== D.$H.HandleRedirect) break;
											return D.$H.None;
										case z.t.LOGIN_SUCCESS:
										case z.t.LOGIN_FAILURE:
										case z.t.ACQUIRE_TOKEN_SUCCESS:
										case z.t.ACQUIRE_TOKEN_FAILURE:
											if (ht.interactionType === D.s_.Redirect || ht.interactionType === D.s_.Popup) {
												if (Pe && Pe !== D.$H.Login && Pe !== D.$H.AcquireToken) break;
												return D.$H.None
											}
									}
									return null
								}, ce
							}(),
							P = E(3593),
							N = E(6767),
							Y = E(4098),
							G = E(1327),
							Q = E(3998),
							X = E(1970),
							te = E(8264),
							ie = E(3216),
							oe = E(5195),
							we = E(8440),
							Fe = E(7580),
							Le = E(6424),
							je = E(2837),
							Ce = E(1565),
							F = E(2653),
							xe = E(9754),
							Ee = E(6425);
						const Ue = new p.OlP("MSAL_INSTANCE"),
							ke = new p.OlP("MSAL_GUARD_CONFIG"),
							Ge = new p.OlP("MSAL_INTERCEPTOR_CONFIG"),
							ft = new p.OlP("MSAL_BROADCAST_CONFIG"),
							nt = "@azure/msal-angular",
							Pt = "2.5.4";
						let at = (() => {
								class ce {
									constructor(Pe, pt) {
										this.instance = Pe, this.location = pt;
										const Bt = this.location.path(!0).split("#").pop();
										Bt && (this.redirectHash = `#${Bt}`), this.instance.initializeWrapperLibrary(D.lA.Angular, Pt)
									}
									initialize() {
										return (0, Q.D)(this.instance.initialize())
									}
									acquireTokenPopup(Pe) {
										return (0, Q.D)(this.instance.acquireTokenPopup(Pe))
									}
									acquireTokenRedirect(Pe) {
										return (0, Q.D)(this.instance.acquireTokenRedirect(Pe))
									}
									acquireTokenSilent(Pe) {
										return (0, Q.D)(this.instance.acquireTokenSilent(Pe))
									}
									handleRedirectObservable(Pe) {
										return (0, Q.D)(this.instance.handleRedirectPromise(Pe || this.redirectHash))
									}
									loginPopup(Pe) {
										return (0, Q.D)(this.instance.loginPopup(Pe))
									}
									loginRedirect(Pe) {
										return (0, Q.D)(this.instance.loginRedirect(Pe))
									}
									logout(Pe) {
										return (0, Q.D)(this.instance.logout(Pe))
									}
									logoutRedirect(Pe) {
										return (0, Q.D)(this.instance.logoutRedirect(Pe))
									}
									logoutPopup(Pe) {
										return (0, Q.D)(this.instance.logoutPopup(Pe))
									}
									ssoSilent(Pe) {
										return (0, Q.D)(this.instance.ssoSilent(Pe))
									}
									getLogger() {
										return this.logger || (this.logger = this.instance.getLogger().clone(nt, Pt)), this.logger
									}
									setLogger(Pe) {
										this.logger = Pe.clone(nt, Pt), this.instance.setLogger(Pe)
									}
								}
								return ce.\u0275fac = function(Pe) {
									return new(Pe || ce)(p.LFG(Ue), p.LFG(y.Ye))
								}, ce.\u0275prov = p.Yz7({
									token: ce,
									factory: ce.\u0275fac
								}), ce
							})(),
							lt = (() => {
								class ce {
									constructor(Pe, pt, Bt) {
										this.msalInstance = Pe, this.authService = pt, this.msalBroadcastConfig = Bt, this.msalBroadcastConfig && this.msalBroadcastConfig.eventsToReplay > 0 ? (this.authService.getLogger().verbose(`BroadcastService - replayPastEvents set on BroadcastConfig, replaying the last ${this.msalBroadcastConfig.eventsToReplay} events`), this._msalSubject = new X.t(this.msalBroadcastConfig.eventsToReplay)) : this._msalSubject = new te.x, this.msalSubject$ = this._msalSubject.asObservable(), this._inProgress = new ie.X(D.$H.Startup), this.inProgress$ = this._inProgress.asObservable(), this.msalInstance.addEventCallback(ot => {
											this._msalSubject.next(ot);
											const Vt = ee.getInteractionStatusFromEvent(ot, this._inProgress.value);
											null !== Vt && (this.authService.getLogger().verbose(`BroadcastService - ${ot.eventType} results in setting inProgress from ${this._inProgress.value} to ${Vt}`), this._inProgress.next(Vt))
										})
									}
								}
								return ce.\u0275fac = function(Pe) {
									return new(Pe || ce)(p.LFG(Ue), p.LFG(at), p.LFG(ft, 8))
								}, ce.\u0275prov = p.Yz7({
									token: ce,
									factory: ce.\u0275fac
								}), ce
							})(),
							et = (() => {
								class ce {
									constructor(Pe, pt, Bt, ot, Vt) {
										this.msalGuardConfig = Pe, this.msalBroadcastService = pt, this.authService = Bt, this.location = ot, this.router = Vt, this.msalBroadcastService.inProgress$.subscribe()
									}
									parseUrl(Pe) {
										return this.router.parseUrl(Pe)
									}
									getDestinationUrl(Pe) {
										this.authService.getLogger().verbose("Guard - getting destination url");
										const pt = document.getElementsByTagName("base"),
											Bt = this.location.normalize(pt.length ? pt[0].href : window.location.origin),
											ot = this.location.prepareExternalUrl(Pe);
										return ot.startsWith("#") ? (this.authService.getLogger().verbose("Guard - destination by hash routing"), `${Bt}/${ot}`) : `${Bt}${Pe}`
									}
									loginInteractively(Pe) {
										const pt = "function" == typeof this.msalGuardConfig.authRequest ? this.msalGuardConfig.authRequest(this.authService, Pe) : Object.assign({}, this.msalGuardConfig.authRequest);
										if (this.msalGuardConfig.interactionType === D.s_.Popup) return this.authService.getLogger().verbose("Guard - logging in by popup"), this.authService.loginPopup(pt).pipe((0, Fe.U)(ot => (this.authService.getLogger().verbose("Guard - login by popup successful, can activate, setting active account"), this.authService.instance.setActiveAccount(ot.account), !0)));
										this.authService.getLogger().verbose("Guard - logging in by redirect");
										const Bt = this.getDestinationUrl(Pe.url);
										return this.authService.loginRedirect(Object.assign({
											redirectStartPage: Bt
										}, pt)).pipe((0, Fe.U)(() => !1))
									}
									activateHelper(Pe) {
										if (this.msalGuardConfig.interactionType !== D.s_.Popup && this.msalGuardConfig.interactionType !== D.s_.Redirect) throw new P.W("invalid_interaction_type", "Invalid interaction type provided to MSAL Guard. InteractionType.Popup or InteractionType.Redirect must be provided in the MsalGuardConfiguration");
										if (this.authService.getLogger().verbose("MSAL Guard activated"), !(typeof window < "u")) return this.authService.getLogger().info("Guard - window is undefined, MSAL does not support server-side token acquisition"), (0, oe.of)(!0);
										if (N.G.hashContainsKnownProperties(window.location.hash) && Y.M.isInIframe() && !this.authService.instance.getConfiguration().system.allowRedirectInIframe) return this.authService.getLogger().warning("Guard - redirectUri set to page with MSAL Guard. It is recommended to not set redirectUri to a page that requires authentication."), (0, oe.of)(!1);
										this.msalGuardConfig.loginFailedRoute && (this.loginFailedRoute = this.parseUrl(this.msalGuardConfig.loginFailedRoute));
										const pt = this.location.path(!0);
										return this.authService.handleRedirectObservable().pipe((0, Le.b)(() => {
											if (!this.authService.instance.getAllAccounts().length) return Pe ? (this.authService.getLogger().verbose("Guard - no accounts retrieved, log in required to activate"), this.loginInteractively(Pe)) : (this.authService.getLogger().verbose("Guard - no accounts retrieved, no state, cannot load"), (0, oe.of)(!1));
											if (this.authService.getLogger().verbose("Guard - at least 1 account exists, can activate or load"), Pe) {
												const Bt = this.includesCode(Pe.url),
													ot = !!Pe.root && !!Pe.root.fragment && this.includesCode(`#${Pe.root.fragment}`),
													Vt = 0 === this.location.prepareExternalUrl(Pe.url).indexOf("#");
												if (Bt && (ot || Vt)) return this.authService.getLogger().info("Guard - Hash contains known code response, stopping navigation."), pt.indexOf("#") > -1 ? (0, oe.of)(this.parseUrl(this.location.path())) : (0, oe.of)(this.parseUrl(""))
											}
											return (0, oe.of)(!0)
										}), (0, je.K)(Bt => (this.authService.getLogger().error("Guard - error while logging in, unable to activate"), this.authService.getLogger().errorPii(`Guard - error: ${Bt.message}`), this.loginFailedRoute && parseInt(p.q4F.major, 10) > 9 && Pe ? (this.authService.getLogger().verbose("Guard - loginFailedRoute set, redirecting"), (0, oe.of)(this.loginFailedRoute)) : (0, oe.of)(!1))))
									}
									includesCode(Pe) {
										return Pe.lastIndexOf("/code") > -1 && Pe.lastIndexOf("/code") === Pe.length - 5 || Pe.indexOf("#code=") > -1 || Pe.indexOf("&code=") > -1
									}
									canActivate(Pe, pt) {
										return this.authService.getLogger().verbose("Guard - canActivate"), this.activateHelper(pt)
									}
									canActivateChild(Pe, pt) {
										return this.authService.getLogger().verbose("Guard - canActivateChild"), this.activateHelper(pt)
									}
									canLoad() {
										return this.authService.getLogger().verbose("Guard - canLoad"), this.activateHelper()
									}
								}
								return ce.\u0275fac = function(Pe) {
									return new(Pe || ce)(p.LFG(ke), p.LFG(lt), p.LFG(at), p.LFG(y.Ye), p.LFG(Ee.F0))
								}, ce.\u0275prov = p.Yz7({
									token: ce,
									factory: ce.\u0275fac
								}), ce
							})(),
							Se = (() => {
								class ce {
									constructor(Pe, pt, Bt, ot, Vt) {
										this.msalInterceptorConfig = Pe, this.authService = pt, this.location = Bt, this.msalBroadcastService = ot, this._document = Vt
									}
									intercept(Pe, pt) {
										if (this.msalInterceptorConfig.interactionType !== D.s_.Popup && this.msalInterceptorConfig.interactionType !== D.s_.Redirect) throw new P.W("invalid_interaction_type", "Invalid interaction type provided to MSAL Interceptor. InteractionType.Popup, InteractionType.Redirect must be provided in the msalInterceptorConfiguration");
										this.authService.getLogger().verbose("MSAL Interceptor activated");
										const Bt = this.getScopesForEndpoint(Pe.url, Pe.method);
										if (!Bt || 0 === Bt.length) return this.authService.getLogger().verbose("Interceptor - no scopes for endpoint"), pt.handle(Pe);
										let ot;
										this.authService.instance.getActiveAccount() ? (this.authService.getLogger().verbose("Interceptor - active account selected"), ot = this.authService.instance.getActiveAccount()) : (this.authService.getLogger().verbose("Interceptor - no active account, fallback to first account"), ot = this.authService.instance.getAllAccounts()[0]);
										const Vt = "function" == typeof this.msalInterceptorConfig.authRequest ? this.msalInterceptorConfig.authRequest(this.authService, Pe, {
											account: ot
										}) : Object.assign(Object.assign({}, this.msalInterceptorConfig.authRequest), {
											account: ot
										});
										return this.authService.getLogger().info(`Interceptor - ${Bt.length} scopes found for endpoint`), this.authService.getLogger().infoPii(`Interceptor - [${Bt}] scopes found for ${Pe.url}`), this.acquireToken(Vt, Bt, ot).pipe((0, Ce.w)(Qt => {
											this.authService.getLogger().verbose("Interceptor - setting authorization headers");
											const cn = Pe.headers.set("Authorization", `Bearer ${Qt.accessToken}`),
												Sn = Pe.clone({
													headers: cn
												});
											return pt.handle(Sn)
										}))
									}
									acquireToken(Pe, pt, Bt) {
										return this.authService.acquireTokenSilent(Object.assign(Object.assign({}, Pe), {
											scopes: pt,
											account: Bt
										})).pipe((0, je.K)(() => (this.authService.getLogger().error("Interceptor - acquireTokenSilent rejected with error. Invoking interaction to resolve."), this.msalBroadcastService.inProgress$.pipe((0, F.q)(1), (0, Ce.w)(ot => ot === D.$H.None ? this.acquireTokenInteractively(Pe, pt) : this.msalBroadcastService.inProgress$.pipe((0, xe.h)(Vt => Vt === D.$H.None), (0, F.q)(1), (0, Ce.w)(() => this.acquireToken(Pe, pt, Bt))))))), (0, Ce.w)(ot => ot.accessToken ? (0, oe.of)(ot) : (this.authService.getLogger().error("Interceptor - acquireTokenSilent resolved with null access token. Known issue with B2C tenants, invoking interaction to resolve."), this.msalBroadcastService.inProgress$.pipe((0, xe.h)(Vt => Vt === D.$H.None), (0, F.q)(1), (0, Ce.w)(() => this.acquireTokenInteractively(Pe, pt))))))
									}
									acquireTokenInteractively(Pe, pt) {
										if (this.msalInterceptorConfig.interactionType === D.s_.Popup) return this.authService.getLogger().verbose("Interceptor - error acquiring token silently, acquiring by popup"), this.authService.acquireTokenPopup(Object.assign(Object.assign({}, Pe), {
											scopes: pt
										}));
										this.authService.getLogger().verbose("Interceptor - error acquiring token silently, acquiring by redirect");
										const Bt = window.location.href;
										return this.authService.acquireTokenRedirect(Object.assign(Object.assign({}, Pe), {
											scopes: pt,
											redirectStartPage: Bt
										})), we.E
									}
									getScopesForEndpoint(Pe, pt) {
										this.authService.getLogger().verbose("Interceptor - getting scopes for endpoint");
										const Bt = this.location.normalize(Pe),
											ot = Array.from(this.msalInterceptorConfig.protectedResourceMap.keys()),
											Vt = this.matchResourcesToEndpoint(ot, Bt);
										return Vt.absoluteResources.length > 0 ? this.matchScopesToEndpoint(this.msalInterceptorConfig.protectedResourceMap, Vt.absoluteResources, pt) : Vt.relativeResources.length > 0 ? this.matchScopesToEndpoint(this.msalInterceptorConfig.protectedResourceMap, Vt.relativeResources, pt) : null
									}
									matchResourcesToEndpoint(Pe, pt) {
										const Bt = {
											absoluteResources: [],
											relativeResources: []
										};
										return Pe.forEach(ot => {
											const Vt = this.location.normalize(ot);
											G.x.matchPattern(Vt, pt) && Bt.absoluteResources.push(ot);
											const Qt = this.getAbsoluteUrl(ot),
												cn = new N.G(Qt).getUrlComponents(),
												Sn = this.getAbsoluteUrl(pt),
												Pn = new N.G(Sn).getUrlComponents(),
												mn = cn.QueryString ? `${cn.AbsolutePath}?${cn.QueryString}` : this.location.normalize(cn.AbsolutePath);
											cn.HostNameAndPort === Pn.HostNameAndPort && G.x.matchPattern(mn, Sn) && "" !== mn && "/*" !== mn && Bt.relativeResources.push(ot)
										}), Bt
									}
									getAbsoluteUrl(Pe) {
										const pt = this._document.createElement("a");
										return pt.href = Pe, pt.href
									}
									matchScopesToEndpoint(Pe, pt, Bt) {
										const ot = [];
										return pt.forEach(Vt => {
											const Qt = [],
												cn = Pe.get(Vt);
											null !== cn ? (cn.forEach(Sn => {
												if ("string" == typeof Sn) Qt.push(Sn);
												else {
													const Pn = Bt.toLowerCase();
													Sn.httpMethod.toLowerCase() === Pn && (null === Sn.scopes ? ot.push(null) : Sn.scopes.forEach(Un => {
														Qt.push(Un)
													}))
												}
											}), Qt.length > 0 && ot.push(Qt)) : ot.push(null)
										}), ot.length > 0 ? (ot.length > 1 && this.authService.getLogger().warning("Interceptor - More than 1 matching scopes for endpoint found."), ot[0]) : null
									}
								}
								return ce.\u0275fac = function(Pe) {
									return new(Pe || ce)(p.LFG(Ge), p.LFG(at), p.LFG(y.Ye), p.LFG(lt), p.LFG(y.K0))
								}, ce.\u0275prov = p.Yz7({
									token: ce,
									factory: ce.\u0275fac
								}), ce
							})(),
							Be = (() => {
								class ce {
									constructor(Pe) {
										this.authService = Pe
									}
									ngOnInit() {
										this.authService.getLogger().verbose("MsalRedirectComponent activated"), this.authService.initialize().pipe((0, Le.b)(() => this.authService.handleRedirectObservable())).subscribe()
									}
								}
								return ce.\u0275fac = function(Pe) {
									return new(Pe || ce)(p.Y36(at))
								}, ce.\u0275cmp = p.Xpm({
									type: ce,
									selectors: [
										["app-redirect"]
									],
									decls: 0,
									vars: 0,
									template: function(Pe, pt) {},
									encapsulation: 2
								}), ce
							})()
					}, 4367: (be, ue, E) => {
						E.d(ue, {
							Jh: () => P,
							ZT: () => y,
							_T: () => z,
							fl: () => Y,
							mG: () => ee,
							pi: () => D
						});
						var p = function(G, Q) {
							return (p = Object.setPrototypeOf || {
									__proto__: []
								}
								instanceof Array && function(X, te) {
									X.__proto__ = te
								} || function(X, te) {
									for (var ie in te) Object.prototype.hasOwnProperty.call(te, ie) && (X[ie] = te[ie])
								})(G, Q)
						};

						function y(G, Q) {
							function X() {
								this.constructor = G
							}
							p(G, Q), G.prototype = null === Q ? Object.create(Q) : (X.prototype = Q.prototype, new X)
						}
						var D = function() {
							return D = Object.assign || function(Q) {
								for (var X, te = 1, ie = arguments.length; te < ie; te++)
									for (var oe in X = arguments[te]) Object.prototype.hasOwnProperty.call(X, oe) && (Q[oe] = X[oe]);
								return Q
							}, D.apply(this, arguments)
						};

						function z(G, Q) {
							var X = {};
							for (var te in G) Object.prototype.hasOwnProperty.call(G, te) && Q.indexOf(te) < 0 && (X[te] = G[te]);
							if (null != G && "function" == typeof Object.getOwnPropertySymbols) {
								var ie = 0;
								for (te = Object.getOwnPropertySymbols(G); ie < te.length; ie++) Q.indexOf(te[ie]) < 0 && Object.prototype.propertyIsEnumerable.call(G, te[ie]) && (X[te[ie]] = G[te[ie]])
							}
							return X
						}

						function ee(G, Q, X, te) {
							return new(X || (X = Promise))(function(oe, we) {
								function Fe(Ce) {
									try {
										je(te.next(Ce))
									} catch (F) {
										we(F)
									}
								}

								function Le(Ce) {
									try {
										je(te.throw(Ce))
									} catch (F) {
										we(F)
									}
								}

								function je(Ce) {
									Ce.done ? oe(Ce.value) : function ie(oe) {
										return oe instanceof X ? oe : new X(function(we) {
											we(oe)
										})
									}(Ce.value).then(Fe, Le)
								}
								je((te = te.apply(G, Q || [])).next())
							})
						}

						function P(G, Q) {
							var te, ie, oe, we, X = {
								label: 0,
								sent: function() {
									if (1 & oe[0]) throw oe[1];
									return oe[1]
								},
								trys: [],
								ops: []
							};
							return we = {
								next: Fe(0),
								throw: Fe(1),
								return: Fe(2)
							}, "function" == typeof Symbol && (we[Symbol.iterator] = function() {
								return this
							}), we;

							function Fe(je) {
								return function(Ce) {
									return function Le(je) {
										if (te) throw new TypeError("Generator is already executing.");
										for (; X;) try {
											if (te = 1, ie && (oe = 2 & je[0] ? ie.return : je[0] ? ie.throw || ((oe = ie.return) && oe.call(ie), 0) : ie.next) && !(oe = oe.call(ie, je[1])).done) return oe;
											switch (ie = 0, oe && (je = [2 & je[0], oe.value]), je[0]) {
												case 0:
												case 1:
													oe = je;
													break;
												case 4:
													return X.label++, {
														value: je[1],
														done: !1
													};
												case 5:
													X.label++, ie = je[1], je = [0];
													continue;
												case 7:
													je = X.ops.pop(), X.trys.pop();
													continue;
												default:
													if (!(oe = (oe = X.trys).length > 0 && oe[oe.length - 1]) && (6 === je[0] || 2 === je[0])) {
														X = 0;
														continue
													}
													if (3 === je[0] && (!oe || je[1] > oe[0] && je[1] < oe[3])) {
														X.label = je[1];
														break
													}
													if (6 === je[0] && X.label < oe[1]) {
														X.label = oe[1], oe = je;
														break
													}
													if (oe && X.label < oe[2]) {
														X.label = oe[2], X.ops.push(je);
														break
													}
													oe[2] && X.ops.pop(), X.trys.pop();
													continue
											}
											je = Q.call(G, X)
										} catch (Ce) {
											je = [6, Ce], ie = 0
										} finally {
											te = oe = 0
										}
										if (5 & je[0]) throw je[1];
										return {
											value: je[0] ? je[1] : void 0,
											done: !0
										}
									}([je, Ce])
								}
							}
						}

						function N(G, Q) {
							var X = "function" == typeof Symbol && G[Symbol.iterator];
							if (!X) return G;
							var ie, we, te = X.call(G),
								oe = [];
							try {
								for (;
									(void 0 === Q || Q-- > 0) && !(ie = te.next()).done;) oe.push(ie.value)
							} catch (Fe) {
								we = {
									error: Fe
								}
							} finally {
								try {
									ie && !ie.done && (X = te.return) && X.call(te)
								} finally {
									if (we) throw we.error
								}
							}
							return oe
						}

						function Y() {
							for (var G = [], Q = 0; Q < arguments.length; Q++) G = G.concat(N(arguments[Q]));
							return G
						}
					}, 5963: (be, ue, E) => {
						E.d(ue, {
							U: () => ee,
							n: () => z
						});
						var p = E(4367),
							y = E(1327),
							D = E(2728),
							z = {
								pkceNotGenerated: {
									code: "pkce_not_created",
									desc: "The PKCE code challenge and verifier could not be generated."
								},
								cryptoDoesNotExist: {
									code: "crypto_nonexistent",
									desc: "The crypto object or function is not available."
								},
								httpMethodNotImplementedError: {
									code: "http_method_not_implemented",
									desc: "The HTTP method given has not been implemented in this library."
								},
								emptyNavigateUriError: {
									code: "empty_navigate_uri",
									desc: "Navigation URI is empty. Please check stack trace for more info."
								},
								hashEmptyError: {
									code: "hash_empty_error",
									desc: "Hash value cannot be processed because it is empty. Please verify that your redirectUri is not clearing the hash. For more visit: aka.ms/msaljs/browser-errors."
								},
								hashDoesNotContainStateError: {
									code: "no_state_in_hash",
									desc: "Hash does not contain state. Please verify that the request originated from msal."
								},
								hashDoesNotContainKnownPropertiesError: {
									code: "hash_does_not_contain_known_properties",
									desc: "Hash does not contain known properites. Please verify that your redirectUri is not changing the hash. For more visit: aka.ms/msaljs/browser-errors."
								},
								unableToParseStateError: {
									code: "unable_to_parse_state",
									desc: "Unable to parse state. Please verify that the request originated from msal."
								},
								stateInteractionTypeMismatchError: {
									code: "state_interaction_type_mismatch",
									desc: "Hash contains state but the interaction type does not match the caller."
								},
								interactionInProgress: {
									code: "interaction_in_progress",
									desc: "Interaction is currently in progress. Please ensure that this interaction has been completed before calling an interactive API.  For more visit: aka.ms/msaljs/browser-errors."
								},
								popupWindowError: {
									code: "popup_window_error",
									desc: "Error opening popup window. This can happen if you are using IE or if popups are blocked in the browser."
								},
								emptyWindowError: {
									code: "empty_window_error",
									desc: "window.open returned null or undefined window object."
								},
								userCancelledError: {
									code: "user_cancelled",
									desc: "User cancelled the flow."
								},
								monitorPopupTimeoutError: {
									code: "monitor_window_timeout",
									desc: "Token acquisition in popup failed due to timeout. For more visit: aka.ms/msaljs/browser-errors."
								},
								monitorIframeTimeoutError: {
									code: "monitor_window_timeout",
									desc: "Token acquisition in iframe failed due to timeout. For more visit: aka.ms/msaljs/browser-errors."
								},
								redirectInIframeError: {
									code: "redirect_in_iframe",
									desc: "Redirects are not supported for iframed or brokered applications. Please ensure you are using MSAL.js in a top frame of the window if using the redirect APIs, or use the popup APIs."
								},
								blockTokenRequestsInHiddenIframeError: {
									code: "block_iframe_reload",
									desc: "Request was blocked inside an iframe because MSAL detected an authentication response. For more visit: aka.ms/msaljs/browser-errors"
								},
								blockAcquireTokenInPopupsError: {
									code: "block_nested_popups",
									desc: "Request was blocked inside a popup because MSAL detected it was running in a popup."
								},
								iframeClosedPrematurelyError: {
									code: "iframe_closed_prematurely",
									desc: "The iframe being monitored was closed prematurely."
								},
								silentLogoutUnsupportedError: {
									code: "silent_logout_unsupported",
									desc: "Silent logout not supported. Please call logoutRedirect or logoutPopup instead."
								},
								noAccountError: {
									code: "no_account_error",
									desc: "No account object provided to acquireTokenSilent and no active account has been set. Please call setActiveAccount or provide an account on the request."
								},
								silentPromptValueError: {
									code: "silent_prompt_value_error",
									desc: "The value given for the prompt value is not valid for silent requests - must be set to 'none' or 'no_session'."
								},
								noTokenRequestCacheError: {
									code: "no_token_request_cache_error",
									desc: "No token request found in cache."
								},
								unableToParseTokenRequestCacheError: {
									code: "unable_to_parse_token_request_cache_error",
									desc: "The cached token request could not be parsed."
								},
								noCachedAuthorityError: {
									code: "no_cached_authority_error",
									desc: "No cached authority found."
								},
								authRequestNotSet: {
									code: "auth_request_not_set_error",
									desc: "Auth Request not set. Please ensure initiateAuthRequest was called from the InteractionHandler"
								},
								invalidCacheType: {
									code: "invalid_cache_type",
									desc: "Invalid cache type"
								},
								notInBrowserEnvironment: {
									code: "non_browser_environment",
									desc: "Login and token requests are not supported in non-browser environments."
								},
								databaseNotOpen: {
									code: "database_not_open",
									desc: "Database is not open!"
								},
								noNetworkConnectivity: {
									code: "no_network_connectivity",
									desc: "No network connectivity. Check your internet connection."
								},
								postRequestFailed: {
									code: "post_request_failed",
									desc: "Network request failed: If the browser threw a CORS error, check that the redirectUri is registered in the Azure App Portal as type 'SPA'"
								},
								getRequestFailed: {
									code: "get_request_failed",
									desc: "Network request failed. Please check the network trace to determine root cause."
								},
								failedToParseNetworkResponse: {
									code: "failed_to_parse_response",
									desc: "Failed to parse network response. Check network trace."
								},
								unableToLoadTokenError: {
									code: "unable_to_load_token",
									desc: "Error loading token to cache."
								},
								signingKeyNotFoundInStorage: {
									code: "crypto_key_not_found",
									desc: "Cryptographic Key or Keypair not found in browser storage."
								},
								authCodeRequired: {
									code: "auth_code_required",
									desc: "An authorization code must be provided (as the `code` property on the request) to this flow."
								},
								authCodeOrNativeAccountRequired: {
									code: "auth_code_or_nativeAccountId_required",
									desc: "An authorization code or nativeAccountId must be provided to this flow."
								},
								spaCodeAndNativeAccountPresent: {
									code: "spa_code_and_nativeAccountId_present",
									desc: "Request cannot contain both spa code and native account id."
								},
								databaseUnavailable: {
									code: "database_unavailable",
									desc: "IndexedDB, which is required for persistent cryptographic key storage, is unavailable. This may be caused by browser privacy features which block persistent storage in third-party contexts."
								},
								unableToAcquireTokenFromNativePlatform: {
									code: "unable_to_acquire_token_from_native_platform",
									desc: "Unable to acquire token from native platform. For a list of possible reasons visit aka.ms/msaljs/browser-errors."
								},
								nativeHandshakeTimeout: {
									code: "native_handshake_timeout",
									desc: "Timed out while attempting to establish connection to browser extension"
								},
								nativeExtensionNotInstalled: {
									code: "native_extension_not_installed",
									desc: "Native extension is not installed. If you think this is a mistake call the initialize function."
								},
								nativeConnectionNotEstablished: {
									code: "native_connection_not_established",
									desc: "Connection to native platform has not been established. Please install a compatible browser extension and run initialize(). For more please visit aka.ms/msaljs/browser-errors."
								},
								nativeBrokerCalledBeforeInitialize: {
									code: "native_broker_called_before_initialize",
									desc: "You must call and await the initialize function before attempting to call any other MSAL API when native brokering is enabled. For more please visit aka.ms/msaljs/browser-errors."
								},
								nativePromptNotSupported: {
									code: "native_prompt_not_supported",
									desc: "The provided prompt is not supported by the native platform. This request should be routed to the web based flow."
								}
							},
							ee = function(P) {
								function N(Y, G) {
									var Q = P.call(this, Y, G) || this;
									return Object.setPrototypeOf(Q, N.prototype), Q.name = "BrowserAuthError", Q
								}
								return (0, p.ZT)(N, P), N.createPkceNotGeneratedError = function(Y) {
									return new N(z.pkceNotGenerated.code, z.pkceNotGenerated.desc + " Detail:" + Y)
								}, N.createCryptoNotAvailableError = function(Y) {
									return new N(z.cryptoDoesNotExist.code, z.cryptoDoesNotExist.desc + " Detail:" + Y)
								}, N.createHttpMethodNotImplementedError = function(Y) {
									return new N(z.httpMethodNotImplementedError.code, z.httpMethodNotImplementedError.desc + " Given Method: " + Y)
								}, N.createEmptyNavigationUriError = function() {
									return new N(z.emptyNavigateUriError.code, z.emptyNavigateUriError.desc)
								}, N.createEmptyHashError = function(Y) {
									return new N(z.hashEmptyError.code, z.hashEmptyError.desc + " Given Url: " + Y)
								}, N.createHashDoesNotContainStateError = function() {
									return new N(z.hashDoesNotContainStateError.code, z.hashDoesNotContainStateError.desc)
								}, N.createHashDoesNotContainKnownPropertiesError = function() {
									return new N(z.hashDoesNotContainKnownPropertiesError.code, z.hashDoesNotContainKnownPropertiesError.desc)
								}, N.createUnableToParseStateError = function() {
									return new N(z.unableToParseStateError.code, z.unableToParseStateError.desc)
								}, N.createStateInteractionTypeMismatchError = function() {
									return new N(z.stateInteractionTypeMismatchError.code, z.stateInteractionTypeMismatchError.desc)
								}, N.createInteractionInProgressError = function() {
									return new N(z.interactionInProgress.code, z.interactionInProgress.desc)
								}, N.createPopupWindowError = function(Y) {
									var G = z.popupWindowError.desc;
									return G = y.x.isEmpty(Y) ? G : G + " Details: " + Y, new N(z.popupWindowError.code, G)
								}, N.createEmptyWindowCreatedError = function() {
									return new N(z.emptyWindowError.code, z.emptyWindowError.desc)
								}, N.createUserCancelledError = function() {
									return new N(z.userCancelledError.code, z.userCancelledError.desc)
								}, N.createMonitorPopupTimeoutError = function() {
									return new N(z.monitorPopupTimeoutError.code, z.monitorPopupTimeoutError.desc)
								}, N.createMonitorIframeTimeoutError = function() {
									return new N(z.monitorIframeTimeoutError.code, z.monitorIframeTimeoutError.desc)
								}, N.createRedirectInIframeError = function(Y) {
									return new N(z.redirectInIframeError.code, z.redirectInIframeError.desc + " (window.parent !== window) => " + Y)
								}, N.createBlockReloadInHiddenIframeError = function() {
									return new N(z.blockTokenRequestsInHiddenIframeError.code, z.blockTokenRequestsInHiddenIframeError.desc)
								}, N.createBlockAcquireTokenInPopupsError = function() {
									return new N(z.blockAcquireTokenInPopupsError.code, z.blockAcquireTokenInPopupsError.desc)
								}, N.createIframeClosedPrematurelyError = function() {
									return new N(z.iframeClosedPrematurelyError.code, z.iframeClosedPrematurelyError.desc)
								}, N.createSilentLogoutUnsupportedError = function() {
									return new N(z.silentLogoutUnsupportedError.code, z.silentLogoutUnsupportedError.desc)
								}, N.createNoAccountError = function() {
									return new N(z.noAccountError.code, z.noAccountError.desc)
								}, N.createSilentPromptValueError = function(Y) {
									return new N(z.silentPromptValueError.code, z.silentPromptValueError.desc + " Given value: " + Y)
								}, N.createUnableToParseTokenRequestCacheError = function() {
									return new N(z.unableToParseTokenRequestCacheError.code, z.unableToParseTokenRequestCacheError.desc)
								}, N.createNoTokenRequestCacheError = function() {
									return new N(z.noTokenRequestCacheError.code, z.noTokenRequestCacheError.desc)
								}, N.createAuthRequestNotSetError = function() {
									return new N(z.authRequestNotSet.code, z.authRequestNotSet.desc)
								}, N.createNoCachedAuthorityError = function() {
									return new N(z.noCachedAuthorityError.code, z.noCachedAuthorityError.desc)
								}, N.createInvalidCacheTypeError = function() {
									return new N(z.invalidCacheType.code, "" + z.invalidCacheType.desc)
								}, N.createNonBrowserEnvironmentError = function() {
									return new N(z.notInBrowserEnvironment.code, z.notInBrowserEnvironment.desc)
								}, N.createDatabaseNotOpenError = function() {
									return new N(z.databaseNotOpen.code, z.databaseNotOpen.desc)
								}, N.createNoNetworkConnectivityError = function() {
									return new N(z.noNetworkConnectivity.code, z.noNetworkConnectivity.desc)
								}, N.createPostRequestFailedError = function(Y, G) {
									return new N(z.postRequestFailed.code, z.postRequestFailed.desc + " | Network client threw: " + Y + " | Attempted to reach: " + G.split("?")[0])
								}, N.createGetRequestFailedError = function(Y, G) {
									return new N(z.getRequestFailed.code, z.getRequestFailed.desc + " | Network client threw: " + Y + " | Attempted to reach: " + G.split("?")[0])
								}, N.createFailedToParseNetworkResponseError = function(Y) {
									return new N(z.failedToParseNetworkResponse.code, z.failedToParseNetworkResponse.desc + " | Attempted to reach: " + Y.split("?")[0])
								}, N.createUnableToLoadTokenError = function(Y) {
									return new N(z.unableToLoadTokenError.code, z.unableToLoadTokenError.desc + " | " + Y)
								}, N.createSigningKeyNotFoundInStorageError = function(Y) {
									return new N(z.signingKeyNotFoundInStorage.code, z.signingKeyNotFoundInStorage.desc + " | No match found for KeyId: " + Y)
								}, N.createAuthCodeRequiredError = function() {
									return new N(z.authCodeRequired.code, z.authCodeRequired.desc)
								}, N.createAuthCodeOrNativeAccountIdRequiredError = function() {
									return new N(z.authCodeOrNativeAccountRequired.code, z.authCodeOrNativeAccountRequired.desc)
								}, N.createSpaCodeAndNativeAccountIdPresentError = function() {
									return new N(z.spaCodeAndNativeAccountPresent.code, z.spaCodeAndNativeAccountPresent.desc)
								}, N.createDatabaseUnavailableError = function() {
									return new N(z.databaseUnavailable.code, z.databaseUnavailable.desc)
								}, N.createUnableToAcquireTokenFromNativePlatformError = function() {
									return new N(z.unableToAcquireTokenFromNativePlatform.code, z.unableToAcquireTokenFromNativePlatform.desc)
								}, N.createNativeHandshakeTimeoutError = function() {
									return new N(z.nativeHandshakeTimeout.code, z.nativeHandshakeTimeout.desc)
								}, N.createNativeExtensionNotInstalledError = function() {
									return new N(z.nativeExtensionNotInstalled.code, z.nativeExtensionNotInstalled.desc)
								}, N.createNativeConnectionNotEstablishedError = function() {
									return new N(z.nativeConnectionNotEstablished.code, z.nativeConnectionNotEstablished.desc)
								}, N.createNativeBrokerCalledBeforeInitialize = function() {
									return new N(z.nativeBrokerCalledBeforeInitialize.code, z.nativeBrokerCalledBeforeInitialize.desc)
								}, N.createNativePromptParameterNotSupportedError = function() {
									return new N(z.nativePromptNotSupported.code, z.nativePromptNotSupported.desc)
								}, N
							}(D.l)
					}, 3593: (be, ue, E) => {
						E.d(ue, {
							W: () => z
						});
						var p = E(4367),
							y = E(2728),
							D_redirectUriNotSet_code = "redirect_uri_empty",
							D_redirectUriNotSet_desc = "A redirect URI is required for all calls, and none has been set.",
							D_postLogoutUriNotSet_code = "post_logout_uri_empty",
							D_postLogoutUriNotSet_desc = "A post logout redirect has not been set.",
							D_storageNotSupportedError_code = "storage_not_supported",
							D_storageNotSupportedError_desc = "Given storage configuration option was not supported.",
							D_noRedirectCallbacksSet_code = "no_redirect_callbacks",
							D_noRedirectCallbacksSet_desc = "No redirect callbacks have been set. Please call setRedirectCallbacks() with the appropriate function arguments before continuing. More information is available here: https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki/MSAL-basics.",
							D_stubPcaInstanceCalled_code = "stubbed_public_client_application_called",
							D_stubPcaInstanceCalled_desc = "Stub instance of Public Client Application was called. If using msal-react, please ensure context is not used without a provider. For more visit: aka.ms/msaljs/browser-errors",
							D_inMemRedirectUnavailable_code = "in_mem_redirect_unavailable",
							D_inMemRedirectUnavailable_desc = "Redirect cannot be supported. In-memory storage was selected and storeAuthStateInCookie=false, which would cause the library to be unable to handle the incoming hash. If you would like to use the redirect API, please use session/localStorage or set storeAuthStateInCookie=true.",
							D_entropyNotProvided_code = "entropy_not_provided",
							D_entropyNotProvided_desc = "The available browser crypto interface requires entropy set via system.cryptoOptions.entropy configuration option.",
							z = function(ee) {
								function P(N, Y) {
									var G = ee.call(this, N, Y) || this;
									return G.name = "BrowserConfigurationAuthError", Object.setPrototypeOf(G, P.prototype), G
								}
								return (0, p.ZT)(P, ee), P.createRedirectUriEmptyError = function() {
									return new P(D_redirectUriNotSet_code, D_redirectUriNotSet_desc)
								}, P.createPostLogoutRedirectUriEmptyError = function() {
									return new P(D_postLogoutUriNotSet_code, D_postLogoutUriNotSet_desc)
								}, P.createStorageNotSupportedError = function(N) {
									return new P(D_storageNotSupportedError_code, D_storageNotSupportedError_desc + " Given Location: " + N)
								}, P.createRedirectCallbacksNotSetError = function() {
									return new P(D_noRedirectCallbacksSet_code, D_noRedirectCallbacksSet_desc)
								}, P.createStubPcaInstanceCalledError = function() {
									return new P(D_stubPcaInstanceCalled_code, D_stubPcaInstanceCalled_desc)
								}, P.createInMemoryRedirectUnavailableError = function() {
									return new P(D_inMemRedirectUnavailable_code, D_inMemRedirectUnavailable_desc)
								}, P.createEntropyNotProvided = function() {
									return new P(D_entropyNotProvided_code, D_entropyNotProvided_desc)
								}, P
							}(y.l)
					}, 4337: (be, ue, E) => {
						E.d(ue, {
							t: () => p
						});
						var p = (() => {
							return (y = p || (p = {})).INITIALIZE_START = "msal:initializeStart", y.INITIALIZE_END = "msal:initializeEnd", y.ACCOUNT_ADDED = "msal:accountAdded", y.ACCOUNT_REMOVED = "msal:accountRemoved", y.LOGIN_START = "msal:loginStart", y.LOGIN_SUCCESS = "msal:loginSuccess", y.LOGIN_FAILURE = "msal:loginFailure", y.ACQUIRE_TOKEN_START = "msal:acquireTokenStart", y.ACQUIRE_TOKEN_SUCCESS = "msal:acquireTokenSuccess", y.ACQUIRE_TOKEN_FAILURE = "msal:acquireTokenFailure", y.ACQUIRE_TOKEN_NETWORK_START = "msal:acquireTokenFromNetworkStart", y.SSO_SILENT_START = "msal:ssoSilentStart", y.SSO_SILENT_SUCCESS = "msal:ssoSilentSuccess", y.SSO_SILENT_FAILURE = "msal:ssoSilentFailure", y.ACQUIRE_TOKEN_BY_CODE_START = "msal:acquireTokenByCodeStart", y.ACQUIRE_TOKEN_BY_CODE_SUCCESS = "msal:acquireTokenByCodeSuccess", y.ACQUIRE_TOKEN_BY_CODE_FAILURE = "msal:acquireTokenByCodeFailure", y.HANDLE_REDIRECT_START = "msal:handleRedirectStart", y.HANDLE_REDIRECT_END = "msal:handleRedirectEnd", y.POPUP_OPENED = "msal:popupOpened", y.LOGOUT_START = "msal:logoutStart", y.LOGOUT_SUCCESS = "msal:logoutSuccess", y.LOGOUT_FAILURE = "msal:logoutFailure", y.LOGOUT_END = "msal:logoutEnd", p;
							var y
						})()
					}, 4857: (be, ue, E) => {
						E.d(ue, {
							$H: () => X,
							BD: () => D,
							Bs: () => Y,
							EC: () => P,
							Gv: () => Le,
							H4: () => we,
							Ix: () => ee,
							Ky: () => z,
							Mm: () => ie,
							WN: () => G,
							c4: () => N,
							kd: () => Fe,
							lA: () => oe,
							lu: () => je,
							qx: () => y,
							s_: () => Q,
							yo: () => te
						});
						var p = E(9986),
							y = {
								INTERACTION_IN_PROGRESS_VALUE: "interaction_in_progress",
								INVALID_GRANT_ERROR: "invalid_grant",
								POPUP_WIDTH: 483,
								POPUP_HEIGHT: 600,
								POPUP_NAME_PREFIX: "msal",
								DEFAULT_POLL_INTERVAL_MS: 30,
								MSAL_SKU: "msal.js.browser"
							},
							D = {
								CHANNEL_ID: "53ee284d-920a-4b59-9d30-a60315b26836",
								PREFERRED_EXTENSION_ID: "ppnbnpeolgkicgegkbkbjmhlideopiji",
								MATS_TELEMETRY: "MATS"
							},
							z = (() => {
								return (Ce = z || (z = {})).HandshakeRequest = "Handshake", Ce.HandshakeResponse = "HandshakeResponse", Ce.GetToken = "GetToken", Ce.Response = "Response", z;
								var Ce
							})(),
							ee = (() => {
								return (Ce = ee || (ee = {})).LocalStorage = "localStorage", Ce.SessionStorage = "sessionStorage", Ce.MemoryStorage = "memoryStorage", ee;
								var Ce
							})(),
							P = (() => {
								return (Ce = P || (P = {})).GET = "GET", Ce.POST = "POST", P;
								var Ce
							})(),
							N = (() => {
								return (Ce = N || (N = {})).AUTHORITY = "authority", Ce.ACQUIRE_TOKEN_ACCOUNT = "acquireToken.account", Ce.SESSION_STATE = "session.state", Ce.REQUEST_STATE = "request.state", Ce.NONCE_IDTOKEN = "nonce.id_token", Ce.ORIGIN_URI = "request.origin", Ce.RENEW_STATUS = "token.renew.status", Ce.URL_HASH = "urlHash", Ce.REQUEST_PARAMS = "request.params", Ce.SCOPES = "scopes", Ce.INTERACTION_STATUS_KEY = "interaction.status", Ce.CCS_CREDENTIAL = "ccs.credential", Ce.CORRELATION_ID = "request.correlationId", Ce.NATIVE_REQUEST = "request.native", Ce.REDIRECT_CONTEXT = "request.redirect.context", N;
								var Ce
							})(),
							Y = (() => {
								return (Ce = Y || (Y = {})).WRAPPER_SKU = "wrapper.sku", Ce.WRAPPER_VER = "wrapper.version", Y;
								var Ce
							})(),
							G = (() => {
								return (Ce = G || (G = {}))[Ce.acquireTokenRedirect = 861] = "acquireTokenRedirect", Ce[Ce.acquireTokenPopup = 862] = "acquireTokenPopup", Ce[Ce.ssoSilent = 863] = "ssoSilent", Ce[Ce.acquireTokenSilent_authCode = 864] = "acquireTokenSilent_authCode", Ce[Ce.handleRedirectPromise = 865] = "handleRedirectPromise", Ce[Ce.acquireTokenByCode = 866] = "acquireTokenByCode", Ce[Ce.acquireTokenSilent_silentFlow = 61] = "acquireTokenSilent_silentFlow", Ce[Ce.logout = 961] = "logout", Ce[Ce.logoutPopup = 962] = "logoutPopup", G;
								var Ce
							})(),
							Q = (() => {
								return (Ce = Q || (Q = {})).Redirect = "redirect", Ce.Popup = "popup", Ce.Silent = "silent", Ce.None = "none", Q;
								var Ce
							})(),
							X = (() => {
								return (Ce = X || (X = {})).Startup = "startup", Ce.Login = "login", Ce.Logout = "logout", Ce.AcquireToken = "acquireToken", Ce.SsoSilent = "ssoSilent", Ce.HandleRedirect = "handleRedirect", Ce.None = "none", X;
								var Ce
							})(),
							te = {
								scopes: p.f_
							},
							ie = "jwk",
							oe = (() => {
								return (Ce = oe || (oe = {})).React = "@azure/msal-react", Ce.Angular = "@azure/msal-angular", oe;
								var Ce
							})(),
							we = "msal.db",
							Fe = 1,
							Le = we + ".keys",
							je = (() => {
								return (Ce = je || (je = {}))[Ce.Default = 0] = "Default", Ce[Ce.AccessToken = 1] = "AccessToken", Ce[Ce.AccessTokenAndRefreshToken = 2] = "AccessTokenAndRefreshToken", Ce[Ce.RefreshToken = 3] = "RefreshToken", Ce[Ce.RefreshTokenAndNetwork = 4] = "RefreshTokenAndNetwork", Ce[Ce.Skip = 5] = "Skip", je;
								var Ce
							})()
					}, 4098: (be, ue, E) => {
						E.d(ue, {
							M: () => Y
						});
						var p = E(9986),
							y = E(6767),
							D = E(4367),
							z = E(5963),
							ee = E(4857),
							P = function() {
								function G() {}
								return G.prototype.sendGetRequestAsync = function(Q, X) {
									return (0, D.mG)(this, void 0, void 0, function() {
										var te, ie, oe;
										return (0, D.Jh)(this, function(we) {
											switch (we.label) {
												case 0:
													return we.trys.push([0, 2, , 3]), [4, fetch(Q, {
														method: ee.EC.GET,
														headers: this.getFetchHeaders(X)
													})];
												case 1:
													return te = we.sent(), [3, 3];
												case 2:
													throw ie = we.sent(), window.navigator.onLine ? z.U.createGetRequestFailedError(ie, Q) : z.U.createNoNetworkConnectivityError();
												case 3:
													return we.trys.push([3, 5, , 6]), oe = {
														headers: this.getHeaderDict(te.headers)
													}, [4, te.json()];
												case 4:
													return [2, (oe.body = we.sent(), oe.status = te.status, oe)];
												case 5:
													throw we.sent(), z.U.createFailedToParseNetworkResponseError(Q);
												case 6:
													return [2]
											}
										})
									})
								}, G.prototype.sendPostRequestAsync = function(Q, X) {
									return (0, D.mG)(this, void 0, void 0, function() {
										var te, ie, oe, we;
										return (0, D.Jh)(this, function(Fe) {
											switch (Fe.label) {
												case 0:
													te = X && X.body || p.gT.EMPTY_STRING, Fe.label = 1;
												case 1:
													return Fe.trys.push([1, 3, , 4]), [4, fetch(Q, {
														method: ee.EC.POST,
														headers: this.getFetchHeaders(X),
														body: te
													})];
												case 2:
													return ie = Fe.sent(), [3, 4];
												case 3:
													throw oe = Fe.sent(), window.navigator.onLine ? z.U.createPostRequestFailedError(oe, Q) : z.U.createNoNetworkConnectivityError();
												case 4:
													return Fe.trys.push([4, 6, , 7]), we = {
														headers: this.getHeaderDict(ie.headers)
													}, [4, ie.json()];
												case 5:
													return [2, (we.body = Fe.sent(), we.status = ie.status, we)];
												case 6:
													throw Fe.sent(), z.U.createFailedToParseNetworkResponseError(Q);
												case 7:
													return [2]
											}
										})
									})
								}, G.prototype.getFetchHeaders = function(Q) {
									var X = new Headers;
									if (!Q || !Q.headers) return X;
									var te = Q.headers;
									return Object.keys(te).forEach(function(ie) {
										X.append(ie, te[ie])
									}), X
								}, G.prototype.getHeaderDict = function(Q) {
									var X = {};
									return Q.forEach(function(te, ie) {
										X[ie] = te
									}), X
								}, G
							}(),
							N = function() {
								function G() {}
								return G.prototype.sendGetRequestAsync = function(Q, X) {
									return (0, D.mG)(this, void 0, void 0, function() {
										return (0, D.Jh)(this, function(te) {
											return [2, this.sendRequestAsync(Q, ee.EC.GET, X)]
										})
									})
								}, G.prototype.sendPostRequestAsync = function(Q, X) {
									return (0, D.mG)(this, void 0, void 0, function() {
										return (0, D.Jh)(this, function(te) {
											return [2, this.sendRequestAsync(Q, ee.EC.POST, X)]
										})
									})
								}, G.prototype.sendRequestAsync = function(Q, X, te) {
									var ie = this;
									return new Promise(function(oe, we) {
										var Fe = new XMLHttpRequest;
										if (Fe.open(X, Q, !0), ie.setXhrHeaders(Fe, te), Fe.onload = function() {
												(Fe.status < 200 || Fe.status >= 300) && we(X === ee.EC.POST ? z.U.createPostRequestFailedError("Failed with status " + Fe.status, Q) : z.U.createGetRequestFailedError("Failed with status " + Fe.status, Q));
												try {
													var Le = JSON.parse(Fe.responseText),
														je = {
															headers: ie.getHeaderDict(Fe),
															body: Le,
															status: Fe.status
														};
													oe(je)
												} catch {
													we(z.U.createFailedToParseNetworkResponseError(Q))
												}
											}, Fe.onerror = function() {
												window.navigator.onLine ? we(X === ee.EC.POST ? z.U.createPostRequestFailedError("Failed with status " + Fe.status, Q) : z.U.createGetRequestFailedError("Failed with status " + Fe.status, Q)) : we(z.U.createNoNetworkConnectivityError())
											}, X === ee.EC.POST && te && te.body) Fe.send(te.body);
										else {
											if (X !== ee.EC.GET) throw z.U.createHttpMethodNotImplementedError(X);
											Fe.send()
										}
									})
								}, G.prototype.setXhrHeaders = function(Q, X) {
									if (X && X.headers) {
										var te = X.headers;
										Object.keys(te).forEach(function(ie) {
											Q.setRequestHeader(ie, te[ie])
										})
									}
								}, G.prototype.getHeaderDict = function(Q) {
									var te = Q.getAllResponseHeaders().trim().split(/[\r\n]+/),
										ie = {};
									return te.forEach(function(oe) {
										var we = oe.split(": "),
											Fe = we.shift(),
											Le = we.join(": ");
										Fe && Le && (ie[Fe] = Le)
									}), ie
								}, G
							}(),
							Y = function() {
								function G() {}
								return G.clearHash = function(Q) {
									Q.location.hash = p.gT.EMPTY_STRING, "function" == typeof Q.history.replaceState && Q.history.replaceState(null, p.gT.EMPTY_STRING, "" + Q.location.origin + Q.location.pathname + Q.location.search)
								}, G.replaceHash = function(Q) {
									var X = Q.split("#");
									X.shift(), window.location.hash = X.length > 0 ? X.join("#") : p.gT.EMPTY_STRING
								}, G.isInIframe = function() {
									return window.parent !== window
								}, G.isInPopup = function() {
									return typeof window < "u" && !!window.opener && window.opener !== window && "string" == typeof window.name && 0 === window.name.indexOf(ee.qx.POPUP_NAME_PREFIX + ".")
								}, G.getCurrentUri = function() {
									return window.location.href.split("?")[0].split("#")[0]
								}, G.getHomepage = function() {
									var X = new y.G(window.location.href).getUrlComponents();
									return X.Protocol + "//" + X.HostNameAndPort + "/"
								}, G.getBrowserNetworkClient = function() {
									return window.fetch && window.Headers ? new P : new N
								}, G.blockReloadInHiddenIframes = function() {
									if (y.G.hashContainsKnownProperties(window.location.hash) && G.isInIframe()) throw z.U.createBlockReloadInHiddenIframeError()
								}, G.blockRedirectInIframe = function(Q, X) {
									var te = G.isInIframe();
									if (Q === ee.s_.Redirect && te && !X) throw z.U.createRedirectInIframeError(te)
								}, G.blockAcquireTokenInPopups = function() {
									if (G.isInPopup()) throw z.U.createBlockAcquireTokenInPopupsError()
								}, G.blockNonBrowserEnvironment = function(Q) {
									if (!Q) throw z.U.createNonBrowserEnvironmentError()
								}, G.blockNativeBrokerCalledBeforeInitialized = function(Q, X) {
									if (Q && !X) throw z.U.createNativeBrokerCalledBeforeInitialize()
								}, G.detectIEOrEdge = function() {
									var Q = window.navigator.userAgent,
										X = Q.indexOf("MSIE "),
										te = Q.indexOf("Trident/"),
										ie = Q.indexOf("Edge/");
									return X > 0 || te > 0 || ie > 0
								}, G
							}()
					}, 2689: (be, ue, E) => {
						E.d(ue, {
							Jh: () => ee,
							ZT: () => y,
							mG: () => z,
							pi: () => D,
							pr: () => P
						});
						var p = function(N, Y) {
							return (p = Object.setPrototypeOf || {
									__proto__: []
								}
								instanceof Array && function(G, Q) {
									G.__proto__ = Q
								} || function(G, Q) {
									for (var X in Q) Object.prototype.hasOwnProperty.call(Q, X) && (G[X] = Q[X])
								})(N, Y)
						};

						function y(N, Y) {
							function G() {
								this.constructor = N
							}
							p(N, Y), N.prototype = null === Y ? Object.create(Y) : (G.prototype = Y.prototype, new G)
						}
						var D = function() {
							return D = Object.assign || function(Y) {
								for (var G, Q = 1, X = arguments.length; Q < X; Q++)
									for (var te in G = arguments[Q]) Object.prototype.hasOwnProperty.call(G, te) && (Y[te] = G[te]);
								return Y
							}, D.apply(this, arguments)
						};

						function z(N, Y, G, Q) {
							return new(G || (G = Promise))(function(te, ie) {
								function oe(Le) {
									try {
										Fe(Q.next(Le))
									} catch (je) {
										ie(je)
									}
								}

								function we(Le) {
									try {
										Fe(Q.throw(Le))
									} catch (je) {
										ie(je)
									}
								}

								function Fe(Le) {
									Le.done ? te(Le.value) : function X(te) {
										return te instanceof G ? te : new G(function(ie) {
											ie(te)
										})
									}(Le.value).then(oe, we)
								}
								Fe((Q = Q.apply(N, Y || [])).next())
							})
						}

						function ee(N, Y) {
							var Q, X, te, ie, G = {
								label: 0,
								sent: function() {
									if (1 & te[0]) throw te[1];
									return te[1]
								},
								trys: [],
								ops: []
							};
							return ie = {
								next: oe(0),
								throw: oe(1),
								return: oe(2)
							}, "function" == typeof Symbol && (ie[Symbol.iterator] = function() {
								return this
							}), ie;

							function oe(Fe) {
								return function(Le) {
									return function we(Fe) {
										if (Q) throw new TypeError("Generator is already executing.");
										for (; G;) try {
											if (Q = 1, X && (te = 2 & Fe[0] ? X.return : Fe[0] ? X.throw || ((te = X.return) && te.call(X), 0) : X.next) && !(te = te.call(X, Fe[1])).done) return te;
											switch (X = 0, te && (Fe = [2 & Fe[0], te.value]), Fe[0]) {
												case 0:
												case 1:
													te = Fe;
													break;
												case 4:
													return G.label++, {
														value: Fe[1],
														done: !1
													};
												case 5:
													G.label++, X = Fe[1], Fe = [0];
													continue;
												case 7:
													Fe = G.ops.pop(), G.trys.pop();
													continue;
												default:
													if (!(te = (te = G.trys).length > 0 && te[te.length - 1]) && (6 === Fe[0] || 2 === Fe[0])) {
														G = 0;
														continue
													}
													if (3 === Fe[0] && (!te || Fe[1] > te[0] && Fe[1] < te[3])) {
														G.label = Fe[1];
														break
													}
													if (6 === Fe[0] && G.label < te[1]) {
														G.label = te[1], te = Fe;
														break
													}
													if (te && G.label < te[2]) {
														G.label = te[2], G.ops.push(Fe);
														break
													}
													te[2] && G.ops.pop(), G.trys.pop();
													continue
											}
											Fe = Y.call(N, G)
										} catch (Le) {
											Fe = [6, Le], X = 0
										} finally {
											Q = te = 0
										}
										if (5 & Fe[0]) throw Fe[1];
										return {
											value: Fe[0] ? Fe[1] : void 0,
											done: !0
										}
									}([Fe, Le])
								}
							}
						}

						function P() {
							for (var N = 0, Y = 0, G = arguments.length; Y < G; Y++) N += arguments[Y].length;
							var Q = Array(N),
								X = 0;
							for (Y = 0; Y < G; Y++)
								for (var te = arguments[Y], ie = 0, oe = te.length; ie < oe; ie++, X++) Q[X] = te[ie];
							return Q
						}
					}, 2728: (be, ue, E) => {
						E.d(ue, {
							l: () => z
						});
						var p = E(2689),
							y = E(9986),
							D_unexpectedError_code = "unexpected_error",
							D_unexpectedError_desc = "Unexpected error in authentication.",
							D_postRequestFailed_code = "post_request_failed",
							D_postRequestFailed_desc = "Post request failed from the network, could be a 4xx/5xx or a network unavailability. Please check the exact error code for details.",
							z = function(ee) {
								function P(N, Y, G) {
									var Q = this;
									return Q = ee.call(this, Y ? N + ": " + Y : N) || this, Object.setPrototypeOf(Q, P.prototype), Q.errorCode = N || y.gT.EMPTY_STRING, Q.errorMessage = Y || y.gT.EMPTY_STRING, Q.subError = G || y.gT.EMPTY_STRING, Q.name = "AuthError", Q
								}
								return (0, p.ZT)(P, ee), P.prototype.setCorrelationId = function(N) {
									this.correlationId = N
								}, P.createUnexpectedError = function(N) {
									return new P(D_unexpectedError_code, D_unexpectedError_desc + ": " + N)
								}, P.createPostRequestFailed = function(N) {
									return new P(D_postRequestFailed_code, D_postRequestFailed_desc + ": " + N)
								}, P
							}(Error)
					}, 2709: (be, ue, E) => {
						E.d(ue, {
							A: () => D,
							e: () => z
						});
						var p = E(2689),
							y = E(2728),
							D = {
								clientInfoDecodingError: {
									code: "client_info_decoding_error",
									desc: "The client info could not be parsed/decoded correctly. Please review the trace to determine the root cause."
								},
								clientInfoEmptyError: {
									code: "client_info_empty_error",
									desc: "The client info was empty. Please review the trace to determine the root cause."
								},
								tokenParsingError: {
									code: "token_parsing_error",
									desc: "Token cannot be parsed. Please review stack trace to determine root cause."
								},
								nullOrEmptyToken: {
									code: "null_or_empty_token",
									desc: "The token is null or empty. Please review the trace to determine the root cause."
								},
								endpointResolutionError: {
									code: "endpoints_resolution_error",
									desc: "Error: could not resolve endpoints. Please check network and try again."
								},
								networkError: {
									code: "network_error",
									desc: "Network request failed. Please check network trace to determine root cause."
								},
								unableToGetOpenidConfigError: {
									code: "openid_config_error",
									desc: "Could not retrieve endpoints. Check your authority and verify the .well-known/openid-configuration endpoint returns the required endpoints."
								},
								hashNotDeserialized: {
									code: "hash_not_deserialized",
									desc: "The hash parameters could not be deserialized. Please review the trace to determine the root cause."
								},
								blankGuidGenerated: {
									code: "blank_guid_generated",
									desc: "The guid generated was blank. Please review the trace to determine the root cause."
								},
								invalidStateError: {
									code: "invalid_state",
									desc: "State was not the expected format. Please check the logs to determine whether the request was sent using ProtocolUtils.setRequestState()."
								},
								stateMismatchError: {
									code: "state_mismatch",
									desc: "State mismatch error. Please check your network. Continued requests may cause cache overflow."
								},
								stateNotFoundError: {
									code: "state_not_found",
									desc: "State not found"
								},
								nonceMismatchError: {
									code: "nonce_mismatch",
									desc: "Nonce mismatch error. This may be caused by a race condition in concurrent requests."
								},
								nonceNotFoundError: {
									code: "nonce_not_found",
									desc: "nonce not found"
								},
								authTimeNotFoundError: {
									code: "auth_time_not_found",
									desc: "Max Age was requested and the ID token is missing the auth_time variable. auth_time is an optional claim and is not enabled by default - it must be enabled. See https://aka.ms/msaljs/optional-claims for more information."
								},
								maxAgeTranspiredError: {
									code: "max_age_transpired",
									desc: "Max Age is set to 0, or too much time has elapsed since the last end-user authentication."
								},
								noTokensFoundError: {
									code: "no_tokens_found",
									desc: "No tokens were found for the given scopes, and no authorization code was passed to acquireToken. You must retrieve an authorization code before making a call to acquireToken()."
								},
								multipleMatchingTokens: {
									code: "multiple_matching_tokens",
									desc: "The cache contains multiple tokens satisfying the requirements. Call AcquireToken again providing more requirements such as authority or account."
								},
								multipleMatchingAccounts: {
									code: "multiple_matching_accounts",
									desc: "The cache contains multiple accounts satisfying the given parameters. Please pass more info to obtain the correct account"
								},
								multipleMatchingAppMetadata: {
									code: "multiple_matching_appMetadata",
									desc: "The cache contains multiple appMetadata satisfying the given parameters. Please pass more info to obtain the correct appMetadata"
								},
								tokenRequestCannotBeMade: {
									code: "request_cannot_be_made",
									desc: "Token request cannot be made without authorization code or refresh token."
								},
								appendEmptyScopeError: {
									code: "cannot_append_empty_scope",
									desc: "Cannot append null or empty scope to ScopeSet. Please check the stack trace for more info."
								},
								removeEmptyScopeError: {
									code: "cannot_remove_empty_scope",
									desc: "Cannot remove null or empty scope from ScopeSet. Please check the stack trace for more info."
								},
								appendScopeSetError: {
									code: "cannot_append_scopeset",
									desc: "Cannot append ScopeSet due to error."
								},
								emptyInputScopeSetError: {
									code: "empty_input_scopeset",
									desc: "Empty input ScopeSet cannot be processed."
								},
								DeviceCodePollingCancelled: {
									code: "device_code_polling_cancelled",
									desc: "Caller has cancelled token endpoint polling during device code flow by setting DeviceCodeRequest.cancel = true."
								},
								DeviceCodeExpired: {
									code: "device_code_expired",
									desc: "Device code is expired."
								},
								DeviceCodeUnknownError: {
									code: "device_code_unknown_error",
									desc: "Device code stopped polling for unknown reasons."
								},
								NoAccountInSilentRequest: {
									code: "no_account_in_silent_request",
									desc: "Please pass an account object, silent flow is not supported without account information"
								},
								invalidCacheRecord: {
									code: "invalid_cache_record",
									desc: "Cache record object was null or undefined."
								},
								invalidCacheEnvironment: {
									code: "invalid_cache_environment",
									desc: "Invalid environment when attempting to create cache entry"
								},
								noAccountFound: {
									code: "no_account_found",
									desc: "No account found in cache for given key."
								},
								CachePluginError: {
									code: "no cache plugin set on CacheManager",
									desc: "ICachePlugin needs to be set before using readFromStorage or writeFromStorage"
								},
								noCryptoObj: {
									code: "no_crypto_object",
									desc: "No crypto object detected. This is required for the following operation: "
								},
								invalidCacheType: {
									code: "invalid_cache_type",
									desc: "Invalid cache type"
								},
								unexpectedAccountType: {
									code: "unexpected_account_type",
									desc: "Unexpected account type."
								},
								unexpectedCredentialType: {
									code: "unexpected_credential_type",
									desc: "Unexpected credential type."
								},
								invalidAssertion: {
									code: "invalid_assertion",
									desc: "Client assertion must meet requirements described in https://tools.ietf.org/html/rfc7515"
								},
								invalidClientCredential: {
									code: "invalid_client_credential",
									desc: "Client credential (secret, certificate, or assertion) must not be empty when creating a confidential client. An application should at most have one credential"
								},
								tokenRefreshRequired: {
									code: "token_refresh_required",
									desc: "Cannot return token from cache because it must be refreshed. This may be due to one of the following reasons: forceRefresh parameter is set to true, claims have been requested, there is no cached access token or it is expired."
								},
								userTimeoutReached: {
									code: "user_timeout_reached",
									desc: "User defined timeout for device code polling reached"
								},
								tokenClaimsRequired: {
									code: "token_claims_cnf_required_for_signedjwt",
									desc: "Cannot generate a POP jwt if the token_claims are not populated"
								},
								noAuthorizationCodeFromServer: {
									code: "authorization_code_missing_from_server_response",
									desc: "Server response does not contain an authorization code to proceed"
								},
								noAzureRegionDetected: {
									code: "no_azure_region_detected",
									desc: "No azure region was detected and no fallback was made available"
								},
								accessTokenEntityNullError: {
									code: "access_token_entity_null",
									desc: "Access token entity is null, please check logs and cache to ensure a valid access token is present."
								},
								bindingKeyNotRemovedError: {
									code: "binding_key_not_removed",
									desc: "Could not remove the credential's binding key from storage."
								},
								logoutNotSupported: {
									code: "end_session_endpoint_not_supported",
									desc: "Provided authority does not support logout."
								},
								keyIdMissing: {
									code: "key_id_missing",
									desc: "A keyId value is missing from the requested bound token's cache record and is required to match the token to it's stored binding key."
								},
								noNetworkConnectivity: {
									code: "no_network_connectivity",
									desc: "No network connectivity. Check your internet connection."
								},
								userCanceledError: {
									code: "user_canceled",
									desc: "User canceled the flow."
								}
							},
							z = function(ee) {
								function P(N, Y) {
									var G = ee.call(this, N, Y) || this;
									return G.name = "ClientAuthError", Object.setPrototypeOf(G, P.prototype), G
								}
								return (0, p.ZT)(P, ee), P.createClientInfoDecodingError = function(N) {
									return new P(D.clientInfoDecodingError.code, D.clientInfoDecodingError.desc + " Failed with error: " + N)
								}, P.createClientInfoEmptyError = function() {
									return new P(D.clientInfoEmptyError.code, "" + D.clientInfoEmptyError.desc)
								}, P.createTokenParsingError = function(N) {
									return new P(D.tokenParsingError.code, D.tokenParsingError.desc + " Failed with error: " + N)
								}, P.createTokenNullOrEmptyError = function(N) {
									return new P(D.nullOrEmptyToken.code, D.nullOrEmptyToken.desc + " Raw Token Value: " + N)
								}, P.createEndpointDiscoveryIncompleteError = function(N) {
									return new P(D.endpointResolutionError.code, D.endpointResolutionError.desc + " Detail: " + N)
								}, P.createNetworkError = function(N, Y) {
									return new P(D.networkError.code, D.networkError.desc + " | Fetch client threw: " + Y + " | Attempted to reach: " + N.split("?")[0])
								}, P.createUnableToGetOpenidConfigError = function(N) {
									return new P(D.unableToGetOpenidConfigError.code, D.unableToGetOpenidConfigError.desc + " Attempted to retrieve endpoints from: " + N)
								}, P.createHashNotDeserializedError = function(N) {
									return new P(D.hashNotDeserialized.code, D.hashNotDeserialized.desc + " Given Object: " + N)
								}, P.createInvalidStateError = function(N, Y) {
									return new P(D.invalidStateError.code, D.invalidStateError.desc + " Invalid State: " + N + ", Root Err: " + Y)
								}, P.createStateMismatchError = function() {
									return new P(D.stateMismatchError.code, D.stateMismatchError.desc)
								}, P.createStateNotFoundError = function(N) {
									return new P(D.stateNotFoundError.code, D.stateNotFoundError.desc + ":  " + N)
								}, P.createNonceMismatchError = function() {
									return new P(D.nonceMismatchError.code, D.nonceMismatchError.desc)
								}, P.createAuthTimeNotFoundError = function() {
									return new P(D.authTimeNotFoundError.code, D.authTimeNotFoundError.desc)
								}, P.createMaxAgeTranspiredError = function() {
									return new P(D.maxAgeTranspiredError.code, D.maxAgeTranspiredError.desc)
								}, P.createNonceNotFoundError = function(N) {
									return new P(D.nonceNotFoundError.code, D.nonceNotFoundError.desc + ":  " + N)
								}, P.createMultipleMatchingTokensInCacheError = function() {
									return new P(D.multipleMatchingTokens.code, D.multipleMatchingTokens.desc + ".")
								}, P.createMultipleMatchingAccountsInCacheError = function() {
									return new P(D.multipleMatchingAccounts.code, D.multipleMatchingAccounts.desc)
								}, P.createMultipleMatchingAppMetadataInCacheError = function() {
									return new P(D.multipleMatchingAppMetadata.code, D.multipleMatchingAppMetadata.desc)
								}, P.createTokenRequestCannotBeMadeError = function() {
									return new P(D.tokenRequestCannotBeMade.code, D.tokenRequestCannotBeMade.desc)
								}, P.createAppendEmptyScopeToSetError = function(N) {
									return new P(D.appendEmptyScopeError.code, D.appendEmptyScopeError.desc + " Given Scope: " + N)
								}, P.createRemoveEmptyScopeFromSetError = function(N) {
									return new P(D.removeEmptyScopeError.code, D.removeEmptyScopeError.desc + " Given Scope: " + N)
								}, P.createAppendScopeSetError = function(N) {
									return new P(D.appendScopeSetError.code, D.appendScopeSetError.desc + " Detail Error: " + N)
								}, P.createEmptyInputScopeSetError = function() {
									return new P(D.emptyInputScopeSetError.code, "" + D.emptyInputScopeSetError.desc)
								}, P.createDeviceCodeCancelledError = function() {
									return new P(D.DeviceCodePollingCancelled.code, "" + D.DeviceCodePollingCancelled.desc)
								}, P.createDeviceCodeExpiredError = function() {
									return new P(D.DeviceCodeExpired.code, "" + D.DeviceCodeExpired.desc)
								}, P.createDeviceCodeUnknownError = function() {
									return new P(D.DeviceCodeUnknownError.code, "" + D.DeviceCodeUnknownError.desc)
								}, P.createNoAccountInSilentRequestError = function() {
									return new P(D.NoAccountInSilentRequest.code, "" + D.NoAccountInSilentRequest.desc)
								}, P.createNullOrUndefinedCacheRecord = function() {
									return new P(D.invalidCacheRecord.code, D.invalidCacheRecord.desc)
								}, P.createInvalidCacheEnvironmentError = function() {
									return new P(D.invalidCacheEnvironment.code, D.invalidCacheEnvironment.desc)
								}, P.createNoAccountFoundError = function() {
									return new P(D.noAccountFound.code, D.noAccountFound.desc)
								}, P.createCachePluginError = function() {
									return new P(D.CachePluginError.code, "" + D.CachePluginError.desc)
								}, P.createNoCryptoObjectError = function(N) {
									return new P(D.noCryptoObj.code, "" + D.noCryptoObj.desc + N)
								}, P.createInvalidCacheTypeError = function() {
									return new P(D.invalidCacheType.code, "" + D.invalidCacheType.desc)
								}, P.createUnexpectedAccountTypeError = function() {
									return new P(D.unexpectedAccountType.code, "" + D.unexpectedAccountType.desc)
								}, P.createUnexpectedCredentialTypeError = function() {
									return new P(D.unexpectedCredentialType.code, "" + D.unexpectedCredentialType.desc)
								}, P.createInvalidAssertionError = function() {
									return new P(D.invalidAssertion.code, "" + D.invalidAssertion.desc)
								}, P.createInvalidCredentialError = function() {
									return new P(D.invalidClientCredential.code, "" + D.invalidClientCredential.desc)
								}, P.createRefreshRequiredError = function() {
									return new P(D.tokenRefreshRequired.code, D.tokenRefreshRequired.desc)
								}, P.createUserTimeoutReachedError = function() {
									return new P(D.userTimeoutReached.code, D.userTimeoutReached.desc)
								}, P.createTokenClaimsRequiredError = function() {
									return new P(D.tokenClaimsRequired.code, D.tokenClaimsRequired.desc)
								}, P.createNoAuthCodeInServerResponseError = function() {
									return new P(D.noAuthorizationCodeFromServer.code, D.noAuthorizationCodeFromServer.desc)
								}, P.createBindingKeyNotRemovedError = function() {
									return new P(D.bindingKeyNotRemovedError.code, D.bindingKeyNotRemovedError.desc)
								}, P.createLogoutNotSupportedError = function() {
									return new P(D.logoutNotSupported.code, D.logoutNotSupported.desc)
								}, P.createKeyIdMissingError = function() {
									return new P(D.keyIdMissing.code, D.keyIdMissing.desc)
								}, P.createNoNetworkConnectivityError = function() {
									return new P(D.noNetworkConnectivity.code, D.noNetworkConnectivity.desc)
								}, P.createUserCanceledError = function() {
									return new P(D.userCanceledError.code, D.userCanceledError.desc)
								}, P
							}(y.l)
					}, 4381: (be, ue, E) => {
						E.d(ue, {
							r: () => z
						});
						var p = E(2689),
							y = E(2709),
							D_redirectUriNotSet_code = "redirect_uri_empty",
							D_redirectUriNotSet_desc = "A redirect URI is required for all calls, and none has been set.",
							D_postLogoutUriNotSet_code = "post_logout_uri_empty",
							D_postLogoutUriNotSet_desc = "A post logout redirect has not been set.",
							D_claimsRequestParsingError_code = "claims_request_parsing_error",
							D_claimsRequestParsingError_desc = "Could not parse the given claims request object.",
							D_authorityUriInsecure_code = "authority_uri_insecure",
							D_authorityUriInsecure_desc = "Authority URIs must use https.  Please see here for valid authority configuration options: https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-js-initializing-client-applications#configuration-options",
							D_urlParseError_code = "url_parse_error",
							D_urlParseError_desc = "URL could not be parsed into appropriate segments.",
							D_urlEmptyError_code = "empty_url_error",
							D_urlEmptyError_desc = "URL was empty or null.",
							D_emptyScopesError_code = "empty_input_scopes_error",
							D_emptyScopesError_desc = "Scopes cannot be passed as null, undefined or empty array because they are required to obtain an access token.",
							D_clientIdSingleScopeError_code = "clientid_input_scopes_error",
							D_clientIdSingleScopeError_desc = "Client ID can only be provided as a single scope.",
							D_invalidPrompt_code = "invalid_prompt_value",
							D_invalidPrompt_desc = "Supported prompt values are 'login', 'select_account', 'consent', 'create', 'none' and 'no_session'.  Please see here for valid configuration options: https://azuread.github.io/microsoft-authentication-library-for-js/ref/modules/_azure_msal_common.html#commonauthorizationurlrequest",
							D_invalidClaimsRequest_code = "invalid_claims",
							D_invalidClaimsRequest_desc = "Given claims parameter must be a stringified JSON object.",
							D_tokenRequestEmptyError_code = "token_request_empty",
							D_tokenRequestEmptyError_desc = "Token request was empty and not found in cache.",
							D_logoutRequestEmptyError_code = "logout_request_empty",
							D_logoutRequestEmptyError_desc = "The logout request was null or undefined.",
							D_invalidCodeChallengeMethod_code = "invalid_code_challenge_method",
							D_invalidCodeChallengeMethod_desc = 'code_challenge_method passed is invalid. Valid values are "plain" and "S256".',
							D_invalidCodeChallengeParams_code = "pkce_params_missing",
							D_invalidCodeChallengeParams_desc = "Both params: code_challenge and code_challenge_method are to be passed if to be sent in the request",
							D_invalidCloudDiscoveryMetadata_code = "invalid_cloud_discovery_metadata",
							D_invalidCloudDiscoveryMetadata_desc = "Invalid cloudDiscoveryMetadata provided. Must be a stringified JSON object containing tenant_discovery_endpoint and metadata fields",
							D_invalidAuthorityMetadata_code = "invalid_authority_metadata",
							D_invalidAuthorityMetadata_desc = "Invalid authorityMetadata provided. Must by a stringified JSON object containing authorization_endpoint, token_endpoint, issuer fields.",
							D_untrustedAuthority_code = "untrusted_authority",
							D_untrustedAuthority_desc = "The provided authority is not a trusted authority. Please include this authority in the knownAuthorities config parameter.",
							D_invalidAzureCloudInstance_code = "invalid_azure_cloud_instance",
							D_invalidAzureCloudInstance_desc = "Invalid AzureCloudInstance provided. Please refer MSAL JS docs: aks.ms/msaljs/azure_cloud_instance for valid values",
							D_missingSshJwk_code = "missing_ssh_jwk",
							D_missingSshJwk_desc = "Missing sshJwk in SSH certificate request. A stringified JSON Web Key is required when using the SSH authentication scheme.",
							D_missingSshKid_code = "missing_ssh_kid",
							D_missingSshKid_desc = "Missing sshKid in SSH certificate request. A string that uniquely identifies the public SSH key is required when using the SSH authentication scheme.",
							D_missingNonceAuthenticationHeader_code = "missing_nonce_authentication_header",
							D_missingNonceAuthenticationHeader_desc = "Unable to find an authentication header containing server nonce. Either the Authentication-Info or WWW-Authenticate headers must be present in order to obtain a server nonce.",
							D_invalidAuthenticationHeader_code = "invalid_authentication_header",
							D_invalidAuthenticationHeader_desc = "Invalid authentication header provided",
							z = function(ee) {
								function P(N, Y) {
									var G = ee.call(this, N, Y) || this;
									return G.name = "ClientConfigurationError", Object.setPrototypeOf(G, P.prototype), G
								}
								return (0, p.ZT)(P, ee), P.createRedirectUriEmptyError = function() {
									return new P(D_redirectUriNotSet_code, D_redirectUriNotSet_desc)
								}, P.createPostLogoutRedirectUriEmptyError = function() {
									return new P(D_postLogoutUriNotSet_code, D_postLogoutUriNotSet_desc)
								}, P.createClaimsRequestParsingError = function(N) {
									return new P(D_claimsRequestParsingError_code, D_claimsRequestParsingError_desc + " Given value: " + N)
								}, P.createInsecureAuthorityUriError = function(N) {
									return new P(D_authorityUriInsecure_code, D_authorityUriInsecure_desc + " Given URI: " + N)
								}, P.createUrlParseError = function(N) {
									return new P(D_urlParseError_code, D_urlParseError_desc + " Given Error: " + N)
								}, P.createUrlEmptyError = function() {
									return new P(D_urlEmptyError_code, D_urlEmptyError_desc)
								}, P.createEmptyScopesArrayError = function() {
									return new P(D_emptyScopesError_code, "" + D_emptyScopesError_desc)
								}, P.createClientIdSingleScopeError = function(N) {
									return new P(D_clientIdSingleScopeError_code, D_clientIdSingleScopeError_desc + " Given Scopes: " + N)
								}, P.createInvalidPromptError = function(N) {
									return new P(D_invalidPrompt_code, D_invalidPrompt_desc + " Given value: " + N)
								}, P.createInvalidClaimsRequestError = function() {
									return new P(D_invalidClaimsRequest_code, D_invalidClaimsRequest_desc)
								}, P.createEmptyLogoutRequestError = function() {
									return new P(D_logoutRequestEmptyError_code, D_logoutRequestEmptyError_desc)
								}, P.createEmptyTokenRequestError = function() {
									return new P(D_tokenRequestEmptyError_code, D_tokenRequestEmptyError_desc)
								}, P.createInvalidCodeChallengeMethodError = function() {
									return new P(D_invalidCodeChallengeMethod_code, D_invalidCodeChallengeMethod_desc)
								}, P.createInvalidCodeChallengeParamsError = function() {
									return new P(D_invalidCodeChallengeParams_code, D_invalidCodeChallengeParams_desc)
								}, P.createInvalidCloudDiscoveryMetadataError = function() {
									return new P(D_invalidCloudDiscoveryMetadata_code, D_invalidCloudDiscoveryMetadata_desc)
								}, P.createInvalidAuthorityMetadataError = function() {
									return new P(D_invalidAuthorityMetadata_code, D_invalidAuthorityMetadata_desc)
								}, P.createUntrustedAuthorityError = function() {
									return new P(D_untrustedAuthority_code, D_untrustedAuthority_desc)
								}, P.createInvalidAzureCloudInstanceError = function() {
									return new P(D_invalidAzureCloudInstance_code, D_invalidAzureCloudInstance_desc)
								}, P.createMissingSshJwkError = function() {
									return new P(D_missingSshJwk_code, D_missingSshJwk_desc)
								}, P.createMissingSshKidError = function() {
									return new P(D_missingSshKid_code, D_missingSshKid_desc)
								}, P.createMissingNonceAuthenticationHeadersError = function() {
									return new P(D_missingNonceAuthenticationHeader_code, D_missingNonceAuthenticationHeader_desc)
								}, P.createInvalidAuthenticationHeaderError = function(N, Y) {
									return new P(D_invalidAuthenticationHeader_code, D_invalidAuthenticationHeader_desc + ". Invalid header: " + N + ". Details: " + Y)
								}, P
							}(y.e)
					}, 6767: (be, ue, E) => {
						E.d(ue, {
							G: () => ee
						});
						var p = E(4381),
							y = E(2709),
							D = E(1327),
							z = E(9986),
							ee = function() {
								function P(N) {
									if (this._urlString = N, D.x.isEmpty(this._urlString)) throw p.r.createUrlEmptyError();
									D.x.isEmpty(this.getHash()) && (this._urlString = P.canonicalizeUri(N))
								}
								return Object.defineProperty(P.prototype, "urlString", {
									get: function() {
										return this._urlString
									},
									enumerable: !1,
									configurable: !0
								}), P.canonicalizeUri = function(N) {
									if (N) {
										var Y = N.toLowerCase();
										return D.x.endsWith(Y, "?") ? Y = Y.slice(0, -1) : D.x.endsWith(Y, "?/") && (Y = Y.slice(0, -2)), D.x.endsWith(Y, "/") || (Y += "/"), Y
									}
									return N
								}, P.prototype.validateAsUri = function() {
									var N;
									try {
										N = this.getUrlComponents()
									} catch (Y) {
										throw p.r.createUrlParseError(Y)
									}
									if (!N.HostNameAndPort || !N.PathSegments) throw p.r.createUrlParseError("Given url string: " + this.urlString);
									if (!N.Protocol || "https:" !== N.Protocol.toLowerCase()) throw p.r.createInsecureAuthorityUriError(this.urlString)
								}, P.appendQueryString = function(N, Y) {
									return D.x.isEmpty(Y) ? N : N.indexOf("?") < 0 ? N + "?" + Y : N + "&" + Y
								}, P.removeHashFromUrl = function(N) {
									return P.canonicalizeUri(N.split("#")[0])
								}, P.prototype.replaceTenantPath = function(N) {
									var Y = this.getUrlComponents(),
										G = Y.PathSegments;
									return N && 0 !== G.length && (G[0] === z.Nb.COMMON || G[0] === z.Nb.ORGANIZATIONS) && (G[0] = N), P.constructAuthorityUriFromObject(Y)
								}, P.prototype.getHash = function() {
									return P.parseHash(this.urlString)
								}, P.prototype.getUrlComponents = function() {
									var N = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?"),
										Y = this.urlString.match(N);
									if (!Y) throw p.r.createUrlParseError("Given url string: " + this.urlString);
									var G = {
											Protocol: Y[1],
											HostNameAndPort: Y[4],
											AbsolutePath: Y[5],
											QueryString: Y[7]
										},
										Q = G.AbsolutePath.split("/");
									return Q = Q.filter(function(X) {
										return X && X.length > 0
									}), G.PathSegments = Q, !D.x.isEmpty(G.QueryString) && G.QueryString.endsWith("/") && (G.QueryString = G.QueryString.substring(0, G.QueryString.length - 1)), G
								}, P.getDomainFromUrl = function(N) {
									var Y = RegExp("^([^:/?#]+://)?([^/?#]*)"),
										G = N.match(Y);
									if (!G) throw p.r.createUrlParseError("Given url string: " + N);
									return G[2]
								}, P.getAbsoluteUrl = function(N, Y) {
									if (N[0] === z.gT.FORWARD_SLASH) {
										var Q = new P(Y).getUrlComponents();
										return Q.Protocol + "//" + Q.HostNameAndPort + N
									}
									return N
								}, P.parseHash = function(N) {
									var Y = N.indexOf("#"),
										G = N.indexOf("#/");
									return G > -1 ? N.substring(G + 2) : Y > -1 ? N.substring(Y + 1) : z.gT.EMPTY_STRING
								}, P.parseQueryString = function(N) {
									var Y = N.indexOf("?"),
										G = N.indexOf("/?");
									return G > -1 ? N.substring(G + 2) : Y > -1 ? N.substring(Y + 1) : z.gT.EMPTY_STRING
								}, P.constructAuthorityUriFromObject = function(N) {
									return new P(N.Protocol + "//" + N.HostNameAndPort + "/" + N.PathSegments.join("/"))
								}, P.getDeserializedHash = function(N) {
									if (D.x.isEmpty(N)) return {};
									var Y = P.parseHash(N),
										G = D.x.queryStringToObject(D.x.isEmpty(Y) ? N : Y);
									if (!G) throw y.e.createHashNotDeserializedError(JSON.stringify(G));
									return G
								}, P.getDeserializedQueryString = function(N) {
									if (D.x.isEmpty(N)) return {};
									var Y = P.parseQueryString(N),
										G = D.x.queryStringToObject(D.x.isEmpty(Y) ? N : Y);
									if (!G) throw y.e.createHashNotDeserializedError(JSON.stringify(G));
									return G
								}, P.hashContainsKnownProperties = function(N) {
									if (D.x.isEmpty(N) || N.indexOf("=") < 0) return !1;
									var Y = P.getDeserializedHash(N);
									return !!(Y.code || Y.error_description || Y.error || Y.state)
								}, P
							}()
					}, 9986: (be, ue, E) => {
						E.d(ue, {
							$f: () => z,
							As: () => G,
							Bv: () => Fe,
							D1: () => Pt,
							Fo: () => Y,
							Ge: () => at,
							HN: () => Ge,
							L: () => ze,
							LL: () => Ce,
							NJ: () => Q,
							Nb: () => N,
							QU: () => Ue,
							SZ: () => ee,
							To: () => Be,
							VO: () => X,
							VX: () => te,
							Vi: () => P,
							W: () => et,
							Xj: () => je,
							YY: () => lt,
							bb: () => nt,
							ch: () => Ee,
							d3: () => Le,
							dg: () => F,
							f_: () => D,
							gT: () => y,
							hO: () => ft,
							iR: () => we,
							ki: () => Se,
							pQ: () => ke,
							qJ: () => oe,
							sR: () => xe,
							vw: () => ie
						});
						var p = E(2689),
							y = {
								LIBRARY_NAME: "MSAL.JS",
								SKU: "msal.js.common",
								CACHE_PREFIX: "msal",
								DEFAULT_AUTHORITY: "https://login.microsoftonline.com/common/",
								DEFAULT_AUTHORITY_HOST: "login.microsoftonline.com",
								DEFAULT_COMMON_TENANT: "common",
								ADFS: "adfs",
								DSTS: "dstsv2",
								AAD_INSTANCE_DISCOVERY_ENDPT: "https://login.microsoftonline.com/common/discovery/instance?api-version=1.1&authorization_endpoint=",
								RESOURCE_DELIM: "|",
								NO_ACCOUNT: "NO_ACCOUNT",
								CLAIMS: "claims",
								CONSUMER_UTID: "9188040d-6c67-4c5b-b112-36a304b66dad",
								OPENID_SCOPE: "openid",
								PROFILE_SCOPE: "profile",
								OFFLINE_ACCESS_SCOPE: "offline_access",
								EMAIL_SCOPE: "email",
								CODE_RESPONSE_TYPE: "code",
								CODE_GRANT_TYPE: "authorization_code",
								RT_GRANT_TYPE: "refresh_token",
								FRAGMENT_RESPONSE_MODE: "fragment",
								S256_CODE_CHALLENGE_METHOD: "S256",
								URL_FORM_CONTENT_TYPE: "application/x-www-form-urlencoded;charset=utf-8",
								AUTHORIZATION_PENDING: "authorization_pending",
								NOT_DEFINED: "not_defined",
								EMPTY_STRING: "",
								NOT_APPLICABLE: "N/A",
								FORWARD_SLASH: "/",
								IMDS_ENDPOINT: "http://169.254.169.254/metadata/instance/compute/location",
								IMDS_VERSION: "2020-06-01",
								IMDS_TIMEOUT: 2e3,
								AZURE_REGION_AUTO_DISCOVER_FLAG: "TryAutoDetect",
								REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX: "login.microsoft.com",
								REGIONAL_AUTH_NON_MSI_QUERY_STRING: "allowestsrnonmsi=true",
								KNOWN_PUBLIC_CLOUDS: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"],
								TOKEN_RESPONSE_TYPE: "token",
								ID_TOKEN_RESPONSE_TYPE: "id_token",
								SHR_NONCE_VALIDITY: 240,
								INVALID_INSTANCE: "invalid_instance"
							},
							D = [y.OPENID_SCOPE, y.PROFILE_SCOPE, y.OFFLINE_ACCESS_SCOPE],
							z = (0, p.pr)(D, [y.EMAIL_SCOPE]),
							ee = (() => {
								return (ce = ee || (ee = {})).CONTENT_TYPE = "Content-Type", ce.RETRY_AFTER = "Retry-After", ce.CCS_HEADER = "X-AnchorMailbox", ce.WWWAuthenticate = "WWW-Authenticate", ce.AuthenticationInfo = "Authentication-Info", ce.X_MS_REQUEST_ID = "x-ms-request-id", ce.X_MS_HTTP_VERSION = "x-ms-httpver", ee;
								var ce
							})(),
							P = (() => {
								return (ce = P || (P = {})).ID_TOKEN = "idtoken", ce.CLIENT_INFO = "client.info", ce.ADAL_ID_TOKEN = "adal.idtoken", ce.ERROR = "error", ce.ERROR_DESC = "error.description", ce.ACTIVE_ACCOUNT = "active-account", ce.ACTIVE_ACCOUNT_FILTERS = "active-account-filters", P;
								var ce
							})(),
							N = (() => {
								return (ce = N || (N = {})).COMMON = "common", ce.ORGANIZATIONS = "organizations", ce.CONSUMERS = "consumers", N;
								var ce
							})(),
							Y = (() => {
								return (ce = Y || (Y = {})).CLIENT_ID = "client_id", ce.REDIRECT_URI = "redirect_uri", ce.RESPONSE_TYPE = "response_type", ce.RESPONSE_MODE = "response_mode", ce.GRANT_TYPE = "grant_type", ce.CLAIMS = "claims", ce.SCOPE = "scope", ce.ERROR = "error", ce.ERROR_DESCRIPTION = "error_description", ce.ACCESS_TOKEN = "access_token", ce.ID_TOKEN = "id_token", ce.REFRESH_TOKEN = "refresh_token", ce.EXPIRES_IN = "expires_in", ce.STATE = "state", ce.NONCE = "nonce", ce.PROMPT = "prompt", ce.SESSION_STATE = "session_state", ce.CLIENT_INFO = "client_info", ce.CODE = "code", ce.CODE_CHALLENGE = "code_challenge", ce.CODE_CHALLENGE_METHOD = "code_challenge_method", ce.CODE_VERIFIER = "code_verifier", ce.CLIENT_REQUEST_ID = "client-request-id", ce.X_CLIENT_SKU = "x-client-SKU", ce.X_CLIENT_VER = "x-client-VER", ce.X_CLIENT_OS = "x-client-OS", ce.X_CLIENT_CPU = "x-client-CPU", ce.X_CLIENT_CURR_TELEM = "x-client-current-telemetry", ce.X_CLIENT_LAST_TELEM = "x-client-last-telemetry", ce.X_MS_LIB_CAPABILITY = "x-ms-lib-capability", ce.X_APP_NAME = "x-app-name", ce.X_APP_VER = "x-app-ver", ce.POST_LOGOUT_URI = "post_logout_redirect_uri", ce.ID_TOKEN_HINT = "id_token_hint", ce.DEVICE_CODE = "device_code", ce.CLIENT_SECRET = "client_secret", ce.CLIENT_ASSERTION = "client_assertion", ce.CLIENT_ASSERTION_TYPE = "client_assertion_type", ce.TOKEN_TYPE = "token_type", ce.REQ_CNF = "req_cnf", ce.OBO_ASSERTION = "assertion", ce.REQUESTED_TOKEN_USE = "requested_token_use", ce.ON_BEHALF_OF = "on_behalf_of", ce.FOCI = "foci", ce.CCS_HEADER = "X-AnchorMailbox", ce.RETURN_SPA_CODE = "return_spa_code", ce.NATIVE_BROKER = "nativebroker", ce.LOGOUT_HINT = "logout_hint", Y;
								var ce
							})(),
							G = (() => {
								return (ce = G || (G = {})).ACCESS_TOKEN = "access_token", ce.XMS_CC = "xms_cc", G;
								var ce
							})(),
							Q = {
								LOGIN: "login",
								SELECT_ACCOUNT: "select_account",
								CONSENT: "consent",
								NONE: "none",
								CREATE: "create",
								NO_SESSION: "no_session"
							},
							X = (() => {
								return (ce = X || (X = {})).ACCOUNT = "account", ce.SID = "sid", ce.LOGIN_HINT = "login_hint", ce.ID_TOKEN = "id_token", ce.DOMAIN_HINT = "domain_hint", ce.ORGANIZATIONS = "organizations", ce.CONSUMERS = "consumers", ce.ACCOUNT_ID = "accountIdentifier", ce.HOMEACCOUNT_ID = "homeAccountIdentifier", X;
								var ce
							})(),
							te = {
								PLAIN: "plain",
								S256: "S256"
							},
							ie = (() => {
								return (ce = ie || (ie = {})).QUERY = "query", ce.FRAGMENT = "fragment", ce.FORM_POST = "form_post", ie;
								var ce
							})(),
							oe = (() => {
								return (ce = oe || (oe = {})).IMPLICIT_GRANT = "implicit", ce.AUTHORIZATION_CODE_GRANT = "authorization_code", ce.CLIENT_CREDENTIALS_GRANT = "client_credentials", ce.RESOURCE_OWNER_PASSWORD_GRANT = "password", ce.REFRESH_TOKEN_GRANT = "refresh_token", ce.DEVICE_CODE_GRANT = "device_code", ce.JWT_BEARER = "urn:ietf:params:oauth:grant-type:jwt-bearer", oe;
								var ce
							})(),
							we = (() => {
								return (ce = we || (we = {})).MSSTS_ACCOUNT_TYPE = "MSSTS", ce.ADFS_ACCOUNT_TYPE = "ADFS", ce.MSAV1_ACCOUNT_TYPE = "MSA", ce.GENERIC_ACCOUNT_TYPE = "Generic", we;
								var ce
							})(),
							Fe = (() => {
								return (ce = Fe || (Fe = {})).CACHE_KEY_SEPARATOR = "-", ce.CLIENT_INFO_SEPARATOR = ".", Fe;
								var ce
							})(),
							Le = (() => {
								return (ce = Le || (Le = {})).ID_TOKEN = "IdToken", ce.ACCESS_TOKEN = "AccessToken", ce.ACCESS_TOKEN_WITH_AUTH_SCHEME = "AccessToken_With_AuthScheme", ce.REFRESH_TOKEN = "RefreshToken", Le;
								var ce
							})(),
							je = (() => {
								return (ce = je || (je = {})).ACCOUNT = "Account", ce.CREDENTIAL = "Credential", ce.ID_TOKEN = "IdToken", ce.ACCESS_TOKEN = "AccessToken", ce.REFRESH_TOKEN = "RefreshToken", ce.APP_METADATA = "AppMetadata", ce.TEMPORARY = "TempCache", ce.TELEMETRY = "Telemetry", ce.UNDEFINED = "Undefined", ce.THROTTLING = "Throttling", je;
								var ce
							})(),
							Ce = (() => {
								return (ce = Ce || (Ce = {}))[ce.ADFS = 1001] = "ADFS", ce[ce.MSA = 1002] = "MSA", ce[ce.MSSTS = 1003] = "MSSTS", ce[ce.GENERIC = 1004] = "GENERIC", ce[ce.ACCESS_TOKEN = 2001] = "ACCESS_TOKEN", ce[ce.REFRESH_TOKEN = 2002] = "REFRESH_TOKEN", ce[ce.ID_TOKEN = 2003] = "ID_TOKEN", ce[ce.APP_METADATA = 3001] = "APP_METADATA", ce[ce.UNDEFINED = 9999] = "UNDEFINED", Ce;
								var ce
							})(),
							F = "appmetadata",
							xe = "client_info",
							Ee = "1",
							Ue = {
								CACHE_KEY: "authority-metadata",
								REFRESH_TIME_SECONDS: 86400
							},
							ke = (() => {
								return (ce = ke || (ke = {})).CONFIG = "config", ce.CACHE = "cache", ce.NETWORK = "network", ce.HARDCODED_VALUES = "hardcoded_values", ke;
								var ce
							})(),
							Ge = {
								SCHEMA_VERSION: 5,
								MAX_CUR_HEADER_BYTES: 80,
								MAX_LAST_HEADER_BYTES: 330,
								MAX_CACHED_ERRORS: 50,
								CACHE_KEY: "server-telemetry",
								CATEGORY_SEPARATOR: "|",
								VALUE_SEPARATOR: ",",
								OVERFLOW_TRUE: "1",
								OVERFLOW_FALSE: "0",
								UNKNOWN_ERROR: "unknown_error"
							},
							ft = (() => {
								return (ce = ft || (ft = {})).BEARER = "Bearer", ce.POP = "pop", ce.SSH = "ssh-cert", ft;
								var ce
							})(),
							nt = {
								DEFAULT_THROTTLE_TIME_SECONDS: 60,
								DEFAULT_MAX_THROTTLE_TIME_SECONDS: 3600,
								THROTTLING_PREFIX: "throttling",
								X_MS_LIB_CAPABILITY_VALUE: "retry-after, h429"
							},
							Pt = {
								INVALID_GRANT_ERROR: "invalid_grant",
								CLIENT_MISMATCH_ERROR: "client_mismatch"
							},
							at = (() => {
								return (ce = at || (at = {})).username = "username", ce.password = "password", at;
								var ce
							})(),
							lt = (() => {
								return (ce = lt || (lt = {}))[ce.httpSuccess = 200] = "httpSuccess", ce[ce.httpBadRequest = 400] = "httpBadRequest", lt;
								var ce
							})(),
							et = (() => {
								return (ce = et || (et = {})).FAILED_AUTO_DETECTION = "1", ce.INTERNAL_CACHE = "2", ce.ENVIRONMENT_VARIABLE = "3", ce.IMDS = "4", et;
								var ce
							})(),
							Se = (() => {
								return (ce = Se || (Se = {})).CONFIGURED_MATCHES_DETECTED = "1", ce.CONFIGURED_NO_AUTO_DETECTION = "2", ce.CONFIGURED_NOT_DETECTED = "3", ce.AUTO_DETECTION_REQUESTED_SUCCESSFUL = "4", ce.AUTO_DETECTION_REQUESTED_FAILED = "5", Se;
								var ce
							})(),
							Be = (() => {
								return (ce = Be || (Be = {})).NO_CACHE_HIT = "0", ce.FORCE_REFRESH = "1", ce.NO_CACHED_ACCESS_TOKEN = "2", ce.CACHED_ACCESS_TOKEN_EXPIRED = "3", ce.REFRESH_CACHED_ACCESS_TOKEN = "4", Be;
								var ce
							})(),
							ze = (() => {
								return (ce = ze || (ze = {})).Jwt = "JWT", ce.Jwk = "JWK", ce.Pop = "pop", ze;
								var ce
							})()
					}, 1327: (be, ue, E) => {
						E.d(ue, {
							x: () => y
						});
						var p = E(2709),
							y = function() {
								function D() {}
								return D.decodeAuthToken = function(z) {
									if (D.isEmpty(z)) throw p.e.createTokenNullOrEmptyError(z);
									var P = /^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/.exec(z);
									if (!P || P.length < 4) throw p.e.createTokenParsingError("Given token is malformed: " + JSON.stringify(z));
									return {
										header: P[1],
										JWSPayload: P[2],
										JWSSig: P[3]
									}
								}, D.isEmpty = function(z) {
									return typeof z > "u" || !z || 0 === z.length
								}, D.isEmptyObj = function(z) {
									if (z && !D.isEmpty(z)) try {
										var ee = JSON.parse(z);
										return 0 === Object.keys(ee).length
									} catch {}
									return !0
								}, D.startsWith = function(z, ee) {
									return 0 === z.indexOf(ee)
								}, D.endsWith = function(z, ee) {
									return z.length >= ee.length && z.lastIndexOf(ee) === z.length - ee.length
								}, D.queryStringToObject = function(z) {
									var ee = {},
										P = z.split("&"),
										N = function(Y) {
											return decodeURIComponent(Y.replace(/\+/g, " "))
										};
									return P.forEach(function(Y) {
										if (Y.trim()) {
											var G = Y.split(/=(.+)/g, 2),
												Q = G[0],
												X = G[1];
											Q && X && (ee[N(Q)] = N(X))
										}
									}), ee
								}, D.trimArrayEntries = function(z) {
									return z.map(function(ee) {
										return ee.trim()
									})
								}, D.removeEmptyStringsFromArray = function(z) {
									return z.filter(function(ee) {
										return !D.isEmpty(ee)
									})
								}, D.jsonParseHelper = function(z) {
									try {
										return JSON.parse(z)
									} catch {
										return null
									}
								}, D.matchPattern = function(z, ee) {
									return new RegExp(z.replace(/\\/g, "\\\\").replace(/\*/g, "[^ ]*").replace(/\?/g, "\\?")).test(ee)
								}, D
							}()
					}, 4033: (be, ue, E) => {
						function p() {
							return typeof __SENTRY_BROWSER_BUNDLE__ < "u" && !!__SENTRY_BROWSER_BUNDLE__
						}

						function y() {
							return "npm"
						}
						E.d(ue, {
							S: () => y,
							n: () => p
						})
					}, 9104: (be, ue, E) => {
						E.d(ue, {
							KV: () => y,
							l$: () => D
						});
						var p = E(4033);

						function y() {
							return !(0, p.n)() && "[object process]" === Object.prototype.toString.call(typeof process < "u" ? process : 0)
						}

						function D(ee, P) {
							return ee.require(P)
						}
						be = E.hmd(be)
					}, 6852: (be, ue, E) => {
						E.d(ue, {
							Z1: () => oe,
							ph: () => Q,
							yW: () => G
						});
						var p = E(9104),
							y = E(3693);
						be = E.hmd(be);
						const D = (0, y.Rf)(),
							z = {
								nowSeconds: () => Date.now() / 1e3
							},
							N = (0, p.KV)() ? function P() {
								try {
									return (0, p.l$)(be, "perf_hooks").performance
								} catch {
									return
								}
							}() : function ee() {
								const {
									performance: we
								} = D;
								if (we && we.now) return {
									now: () => we.now(),
									timeOrigin: Date.now() - we.now()
								}
							}(),
							Y = void 0 === N ? z : {
								nowSeconds: () => (N.timeOrigin + N.now()) / 1e3
							},
							G = z.nowSeconds.bind(z),
							Q = Y.nowSeconds.bind(Y);
						let ie;
						const oe = (() => {
							const {
								performance: we
							} = D;
							if (!we || !we.now) return void(ie = "none");
							const Fe = 36e5,
								Le = we.now(),
								je = Date.now(),
								Ce = we.timeOrigin ? Math.abs(we.timeOrigin + Le - je) : Fe,
								F = Ce < Fe,
								xe = we.timing && we.timing.navigationStart,
								Ue = "number" == typeof xe ? Math.abs(xe + Le - je) : Fe;
							return F || Ue < Fe ? Ce <= Ue ? (ie = "timeOrigin", we.timeOrigin) : (ie = "navigationStart", xe) : (ie = "dateNow", je)
						})()
					}, 3693: (be, ue, E) => {
						function p(ee) {
							return ee && ee.Math == Math ? ee : void 0
						}
						E.d(ue, {
							Rf: () => D,
							YO: () => z,
							n2: () => y
						});
						const y = "object" == typeof globalThis && p(globalThis) || "object" == typeof window && p(window) || "object" == typeof self && p(self) || "object" == typeof global && p(global) || function() {
							return this
						}() || {};

						function D() {
							return y
						}

						function z(ee, P, N) {
							const Y = N || y,
								G = Y.__SENTRY__ = Y.__SENTRY__ || {};
							return G[ee] || (G[ee] = P())
						}
					}, 2358: be => {
						var E, ue = {
							DEBUG: !1,
							LIB_VERSION: "2.47.0"
						};
						if (typeof window > "u") {
							var p = {
								hostname: ""
							};
							E = {
								navigator: {
									userAgent: ""
								},
								document: {
									location: p,
									referrer: ""
								},
								screen: {
									width: 0,
									height: 0
								},
								location: p
							}
						} else E = window;
						var f, T, K, Et, L, he, ye, He, gt, st, y = Array.prototype,
							z = Object.prototype,
							ee = y.slice,
							P = z.toString,
							N = z.hasOwnProperty,
							Y = E.console,
							G = E.navigator,
							Q = E.document,
							X = E.opera,
							te = E.screen,
							ie = G.userAgent,
							oe = Function.prototype.bind,
							we = y.forEach,
							Fe = y.indexOf,
							Le = y.map,
							je = Array.isArray,
							Ce = {},
							F = {
								trim: function(f) {
									return f.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
								}
							},
							xe = {
								log: function() {
									if (ue.DEBUG && !F.isUndefined(Y) && Y) try {
										Y.log.apply(Y, arguments)
									} catch {
										F.each(arguments, function(T) {
											Y.log(T)
										})
									}
								},
								warn: function() {
									if (ue.DEBUG && !F.isUndefined(Y) && Y) {
										var f = ["Mixpanel warning:"].concat(F.toArray(arguments));
										try {
											Y.warn.apply(Y, f)
										} catch {
											F.each(f, function(L) {
												Y.warn(L)
											})
										}
									}
								},
								error: function() {
									if (ue.DEBUG && !F.isUndefined(Y) && Y) {
										var f = ["Mixpanel error:"].concat(F.toArray(arguments));
										try {
											Y.error.apply(Y, f)
										} catch {
											F.each(f, function(L) {
												Y.error(L)
											})
										}
									}
								},
								critical: function() {
									if (!F.isUndefined(Y) && Y) {
										var f = ["Mixpanel error:"].concat(F.toArray(arguments));
										try {
											Y.error.apply(Y, f)
										} catch {
											F.each(f, function(L) {
												Y.error(L)
											})
										}
									}
								}
							},
							Ee = function(f, T) {
								return function() {
									return arguments[0] = "[" + T + "] " + arguments[0], f.apply(xe, arguments)
								}
							},
							Ue = function(f) {
								return {
									log: Ee(xe.log, f),
									error: Ee(xe.error, f),
									critical: Ee(xe.critical, f)
								}
							};
						F.bind = function(f, T) {
							var L, K;
							if (oe && f.bind === oe) return oe.apply(f, ee.call(arguments, 1));
							if (!F.isFunction(f)) throw new TypeError;
							return L = ee.call(arguments, 2), K = function() {
								if (!(this instanceof K)) return f.apply(T, L.concat(ee.call(arguments)));
								var he = {};
								he.prototype = f.prototype;
								var ye = new he;
								he.prototype = null;
								var He = f.apply(ye, L.concat(ee.call(arguments)));
								return Object(He) === He ? He : ye
							}, K
						}, F.each = function(f, T, L) {
							if (null != f)
								if (we && f.forEach === we) f.forEach(T, L);
								else if (f.length === +f.length) {
								for (var K = 0, he = f.length; K < he; K++)
									if (K in f && T.call(L, f[K], K, f) === Ce) return
							} else
								for (var ye in f)
									if (N.call(f, ye) && T.call(L, f[ye], ye, f) === Ce) return
						}, F.extend = function(f) {
							return F.each(ee.call(arguments, 1), function(T) {
								for (var L in T) void 0 !== T[L] && (f[L] = T[L])
							}), f
						}, F.isArray = je || function(f) {
							return "[object Array]" === P.call(f)
						}, F.isFunction = function(f) {
							try {
								return /^\s*\bfunction\b/.test(f)
							} catch {
								return !1
							}
						}, F.isArguments = function(f) {
							return !(!f || !N.call(f, "callee"))
						}, F.toArray = function(f) {
							return f ? f.toArray ? f.toArray() : F.isArray(f) || F.isArguments(f) ? ee.call(f) : F.values(f) : []
						}, F.map = function(f, T, L) {
							if (Le && f.map === Le) return f.map(T, L);
							var K = [];
							return F.each(f, function(he) {
								K.push(T.call(L, he))
							}), K
						}, F.keys = function(f) {
							var T = [];
							return null === f || F.each(f, function(L, K) {
								T[T.length] = K
							}), T
						}, F.values = function(f) {
							var T = [];
							return null === f || F.each(f, function(L) {
								T[T.length] = L
							}), T
						}, F.include = function(f, T) {
							var L = !1;
							return null === f ? L : Fe && f.indexOf === Fe ? -1 != f.indexOf(T) : (F.each(f, function(K) {
								if (L || (L = K === T)) return Ce
							}), L)
						}, F.includes = function(f, T) {
							return -1 !== f.indexOf(T)
						}, F.inherit = function(f, T) {
							return f.prototype = new T, f.prototype.constructor = f, f.superclass = T.prototype, f
						}, F.isObject = function(f) {
							return f === Object(f) && !F.isArray(f)
						}, F.isEmptyObject = function(f) {
							if (F.isObject(f)) {
								for (var T in f)
									if (N.call(f, T)) return !1;
								return !0
							}
							return !1
						}, F.isUndefined = function(f) {
							return void 0 === f
						}, F.isString = function(f) {
							return "[object String]" == P.call(f)
						}, F.isDate = function(f) {
							return "[object Date]" == P.call(f)
						}, F.isNumber = function(f) {
							return "[object Number]" == P.call(f)
						}, F.isElement = function(f) {
							return !(!f || 1 !== f.nodeType)
						}, F.encodeDates = function(f) {
							return F.each(f, function(T, L) {
								F.isDate(T) ? f[L] = F.formatDate(T) : F.isObject(T) && (f[L] = F.encodeDates(T))
							}), f
						}, F.timestamp = function() {
							return Date.now = Date.now || function() {
								return +new Date
							}, Date.now()
						}, F.formatDate = function(f) {
							function T(L) {
								return L < 10 ? "0" + L : L
							}
							return f.getUTCFullYear() + "-" + T(f.getUTCMonth() + 1) + "-" + T(f.getUTCDate()) + "T" + T(f.getUTCHours()) + ":" + T(f.getUTCMinutes()) + ":" + T(f.getUTCSeconds())
						}, F.strip_empty_properties = function(f) {
							var T = {};
							return F.each(f, function(L, K) {
								F.isString(L) && L.length > 0 && (T[K] = L)
							}), T
						}, F.truncate = function(f, T) {
							var L;
							return "string" == typeof f ? L = f.slice(0, T) : F.isArray(f) ? (L = [], F.each(f, function(K) {
								L.push(F.truncate(K, T))
							})) : F.isObject(f) ? (L = {}, F.each(f, function(K, he) {
								L[he] = F.truncate(K, T)
							})) : L = f, L
						}, F.JSONEncode = function(f) {
							var L = function(he) {
									var ye = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
										He = {
											"\b": "\\b",
											"\t": "\\t",
											"\n": "\\n",
											"\f": "\\f",
											"\r": "\\r",
											'"': '\\"',
											"\\": "\\\\"
										};
									return ye.lastIndex = 0, ye.test(he) ? '"' + he.replace(ye, function(gt) {
										var st = He[gt];
										return "string" == typeof st ? st : "\\u" + ("0000" + gt.charCodeAt(0).toString(16)).slice(-4)
									}) + '"' : '"' + he + '"'
								},
								K = function(he, ye) {
									var He = "",
										st = 0,
										mt = "",
										Et = "",
										Gt = 0,
										Rt = He,
										Ot = [],
										Jt = ye[he];
									switch (Jt && "object" == typeof Jt && "function" == typeof Jt.toJSON && (Jt = Jt.toJSON(he)), typeof Jt) {
										case "string":
											return L(Jt);
										case "number":
											return isFinite(Jt) ? String(Jt) : "null";
										case "boolean":
										case "null":
											return String(Jt);
										case "object":
											if (!Jt) return "null";
											if (He += "    ", Ot = [], "[object Array]" === P.apply(Jt)) {
												for (Gt = Jt.length, st = 0; st < Gt; st += 1) Ot[st] = K(st, Jt) || "null";
												return Et = 0 === Ot.length ? "[]" : He ? "[\n" + He + Ot.join(",\n" + He) + "\n" + Rt + "]" : "[" + Ot.join(",") + "]", He = Rt, Et
											}
											for (mt in Jt) N.call(Jt, mt) && (Et = K(mt, Jt)) && Ot.push(L(mt) + (He ? ": " : ":") + Et);
											return Et = 0 === Ot.length ? "{}" : He ? "{" + Ot.join(",") + Rt + "}" : "{" + Ot.join(",") + "}", He = Rt, Et
									}
								};
							return K("", {
								"": f
							})
						}, F.JSONDecode = (L = {
							'"': '"',
							"\\": "\\",
							"/": "/",
							b: "\b",
							f: "\f",
							n: "\n",
							r: "\r",
							t: "\t"
						}, he = function(Ot) {
							var Jt = new SyntaxError(Ot);
							throw Jt.at = f, Jt.text = K, Jt
						}, ye = function(Ot) {
							return Ot && Ot !== T && he("Expected '" + Ot + "' instead of '" + T + "'"), T = K.charAt(f), f += 1, T
						}, He = function() {
							var Ot, Jt = "";
							for ("-" === T && (Jt = "-", ye("-")); T >= "0" && T <= "9";) Jt += T, ye();
							if ("." === T)
								for (Jt += "."; ye() && T >= "0" && T <= "9";) Jt += T;
							if ("e" === T || "E" === T)
								for (Jt += T, ye(), ("-" === T || "+" === T) && (Jt += T, ye()); T >= "0" && T <= "9";) Jt += T, ye();
							if (Ot = +Jt, isFinite(Ot)) return Ot;
							he("Bad number")
						}, gt = function() {
							var Ot, Jt, Cn, Mn = "";
							if ('"' === T)
								for (; ye();) {
									if ('"' === T) return ye(), Mn;
									if ("\\" === T)
										if (ye(), "u" === T) {
											for (Cn = 0, Jt = 0; Jt < 4 && (Ot = parseInt(ye(), 16), isFinite(Ot)); Jt += 1) Cn = 16 * Cn + Ot;
											Mn += String.fromCharCode(Cn)
										} else {
											if ("string" != typeof L[T]) break;
											Mn += L[T]
										}
									else Mn += T
								}
							he("Bad string")
						}, st = function() {
							for (; T && T <= " ";) ye()
						}, Et = function() {
							switch (st(), T) {
								case "{":
									return function() {
										var Ot, Jt = {};
										if ("{" === T) {
											if (ye("{"), st(), "}" === T) return ye("}"), Jt;
											for (; T;) {
												if (Ot = gt(), st(), ye(":"), Object.hasOwnProperty.call(Jt, Ot) && he('Duplicate key "' + Ot + '"'), Jt[Ot] = Et(), st(), "}" === T) return ye("}"), Jt;
												ye(","), st()
											}
										}
										he("Bad object")
									}();
								case "[":
									return function() {
										var Ot = [];
										if ("[" === T) {
											if (ye("["), st(), "]" === T) return ye("]"), Ot;
											for (; T;) {
												if (Ot.push(Et()), st(), "]" === T) return ye("]"), Ot;
												ye(","), st()
											}
										}
										he("Bad array")
									}();
								case '"':
									return gt();
								case "-":
									return He();
								default:
									return T >= "0" && T <= "9" ? He() : function() {
										switch (T) {
											case "t":
												return ye("t"), ye("r"), ye("u"), ye("e"), !0;
											case "f":
												return ye("f"), ye("a"), ye("l"), ye("s"), ye("e"), !1;
											case "n":
												return ye("n"), ye("u"), ye("l"), ye("l"), null
										}
										he('Unexpected "' + T + '"')
									}()
							}
						}, function(Ot) {
							var Jt;
							return K = Ot, f = 0, T = " ", Jt = Et(), st(), T && he("Syntax error"), Jt
						}), F.base64Encode = function(f) {
							var He, gt, st, mt, T = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
								Et = 0,
								Gt = 0,
								Rt = "",
								Ot = [];
							if (!f) return f;
							f = F.utf8Encode(f);
							do {
								He = (mt = f.charCodeAt(Et++) << 16 | f.charCodeAt(Et++) << 8 | f.charCodeAt(Et++)) >> 12 & 63, gt = mt >> 6 & 63, st = 63 & mt, Ot[Gt++] = T.charAt(mt >> 18 & 63) + T.charAt(He) + T.charAt(gt) + T.charAt(st)
							} while (Et < f.length);
							switch (Rt = Ot.join(""), f.length % 3) {
								case 1:
									Rt = Rt.slice(0, -2) + "==";
									break;
								case 2:
									Rt = Rt.slice(0, -1) + "="
							}
							return Rt
						}, F.utf8Encode = function(f) {
							var L, K, he, ye, T = "";
							for (L = K = 0, he = (f = (f + "").replace(/\r\n/g, "\n").replace(/\r/g, "\n")).length, ye = 0; ye < he; ye++) {
								var He = f.charCodeAt(ye),
									gt = null;
								He < 128 ? K++ : gt = He > 127 && He < 2048 ? String.fromCharCode(He >> 6 | 192, 63 & He | 128) : String.fromCharCode(He >> 12 | 224, He >> 6 & 63 | 128, 63 & He | 128), null !== gt && (K > L && (T += f.substring(L, K)), T += gt, L = K = ye + 1)
							}
							return K > L && (T += f.substring(L, f.length)), T
						}, F.UUID = function() {
							var f = function() {
								var he, K = 1 * new Date;
								if (E.performance && E.performance.now) he = E.performance.now();
								else
									for (he = 0; K == 1 * new Date;) he++;
								return K.toString(16) + Math.floor(he).toString(16)
							};
							return function() {
								var K = (te.height * te.width).toString(16);
								return f() + "-" + Math.random().toString(16).replace(".", "") + "-" + function() {
									var he, ye, K = ie,
										He = [],
										gt = 0;

									function st(mt, Et) {
										var Gt, Rt = 0;
										for (Gt = 0; Gt < Et.length; Gt++) Rt |= He[Gt] << 8 * Gt;
										return mt ^ Rt
									}
									for (he = 0; he < K.length; he++) ye = K.charCodeAt(he), He.unshift(255 & ye), He.length >= 4 && (gt = st(gt, He), He = []);
									return He.length > 0 && (gt = st(gt, He)), gt.toString(16)
								}() + "-" + K + "-" + f()
							}
						}();
						var ke = ["ahrefsbot", "baiduspider", "bingbot", "bingpreview", "facebookexternal", "petalbot", "pinterest", "screaming frog", "yahoo! slurp", "yandexbot", "adsbot-google", "apis-google", "duplexweb-google", "feedfetcher-google", "google favicon", "google web preview", "google-read-aloud", "googlebot", "googleweblight", "mediapartners-google", "storebot-google"];
						F.isBlockedUA = function(f) {
							var T;
							for (f = f.toLowerCase(), T = 0; T < ke.length; T++)
								if (-1 !== f.indexOf(ke[T])) return !0;
							return !1
						}, F.HTTPBuildQuery = function(f, T) {
							var L, K, he = [];
							return F.isUndefined(T) && (T = "&"), F.each(f, function(ye, He) {
								L = encodeURIComponent(ye.toString()), K = encodeURIComponent(He), he[he.length] = K + "=" + L
							}), he.join(T)
						}, F.getQueryParam = function(f, T) {
							T = T.replace(/[[]/, "\\[").replace(/[\]]/, "\\]");
							var he = new RegExp("[\\?&]" + T + "=([^&#]*)").exec(f);
							if (null === he || he && "string" != typeof he[1] && he[1].length) return "";
							var ye = he[1];
							try {
								ye = decodeURIComponent(ye)
							} catch {
								xe.error("Skipping decoding for malformed query param: " + ye)
							}
							return ye.replace(/\+/g, " ")
						}, F.cookie = {
							get: function(f) {
								for (var T = f + "=", L = Q.cookie.split(";"), K = 0; K < L.length; K++) {
									for (var he = L[K];
										" " == he.charAt(0);) he = he.substring(1, he.length);
									if (0 === he.indexOf(T)) return decodeURIComponent(he.substring(T.length, he.length))
								}
								return null
							},
							parse: function(f) {
								var T;
								try {
									T = F.JSONDecode(F.cookie.get(f)) || {}
								} catch {}
								return T
							},
							set_seconds: function(f, T, L, K, he, ye, He) {
								var gt = "",
									st = "",
									mt = "";
								if (He) gt = "; domain=" + He;
								else if (K) {
									var Et = Be(Q.location.hostname);
									gt = Et ? "; domain=." + Et : ""
								}
								if (L) {
									var Gt = new Date;
									Gt.setTime(Gt.getTime() + 1e3 * L), st = "; expires=" + Gt.toGMTString()
								}
								ye && (he = !0, mt = "; SameSite=None"), he && (mt += "; secure"), Q.cookie = f + "=" + encodeURIComponent(T) + st + "; path=/" + gt + mt
							},
							set: function(f, T, L, K, he, ye, He) {
								var gt = "",
									st = "",
									mt = "";
								if (He) gt = "; domain=" + He;
								else if (K) {
									var Et = Be(Q.location.hostname);
									gt = Et ? "; domain=." + Et : ""
								}
								if (L) {
									var Gt = new Date;
									Gt.setTime(Gt.getTime() + 24 * L * 60 * 60 * 1e3), st = "; expires=" + Gt.toGMTString()
								}
								ye && (he = !0, mt = "; SameSite=None"), he && (mt += "; secure");
								var Rt = f + "=" + encodeURIComponent(T) + st + "; path=/" + gt + mt;
								return Q.cookie = Rt, Rt
							},
							remove: function(f, T, L) {
								F.cookie.set(f, "", -1, T, !1, !1, L)
							}
						};
						var Ge = null,
							ft = function(f, T) {
								if (null !== Ge && !T) return Ge;
								var L = !0;
								try {
									f = f || window.localStorage;
									var K = "__mplss_" + lt(8);
									f.setItem(K, "xyz"), "xyz" !== f.getItem(K) && (L = !1), f.removeItem(K)
								} catch {
									L = !1
								}
								return Ge = L, L
							};
						F.localStorage = {
							is_supported: function(f) {
								var T = ft(null, f);
								return T || xe.error("localStorage unsupported; falling back to cookie store"), T
							},
							error: function(f) {
								xe.error("localStorage error: " + f)
							},
							get: function(f) {
								try {
									return window.localStorage.getItem(f)
								} catch (T) {
									F.localStorage.error(T)
								}
								return null
							},
							parse: function(f) {
								try {
									return F.JSONDecode(F.localStorage.get(f)) || {}
								} catch {}
								return null
							},
							set: function(f, T) {
								try {
									window.localStorage.setItem(f, T)
								} catch (L) {
									F.localStorage.error(L)
								}
							},
							remove: function(f) {
								try {
									window.localStorage.removeItem(f)
								} catch (T) {
									F.localStorage.error(T)
								}
							}
						}, F.register_event = function() {
							function L(K) {
								return K && (K.preventDefault = L.preventDefault, K.stopPropagation = L.stopPropagation), K
							}
							return L.preventDefault = function() {
									this.returnValue = !1
								}, L.stopPropagation = function() {
									this.cancelBubble = !0
								},
								function(K, he, ye, He, gt) {
									if (K)
										if (K.addEventListener && !He) K.addEventListener(he, ye, !!gt);
										else {
											var st = "on" + he;
											K[st] = function T(K, he, ye) {
												return function(gt) {
													if (gt = gt || L(window.event)) {
														var mt, Et, st = !0;
														return F.isFunction(ye) && (mt = ye(gt)), Et = he.call(K, gt), (!1 === mt || !1 === Et) && (st = !1), st
													}
												}
											}(K, ye, K[st])
										}
									else xe.error("No valid element provided to register_event")
								}
						}();
						var nt = new RegExp('^(\\w*)\\[(\\w+)([=~\\|\\^\\$\\*]?)=?"?([^\\]"]*)"?\\]$');
						F.dom_query = function() {
							function f(he) {
								return he.all ? he.all : he.getElementsByTagName("*")
							}
							var T = /[\t\r\n]/g;

							function L(he, ye) {
								var He = " " + ye + " ";
								return (" " + he.className + " ").replace(T, " ").indexOf(He) >= 0
							}

							function K(he) {
								if (!Q.getElementsByTagName) return [];
								var He, gt, st, mt, Et, Gt, Rt, Ot, Jt, Mn, ye = he.split(" "),
									Cn = [Q];
								for (Gt = 0; Gt < ye.length; Gt++)
									if ((He = ye[Gt].replace(/^\s+/, "").replace(/\s+$/, "")).indexOf("#") > -1) {
										st = (gt = He.split("#"))[0];
										var xn = Q.getElementById(gt[1]);
										if (!xn || st && xn.nodeName.toLowerCase() != st) return [];
										Cn = [xn]
									} else if (He.indexOf(".") > -1) {
									var Br = (gt = He.split("."))[1];
									for ((st = gt[0]) || (st = "*"), mt = [], Et = 0, Rt = 0; Rt < Cn.length; Rt++)
										for (Jt = "*" == st ? f(Cn[Rt]) : Cn[Rt].getElementsByTagName(st), Ot = 0; Ot < Jt.length; Ot++) mt[Et++] = Jt[Ot];
									for (Cn = [], Mn = 0, Rt = 0; Rt < mt.length; Rt++) mt[Rt].className && F.isString(mt[Rt].className) && L(mt[Rt], Br) && (Cn[Mn++] = mt[Rt])
								} else {
									var me = He.match(nt);
									if (me) {
										var Dt, tt = me[2],
											qe = me[3],
											dt = me[4];
										for ((st = me[1]) || (st = "*"), mt = [], Et = 0, Rt = 0; Rt < Cn.length; Rt++)
											for (Jt = "*" == st ? f(Cn[Rt]) : Cn[Rt].getElementsByTagName(st), Ot = 0; Ot < Jt.length; Ot++) mt[Et++] = Jt[Ot];
										switch (Cn = [], Mn = 0, qe) {
											case "=":
												Dt = function(Mt) {
													return Mt.getAttribute(tt) == dt
												};
												break;
											case "~":
												Dt = function(Mt) {
													return Mt.getAttribute(tt).match(new RegExp("\\b" + dt + "\\b"))
												};
												break;
											case "|":
												Dt = function(Mt) {
													return Mt.getAttribute(tt).match(new RegExp("^" + dt + "-?"))
												};
												break;
											case "^":
												Dt = function(Mt) {
													return 0 === Mt.getAttribute(tt).indexOf(dt)
												};
												break;
											case "$":
												Dt = function(Mt) {
													return Mt.getAttribute(tt).lastIndexOf(dt) == Mt.getAttribute(tt).length - dt.length
												};
												break;
											case "*":
												Dt = function(Mt) {
													return Mt.getAttribute(tt).indexOf(dt) > -1
												};
												break;
											default:
												Dt = function(Mt) {
													return Mt.getAttribute(tt)
												}
										}
										for (Cn = [], Mn = 0, Rt = 0; Rt < mt.length; Rt++) Dt(mt[Rt]) && (Cn[Mn++] = mt[Rt])
									} else {
										for (st = He, mt = [], Et = 0, Rt = 0; Rt < Cn.length; Rt++)
											for (Jt = Cn[Rt].getElementsByTagName(st), Ot = 0; Ot < Jt.length; Ot++) mt[Et++] = Jt[Ot];
										Cn = mt
									}
								}
								return Cn
							}
							return function(he) {
								return F.isElement(he) ? [he] : F.isObject(he) && !F.isUndefined(he.length) ? he : K.call(this, he)
							}
						}();
						var Pt = ["utm_source", "utm_medium", "utm_campaign", "utm_content", "utm_term"],
							at = ["dclid", "fbclid", "gclid", "ko_click_id", "li_fat_id", "msclkid", "ttclid", "twclid", "wbraid"];
						F.info = {
							campaignParams: function(f) {
								var T = "",
									L = {};
								return F.each(Pt, function(K) {
									(T = F.getQueryParam(Q.URL, K)).length ? L[K] = T : void 0 !== f && (L[K] = f)
								}), L
							},
							clickParams: function() {
								var f = "",
									T = {};
								return F.each(at, function(L) {
									(f = F.getQueryParam(Q.URL, L)).length && (T[L] = f)
								}), T
							},
							marketingParams: function() {
								return F.extend(F.info.campaignParams(), F.info.clickParams())
							},
							searchEngine: function(f) {
								return 0 === f.search("https?://(.*)google.([^/?]*)") ? "google" : 0 === f.search("https?://(.*)bing.com") ? "bing" : 0 === f.search("https?://(.*)yahoo.com") ? "yahoo" : 0 === f.search("https?://(.*)duckduckgo.com") ? "duckduckgo" : null
							},
							searchInfo: function(f) {
								var T = F.info.searchEngine(f),
									L = "yahoo" != T ? "q" : "p",
									K = {};
								if (null !== T) {
									K.$search_engine = T;
									var he = F.getQueryParam(f, L);
									he.length && (K.mp_keyword = he)
								}
								return K
							},
							browser: function(f, T, L) {
								return T = T || "", L || F.includes(f, " OPR/") ? F.includes(f, "Mini") ? "Opera Mini" : "Opera" : /(BlackBerry|PlayBook|BB10)/i.test(f) ? "BlackBerry" : F.includes(f, "IEMobile") || F.includes(f, "WPDesktop") ? "Internet Explorer Mobile" : F.includes(f, "SamsungBrowser/") ? "Samsung Internet" : F.includes(f, "Edge") || F.includes(f, "Edg/") ? "Microsoft Edge" : F.includes(f, "FBIOS") ? "Facebook Mobile" : F.includes(f, "Chrome") ? "Chrome" : F.includes(f, "CriOS") ? "Chrome iOS" : F.includes(f, "UCWEB") || F.includes(f, "UCBrowser") ? "UC Browser" : F.includes(f, "FxiOS") ? "Firefox iOS" : F.includes(T, "Apple") ? F.includes(f, "Mobile") ? "Mobile Safari" : "Safari" : F.includes(f, "Android") ? "Android Mobile" : F.includes(f, "Konqueror") ? "Konqueror" : F.includes(f, "Firefox") ? "Firefox" : F.includes(f, "MSIE") || F.includes(f, "Trident/") ? "Internet Explorer" : F.includes(f, "Gecko") ? "Mozilla" : ""
							},
							browserVersion: function(f, T, L) {
								var ye = {
									"Internet Explorer Mobile": /rv:(\d+(\.\d+)?)/,
									"Microsoft Edge": /Edge?\/(\d+(\.\d+)?)/,
									Chrome: /Chrome\/(\d+(\.\d+)?)/,
									"Chrome iOS": /CriOS\/(\d+(\.\d+)?)/,
									"UC Browser": /(UCBrowser|UCWEB)\/(\d+(\.\d+)?)/,
									Safari: /Version\/(\d+(\.\d+)?)/,
									"Mobile Safari": /Version\/(\d+(\.\d+)?)/,
									Opera: /(Opera|OPR)\/(\d+(\.\d+)?)/,
									Firefox: /Firefox\/(\d+(\.\d+)?)/,
									"Firefox iOS": /FxiOS\/(\d+(\.\d+)?)/,
									Konqueror: /Konqueror:(\d+(\.\d+)?)/,
									BlackBerry: /BlackBerry (\d+(\.\d+)?)/,
									"Android Mobile": /android\s(\d+(\.\d+)?)/,
									"Samsung Internet": /SamsungBrowser\/(\d+(\.\d+)?)/,
									"Internet Explorer": /(rv:|MSIE )(\d+(\.\d+)?)/,
									Mozilla: /rv:(\d+(\.\d+)?)/
								} [F.info.browser(f, T, L)];
								if (void 0 === ye) return null;
								var He = f.match(ye);
								return He ? parseFloat(He[He.length - 2]) : null
							},
							os: function() {
								var f = ie;
								return /Windows/i.test(f) ? /Phone/.test(f) || /WPDesktop/.test(f) ? "Windows Phone" : "Windows" : /(iPhone|iPad|iPod)/.test(f) ? "iOS" : /Android/.test(f) ? "Android" : /(BlackBerry|PlayBook|BB10)/i.test(f) ? "BlackBerry" : /Mac/i.test(f) ? "Mac OS X" : /Linux/.test(f) ? "Linux" : /CrOS/.test(f) ? "Chrome OS" : ""
							},
							device: function(f) {
								return /Windows Phone/i.test(f) || /WPDesktop/.test(f) ? "Windows Phone" : /iPad/.test(f) ? "iPad" : /iPod/.test(f) ? "iPod Touch" : /iPhone/.test(f) ? "iPhone" : /(BlackBerry|PlayBook|BB10)/i.test(f) ? "BlackBerry" : /Android/.test(f) ? "Android" : ""
							},
							referringDomain: function(f) {
								var T = f.split("/");
								return T.length >= 3 ? T[2] : ""
							},
							properties: function() {
								return F.extend(F.strip_empty_properties({
									$os: F.info.os(),
									$browser: F.info.browser(ie, G.vendor, X),
									$referrer: Q.referrer,
									$referring_domain: F.info.referringDomain(Q.referrer),
									$device: F.info.device(ie)
								}), {
									$current_url: E.location.href,
									$browser_version: F.info.browserVersion(ie, G.vendor, X),
									$screen_height: te.height,
									$screen_width: te.width,
									mp_lib: "web",
									$lib_version: ue.LIB_VERSION,
									$insert_id: lt(),
									time: F.timestamp() / 1e3
								})
							},
							people_properties: function() {
								return F.extend(F.strip_empty_properties({
									$os: F.info.os(),
									$browser: F.info.browser(ie, G.vendor, X)
								}), {
									$browser_version: F.info.browserVersion(ie, G.vendor, X)
								})
							},
							mpPageViewProperties: function() {
								return F.strip_empty_properties({
									current_page_title: Q.title,
									current_domain: E.location.hostname,
									current_url_path: E.location.pathname,
									current_url_protocol: E.location.protocol,
									current_url_search: E.location.search
								})
							}
						};
						var lt = function(f) {
								var T = Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10);
								return f ? T.substring(0, f) : T
							},
							et = /[a-z0-9][a-z0-9-]*\.[a-z]+$/i,
							Se = /[a-z0-9][a-z0-9-]+\.[a-z.]{2,6}$/i,
							Be = function(f) {
								var T = Se,
									L = f.split("."),
									K = L[L.length - 1];
								(K.length > 4 || "com" === K || "org" === K) && (T = et);
								var he = f.match(T);
								return he ? he[0] : ""
							},
							ze = null,
							it = null;
						typeof JSON < "u" && (ze = JSON.stringify, it = JSON.parse), ze = ze || F.JSONEncode, it = it || F.JSONDecode, F.toArray = F.toArray, F.isObject = F.isObject, F.JSONEncode = F.JSONEncode, F.JSONDecode = F.JSONDecode, F.isBlockedUA = F.isBlockedUA, F.isEmptyObject = F.isEmptyObject, F.info = F.info, F.info.device = F.info.device, F.info.browser = F.info.browser, F.info.browserVersion = F.info.browserVersion, F.info.properties = F.info.properties;
						var ce = function() {};
						ce.prototype.create_properties = function() {}, ce.prototype.event_handler = function() {}, ce.prototype.after_track_handler = function() {}, ce.prototype.init = function(f) {
							return this.mp = f, this
						}, ce.prototype.track = function(f, T, L, K) {
							var he = this,
								ye = F.dom_query(f);
							if (0 !== ye.length) return F.each(ye, function(He) {
								F.register_event(He, this.override_event, function(gt) {
									var st = {},
										mt = he.create_properties(L, this),
										Et = he.mp.get_config("track_links_timeout");
									he.event_handler(gt, this, st), window.setTimeout(he.track_callback(K, mt, st, !0), Et), he.mp.track(T, mt, he.track_callback(K, mt, st))
								})
							}, this), !0;
							xe.error("The DOM query (" + f + ") returned 0 elements")
						}, ce.prototype.track_callback = function(f, T, L, K) {
							K = K || !1;
							var he = this;
							return function() {
								L.callback_fired || (L.callback_fired = !0, (!f || !1 !== f(K, T)) && he.after_track_handler(T, L, K))
							}
						}, ce.prototype.create_properties = function(f, T) {
							return "function" == typeof f ? f(T) : F.extend({}, f)
						};
						var ht = function() {
							this.override_event = "click"
						};
						F.inherit(ht, ce), ht.prototype.create_properties = function(f, T) {
							var L = ht.superclass.create_properties.apply(this, arguments);
							return T.href && (L.url = T.href), L
						}, ht.prototype.event_handler = function(f, T, L) {
							L.new_tab = 2 === f.which || f.metaKey || f.ctrlKey || "_blank" === T.target, L.href = T.href, L.new_tab || f.preventDefault()
						}, ht.prototype.after_track_handler = function(f, T) {
							T.new_tab || setTimeout(function() {
								window.location = T.href
							}, 0)
						};
						var Pe = function() {
							this.override_event = "submit"
						};
						F.inherit(Pe, ce), Pe.prototype.event_handler = function(f, T, L) {
							L.element = T, f.preventDefault()
						}, Pe.prototype.after_track_handler = function(f, T) {
							setTimeout(function() {
								T.element.submit()
							}, 0)
						};
						var pt = Ue("lock"),
							Bt = function(f, T) {
								T = T || {}, this.storageKey = f, this.storage = T.storage || window.localStorage, this.pollIntervalMS = T.pollIntervalMS || 100, this.timeoutMS = T.timeoutMS || 2e3
							};
						Bt.prototype.withLock = function(f, T, L) {
							!L && "function" != typeof T && (L = T, T = null);
							var K = L || (new Date).getTime() + "|" + Math.random(),
								he = (new Date).getTime(),
								ye = this.storageKey,
								He = this.pollIntervalMS,
								gt = this.timeoutMS,
								st = this.storage,
								mt = ye + ":X",
								Et = ye + ":Y",
								Gt = ye + ":Z",
								Rt = function(xn) {
									T && T(xn)
								},
								Ot = function(xn) {
									if ((new Date).getTime() - he > gt) return pt.error("Timeout waiting for mutex on " + ye + "; clearing lock. [" + K + "]"), st.removeItem(Gt), st.removeItem(Et), void Cn();
									setTimeout(function() {
										try {
											xn()
										} catch (Br) {
											Rt(Br)
										}
									}, He * (Math.random() + .1))
								},
								Jt = function(xn, Br) {
									xn() ? Br() : Ot(function() {
										Jt(xn, Br)
									})
								},
								Mn = function() {
									var xn = st.getItem(Et);
									if (xn && xn !== K) return !1;
									if (st.setItem(Et, K), st.getItem(Et) === K) return !0;
									if (!ft(st, !0)) throw new Error("localStorage support dropped while acquiring lock");
									return !1
								},
								Cn = function() {
									st.setItem(mt, K), Jt(Mn, function() {
										st.getItem(mt) !== K ? Ot(function() {
											st.getItem(Et) === K ? Jt(function() {
												return !st.getItem(Gt)
											}, Jn) : Cn()
										}) : Jn()
									})
								},
								Jn = function() {
									st.setItem(Gt, "1");
									try {
										f()
									} finally {
										st.removeItem(Gt), st.getItem(Et) === K && st.removeItem(Et), st.getItem(mt) === K && st.removeItem(mt)
									}
								};
							try {
								if (!ft(st, !0)) throw new Error("localStorage support check failed");
								Cn()
							} catch (xn) {
								Rt(xn)
							}
						};
						var ot = Ue("batch"),
							Vt = function(f, T) {
								T = T || {}, this.storageKey = f, this.storage = T.storage || window.localStorage, this.reportError = T.errorReporter || F.bind(ot.error, ot), this.lock = new Bt(f, {
									storage: this.storage
								}), this.pid = T.pid || null, this.memQueue = []
							};
						Vt.prototype.enqueue = function(f, T, L) {
							var K = {
								id: lt(),
								flushAfter: (new Date).getTime() + 2 * T,
								payload: f
							};
							this.lock.withLock(F.bind(function() {
								var ye;
								try {
									var He = this.readFromStorage();
									He.push(K), (ye = this.saveToStorage(He)) && this.memQueue.push(K)
								} catch {
									this.reportError("Error enqueueing item", f), ye = !1
								}
								L && L(ye)
							}, this), F.bind(function(ye) {
								this.reportError("Error acquiring storage lock", ye), L && L(!1)
							}, this), this.pid)
						}, Vt.prototype.fillBatch = function(f) {
							var T = this.memQueue.slice(0, f);
							if (T.length < f) {
								var L = this.readFromStorage();
								if (L.length) {
									var K = {};
									F.each(T, function(He) {
										K[He.id] = !0
									});
									for (var he = 0; he < L.length; he++) {
										var ye = L[he];
										if ((new Date).getTime() > ye.flushAfter && !K[ye.id] && (ye.orphaned = !0, T.push(ye), T.length >= f)) break
									}
								}
							}
							return T
						};
						var Qt = function(f, T) {
							var L = [];
							return F.each(f, function(K) {
								K.id && !T[K.id] && L.push(K)
							}), L
						};
						Vt.prototype.removeItemsByID = function(f, T) {
							var L = {};
							F.each(f, function(he) {
								L[he] = !0
							}), this.memQueue = Qt(this.memQueue, L);
							var K = F.bind(function() {
								var he;
								try {
									var ye = this.readFromStorage();
									if (ye = Qt(ye, L), he = this.saveToStorage(ye)) {
										ye = this.readFromStorage();
										for (var He = 0; He < ye.length; He++) {
											var gt = ye[He];
											if (gt.id && L[gt.id]) return this.reportError("Item not removed from storage"), !1
										}
									}
								} catch {
									this.reportError("Error removing items", f), he = !1
								}
								return he
							}, this);
							this.lock.withLock(function() {
								var ye = K();
								T && T(ye)
							}, F.bind(function(ye) {
								var He = !1;
								if (this.reportError("Error acquiring storage lock", ye), !ft(this.storage, !0) && !(He = K())) try {
									this.storage.removeItem(this.storageKey)
								} catch (gt) {
									this.reportError("Error clearing queue", gt)
								}
								T && T(He)
							}, this), this.pid)
						};
						var cn = function(f, T) {
							var L = [];
							return F.each(f, function(K) {
								var he = K.id;
								if (he in T) {
									var ye = T[he];
									null !== ye && (K.payload = ye, L.push(K))
								} else L.push(K)
							}), L
						};
						Vt.prototype.updatePayloads = function(f, T) {
							this.memQueue = cn(this.memQueue, f), this.lock.withLock(F.bind(function() {
								var K;
								try {
									var he = this.readFromStorage();
									he = cn(he, f), K = this.saveToStorage(he)
								} catch {
									this.reportError("Error updating items", f), K = !1
								}
								T && T(K)
							}, this), F.bind(function(K) {
								this.reportError("Error acquiring storage lock", K), T && T(!1)
							}, this), this.pid)
						}, Vt.prototype.readFromStorage = function() {
							var f;
							try {
								(f = this.storage.getItem(this.storageKey)) && (f = it(f), F.isArray(f) || (this.reportError("Invalid storage entry:", f), f = null))
							} catch (T) {
								this.reportError("Error retrieving queue", T), f = null
							}
							return f || []
						}, Vt.prototype.saveToStorage = function(f) {
							try {
								return this.storage.setItem(this.storageKey, ze(f)), !0
							} catch (T) {
								return this.reportError("Error saving queue", T), !1
							}
						}, Vt.prototype.clear = function() {
							this.memQueue = [], this.storage.removeItem(this.storageKey)
						};
						var Pn = Ue("batch"),
							mn = function(f, T) {
								this.errorReporter = T.errorReporter, this.queue = new Vt(f, {
									errorReporter: F.bind(this.reportError, this),
									storage: T.storage
								}), this.libConfig = T.libConfig, this.sendRequest = T.sendRequestFunc, this.beforeSendHook = T.beforeSendHook, this.stopAllBatching = T.stopAllBatchingFunc, this.batchSize = this.libConfig.batch_size, this.flushInterval = this.libConfig.batch_flush_interval_ms, this.stopped = !this.libConfig.batch_autostart, this.consecutiveRemovalFailures = 0, this.itemIdsSentSuccessfully = {}
							};
						mn.prototype.enqueue = function(f, T) {
							this.queue.enqueue(f, this.flushInterval, T)
						}, mn.prototype.start = function() {
							this.stopped = !1, this.consecutiveRemovalFailures = 0, this.flush()
						}, mn.prototype.stop = function() {
							this.stopped = !0, this.timeoutID && (clearTimeout(this.timeoutID), this.timeoutID = null)
						}, mn.prototype.clear = function() {
							this.queue.clear()
						}, mn.prototype.resetBatchSize = function() {
							this.batchSize = this.libConfig.batch_size
						}, mn.prototype.resetFlush = function() {
							this.scheduleFlush(this.libConfig.batch_flush_interval_ms)
						}, mn.prototype.scheduleFlush = function(f) {
							this.flushInterval = f, this.stopped || (this.timeoutID = setTimeout(F.bind(this.flush, this), this.flushInterval))
						}, mn.prototype.flush = function(f) {
							try {
								if (this.requestInProgress) return void Pn.log("Flush: Request already in progress");
								f = f || {};
								var T = this.libConfig.batch_request_timeout_ms,
									L = (new Date).getTime(),
									K = this.batchSize,
									he = this.queue.fillBatch(K),
									ye = [],
									He = {};
								if (F.each(he, function(mt) {
										var Et = mt.payload;
										if (this.beforeSendHook && !mt.orphaned && (Et = this.beforeSendHook(Et)), Et) {
											Et.event && Et.properties && (Et.properties = F.extend({}, Et.properties, {
												mp_sent_by_lib_version: ue.LIB_VERSION
											}));
											var Gt = !0,
												Rt = mt.id;
											Rt ? (this.itemIdsSentSuccessfully[Rt] || 0) > 5 && (this.reportError("[dupe] item ID sent too many times, not sending", {
												item: mt,
												batchSize: he.length,
												timesSent: this.itemIdsSentSuccessfully[Rt]
											}), Gt = !1) : this.reportError("[dupe] found item with no ID", {
												item: mt
											}), Gt && ye.push(Et)
										}
										He[mt.id] = Et
									}, this), ye.length < 1) return void this.resetFlush();
								this.requestInProgress = !0;
								var gt = F.bind(function(mt) {
										this.requestInProgress = !1;
										try {
											var Et = !1;
											if (f.unloading) this.queue.updatePayloads(He);
											else if (F.isObject(mt) && "timeout" === mt.error && (new Date).getTime() - L >= T) this.reportError("Network timeout; retrying"), this.flush();
											else if (F.isObject(mt) && mt.xhr_req && (mt.xhr_req.status >= 500 || 429 === mt.xhr_req.status || "timeout" === mt.error)) {
												var Gt = 2 * this.flushInterval,
													Rt = mt.xhr_req.responseHeaders;
												if (Rt) {
													var Ot = Rt["Retry-After"];
													Ot && (Gt = 1e3 * parseInt(Ot, 10) || Gt)
												}
												Gt = Math.min(6e5, Gt), this.reportError("Error; retry in " + Gt + " ms"), this.scheduleFlush(Gt)
											} else if (F.isObject(mt) && mt.xhr_req && 413 === mt.xhr_req.status)
												if (he.length > 1) {
													var Jt = Math.max(1, Math.floor(K / 2));
													this.batchSize = Math.min(this.batchSize, Jt, he.length - 1), this.reportError("413 response; reducing batch size to " + this.batchSize), this.resetFlush()
												} else this.reportError("Single-event request too large; dropping", he), this.resetBatchSize(), Et = !0;
											else Et = !0;
											Et && (this.queue.removeItemsByID(F.map(he, function(Mn) {
												return Mn.id
											}), F.bind(function(Mn) {
												Mn ? (this.consecutiveRemovalFailures = 0, this.flush()) : (this.reportError("Failed to remove items from queue"), ++this.consecutiveRemovalFailures > 5 ? (this.reportError("Too many queue failures; disabling batching system."), this.stopAllBatching()) : this.resetFlush())
											}, this)), F.each(he, F.bind(function(Mn) {
												var Cn = Mn.id;
												Cn ? (this.itemIdsSentSuccessfully[Cn] = this.itemIdsSentSuccessfully[Cn] || 0, this.itemIdsSentSuccessfully[Cn]++, this.itemIdsSentSuccessfully[Cn] > 5 && this.reportError("[dupe] item ID sent too many times", {
													item: Mn,
													batchSize: he.length,
													timesSent: this.itemIdsSentSuccessfully[Cn]
												})) : this.reportError("[dupe] found item with no ID while removing", {
													item: Mn
												})
											}, this)))
										} catch (Mn) {
											this.reportError("Error handling API response", Mn), this.resetFlush()
										}
									}, this),
									st = {
										method: "POST",
										verbose: !0,
										ignore_json_errors: !0,
										timeout_ms: T
									};
								f.unloading && (st.transport = "sendBeacon"), Pn.log("MIXPANEL REQUEST:", ye), this.sendRequest(ye, st, gt)
							} catch (mt) {
								this.reportError("Error flushing request queue", mt), this.resetFlush()
							}
						}, mn.prototype.reportError = function(f, T) {
							if (Pn.error.apply(Pn.error, arguments), this.errorReporter) try {
								T instanceof Error || (T = new Error(f)), this.errorReporter(f, T)
							} catch (L) {
								Pn.error(L)
							}
						};
						var Un = "__mp_opt_in_out_";

						function Kn(f, T) {
							hr(!0, f, T)
						}

						function Vn(f, T) {
							hr(!1, f, T)
						}

						function Zt(f, T) {
							return "1" === Nn(f, T)
						}

						function bn(f, T) {
							if (function ar(f) {
									if (f && f.ignoreDnt) return !1;
									var T = f && f.window || E,
										L = T.navigator || {},
										K = !1;
									return F.each([L.doNotTrack, L.msDoNotTrack, T.doNotTrack], function(he) {
										F.includes([!0, 1, "1", "yes"], he) && (K = !0)
									}), K
								}(T)) return xe.warn('This browser has "Do Not Track" enabled. This will prevent the Mixpanel SDK from sending any data. To ignore the "Do Not Track" browser setting, initialize the Mixpanel instance with the config "ignore_dnt: true"'), !0;
							var L = "0" === Nn(f, T);
							return L && xe.warn("You are opted out of Mixpanel tracking. This will prevent the Mixpanel SDK from sending any data."), L
						}

						function Bn(f) {
							return un(f, function(T) {
								return this.get_config(T)
							})
						}

						function qt(f) {
							return un(f, function(T) {
								return this._get_config(T)
							})
						}

						function tn(f) {
							return un(f, function(T) {
								return this._get_config(T)
							})
						}

						function en(f, T) {
							Qn(T = T || {}).remove(Wn(f, T), !!T.crossSubdomainCookie, T.cookieDomain)
						}

						function Qn(f) {
							return "localStorage" === (f = f || {}).persistenceType ? F.localStorage : F.cookie
						}

						function Wn(f, T) {
							return ((T = T || {}).persistencePrefix || Un) + f
						}

						function Nn(f, T) {
							return Qn(T).get(Wn(f, T))
						}

						function hr(f, T, L) {
							F.isString(T) && T.length ? (Qn(L = L || {}).set(Wn(T, L), f ? 1 : 0, F.isNumber(L.cookieExpiration) ? L.cookieExpiration : null, !!L.crossSubdomainCookie, !!L.secureCookie, !!L.crossSiteCookie, L.cookieDomain), L.track && f && L.track(L.trackEventName || "$opt_in", L.trackProperties, {
								send_immediately: !0
							})) : xe.error("gdpr." + (f ? "optIn" : "optOut") + " called with an invalid token")
						}

						function un(f, T) {
							return function() {
								var L = !1;
								try {
									var K = T.call(this, "token"),
										he = T.call(this, "ignore_dnt"),
										ye = T.call(this, "opt_out_tracking_persistence_type"),
										He = T.call(this, "opt_out_tracking_cookie_prefix"),
										gt = T.call(this, "window");
									K && (L = bn(K, {
										ignoreDnt: he,
										persistenceType: ye,
										persistencePrefix: He,
										window: gt
									}))
								} catch (mt) {
									xe.error("Unexpected error when checking tracking opt-out status: " + mt)
								}
								if (!L) return f.apply(this, arguments);
								var st = arguments[arguments.length - 1];
								"function" == typeof st && st(0)
							}
						}
						var Nt = "$set",
							Xe = "$set_once",
							pe = "$unset",
							Te = "$add",
							Je = "$append",
							yt = "$union",
							Ht = "$remove",
							$t = {
								set_action: function(f, T) {
									var L = {},
										K = {};
									return F.isObject(f) ? F.each(f, function(he, ye) {
										this._is_reserved_property(ye) || (K[ye] = he)
									}, this) : K[f] = T, L[Nt] = K, L
								},
								unset_action: function(f) {
									var T = {},
										L = [];
									return F.isArray(f) || (f = [f]), F.each(f, function(K) {
										this._is_reserved_property(K) || L.push(K)
									}, this), T[pe] = L, T
								},
								set_once_action: function(f, T) {
									var L = {},
										K = {};
									return F.isObject(f) ? F.each(f, function(he, ye) {
										this._is_reserved_property(ye) || (K[ye] = he)
									}, this) : K[f] = T, L[Xe] = K, L
								},
								union_action: function(f, T) {
									var L = {},
										K = {};
									return F.isObject(f) ? F.each(f, function(he, ye) {
										this._is_reserved_property(ye) || (K[ye] = F.isArray(he) ? he : [he])
									}, this) : K[f] = F.isArray(T) ? T : [T], L[yt] = K, L
								},
								append_action: function(f, T) {
									var L = {},
										K = {};
									return F.isObject(f) ? F.each(f, function(he, ye) {
										this._is_reserved_property(ye) || (K[ye] = he)
									}, this) : K[f] = T, L[Je] = K, L
								},
								remove_action: function(f, T) {
									var L = {},
										K = {};
									return F.isObject(f) ? F.each(f, function(he, ye) {
										this._is_reserved_property(ye) || (K[ye] = he)
									}, this) : K[f] = T, L[Ht] = K, L
								},
								delete_action: function() {
									return {
										$delete: ""
									}
								}
							},
							hn = function() {};
						F.extend(hn.prototype, $t), hn.prototype._init = function(f, T, L) {
							this._mixpanel = f, this._group_key = T, this._group_id = L
						}, hn.prototype.set = tn(function(f, T, L) {
							var K = this.set_action(f, T);
							return F.isObject(f) && (L = T), this._send_request(K, L)
						}), hn.prototype.set_once = tn(function(f, T, L) {
							var K = this.set_once_action(f, T);
							return F.isObject(f) && (L = T), this._send_request(K, L)
						}), hn.prototype.unset = tn(function(f, T) {
							var L = this.unset_action(f);
							return this._send_request(L, T)
						}), hn.prototype.union = tn(function(f, T, L) {
							F.isObject(f) && (L = T);
							var K = this.union_action(f, T);
							return this._send_request(K, L)
						}), hn.prototype.delete = tn(function(f) {
							var T = this.delete_action();
							return this._send_request(T, f)
						}), hn.prototype.remove = tn(function(f, T, L) {
							var K = this.remove_action(f, T);
							return this._send_request(K, L)
						}), hn.prototype._send_request = function(f, T) {
							f.$group_key = this._group_key, f.$group_id = this._group_id, f.$token = this._get_config("token");
							var L = F.encodeDates(f);
							return this._mixpanel._track_or_batch({
								type: "groups",
								data: L,
								endpoint: this._get_config("api_host") + "/groups/",
								batcher: this._mixpanel.request_batchers.groups
							}, T)
						}, hn.prototype._is_reserved_property = function(f) {
							return "$group_key" === f || "$group_id" === f
						}, hn.prototype._get_config = function(f) {
							return this._mixpanel.get_config(f)
						}, hn.prototype.toString = function() {
							return this._mixpanel.toString() + ".group." + this._group_key + "." + this._group_id
						}, hn.prototype.remove = hn.prototype.remove, hn.prototype.set = hn.prototype.set, hn.prototype.set_once = hn.prototype.set_once, hn.prototype.union = hn.prototype.union, hn.prototype.unset = hn.prototype.unset, hn.prototype.toString = hn.prototype.toString;
						var kt = function() {};
						F.extend(kt.prototype, $t), kt.prototype._init = function(f) {
							this._mixpanel = f
						}, kt.prototype.set = qt(function(f, T, L) {
							var K = this.set_action(f, T);
							return F.isObject(f) && (L = T), this._get_config("save_referrer") && this._mixpanel.persistence.update_referrer_info(document.referrer), K[Nt] = F.extend({}, F.info.people_properties(), this._mixpanel.persistence.get_referrer_info(), K[Nt]), this._send_request(K, L)
						}), kt.prototype.set_once = qt(function(f, T, L) {
							var K = this.set_once_action(f, T);
							return F.isObject(f) && (L = T), this._send_request(K, L)
						}), kt.prototype.unset = qt(function(f, T) {
							var L = this.unset_action(f);
							return this._send_request(L, T)
						}), kt.prototype.increment = qt(function(f, T, L) {
							var K = {},
								he = {};
							return F.isObject(f) ? (F.each(f, function(ye, He) {
								if (!this._is_reserved_property(He)) {
									if (isNaN(parseFloat(ye))) return void xe.error("Invalid increment value passed to mixpanel.people.increment - must be a number");
									he[He] = ye
								}
							}, this), L = T) : (F.isUndefined(T) && (T = 1), he[f] = T), K[Te] = he, this._send_request(K, L)
						}), kt.prototype.append = qt(function(f, T, L) {
							F.isObject(f) && (L = T);
							var K = this.append_action(f, T);
							return this._send_request(K, L)
						}), kt.prototype.remove = qt(function(f, T, L) {
							F.isObject(f) && (L = T);
							var K = this.remove_action(f, T);
							return this._send_request(K, L)
						}), kt.prototype.union = qt(function(f, T, L) {
							F.isObject(f) && (L = T);
							var K = this.union_action(f, T);
							return this._send_request(K, L)
						}), kt.prototype.track_charge = qt(function(f, T, L) {
							if (F.isNumber(f) || (f = parseFloat(f), !isNaN(f))) return this.append("$transactions", F.extend({
								$amount: f
							}, T), L);
							xe.error("Invalid value passed to mixpanel.people.track_charge - must be a number")
						}), kt.prototype.clear_charges = function(f) {
							return this.set("$transactions", [], f)
						}, kt.prototype.delete_user = function() {
							if (this._identify_called()) {
								var f = {
									$delete: this._mixpanel.get_distinct_id()
								};
								return this._send_request(f)
							}
							xe.error("mixpanel.people.delete_user() requires you to call identify() first")
						}, kt.prototype.toString = function() {
							return this._mixpanel.toString() + ".people"
						}, kt.prototype._send_request = function(f, T) {
							f.$token = this._get_config("token"), f.$distinct_id = this._mixpanel.get_distinct_id();
							var L = this._mixpanel.get_property("$device_id"),
								K = this._mixpanel.get_property("$user_id"),
								he = this._mixpanel.get_property("$had_persisted_distinct_id");
							L && (f.$device_id = L), K && (f.$user_id = K), he && (f.$had_persisted_distinct_id = he);
							var ye = F.encodeDates(f);
							return this._identify_called() ? this._mixpanel._track_or_batch({
								type: "people",
								data: ye,
								endpoint: this._get_config("api_host") + "/engage/",
								batcher: this._mixpanel.request_batchers.people
							}, T) : (this._enqueue(f), F.isUndefined(T) || (this._get_config("verbose") ? T({
								status: -1,
								error: null
							}) : T(-1)), F.truncate(ye, 255))
						}, kt.prototype._get_config = function(f) {
							return this._mixpanel.get_config(f)
						}, kt.prototype._identify_called = function() {
							return !0 === this._mixpanel._flags.identify_called
						}, kt.prototype._enqueue = function(f) {
							Nt in f ? this._mixpanel.persistence._add_to_people_queue(Nt, f) : Xe in f ? this._mixpanel.persistence._add_to_people_queue(Xe, f) : pe in f ? this._mixpanel.persistence._add_to_people_queue(pe, f) : Te in f ? this._mixpanel.persistence._add_to_people_queue(Te, f) : Je in f ? this._mixpanel.persistence._add_to_people_queue(Je, f) : Ht in f ? this._mixpanel.persistence._add_to_people_queue(Ht, f) : yt in f ? this._mixpanel.persistence._add_to_people_queue(yt, f) : xe.error("Invalid call to _enqueue():", f)
						}, kt.prototype._flush_one_queue = function(f, T, L, K) {
							var he = this,
								ye = F.extend({}, this._mixpanel.persistence._get_queue(f)),
								He = ye;
							!F.isUndefined(ye) && F.isObject(ye) && !F.isEmptyObject(ye) && (he._mixpanel.persistence._pop_from_people_queue(f, ye), K && (He = K(ye)), T.call(he, He, function(gt, st) {
								0 === gt && he._mixpanel.persistence._add_to_people_queue(f, ye), F.isUndefined(L) || L(gt, st)
							}))
						}, kt.prototype._flush = function(f, T, L, K, he, ye, He) {
							var gt = this,
								st = this._mixpanel.persistence._get_queue(Je),
								mt = this._mixpanel.persistence._get_queue(Ht);
							if (this._flush_one_queue(Nt, this.set, f), this._flush_one_queue(Xe, this.set_once, K), this._flush_one_queue(pe, this.unset, ye, function(Cn) {
									return F.keys(Cn)
								}), this._flush_one_queue(Te, this.increment, T), this._flush_one_queue(yt, this.union, he), !F.isUndefined(st) && F.isArray(st) && st.length) {
								for (var Et, Gt = function(Cn, Jn) {
										0 === Cn && gt._mixpanel.persistence._add_to_people_queue(Je, Et), F.isUndefined(L) || L(Cn, Jn)
									}, Rt = st.length - 1; Rt >= 0; Rt--) Et = st.pop(), F.isEmptyObject(Et) || gt.append(Et, Gt);
								gt._mixpanel.persistence.save()
							}
							if (!F.isUndefined(mt) && F.isArray(mt) && mt.length) {
								for (var Ot, Jt = function(Cn, Jn) {
										0 === Cn && gt._mixpanel.persistence._add_to_people_queue(Ht, Ot), F.isUndefined(He) || He(Cn, Jn)
									}, Mn = mt.length - 1; Mn >= 0; Mn--) Ot = mt.pop(), F.isEmptyObject(Ot) || gt.remove(Ot, Jt);
								gt._mixpanel.persistence.save()
							}
						}, kt.prototype._is_reserved_property = function(f) {
							return "$distinct_id" === f || "$token" === f || "$device_id" === f || "$user_id" === f || "$had_persisted_distinct_id" === f
						}, kt.prototype.set = kt.prototype.set, kt.prototype.set_once = kt.prototype.set_once, kt.prototype.unset = kt.prototype.unset, kt.prototype.increment = kt.prototype.increment, kt.prototype.append = kt.prototype.append, kt.prototype.remove = kt.prototype.remove, kt.prototype.union = kt.prototype.union, kt.prototype.track_charge = kt.prototype.track_charge, kt.prototype.clear_charges = kt.prototype.clear_charges, kt.prototype.delete_user = kt.prototype.delete_user, kt.prototype.toString = kt.prototype.toString;
						var ct = "__mps",
							De = "__mpso",
							B = "__mpus",
							J = "__mpa",
							k = "__mpap",
							H = "__mpr",
							ne = "__mpu",
							Ne = "$people_distinct_id",
							Ye = "__alias",
							Ft = "__timers",
							an = [ct, De, B, J, k, H, ne, Ne, Ye, Ft],
							xt = function(f) {
								this.props = {}, this.campaign_params_saved = !1, this.name = f.persistence_name ? "mp_" + f.persistence_name : "mp_" + f.token + "_mixpanel";
								var T = f.persistence;
								"cookie" !== T && "localStorage" !== T && (xe.critical("Unknown persistence type " + T + "; falling back to cookie"), T = f.persistence = "cookie"), this.storage = "localStorage" === T && F.localStorage.is_supported() ? F.localStorage : F.cookie, this.load(), this.update_config(f), this.upgrade(f), this.save()
							};
						xt.prototype.properties = function() {
							var f = {};
							return F.each(this.props, function(T, L) {
								F.include(an, L) || (f[L] = T)
							}), f
						}, xt.prototype.load = function() {
							if (!this.disabled) {
								var f = this.storage.parse(this.name);
								f && (this.props = F.extend({}, f))
							}
						}, xt.prototype.upgrade = function(f) {
							var L, K, T = f.upgrade;
							T && (L = "mp_super_properties", "string" == typeof T && (L = T), K = this.storage.parse(L), this.storage.remove(L), this.storage.remove(L, !0), K && (this.props = F.extend(this.props, K.all, K.events))), !f.cookie_name && "mixpanel" !== f.name && (K = this.storage.parse(L = "mp_" + f.token + "_" + f.name)) && (this.storage.remove(L), this.storage.remove(L, !0), this.register_once(K)), this.storage === F.localStorage && (K = F.cookie.parse(this.name), F.cookie.remove(this.name), F.cookie.remove(this.name, !0), K && this.register_once(K))
						}, xt.prototype.save = function() {
							this.disabled || this.storage.set(this.name, F.JSONEncode(this.props), this.expire_days, this.cross_subdomain, this.secure, this.cross_site, this.cookie_domain)
						}, xt.prototype.remove = function() {
							this.storage.remove(this.name, !1, this.cookie_domain), this.storage.remove(this.name, !0, this.cookie_domain)
						}, xt.prototype.clear = function() {
							this.remove(), this.props = {}
						}, xt.prototype.register_once = function(f, T, L) {
							return !!F.isObject(f) && (typeof T > "u" && (T = "None"), this.expire_days = typeof L > "u" ? this.default_expiry : L, F.each(f, function(K, he) {
								(!this.props.hasOwnProperty(he) || this.props[he] === T) && (this.props[he] = K)
							}, this), this.save(), !0)
						}, xt.prototype.register = function(f, T) {
							return !!F.isObject(f) && (this.expire_days = typeof T > "u" ? this.default_expiry : T, F.extend(this.props, f), this.save(), !0)
						}, xt.prototype.unregister = function(f) {
							f in this.props && (delete this.props[f], this.save())
						}, xt.prototype.update_search_keyword = function(f) {
							this.register(F.info.searchInfo(f))
						}, xt.prototype.update_referrer_info = function(f) {
							this.register_once({
								$initial_referrer: f || "$direct",
								$initial_referring_domain: F.info.referringDomain(f) || "$direct"
							}, "")
						}, xt.prototype.get_referrer_info = function() {
							return F.strip_empty_properties({
								$initial_referrer: this.props.$initial_referrer,
								$initial_referring_domain: this.props.$initial_referring_domain
							})
						}, xt.prototype.safe_merge = function(f) {
							return F.each(this.props, function(T, L) {
								L in f || (f[L] = T)
							}), f
						}, xt.prototype.update_config = function(f) {
							this.default_expiry = this.expire_days = f.cookie_expiration, this.set_disabled(f.disable_persistence), this.set_cookie_domain(f.cookie_domain), this.set_cross_site(f.cross_site_cookie), this.set_cross_subdomain(f.cross_subdomain_cookie), this.set_secure(f.secure_cookie)
						}, xt.prototype.set_disabled = function(f) {
							this.disabled = f, this.disabled ? this.remove() : this.save()
						}, xt.prototype.set_cookie_domain = function(f) {
							f !== this.cookie_domain && (this.remove(), this.cookie_domain = f, this.save())
						}, xt.prototype.set_cross_site = function(f) {
							f !== this.cross_site && (this.cross_site = f, this.remove(), this.save())
						}, xt.prototype.set_cross_subdomain = function(f) {
							f !== this.cross_subdomain && (this.cross_subdomain = f, this.remove(), this.save())
						}, xt.prototype.get_cross_subdomain = function() {
							return this.cross_subdomain
						}, xt.prototype.set_secure = function(f) {
							f !== this.secure && (this.secure = !!f, this.remove(), this.save())
						}, xt.prototype._add_to_people_queue = function(f, T) {
							var L = this._get_queue_key(f),
								K = T[f],
								he = this._get_or_create_queue(Nt),
								ye = this._get_or_create_queue(Xe),
								He = this._get_or_create_queue(pe),
								gt = this._get_or_create_queue(Te),
								st = this._get_or_create_queue(yt),
								mt = this._get_or_create_queue(Ht, []),
								Et = this._get_or_create_queue(Je, []);
							L === ct ? (F.extend(he, K), this._pop_from_people_queue(Te, K), this._pop_from_people_queue(yt, K), this._pop_from_people_queue(pe, K)) : L === De ? (F.each(K, function(Gt, Rt) {
								Rt in ye || (ye[Rt] = Gt)
							}), this._pop_from_people_queue(pe, K)) : L === B ? F.each(K, function(Gt) {
								F.each([he, ye, gt, st], function(Rt) {
									Gt in Rt && delete Rt[Gt]
								}), F.each(Et, function(Rt) {
									Gt in Rt && delete Rt[Gt]
								}), He[Gt] = !0
							}) : L === J ? (F.each(K, function(Gt, Rt) {
								Rt in he ? he[Rt] += Gt : (Rt in gt || (gt[Rt] = 0), gt[Rt] += Gt)
							}, this), this._pop_from_people_queue(pe, K)) : L === ne ? (F.each(K, function(Gt, Rt) {
								F.isArray(Gt) && (Rt in st || (st[Rt] = []), st[Rt] = st[Rt].concat(Gt))
							}), this._pop_from_people_queue(pe, K)) : L === H ? (mt.push(K), this._pop_from_people_queue(Je, K)) : L === k && (Et.push(K), this._pop_from_people_queue(pe, K)), xe.log("MIXPANEL PEOPLE REQUEST (QUEUED, PENDING IDENTIFY):"), xe.log(T), this.save()
						}, xt.prototype._pop_from_people_queue = function(f, T) {
							var L = this._get_queue(f);
							F.isUndefined(L) || (F.each(T, function(K, he) {
								f === Je || f === Ht ? F.each(L, function(ye) {
									ye[he] === K && delete ye[he]
								}) : delete L[he]
							}, this), this.save())
						}, xt.prototype._get_queue_key = function(f) {
							return f === Nt ? ct : f === Xe ? De : f === pe ? B : f === Te ? J : f === Je ? k : f === Ht ? H : f === yt ? ne : void xe.error("Invalid queue:", f)
						}, xt.prototype._get_queue = function(f) {
							return this.props[this._get_queue_key(f)]
						}, xt.prototype._get_or_create_queue = function(f, T) {
							var L = this._get_queue_key(f);
							return T = F.isUndefined(T) ? {} : T, this.props[L] || (this.props[L] = T)
						}, xt.prototype.set_event_timer = function(f, T) {
							var L = this.props[Ft] || {};
							L[f] = T, this.props[Ft] = L, this.save()
						}, xt.prototype.remove_event_timer = function(f) {
							var L = (this.props[Ft] || {})[f];
							return F.isUndefined(L) || (delete this.props[Ft][f], this.save()), L
						};
						var ln, yn, En = function(f) {
								return f
							},
							Me = function() {},
							Ie = "mixpanel",
							Tt = "$device:",
							Xt = E.XMLHttpRequest && "withCredentials" in new XMLHttpRequest,
							Tn = !Xt && -1 === ie.indexOf("MSIE") && -1 === ie.indexOf("Mozilla"),
							Zn = null;
						G.sendBeacon && (Zn = function() {
							return G.sendBeacon.apply(G, arguments)
						});
						var pr = {
								api_host: "https://api-js.mixpanel.com",
								api_method: "POST",
								api_transport: "XHR",
								api_payload_format: "base64",
								app_host: "https://mixpanel.com",
								cdn: "https://cdn.mxpnl.com",
								cross_site_cookie: !1,
								cross_subdomain_cookie: !0,
								error_reporter: Me,
								persistence: "cookie",
								persistence_name: "",
								cookie_domain: "",
								cookie_name: "",
								loaded: Me,
								track_marketing: !0,
								track_pageview: !1,
								skip_first_touch_marketing: !1,
								store_google: !0,
								save_referrer: !0,
								test: !1,
								verbose: !1,
								img: !1,
								debug: !1,
								track_links_timeout: 300,
								cookie_expiration: 365,
								upgrade: !1,
								disable_persistence: !1,
								disable_cookie: !1,
								secure_cookie: !1,
								ip: !0,
								opt_out_tracking_by_default: !1,
								opt_out_persistence_by_default: !1,
								opt_out_tracking_persistence_type: "localStorage",
								opt_out_tracking_cookie_prefix: null,
								property_blacklist: [],
								xhr_headers: {},
								ignore_dnt: !1,
								batch_requests: !0,
								batch_size: 50,
								batch_flush_interval_ms: 5e3,
								batch_request_timeout_ms: 9e4,
								batch_autostart: !0,
								hooks: {}
							},
							Pr = !1,
							vt = function() {},
							ei = function(f, T, L) {
								var K, he = L === Ie ? yn : yn[L];
								if (he && 0 === ln) K = he;
								else {
									if (he && !F.isArray(he)) return void xe.error("You have already initialized " + L);
									K = new vt
								}
								if (K._cached_groups = {}, K._init(f, T, L), K.people = new kt, K.people._init(K), !K.get_config("skip_first_touch_marketing")) {
									var ye = F.info.campaignParams(null),
										He = {},
										gt = !1;
									F.each(ye, function(st, mt) {
										He["initial_" + mt] = st, st && (gt = !0)
									}), gt && K.people.set_once(He)
								}
								return ue.DEBUG = ue.DEBUG || K.get_config("debug"), !F.isUndefined(he) && F.isArray(he) && (K._execute_array.call(K.people, he.people), K._execute_array(he)), K
							};
						vt.prototype.init = function(f, T, L) {
							if (F.isUndefined(L)) this.report_error("You must name your new library: init(token, config, name)");
							else {
								if (L !== Ie) {
									var K = ei(f, T, L);
									return yn[L] = K, K._loaded(), K
								}
								this.report_error("You must initialize the main mixpanel object right after you include the Mixpanel js snippet")
							}
						}, vt.prototype._init = function(f, T, L) {
							T = T || {}, this.__loaded = !0, this.config = {};
							var K = {};
							if ("api_payload_format" in T || (T.api_host || pr.api_host).match(/\.mixpanel\.com/) && (K.api_payload_format = "json"), this.set_config(F.extend({}, pr, K, T, {
									name: L,
									token: f,
									callback_fn: (L === Ie ? L : Ie + "." + L) + "._jsc"
								})), this._jsc = Me, this.__dom_loaded_queue = [], this.__request_queue = [], this.__disabled_events = [], this._flags = {
									disable_all_events: !1,
									identify_called: !1
								}, this.request_batchers = {}, this._batch_requests = this.get_config("batch_requests"), this._batch_requests)
								if (F.localStorage.is_supported(!0) && Xt) {
									if (this.init_batchers(), Zn && E.addEventListener) {
										var ye = F.bind(function() {
											this.request_batchers.events.stopped || this.request_batchers.events.flush({
												unloading: !0
											})
										}, this);
										E.addEventListener("pagehide", function(gt) {
											gt.persisted && ye()
										}), E.addEventListener("visibilitychange", function() {
											"hidden" === Q.visibilityState && ye()
										})
									}
								} else this._batch_requests = !1, xe.log("Turning off Mixpanel request-queueing; needs XHR and localStorage support");
							this.persistence = this.cookie = new xt(this.config), this.unpersisted_superprops = {}, this._gdpr_init();
							var He = F.UUID();
							this.get_distinct_id() || this.register_once({
								distinct_id: Tt + He,
								$device_id: He
							}, ""), this.get_config("track_pageview") && this.track_pageview()
						}, vt.prototype._loaded = function() {
							this.get_config("loaded")(this), this._set_default_superprops()
						}, vt.prototype._set_default_superprops = function() {
							this.persistence.update_search_keyword(Q.referrer), this.get_config("store_google") && this.register(F.info.campaignParams(), {
								persistent: !1
							}), this.get_config("save_referrer") && this.persistence.update_referrer_info(Q.referrer)
						}, vt.prototype._dom_loaded = function() {
							F.each(this.__dom_loaded_queue, function(f) {
								this._track_dom.apply(this, f)
							}, this), this.has_opted_out_tracking() || F.each(this.__request_queue, function(f) {
								this._send_request.apply(this, f)
							}, this), delete this.__dom_loaded_queue, delete this.__request_queue
						}, vt.prototype._track_dom = function(f, T) {
							if (this.get_config("img")) return this.report_error("You can't use DOM tracking functions with img = true."), !1;
							if (!Pr) return this.__dom_loaded_queue.push([f, T]), !1;
							var L = (new f).init(this);
							return L.track.apply(L, T)
						}, vt.prototype._prepare_callback = function(f, T) {
							if (F.isUndefined(f)) return null;
							if (Xt) return function(He) {
								f(He, T)
							};
							var K = this._jsc,
								he = "" + Math.floor(1e8 * Math.random()),
								ye = this.get_config("callback_fn") + "[" + he + "]";
							return K[he] = function(He) {
								delete K[he], f(He, T)
							}, ye
						}, vt.prototype._send_request = function(f, T, L, K) {
							var he = !0;
							if (Tn) return this.__request_queue.push(arguments), he;
							var ye = {
									method: this.get_config("api_method"),
									transport: this.get_config("api_transport"),
									verbose: this.get_config("verbose")
								},
								He = null;
							!K && (F.isFunction(L) || "string" == typeof L) && (K = L, L = null), L = F.extend(ye, L || {}), Xt || (L.method = "GET");
							var gt = "POST" === L.method,
								st = Zn && gt && "sendbeacon" === L.transport.toLowerCase(),
								mt = L.verbose;
							T.verbose && (mt = !0), this.get_config("test") && (T.test = 1), mt && (T.verbose = 1), this.get_config("img") && (T.img = 1), Xt || (K ? T.callback = K : (mt || this.get_config("test")) && (T.callback = "(function(){})")), T.ip = this.get_config("ip") ? 1 : 0, T._ = (new Date).getTime().toString(), gt && (He = "data=" + encodeURIComponent(T.data), delete T.data), f += "?" + F.HTTPBuildQuery(T);
							var Et = this;
							if ("img" in T) {
								var Gt = Q.createElement("img");
								Gt.src = f, Q.body.appendChild(Gt)
							} else if (st) {
								try {
									he = Zn(f, He)
								} catch (Jn) {
									Et.report_error(Jn), he = !1
								}
								try {
									K && K(he ? 1 : 0)
								} catch (Jn) {
									Et.report_error(Jn)
								}
							} else if (Xt) try {
								var Rt = new XMLHttpRequest;
								Rt.open(L.method, f, !0);
								var Ot = this.get_config("xhr_headers");
								if (gt && (Ot["Content-Type"] = "application/x-www-form-urlencoded"), F.each(Ot, function(Jn, xn) {
										Rt.setRequestHeader(xn, Jn)
									}), L.timeout_ms && typeof Rt.timeout < "u") {
									Rt.timeout = L.timeout_ms;
									var Jt = (new Date).getTime()
								}
								Rt.withCredentials = !0, Rt.onreadystatechange = function() {
									if (4 === Rt.readyState)
										if (200 === Rt.status) {
											if (K)
												if (mt) {
													var Jn;
													try {
														Jn = F.JSONDecode(Rt.responseText)
													} catch (Br) {
														if (Et.report_error(Br), !L.ignore_json_errors) return;
														Jn = Rt.responseText
													}
													K(Jn)
												} else K(Number(Rt.responseText))
										} else {
											var xn;
											xn = Rt.timeout && !Rt.status && (new Date).getTime() - Jt >= Rt.timeout ? "timeout" : "Bad HTTP status: " + Rt.status + " " + Rt.statusText, Et.report_error(xn), K && K(mt ? {
												status: 0,
												error: xn,
												xhr_req: Rt
											} : 0)
										}
								}, Rt.send(He)
							} catch (Jn) {
								Et.report_error(Jn), he = !1
							} else {
								var Mn = Q.createElement("script");
								Mn.type = "text/javascript", Mn.async = !0, Mn.defer = !0, Mn.src = f;
								var Cn = Q.getElementsByTagName("script")[0];
								Cn.parentNode.insertBefore(Mn, Cn)
							}
							return he
						}, vt.prototype._execute_array = function(f) {
							var T, L = [],
								K = [],
								he = [];
							F.each(f, function(He) {
								He && (F.isArray(T = He[0]) ? he.push(He) : "function" == typeof He ? He.call(this) : F.isArray(He) && "alias" === T ? L.push(He) : F.isArray(He) && -1 !== T.indexOf("track") && "function" == typeof this[T] ? he.push(He) : K.push(He))
							}, this);
							var ye = function(He, gt) {
								F.each(He, function(st) {
									if (F.isArray(st[0])) {
										var mt = gt;
										F.each(st, function(Et) {
											mt = mt[Et[0]].apply(mt, Et.slice(1))
										})
									} else this[st[0]].apply(this, st.slice(1))
								}, gt)
							};
							ye(L, this), ye(K, this), ye(he, this)
						}, vt.prototype.are_batchers_initialized = function() {
							return !!this.request_batchers.events
						}, vt.prototype.init_batchers = function() {
							var f = this.get_config("token");
							if (!this.are_batchers_initialized()) {
								var T = F.bind(function(L) {
									return new mn("__mpq_" + f + L.queue_suffix, {
										libConfig: this.config,
										sendRequestFunc: F.bind(function(K, he, ye) {
											this._send_request(this.get_config("api_host") + L.endpoint, this._encode_data_for_request(K), he, this._prepare_callback(ye, K))
										}, this),
										beforeSendHook: F.bind(function(K) {
											return this._run_hook("before_send_" + L.type, K)
										}, this),
										errorReporter: this.get_config("error_reporter"),
										stopAllBatchingFunc: F.bind(this.stop_batch_senders, this)
									})
								}, this);
								this.request_batchers = {
									events: T({
										type: "events",
										endpoint: "/track/",
										queue_suffix: "_ev"
									}),
									people: T({
										type: "people",
										endpoint: "/engage/",
										queue_suffix: "_pp"
									}),
									groups: T({
										type: "groups",
										endpoint: "/groups/",
										queue_suffix: "_gr"
									})
								}
							}
							this.get_config("batch_autostart") && this.start_batch_senders()
						}, vt.prototype.start_batch_senders = function() {
							this.are_batchers_initialized() && (this._batch_requests = !0, F.each(this.request_batchers, function(f) {
								f.start()
							}))
						}, vt.prototype.stop_batch_senders = function() {
							this._batch_requests = !1, F.each(this.request_batchers, function(f) {
								f.stop(), f.clear()
							})
						}, vt.prototype.push = function(f) {
							this._execute_array([f])
						}, vt.prototype.disable = function(f) {
							typeof f > "u" ? this._flags.disable_all_events = !0 : this.__disabled_events = this.__disabled_events.concat(f)
						}, vt.prototype._encode_data_for_request = function(f) {
							var T = F.JSONEncode(f);
							return "base64" === this.get_config("api_payload_format") && (T = F.base64Encode(T)), {
								data: T
							}
						}, vt.prototype._track_or_batch = function(f, T) {
							var L = F.truncate(f.data, 255),
								K = f.endpoint,
								he = f.batcher,
								ye = f.should_send_immediately,
								He = f.send_request_options || {};
							T = T || Me;
							var gt = !0,
								st = F.bind(function() {
									return He.skip_hooks || (L = this._run_hook("before_send_" + f.type, L)), L ? (xe.log("MIXPANEL REQUEST:"), xe.log(L), this._send_request(K, this._encode_data_for_request(L), He, this._prepare_callback(T, L))) : null
								}, this);
							return this._batch_requests && !ye ? he.enqueue(L, function(mt) {
								mt ? T(1, L) : st()
							}) : gt = st(), gt && L
						}, vt.prototype.track = Bn(function(f, T, L, K) {
							!K && "function" == typeof L && (K = L, L = null);
							var he = (L = L || {}).transport;
							he && (L.transport = he);
							var ye = L.send_immediately;
							if ("function" != typeof K && (K = Me), F.isUndefined(f)) this.report_error("No event name provided to mixpanel.track");
							else {
								if (!this._event_is_disabled(f)) {
									(T = T || {}).token = this.get_config("token");
									var He = this.persistence.remove_event_timer(f);
									if (!F.isUndefined(He)) {
										var gt = (new Date).getTime() - He;
										T.$duration = parseFloat((gt / 1e3).toFixed(3))
									}
									this._set_default_superprops();
									var st = this.get_config("track_marketing") ? F.info.marketingParams() : {};
									T = F.extend({}, F.info.properties(), st, this.persistence.properties(), this.unpersisted_superprops, T);
									var mt = this.get_config("property_blacklist");
									return F.isArray(mt) ? F.each(mt, function(Rt) {
										delete T[Rt]
									}) : this.report_error("Invalid value for property_blacklist config: " + mt), this._track_or_batch({
										type: "events",
										data: {
											event: f,
											properties: T
										},
										endpoint: this.get_config("api_host") + "/track/",
										batcher: this.request_batchers.events,
										should_send_immediately: ye,
										send_request_options: L
									}, K)
								}
								K(0)
							}
						}), vt.prototype.set_group = Bn(function(f, T, L) {
							F.isArray(T) || (T = [T]);
							var K = {};
							return K[f] = T, this.register(K), this.people.set(f, T, L)
						}), vt.prototype.add_group = Bn(function(f, T, L) {
							var K = this.get_property(f);
							if (void 0 === K) {
								var he = {};
								he[f] = [T], this.register(he)
							} else - 1 === K.indexOf(T) && (K.push(T), this.register(he));
							return this.people.union(f, T, L)
						}), vt.prototype.remove_group = Bn(function(f, T, L) {
							var K = this.get_property(f);
							if (void 0 !== K) {
								var he = K.indexOf(T);
								he > -1 && (K.splice(he, 1), this.register({
									group_key: K
								})), 0 === K.length && this.unregister(f)
							}
							return this.people.remove(f, T, L)
						}), vt.prototype.track_with_groups = Bn(function(f, T, L, K) {
							var he = F.extend({}, T || {});
							return F.each(L, function(ye, He) {
								null != ye && (he[He] = ye)
							}), this.track(f, he, K)
						}), vt.prototype._create_map_key = function(f, T) {
							return f + "_" + JSON.stringify(T)
						}, vt.prototype._remove_group_from_cache = function(f, T) {
							delete this._cached_groups[this._create_map_key(f, T)]
						}, vt.prototype.get_group = function(f, T) {
							var L = this._create_map_key(f, T),
								K = this._cached_groups[L];
							return (void 0 === K || K._group_key !== f || K._group_id !== T) && ((K = new hn)._init(this, f, T), this._cached_groups[L] = K), K
						}, vt.prototype.track_pageview = Bn(function(f, T) {
							"object" != typeof f && (f = {});
							var L = (T = T || {}).event_name || "$mp_web_page_view",
								K = F.extend(F.info.mpPageViewProperties(), F.info.campaignParams(), F.info.clickParams()),
								he = F.extend({}, K, f);
							return this.track(L, he)
						}), vt.prototype.track_links = function() {
							return this._track_dom.call(this, ht, arguments)
						}, vt.prototype.track_forms = function() {
							return this._track_dom.call(this, Pe, arguments)
						}, vt.prototype.time_event = function(f) {
							F.isUndefined(f) ? this.report_error("No event name provided to mixpanel.time_event") : this._event_is_disabled(f) || this.persistence.set_event_timer(f, (new Date).getTime())
						};
						var ti = {
								persistent: !0
							},
							Sr = function(f) {
								var T;
								return T = F.isObject(f) ? f : F.isUndefined(f) ? {} : {
									days: f
								}, F.extend({}, ti, T)
							};
						vt.prototype.register = function(f, T) {
							var L = Sr(T);
							L.persistent ? this.persistence.register(f, L.days) : F.extend(this.unpersisted_superprops, f)
						}, vt.prototype.register_once = function(f, T, L) {
							var K = Sr(L);
							K.persistent ? this.persistence.register_once(f, T, K.days) : (typeof T > "u" && (T = "None"), F.each(f, function(he, ye) {
								(!this.unpersisted_superprops.hasOwnProperty(ye) || this.unpersisted_superprops[ye] === T) && (this.unpersisted_superprops[ye] = he)
							}, this))
						}, vt.prototype.unregister = function(f, T) {
							(T = Sr(T)).persistent ? this.persistence.unregister(f) : delete this.unpersisted_superprops[f]
						}, vt.prototype._register_single = function(f, T) {
							var L = {};
							L[f] = T, this.register(L)
						}, vt.prototype.identify = function(f, T, L, K, he, ye, He, gt) {
							var st = this.get_distinct_id();
							if (f && st !== f) {
								if ("string" == typeof f && 0 === f.indexOf(Tt)) return this.report_error("distinct_id cannot have $device: prefix"), -1;
								this.register({
									$user_id: f
								})
							}
							this.get_property("$device_id") || this.register_once({
								$had_persisted_distinct_id: !0,
								$device_id: st
							}, ""), f !== st && f !== this.get_property(Ye) && (this.unregister(Ye), this.register({
								distinct_id: f
							})), this._flags.identify_called = !0, this.people._flush(T, L, K, he, ye, He, gt), f !== st && this.track("$identify", {
								distinct_id: f,
								$anon_distinct_id: st
							}, {
								skip_hooks: !0
							})
						}, vt.prototype.reset = function() {
							this.persistence.clear(), this._flags.identify_called = !1;
							var f = F.UUID();
							this.register_once({
								distinct_id: Tt + f,
								$device_id: f
							}, "")
						}, vt.prototype.get_distinct_id = function() {
							return this.get_property("distinct_id")
						}, vt.prototype.alias = function(f, T) {
							if (f === this.get_property(Ne)) return this.report_error("Attempting to create alias for existing People user - aborting."), -2;
							var L = this;
							return F.isUndefined(T) && (T = this.get_distinct_id()), f !== T ? (this._register_single(Ye, f), this.track("$create_alias", {
								alias: f,
								distinct_id: T
							}, {
								skip_hooks: !0
							}, function() {
								L.identify(f)
							})) : (this.report_error("alias matches current distinct_id - skipping api call."), this.identify(f), -1)
						}, vt.prototype.name_tag = function(f) {
							this._register_single("mp_name_tag", f)
						}, vt.prototype.set_config = function(f) {
							F.isObject(f) && (F.extend(this.config, f), f.batch_size && F.each(this.request_batchers, function(L) {
								L.resetBatchSize()
							}), this.get_config("persistence_name") || (this.config.persistence_name = this.config.cookie_name), this.get_config("disable_persistence") || (this.config.disable_persistence = this.config.disable_cookie), this.persistence && this.persistence.update_config(this.config), ue.DEBUG = ue.DEBUG || this.get_config("debug"))
						}, vt.prototype.get_config = function(f) {
							return this.config[f]
						}, vt.prototype._run_hook = function(f) {
							var T = (this.config.hooks[f] || En).apply(this, ee.call(arguments, 1));
							return typeof T > "u" && (this.report_error(f + " hook did not return a value"), T = null), T
						}, vt.prototype.get_property = function(f) {
							return this.persistence.props[f]
						}, vt.prototype.toString = function() {
							var f = this.get_config("name");
							return f !== Ie && (f = Ie + "." + f), f
						}, vt.prototype._event_is_disabled = function(f) {
							return F.isBlockedUA(ie) || this._flags.disable_all_events || F.include(this.__disabled_events, f)
						}, vt.prototype._gdpr_init = function() {
							"localStorage" === this.get_config("opt_out_tracking_persistence_type") && F.localStorage.is_supported() && (!this.has_opted_in_tracking() && this.has_opted_in_tracking({
								persistence_type: "cookie"
							}) && this.opt_in_tracking({
								enable_persistence: !1
							}), !this.has_opted_out_tracking() && this.has_opted_out_tracking({
								persistence_type: "cookie"
							}) && this.opt_out_tracking({
								clear_persistence: !1
							}), this.clear_opt_in_out_tracking({
								persistence_type: "cookie",
								enable_persistence: !1
							})), this.has_opted_out_tracking() ? this._gdpr_update_persistence({
								clear_persistence: !0
							}) : !this.has_opted_in_tracking() && (this.get_config("opt_out_tracking_by_default") || F.cookie.get("mp_optout")) && (F.cookie.remove("mp_optout"), this.opt_out_tracking({
								clear_persistence: this.get_config("opt_out_persistence_by_default")
							}))
						}, vt.prototype._gdpr_update_persistence = function(f) {
							var T;
							if (f && f.clear_persistence) T = !0;
							else {
								if (!f || !f.enable_persistence) return;
								T = !1
							}!this.get_config("disable_persistence") && this.persistence.disabled !== T && this.persistence.set_disabled(T), T && F.each(this.request_batchers, function(L) {
								L.clear()
							})
						}, vt.prototype._gdpr_call_func = function(f, T) {
							return T = F.extend({
								track: F.bind(this.track, this),
								persistence_type: this.get_config("opt_out_tracking_persistence_type"),
								cookie_prefix: this.get_config("opt_out_tracking_cookie_prefix"),
								cookie_expiration: this.get_config("cookie_expiration"),
								cross_site_cookie: this.get_config("cross_site_cookie"),
								cross_subdomain_cookie: this.get_config("cross_subdomain_cookie"),
								cookie_domain: this.get_config("cookie_domain"),
								secure_cookie: this.get_config("secure_cookie"),
								ignore_dnt: this.get_config("ignore_dnt")
							}, T), F.localStorage.is_supported() || (T.persistence_type = "cookie"), f(this.get_config("token"), {
								track: T.track,
								trackEventName: T.track_event_name,
								trackProperties: T.track_properties,
								persistenceType: T.persistence_type,
								persistencePrefix: T.cookie_prefix,
								cookieDomain: T.cookie_domain,
								cookieExpiration: T.cookie_expiration,
								crossSiteCookie: T.cross_site_cookie,
								crossSubdomainCookie: T.cross_subdomain_cookie,
								secureCookie: T.secure_cookie,
								ignoreDnt: T.ignore_dnt
							})
						}, vt.prototype.opt_in_tracking = function(f) {
							f = F.extend({
								enable_persistence: !0
							}, f), this._gdpr_call_func(Kn, f), this._gdpr_update_persistence(f)
						}, vt.prototype.opt_out_tracking = function(f) {
							(f = F.extend({
								clear_persistence: !0,
								delete_user: !0
							}, f)).delete_user && this.people && this.people._identify_called() && (this.people.delete_user(), this.people.clear_charges()), this._gdpr_call_func(Vn, f), this._gdpr_update_persistence(f)
						}, vt.prototype.has_opted_in_tracking = function(f) {
							return this._gdpr_call_func(Zt, f)
						}, vt.prototype.has_opted_out_tracking = function(f) {
							return this._gdpr_call_func(bn, f)
						}, vt.prototype.clear_opt_in_out_tracking = function(f) {
							f = F.extend({
								enable_persistence: !0
							}, f), this._gdpr_call_func(en, f), this._gdpr_update_persistence(f)
						}, vt.prototype.report_error = function(f, T) {
							xe.error.apply(xe.error, arguments);
							try {
								!T && !(f instanceof Error) && (f = new Error(f)), this.get_config("error_reporter")(f, T)
							} catch (L) {
								xe.error(L)
							}
						}, vt.prototype.init = vt.prototype.init, vt.prototype.reset = vt.prototype.reset, vt.prototype.disable = vt.prototype.disable, vt.prototype.time_event = vt.prototype.time_event, vt.prototype.track = vt.prototype.track, vt.prototype.track_links = vt.prototype.track_links, vt.prototype.track_forms = vt.prototype.track_forms, vt.prototype.track_pageview = vt.prototype.track_pageview, vt.prototype.register = vt.prototype.register, vt.prototype.register_once = vt.prototype.register_once, vt.prototype.unregister = vt.prototype.unregister, vt.prototype.identify = vt.prototype.identify, vt.prototype.alias = vt.prototype.alias, vt.prototype.name_tag = vt.prototype.name_tag, vt.prototype.set_config = vt.prototype.set_config, vt.prototype.get_config = vt.prototype.get_config, vt.prototype.get_property = vt.prototype.get_property, vt.prototype.get_distinct_id = vt.prototype.get_distinct_id, vt.prototype.toString = vt.prototype.toString, vt.prototype.opt_out_tracking = vt.prototype.opt_out_tracking, vt.prototype.opt_in_tracking = vt.prototype.opt_in_tracking, vt.prototype.has_opted_out_tracking = vt.prototype.has_opted_out_tracking, vt.prototype.has_opted_in_tracking = vt.prototype.has_opted_in_tracking, vt.prototype.clear_opt_in_out_tracking = vt.prototype.clear_opt_in_out_tracking, vt.prototype.get_group = vt.prototype.get_group, vt.prototype.set_group = vt.prototype.set_group, vt.prototype.add_group = vt.prototype.add_group, vt.prototype.remove_group = vt.prototype.remove_group, vt.prototype.track_with_groups = vt.prototype.track_with_groups, vt.prototype.start_batch_senders = vt.prototype.start_batch_senders, vt.prototype.stop_batch_senders = vt.prototype.stop_batch_senders, xt.prototype.properties = xt.prototype.properties, xt.prototype.update_search_keyword = xt.prototype.update_search_keyword, xt.prototype.update_referrer_info = xt.prototype.update_referrer_info, xt.prototype.get_cross_subdomain = xt.prototype.get_cross_subdomain, xt.prototype.clear = xt.prototype.clear;
						var $r = {},
							fe = function U() {
								return ln = 0, (yn = new vt).init = function(f, T, L) {
										if (L) return yn[L] || (yn[L] = $r[L] = ei(f, T, L), yn[L]._loaded()), yn[L];
										var K = yn;
										$r[Ie] ? K = $r[Ie] : f && ((K = ei(f, T, Ie))._loaded(), $r[Ie] = K), yn = K, 1 === ln && (E[Ie] = yn), F.each($r, function(f, T) {
											T !== Ie && (yn[T] = f)
										}), yn._ = F
									}, yn.init(),
									function() {
										function f() {
											f.done || (f.done = !0, Pr = !0, Tn = !1, F.each($r, function(K) {
												K._dom_loaded()
											}))
										}
										if (Q.addEventListener) "complete" === Q.readyState ? f() : Q.addEventListener("DOMContentLoaded", f, !1);
										else if (Q.attachEvent) {
											Q.attachEvent("onreadystatechange", f);
											var L = !1;
											try {
												L = null === E.frameElement
											} catch {}
											Q.documentElement.doScroll && L && function T() {
												try {
													Q.documentElement.doScroll("left")
												} catch {
													return void setTimeout(T, 1)
												}
												f()
											}()
										}
										F.register_event(E, "load", f, !0)
									}(), yn
							}();
						be.exports = fe
					}, 3216: (be, ue, E) => {
						E.d(ue, {
							X: () => y
						});
						var p = E(8264);
						class y extends p.x {
							constructor(z) {
								super(), this._value = z
							}
							get value() {
								return this.getValue()
							}
							_subscribe(z) {
								const ee = super._subscribe(z);
								return !ee.closed && z.next(this._value), ee
							}
							getValue() {
								const {
									hasError: z,
									thrownError: ee,
									_value: P
								} = this;
								if (z) throw ee;
								return this._throwIfClosed(), P
							}
							next(z) {
								super.next(this._value = z)
							}
						}
					}, 4070: (be, ue, E) => {
						E.d(ue, {
							y: () => Y
						});
						var p = E(5324),
							y = E(2292),
							D = E(8268),
							z = E(602),
							ee = E(3243),
							P = E(7479),
							N = E(9848);
						let Y = (() => {
							class te {
								constructor(oe) {
									oe && (this._subscribe = oe)
								}
								lift(oe) {
									const we = new te;
									return we.source = this, we.operator = oe, we
								}
								subscribe(oe, we, Fe) {
									const Le = function X(te) {
										return te && te instanceof p.Lv || function Q(te) {
											return te && (0, P.m)(te.next) && (0, P.m)(te.error) && (0, P.m)(te.complete)
										}(te) && (0, y.Nn)(te)
									}(oe) ? oe : new p.Hp(oe, we, Fe);
									return (0, N.x)(() => {
										const {
											operator: je,
											source: Ce
										} = this;
										Le.add(je ? je.call(Le, Ce) : Ce ? this._subscribe(Le) : this._trySubscribe(Le))
									}), Le
								}
								_trySubscribe(oe) {
									try {
										return this._subscribe(oe)
									} catch (we) {
										oe.error(we)
									}
								}
								forEach(oe, we) {
									return new(we = G(we))((Fe, Le) => {
										const je = new p.Hp({
											next: Ce => {
												try {
													oe(Ce)
												} catch (F) {
													Le(F), je.unsubscribe()
												}
											},
											error: Le,
											complete: Fe
										});
										this.subscribe(je)
									})
								}
								_subscribe(oe) {
									var we;
									return null === (we = this.source) || void 0 === we ? void 0 : we.subscribe(oe)
								} [D.L]() {
									return this
								}
								pipe(...oe) {
									return (0, z.U)(oe)(this)
								}
								toPromise(oe) {
									return new(oe = G(oe))((we, Fe) => {
										let Le;
										this.subscribe(je => Le = je, je => Fe(je), () => we(Le))
									})
								}
							}
							return te.create = ie => new te(ie), te
						})();

						function G(te) {
							var ie;
							return null !== (ie = te ?? ee.v.Promise) && void 0 !== ie ? ie : Promise
						}
					}, 1970: (be, ue, E) => {
						E.d(ue, {
							t: () => D
						});
						var p = E(8264),
							y = E(3450);
						class D extends p.x {
							constructor(ee = 1 / 0, P = 1 / 0, N = y.l) {
								super(), this._bufferSize = ee, this._windowTime = P, this._timestampProvider = N, this._buffer = [], this._infiniteTimeWindow = !0, this._infiniteTimeWindow = P === 1 / 0, this._bufferSize = Math.max(1, ee), this._windowTime = Math.max(1, P)
							}
							next(ee) {
								const {
									isStopped: P,
									_buffer: N,
									_infiniteTimeWindow: Y,
									_timestampProvider: G,
									_windowTime: Q
								} = this;
								P || (N.push(ee), !Y && N.push(G.now() + Q)), this._trimBuffer(), super.next(ee)
							}
							_subscribe(ee) {
								this._throwIfClosed(), this._trimBuffer();
								const P = this._innerSubscribe(ee),
									{
										_infiniteTimeWindow: N,
										_buffer: Y
									} = this,
									G = Y.slice();
								for (let Q = 0; Q < G.length && !ee.closed; Q += N ? 1 : 2) ee.next(G[Q]);
								return this._checkFinalizedStatuses(ee), P
							}
							_trimBuffer() {
								const {
									_bufferSize: ee,
									_timestampProvider: P,
									_buffer: N,
									_infiniteTimeWindow: Y
								} = this, G = (Y ? 1 : 2) * ee;
								if (ee < 1 / 0 && G < N.length && N.splice(0, N.length - G), !Y) {
									const Q = P.now();
									let X = 0;
									for (let te = 1; te < N.length && N[te] <= Q; te += 2) X = te;
									X && N.splice(0, X + 1)
								}
							}
						}
					}, 8264: (be, ue, E) => {
						E.d(ue, {
							x: () => N
						});
						var p = E(4070),
							y = E(2292);
						const z = (0, E(3922).d)(G => function() {
							G(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed"
						});
						var ee = E(5848),
							P = E(9848);
						let N = (() => {
							class G extends p.y {
								constructor() {
									super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null
								}
								lift(X) {
									const te = new Y(this, this);
									return te.operator = X, te
								}
								_throwIfClosed() {
									if (this.closed) throw new z
								}
								next(X) {
									(0, P.x)(() => {
										if (this._throwIfClosed(), !this.isStopped) {
											this.currentObservers || (this.currentObservers = Array.from(this.observers));
											for (const te of this.currentObservers) te.next(X)
										}
									})
								}
								error(X) {
									(0, P.x)(() => {
										if (this._throwIfClosed(), !this.isStopped) {
											this.hasError = this.isStopped = !0, this.thrownError = X;
											const {
												observers: te
											} = this;
											for (; te.length;) te.shift().error(X)
										}
									})
								}
								complete() {
									(0, P.x)(() => {
										if (this._throwIfClosed(), !this.isStopped) {
											this.isStopped = !0;
											const {
												observers: X
											} = this;
											for (; X.length;) X.shift().complete()
										}
									})
								}
								unsubscribe() {
									this.isStopped = this.closed = !0, this.observers = this.currentObservers = null
								}
								get observed() {
									var X;
									return (null === (X = this.observers) || void 0 === X ? void 0 : X.length) > 0
								}
								_trySubscribe(X) {
									return this._throwIfClosed(), super._trySubscribe(X)
								}
								_subscribe(X) {
									return this._throwIfClosed(), this._checkFinalizedStatuses(X), this._innerSubscribe(X)
								}
								_innerSubscribe(X) {
									const {
										hasError: te,
										isStopped: ie,
										observers: oe
									} = this;
									return te || ie ? y.Lc : (this.currentObservers = null, oe.push(X), new y.w0(() => {
										this.currentObservers = null, (0, ee.P)(oe, X)
									}))
								}
								_checkFinalizedStatuses(X) {
									const {
										hasError: te,
										thrownError: ie,
										isStopped: oe
									} = this;
									te ? X.error(ie) : oe && X.complete()
								}
								asObservable() {
									const X = new p.y;
									return X.source = this, X
								}
							}
							return G.create = (Q, X) => new Y(Q, X), G
						})();
						class Y extends N {
							constructor(Q, X) {
								super(), this.destination = Q, this.source = X
							}
							next(Q) {
								var X, te;
								null === (te = null === (X = this.destination) || void 0 === X ? void 0 : X.next) || void 0 === te || te.call(X, Q)
							}
							error(Q) {
								var X, te;
								null === (te = null === (X = this.destination) || void 0 === X ? void 0 : X.error) || void 0 === te || te.call(X, Q)
							}
							complete() {
								var Q, X;
								null === (X = null === (Q = this.destination) || void 0 === Q ? void 0 : Q.complete) || void 0 === X || X.call(Q)
							}
							_subscribe(Q) {
								var X, te;
								return null !== (te = null === (X = this.source) || void 0 === X ? void 0 : X.subscribe(Q)) && void 0 !== te ? te : y.Lc
							}
						}
					}, 5324: (be, ue, E) => {
						E.d(ue, {
							Hp: () => Fe,
							Lv: () => te
						});
						var p = E(7479),
							y = E(2292),
							D = E(3243),
							z = E(3367),
							ee = E(222);
						const P = G("C", void 0, void 0);

						function G(xe, Ee, Ue) {
							return {
								kind: xe,
								value: Ee,
								error: Ue
							}
						}
						var Q = E(2631),
							X = E(9848);
						class te extends y.w0 {
							constructor(Ee) {
								super(), this.isStopped = !1, Ee ? (this.destination = Ee, (0, y.Nn)(Ee) && Ee.add(this)) : this.destination = F
							}
							static create(Ee, Ue, ke) {
								return new Fe(Ee, Ue, ke)
							}
							next(Ee) {
								this.isStopped ? Ce(function Y(xe) {
									return G("N", xe, void 0)
								}(Ee), this) : this._next(Ee)
							}
							error(Ee) {
								this.isStopped ? Ce(function N(xe) {
									return G("E", void 0, xe)
								}(Ee), this) : (this.isStopped = !0, this._error(Ee))
							}
							complete() {
								this.isStopped ? Ce(P, this) : (this.isStopped = !0, this._complete())
							}
							unsubscribe() {
								this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null)
							}
							_next(Ee) {
								this.destination.next(Ee)
							}
							_error(Ee) {
								try {
									this.destination.error(Ee)
								} finally {
									this.unsubscribe()
								}
							}
							_complete() {
								try {
									this.destination.complete()
								} finally {
									this.unsubscribe()
								}
							}
						}
						const ie = Function.prototype.bind;

						function oe(xe, Ee) {
							return ie.call(xe, Ee)
						}
						class we {
							constructor(Ee) {
								this.partialObserver = Ee
							}
							next(Ee) {
								const {
									partialObserver: Ue
								} = this;
								if (Ue.next) try {
									Ue.next(Ee)
								} catch (ke) {
									Le(ke)
								}
							}
							error(Ee) {
								const {
									partialObserver: Ue
								} = this;
								if (Ue.error) try {
									Ue.error(Ee)
								} catch (ke) {
									Le(ke)
								} else Le(Ee)
							}
							complete() {
								const {
									partialObserver: Ee
								} = this;
								if (Ee.complete) try {
									Ee.complete()
								} catch (Ue) {
									Le(Ue)
								}
							}
						}
						class Fe extends te {
							constructor(Ee, Ue, ke) {
								let Ge;
								if (super(), (0, p.m)(Ee) || !Ee) Ge = {
									next: Ee ?? void 0,
									error: Ue ?? void 0,
									complete: ke ?? void 0
								};
								else {
									let ft;
									this && D.v.useDeprecatedNextContext ? (ft = Object.create(Ee), ft.unsubscribe = () => this.unsubscribe(), Ge = {
										next: Ee.next && oe(Ee.next, ft),
										error: Ee.error && oe(Ee.error, ft),
										complete: Ee.complete && oe(Ee.complete, ft)
									}) : Ge = Ee
								}
								this.destination = new we(Ge)
							}
						}

						function Le(xe) {
							D.v.useDeprecatedSynchronousErrorHandling ? (0, X.O)(xe) : (0, z.h)(xe)
						}

						function Ce(xe, Ee) {
							const {
								onStoppedNotification: Ue
							} = D.v;
							Ue && Q.z.setTimeout(() => Ue(xe, Ee))
						}
						const F = {
							closed: !0,
							next: ee.Z,
							error: function je(xe) {
								throw xe
							},
							complete: ee.Z
						}
					}, 2292: (be, ue, E) => {
						E.d(ue, {
							Lc: () => P,
							w0: () => ee,
							Nn: () => N
						});
						var p = E(7479);
						const D = (0, E(3922).d)(G => function(X) {
							G(this), this.message = X ? `${X.length} errors occurred during unsubscription:\n${X.map((te,ie)=>`${ie+1}) ${te.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = X
						});
						var z = E(5848);
						class ee {
							constructor(Q) {
								this.initialTeardown = Q, this.closed = !1, this._parentage = null, this._finalizers = null
							}
							unsubscribe() {
								let Q;
								if (!this.closed) {
									this.closed = !0;
									const {
										_parentage: X
									} = this;
									if (X)
										if (this._parentage = null, Array.isArray(X))
											for (const oe of X) oe.remove(this);
										else X.remove(this);
									const {
										initialTeardown: te
									} = this;
									if ((0, p.m)(te)) try {
										te()
									} catch (oe) {
										Q = oe instanceof D ? oe.errors : [oe]
									}
									const {
										_finalizers: ie
									} = this;
									if (ie) {
										this._finalizers = null;
										for (const oe of ie) try {
											Y(oe)
										} catch (we) {
											Q = Q ?? [], we instanceof D ? Q = [...Q, ...we.errors] : Q.push(we)
										}
									}
									if (Q) throw new D(Q)
								}
							}
							add(Q) {
								var X;
								if (Q && Q !== this)
									if (this.closed) Y(Q);
									else {
										if (Q instanceof ee) {
											if (Q.closed || Q._hasParent(this)) return;
											Q._addParent(this)
										}(this._finalizers = null !== (X = this._finalizers) && void 0 !== X ? X : []).push(Q)
									}
							}
							_hasParent(Q) {
								const {
									_parentage: X
								} = this;
								return X === Q || Array.isArray(X) && X.includes(Q)
							}
							_addParent(Q) {
								const {
									_parentage: X
								} = this;
								this._parentage = Array.isArray(X) ? (X.push(Q), X) : X ? [X, Q] : Q
							}
							_removeParent(Q) {
								const {
									_parentage: X
								} = this;
								X === Q ? this._parentage = null : Array.isArray(X) && (0, z.P)(X, Q)
							}
							remove(Q) {
								const {
									_finalizers: X
								} = this;
								X && (0, z.P)(X, Q), Q instanceof ee && Q._removeParent(this)
							}
						}
						ee.EMPTY = (() => {
							const G = new ee;
							return G.closed = !0, G
						})();
						const P = ee.EMPTY;

						function N(G) {
							return G instanceof ee || G && "closed" in G && (0, p.m)(G.remove) && (0, p.m)(G.add) && (0, p.m)(G.unsubscribe)
						}

						function Y(G) {
							(0, p.m)(G) ? G(): G.unsubscribe()
						}
					}, 3243: (be, ue, E) => {
						E.d(ue, {
							v: () => p
						});
						const p = {
							onUnhandledError: null,
							onStoppedNotification: null,
							Promise: void 0,
							useDeprecatedSynchronousErrorHandling: !1,
							useDeprecatedNextContext: !1
						}
					}, 754: (be, ue, E) => {
						E.d(ue, {
							a: () => Q
						});
						var p = E(4070),
							y = E(7227),
							D = E(3998),
							z = E(4874),
							ee = E(3159),
							P = E(3596),
							N = E(1391),
							Y = E(5694),
							G = E(1552);

						function Q(...ie) {
							const oe = (0, P.yG)(ie),
								we = (0, P.jO)(ie),
								{
									args: Fe,
									keys: Le
								} = (0, y.D)(ie);
							if (0 === Fe.length) return (0, D.D)([], oe);
							const je = new p.y(function X(ie, oe, we = z.y) {
								return Fe => {
									te(oe, () => {
										const {
											length: Le
										} = ie, je = new Array(Le);
										let Ce = Le,
											F = Le;
										for (let xe = 0; xe < Le; xe++) te(oe, () => {
											const Ee = (0, D.D)(ie[xe], oe);
											let Ue = !1;
											Ee.subscribe((0, Y.x)(Fe, ke => {
												je[xe] = ke, Ue || (Ue = !0, F--), F || Fe.next(we(je.slice()))
											}, () => {
												--Ce || Fe.complete()
											}))
										}, Fe)
									}, Fe)
								}
							}(Fe, oe, Le ? Ce => (0, N.n)(Le, Ce) : z.y));
							return we ? je.pipe((0, ee.Z)(we)) : je
						}

						function te(ie, oe, we) {
							ie ? (0, G.f)(we, ie, oe) : oe()
						}
					}, 1785: (be, ue, E) => {
						E.d(ue, {
							z: () => ee
						});
						var p = E(3834),
							D = E(3596),
							z = E(3998);

						function ee(...P) {
							return function y() {
								return (0, p.J)(1)
							}()((0, z.D)(P, (0, D.yG)(P)))
						}
					}, 2588: (be, ue, E) => {
						E.d(ue, {
							P: () => D
						});
						var p = E(4070),
							y = E(3171);

						function D(z) {
							return new p.y(ee => {
								(0, y.Xf)(z()).subscribe(ee)
							})
						}
					}, 8440: (be, ue, E) => {
						E.d(ue, {
							E: () => y
						});
						const y = new(E(4070).y)(ee => ee.complete())
					}, 3998: (be, ue, E) => {
						E.d(ue, {
							D: () => Ue
						});
						var p = E(3171),
							y = E(9534),
							D = E(9681);

						function z(ke, Ge = 0) {
							return (0, D.e)((ft, nt) => {
								nt.add(ke.schedule(() => ft.subscribe(nt), Ge))
							})
						}
						var N = E(4070),
							G = E(1794),
							Q = E(7479),
							X = E(1552);

						function ie(ke, Ge) {
							if (!ke) throw new Error("Iterable cannot be null");
							return new N.y(ft => {
								(0, X.f)(ft, Ge, () => {
									const nt = ke[Symbol.asyncIterator]();
									(0, X.f)(ft, Ge, () => {
										nt.next().then(Pt => {
											Pt.done ? ft.complete() : ft.next(Pt.value)
										})
									}, 0, !0)
								})
							})
						}
						var oe = E(1828),
							we = E(757),
							Fe = E(3901),
							Le = E(3296),
							je = E(1009),
							Ce = E(4704),
							F = E(6401);

						function Ue(ke, Ge) {
							return Ge ? function Ee(ke, Ge) {
								if (null != ke) {
									if ((0, oe.c)(ke)) return function ee(ke, Ge) {
										return (0, p.Xf)(ke).pipe(z(Ge), (0, y.Q)(Ge))
									}(ke, Ge);
									if ((0, Fe.z)(ke)) return function Y(ke, Ge) {
										return new N.y(ft => {
											let nt = 0;
											return Ge.schedule(function() {
												nt === ke.length ? ft.complete() : (ft.next(ke[nt++]), ft.closed || this.schedule())
											})
										})
									}(ke, Ge);
									if ((0, we.t)(ke)) return function P(ke, Ge) {
										return (0, p.Xf)(ke).pipe(z(Ge), (0, y.Q)(Ge))
									}(ke, Ge);
									if ((0, je.D)(ke)) return ie(ke, Ge);
									if ((0, Le.T)(ke)) return function te(ke, Ge) {
										return new N.y(ft => {
											let nt;
											return (0, X.f)(ft, Ge, () => {
												nt = ke[G.h](), (0, X.f)(ft, Ge, () => {
													let Pt, at;
													try {
														({
															value: Pt,
															done: at
														} = nt.next())
													} catch (lt) {
														return void ft.error(lt)
													}
													at ? ft.complete() : ft.next(Pt)
												}, 0, !0)
											}), () => (0, Q.m)(nt?.return) && nt.return()
										})
									}(ke, Ge);
									if ((0, F.L)(ke)) return function xe(ke, Ge) {
										return ie((0, F.Q)(ke), Ge)
									}(ke, Ge)
								}
								throw (0, Ce.z)(ke)
							}(ke, Ge) : (0, p.Xf)(ke)
						}
					}, 4845: (be, ue, E) => {
						E.d(ue, {
							R: () => Q
						});
						var p = E(3171),
							y = E(4070),
							D = E(6443),
							z = E(3901),
							ee = E(7479),
							P = E(3159);
						const N = ["addListener", "removeListener"],
							Y = ["addEventListener", "removeEventListener"],
							G = ["on", "off"];

						function Q(we, Fe, Le, je) {
							if ((0, ee.m)(Le) && (je = Le, Le = void 0), je) return Q(we, Fe, Le).pipe((0, P.Z)(je));
							const [Ce, F] = function oe(we) {
								return (0, ee.m)(we.addEventListener) && (0, ee.m)(we.removeEventListener)
							}(we) ? Y.map(xe => Ee => we[xe](Fe, Ee, Le)): function te(we) {
								return (0, ee.m)(we.addListener) && (0, ee.m)(we.removeListener)
							}(we) ? N.map(X(we, Fe)) : function ie(we) {
								return (0, ee.m)(we.on) && (0, ee.m)(we.off)
							}(we) ? G.map(X(we, Fe)) : [];
							if (!Ce && (0, z.z)(we)) return (0, D.z)(xe => Q(xe, Fe, Le))((0, p.Xf)(we));
							if (!Ce) throw new TypeError("Invalid event target");
							return new y.y(xe => {
								const Ee = (...Ue) => xe.next(1 < Ue.length ? Ue : Ue[0]);
								return Ce(Ee), () => F(Ee)
							})
						}

						function X(we, Fe) {
							return Le => je => we[Le](Fe, je)
						}
					}, 3171: (be, ue, E) => {
						E.d(ue, {
							Xf: () => ie
						});
						var p = E(4929),
							y = E(3901),
							D = E(757),
							z = E(4070),
							ee = E(1828),
							P = E(1009),
							N = E(4704),
							Y = E(3296),
							G = E(6401),
							Q = E(7479),
							X = E(3367),
							te = E(8268);

						function ie(xe) {
							if (xe instanceof z.y) return xe;
							if (null != xe) {
								if ((0, ee.c)(xe)) return function oe(xe) {
									return new z.y(Ee => {
										const Ue = xe[te.L]();
										if ((0, Q.m)(Ue.subscribe)) return Ue.subscribe(Ee);
										throw new TypeError("Provided object does not correctly implement Symbol.observable")
									})
								}(xe);
								if ((0, y.z)(xe)) return function we(xe) {
									return new z.y(Ee => {
										for (let Ue = 0; Ue < xe.length && !Ee.closed; Ue++) Ee.next(xe[Ue]);
										Ee.complete()
									})
								}(xe);
								if ((0, D.t)(xe)) return function Fe(xe) {
									return new z.y(Ee => {
										xe.then(Ue => {
											Ee.closed || (Ee.next(Ue), Ee.complete())
										}, Ue => Ee.error(Ue)).then(null, X.h)
									})
								}(xe);
								if ((0, P.D)(xe)) return je(xe);
								if ((0, Y.T)(xe)) return function Le(xe) {
									return new z.y(Ee => {
										for (const Ue of xe)
											if (Ee.next(Ue), Ee.closed) return;
										Ee.complete()
									})
								}(xe);
								if ((0, G.L)(xe)) return function Ce(xe) {
									return je((0, G.Q)(xe))
								}(xe)
							}
							throw (0, N.z)(xe)
						}

						function je(xe) {
							return new z.y(Ee => {
								(function F(xe, Ee) {
									var Ue, ke, Ge, ft;
									return (0, p.mG)(this, void 0, void 0, function*() {
										try {
											for (Ue = (0, p.KL)(xe); !(ke = yield Ue.next()).done;)
												if (Ee.next(ke.value), Ee.closed) return
										} catch (nt) {
											Ge = {
												error: nt
											}
										} finally {
											try {
												ke && !ke.done && (ft = Ue.return) && (yield ft.call(Ue))
											} finally {
												if (Ge) throw Ge.error
											}
										}
										Ee.complete()
									})
								})(xe, Ee).catch(Ue => Ee.error(Ue))
							})
						}
					}, 805: (be, ue, E) => {
						E.d(ue, {
							T: () => P
						});
						var p = E(3834),
							y = E(3171),
							D = E(8440),
							z = E(3596),
							ee = E(3998);

						function P(...N) {
							const Y = (0, z.yG)(N),
								G = (0, z._6)(N, 1 / 0),
								Q = N;
							return Q.length ? 1 === Q.length ? (0, y.Xf)(Q[0]) : (0, p.J)(G)((0, ee.D)(Q, Y)) : D.E
						}
					}, 5195: (be, ue, E) => {
						E.d(ue, {
							of: () => D
						});
						var p = E(3596),
							y = E(3998);

						function D(...z) {
							const ee = (0, p.yG)(z);
							return (0, y.D)(z, ee)
						}
					}, 9099: (be, ue, E) => {
						E.d(ue, {
							_: () => D
						});
						var p = E(4070),
							y = E(7479);

						function D(z, ee) {
							const P = (0, y.m)(z) ? z : () => z,
								N = Y => Y.error(P());
							return new p.y(ee ? Y => ee.schedule(N, 0, Y) : N)
						}
					}, 2159: (be, ue, E) => {
						E.d(ue, {
							H: () => ee
						});
						var p = E(4070),
							y = E(9615),
							D = E(3088),
							z = E(8662);

						function ee(P = 0, N, Y = y.P) {
							let G = -1;
							return null != N && ((0, D.K)(N) ? Y = N : G = N), new p.y(Q => {
								let X = (0, z.q)(P) ? +P - Y.now() : P;
								X < 0 && (X = 0);
								let te = 0;
								return Y.schedule(function() {
									Q.closed || (Q.next(te++), 0 <= G ? this.schedule(void 0, G) : Q.complete())
								}, X)
							})
						}
					}, 5694: (be, ue, E) => {
						E.d(ue, {
							Q: () => D,
							x: () => y
						});
						var p = E(5324);

						function y(z, ee, P, N, Y) {
							return new D(z, ee, P, N, Y)
						}
						class D extends p.Lv {
							constructor(ee, P, N, Y, G, Q) {
								super(ee), this.onFinalize = G, this.shouldUnsubscribe = Q, this._next = P ? function(X) {
									try {
										P(X)
									} catch (te) {
										ee.error(te)
									}
								} : super._next, this._error = Y ? function(X) {
									try {
										Y(X)
									} catch (te) {
										ee.error(te)
									} finally {
										this.unsubscribe()
									}
								} : super._error, this._complete = N ? function() {
									try {
										N()
									} catch (X) {
										ee.error(X)
									} finally {
										this.unsubscribe()
									}
								} : super._complete
							}
							unsubscribe() {
								var ee;
								if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
									const {
										closed: P
									} = this;
									super.unsubscribe(), !P && (null === (ee = this.onFinalize) || void 0 === ee || ee.call(this))
								}
							}
						}
					}, 2837: (be, ue, E) => {
						E.d(ue, {
							K: () => z
						});
						var p = E(3171),
							y = E(5694),
							D = E(9681);

						function z(ee) {
							return (0, D.e)((P, N) => {
								let Q, Y = null,
									G = !1;
								Y = P.subscribe((0, y.x)(N, void 0, void 0, X => {
									Q = (0, p.Xf)(ee(X, z(ee)(P))), Y ? (Y.unsubscribe(), Y = null, Q.subscribe(N)) : G = !0
								})), G && (Y.unsubscribe(), Y = null, Q.subscribe(N))
							})
						}
					}, 6424: (be, ue, E) => {
						E.d(ue, {
							b: () => D
						});
						var p = E(6443),
							y = E(7479);

						function D(z, ee) {
							return (0, y.m)(ee) ? (0, p.z)(z, ee, 1) : (0, p.z)(z, 1)
						}
					}, 9435: (be, ue, E) => {
						E.d(ue, {
							b: () => z
						});
						var p = E(9615),
							y = E(9681),
							D = E(5694);

						function z(ee, P = p.z) {
							return (0, y.e)((N, Y) => {
								let G = null,
									Q = null,
									X = null;
								const te = () => {
									if (G) {
										G.unsubscribe(), G = null;
										const oe = Q;
										Q = null, Y.next(oe)
									}
								};

								function ie() {
									const oe = X + ee,
										we = P.now();
									if (we < oe) return G = this.schedule(void 0, oe - we), void Y.add(G);
									te()
								}
								N.subscribe((0, D.x)(Y, oe => {
									Q = oe, X = P.now(), G || (G = P.schedule(ie, ee), Y.add(G))
								}, () => {
									te(), Y.complete()
								}, void 0, () => {
									Q = G = null
								}))
							})
						}
					}, 2595: (be, ue, E) => {
						E.d(ue, {
							d: () => D
						});
						var p = E(9681),
							y = E(5694);

						function D(z) {
							return (0, p.e)((ee, P) => {
								let N = !1;
								ee.subscribe((0, y.x)(P, Y => {
									N = !0, P.next(Y)
								}, () => {
									N || P.next(z), P.complete()
								}))
							})
						}
					}, 354: (be, ue, E) => {
						E.d(ue, {
							x: () => z
						});
						var p = E(4874),
							y = E(9681),
							D = E(5694);

						function z(P, N = p.y) {
							return P = P ?? ee, (0, y.e)((Y, G) => {
								let Q, X = !0;
								Y.subscribe((0, D.x)(G, te => {
									const ie = N(te);
									(X || !P(Q, ie)) && (X = !1, Q = ie, G.next(te))
								}))
							})
						}

						function ee(P, N) {
							return P === N
						}
					}, 9754: (be, ue, E) => {
						E.d(ue, {
							h: () => D
						});
						var p = E(9681),
							y = E(5694);

						function D(z, ee) {
							return (0, p.e)((P, N) => {
								let Y = 0;
								P.subscribe((0, y.x)(N, G => z.call(ee, G, Y++) && N.next(G)))
							})
						}
					}, 3710: (be, ue, E) => {
						E.d(ue, {
							P: () => N
						});
						var p = E(8167),
							y = E(9754),
							D = E(2653),
							z = E(2595),
							ee = E(8827),
							P = E(4874);

						function N(Y, G) {
							const Q = arguments.length >= 2;
							return X => X.pipe(Y ? (0, y.h)((te, ie) => Y(te, ie, X)) : P.y, (0, D.q)(1), Q ? (0, z.d)(G) : (0, ee.T)(() => new p.K))
						}
					}, 7155: (be, ue, E) => {
						E.d(ue, {
							l: () => z
						});
						var p = E(9681),
							y = E(5694),
							D = E(222);

						function z() {
							return (0, p.e)((ee, P) => {
								ee.subscribe((0, y.x)(P, D.Z))
							})
						}
					}, 7580: (be, ue, E) => {
						E.d(ue, {
							U: () => D
						});
						var p = E(9681),
							y = E(5694);

						function D(z, ee) {
							return (0, p.e)((P, N) => {
								let Y = 0;
								P.subscribe((0, y.x)(N, G => {
									N.next(z.call(ee, G, Y++))
								}))
							})
						}
					}, 3532: (be, ue, E) => {
						E.d(ue, {
							h: () => y
						});
						var p = E(7580);

						function y(D) {
							return (0, p.U)(() => D)
						}
					}, 3834: (be, ue, E) => {
						E.d(ue, {
							J: () => D
						});
						var p = E(6443),
							y = E(4874);

						function D(z = 1 / 0) {
							return (0, p.z)(y.y, z)
						}
					}, 6443: (be, ue, E) => {
						E.d(ue, {
							z: () => Y
						});
						var p = E(7580),
							y = E(3171),
							D = E(9681),
							z = E(1552),
							ee = E(5694),
							N = E(7479);

						function Y(G, Q, X = 1 / 0) {
							return (0, N.m)(Q) ? Y((te, ie) => (0, p.U)((oe, we) => Q(te, oe, ie, we))((0, y.Xf)(G(te, ie))), X) : ("number" == typeof Q && (X = Q), (0, D.e)((te, ie) => function P(G, Q, X, te, ie, oe, we, Fe) {
								const Le = [];
								let je = 0,
									Ce = 0,
									F = !1;
								const xe = () => {
										F && !Le.length && !je && Q.complete()
									},
									Ee = ke => je < te ? Ue(ke) : Le.push(ke),
									Ue = ke => {
										oe && Q.next(ke), je++;
										let Ge = !1;
										(0, y.Xf)(X(ke, Ce++)).subscribe((0, ee.x)(Q, ft => {
											ie?.(ft), oe ? Ee(ft) : Q.next(ft)
										}, () => {
											Ge = !0
										}, void 0, () => {
											if (Ge) try {
												for (je--; Le.length && je < te;) {
													const ft = Le.shift();
													we ? (0, z.f)(Q, we, () => Ue(ft)) : Ue(ft)
												}
												xe()
											} catch (ft) {
												Q.error(ft)
											}
										}))
									};
								return G.subscribe((0, ee.x)(Q, Ee, () => {
									F = !0, xe()
								})), () => {
									Fe?.()
								}
							}(te, ie, G, X)))
						}
					}, 9534: (be, ue, E) => {
						E.d(ue, {
							Q: () => z
						});
						var p = E(1552),
							y = E(9681),
							D = E(5694);

						function z(ee, P = 0) {
							return (0, y.e)((N, Y) => {
								N.subscribe((0, D.x)(Y, G => (0, p.f)(Y, ee, () => Y.next(G), P), () => (0, p.f)(Y, ee, () => Y.complete(), P), G => (0, p.f)(Y, ee, () => Y.error(G), P)))
							})
						}
					}, 3356: (be, ue, E) => {
						E.d(ue, {
							R: () => z
						});
						var p = E(9681),
							y = E(5694);

						function z(ee, P) {
							return (0, p.e)(function D(ee, P, N, Y, G) {
								return (Q, X) => {
									let te = N,
										ie = P,
										oe = 0;
									Q.subscribe((0, y.x)(X, we => {
										const Fe = oe++;
										ie = te ? ee(ie, we, Fe) : (te = !0, we), Y && X.next(ie)
									}, G && (() => {
										te && X.next(ie), X.complete()
									})))
								}
							}(ee, P, arguments.length >= 2, !0))
						}
					}, 7957: (be, ue, E) => {
						E.d(ue, {
							B: () => ee
						});
						var p = E(3171),
							y = E(8264),
							D = E(5324),
							z = E(9681);

						function ee(N = {}) {
							const {
								connector: Y = (() => new y.x),
								resetOnError: G = !0,
								resetOnComplete: Q = !0,
								resetOnRefCountZero: X = !0
							} = N;
							return te => {
								let ie, oe, we, Fe = 0,
									Le = !1,
									je = !1;
								const Ce = () => {
										oe?.unsubscribe(), oe = void 0
									},
									F = () => {
										Ce(), ie = we = void 0, Le = je = !1
									},
									xe = () => {
										const Ee = ie;
										F(), Ee?.unsubscribe()
									};
								return (0, z.e)((Ee, Ue) => {
									Fe++, !je && !Le && Ce();
									const ke = we = we ?? Y();
									Ue.add(() => {
										Fe--, 0 === Fe && !je && !Le && (oe = P(xe, X))
									}), ke.subscribe(Ue), !ie && Fe > 0 && (ie = new D.Hp({
										next: Ge => ke.next(Ge),
										error: Ge => {
											je = !0, Ce(), oe = P(F, G, Ge), ke.error(Ge)
										},
										complete: () => {
											Le = !0, Ce(), oe = P(F, Q), ke.complete()
										}
									}), (0, p.Xf)(Ee).subscribe(ie))
								})(te)
							}
						}

						function P(N, Y, ...G) {
							if (!0 === Y) return void N();
							if (!1 === Y) return;
							const Q = new D.Hp({
								next: () => {
									Q.unsubscribe(), N()
								}
							});
							return Y(...G).subscribe(Q)
						}
					}, 4276: (be, ue, E) => {
						E.d(ue, {
							T: () => y
						});
						var p = E(9754);

						function y(D) {
							return (0, p.h)((z, ee) => D <= ee)
						}
					}, 1743: (be, ue, E) => {
						E.d(ue, {
							O: () => z
						});
						var p = E(1785),
							y = E(3596),
							D = E(9681);

						function z(...ee) {
							const P = (0, y.yG)(ee);
							return (0, D.e)((N, Y) => {
								(P ? (0, p.z)(ee, N, P) : (0, p.z)(ee, N)).subscribe(Y)
							})
						}
					}, 1565: (be, ue, E) => {
						E.d(ue, {
							w: () => z
						});
						var p = E(3171),
							y = E(9681),
							D = E(5694);

						function z(ee, P) {
							return (0, y.e)((N, Y) => {
								let G = null,
									Q = 0,
									X = !1;
								const te = () => X && !G && Y.complete();
								N.subscribe((0, D.x)(Y, ie => {
									G?.unsubscribe();
									let oe = 0;
									const we = Q++;
									(0, p.Xf)(ee(ie, we)).subscribe(G = (0, D.x)(Y, Fe => Y.next(P ? P(ie, Fe, we, oe++) : Fe), () => {
										G = null, te()
									}))
								}, () => {
									X = !0, te()
								}))
							})
						}
					}, 2653: (be, ue, E) => {
						E.d(ue, {
							q: () => z
						});
						var p = E(8440),
							y = E(9681),
							D = E(5694);

						function z(ee) {
							return ee <= 0 ? () => p.E : (0, y.e)((P, N) => {
								let Y = 0;
								P.subscribe((0, D.x)(N, G => {
									++Y <= ee && (N.next(G), ee <= Y && N.complete())
								}))
							})
						}
					}, 3: (be, ue, E) => {
						E.d(ue, {
							R: () => ee
						});
						var p = E(9681),
							y = E(5694),
							D = E(3171),
							z = E(222);

						function ee(P) {
							return (0, p.e)((N, Y) => {
								(0, D.Xf)(P).subscribe((0, y.x)(Y, () => Y.complete(), z.Z)), !Y.closed && N.subscribe(Y)
							})
						}
					}, 7374: (be, ue, E) => {
						E.d(ue, {
							b: () => ee
						});
						var p = E(7479),
							y = E(9681),
							D = E(5694),
							z = E(4874);

						function ee(P, N, Y) {
							const G = (0, p.m)(P) || N || Y ? {
								next: P,
								error: N,
								complete: Y
							} : P;
							return G ? (0, y.e)((Q, X) => {
								var te;
								null === (te = G.subscribe) || void 0 === te || te.call(G);
								let ie = !0;
								Q.subscribe((0, D.x)(X, oe => {
									var we;
									null === (we = G.next) || void 0 === we || we.call(G, oe), X.next(oe)
								}, () => {
									var oe;
									ie = !1, null === (oe = G.complete) || void 0 === oe || oe.call(G), X.complete()
								}, oe => {
									var we;
									ie = !1, null === (we = G.error) || void 0 === we || we.call(G, oe), X.error(oe)
								}, () => {
									var oe, we;
									ie && (null === (oe = G.unsubscribe) || void 0 === oe || oe.call(G)), null === (we = G.finalize) || void 0 === we || we.call(G)
								}))
							}) : z.y
						}
					}, 8827: (be, ue, E) => {
						E.d(ue, {
							T: () => z
						});
						var p = E(8167),
							y = E(9681),
							D = E(5694);

						function z(P = ee) {
							return (0, y.e)((N, Y) => {
								let G = !1;
								N.subscribe((0, D.x)(Y, Q => {
									G = !0, Y.next(Q)
								}, () => G ? Y.complete() : Y.error(P())))
							})
						}

						function ee() {
							return new p.K
						}
					}, 7571: (be, ue, E) => {
						E.d(ue, {
							V: () => G
						});
						var p = E(9615),
							y = E(8662),
							D = E(9681),
							z = E(3171),
							ee = E(3922),
							P = E(5694),
							N = E(1552);
						const Y = (0, ee.d)(X => function(ie = null) {
							X(this), this.message = "Timeout has occurred", this.name = "TimeoutError", this.info = ie
						});

						function G(X, te) {
							const {
								first: ie,
								each: oe,
								with: we = Q,
								scheduler: Fe = te ?? p.z,
								meta: Le = null
							} = (0, y.q)(X) ? {
								first: X
							} : "number" == typeof X ? {
								each: X
							} : X;
							if (null == ie && null == oe) throw new TypeError("No timeout provided.");
							return (0, D.e)((je, Ce) => {
								let F, xe, Ee = null,
									Ue = 0;
								const ke = Ge => {
									xe = (0, N.f)(Ce, Fe, () => {
										try {
											F.unsubscribe(), (0, z.Xf)(we({
												meta: Le,
												lastValue: Ee,
												seen: Ue
											})).subscribe(Ce)
										} catch (ft) {
											Ce.error(ft)
										}
									}, Ge)
								};
								F = je.subscribe((0, P.x)(Ce, Ge => {
									xe?.unsubscribe(), Ue++, Ce.next(Ee = Ge), oe > 0 && ke(oe)
								}, void 0, void 0, () => {
									xe?.closed || xe?.unsubscribe(), Ee = null
								})), !Ue && ke(null != ie ? "number" == typeof ie ? ie : +ie - Fe.now() : oe)
							})
						}

						function Q(X) {
							throw new Y(X)
						}
					}, 422: (be, ue, E) => {
						E.d(ue, {
							M: () => N
						});
						var p = E(9681),
							y = E(5694),
							D = E(3171),
							z = E(4874),
							ee = E(222),
							P = E(3596);

						function N(...Y) {
							const G = (0, P.jO)(Y);
							return (0, p.e)((Q, X) => {
								const te = Y.length,
									ie = new Array(te);
								let oe = Y.map(() => !1),
									we = !1;
								for (let Fe = 0; Fe < te; Fe++)(0, D.Xf)(Y[Fe]).subscribe((0, y.x)(X, Le => {
									ie[Fe] = Le, !we && !oe[Fe] && (oe[Fe] = !0, (we = oe.every(z.y)) && (oe = null))
								}, ee.Z));
								Q.subscribe((0, y.x)(X, Fe => {
									if (we) {
										const Le = [Fe, ...ie];
										X.next(G ? G(...Le) : Le)
									}
								}))
							})
						}
					}, 5168: (be, ue, E) => {
						E.d(ue, {
							o: () => ee
						});
						var p = E(2292);
						class y extends p.w0 {
							constructor(N, Y) {
								super()
							}
							schedule(N, Y = 0) {
								return this
							}
						}
						const D = {
							setInterval(P, N, ...Y) {
								const {
									delegate: G
								} = D;
								return G?.setInterval ? G.setInterval(P, N, ...Y) : setInterval(P, N, ...Y)
							},
							clearInterval(P) {
								const {
									delegate: N
								} = D;
								return (N?.clearInterval || clearInterval)(P)
							},
							delegate: void 0
						};
						var z = E(5848);
						class ee extends y {
							constructor(N, Y) {
								super(N, Y), this.scheduler = N, this.work = Y, this.pending = !1
							}
							schedule(N, Y = 0) {
								var G;
								if (this.closed) return this;
								this.state = N;
								const Q = this.id,
									X = this.scheduler;
								return null != Q && (this.id = this.recycleAsyncId(X, Q, Y)), this.pending = !0, this.delay = Y, this.id = null !== (G = this.id) && void 0 !== G ? G : this.requestAsyncId(X, this.id, Y), this
							}
							requestAsyncId(N, Y, G = 0) {
								return D.setInterval(N.flush.bind(N, this), G)
							}
							recycleAsyncId(N, Y, G = 0) {
								if (null != G && this.delay === G && !1 === this.pending) return Y;
								null != Y && D.clearInterval(Y)
							}
							execute(N, Y) {
								if (this.closed) return new Error("executing a cancelled action");
								this.pending = !1;
								const G = this._execute(N, Y);
								if (G) return G;
								!1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null))
							}
							_execute(N, Y) {
								let Q, G = !1;
								try {
									this.work(N)
								} catch (X) {
									G = !0, Q = X || new Error("Scheduled action threw falsy error")
								}
								if (G) return this.unsubscribe(), Q
							}
							unsubscribe() {
								if (!this.closed) {
									const {
										id: N,
										scheduler: Y
									} = this, {
										actions: G
									} = Y;
									this.work = this.state = this.scheduler = null, this.pending = !1, (0, z.P)(G, this), null != N && (this.id = this.recycleAsyncId(Y, N, null)), this.delay = null, super.unsubscribe()
								}
							}
						}
					}, 4713: (be, ue, E) => {
						E.d(ue, {
							v: () => D
						});
						var p = E(3450);
						class y {
							constructor(ee, P = y.now) {
								this.schedulerActionCtor = ee, this.now = P
							}
							schedule(ee, P = 0, N) {
								return new this.schedulerActionCtor(this, ee).schedule(N, P)
							}
						}
						y.now = p.l.now;
						class D extends y {
							constructor(ee, P = y.now) {
								super(ee, P), this.actions = [], this._active = !1
							}
							flush(ee) {
								const {
									actions: P
								} = this;
								if (this._active) return void P.push(ee);
								let N;
								this._active = !0;
								do {
									if (N = ee.execute(ee.state, ee.delay)) break
								} while (ee = P.shift());
								if (this._active = !1, N) {
									for (; ee = P.shift();) ee.unsubscribe();
									throw N
								}
							}
						}
					}, 9615: (be, ue, E) => {
						E.d(ue, {
							P: () => z,
							z: () => D
						});
						var p = E(5168);
						const D = new(E(4713).v)(p.o),
							z = D
					}, 3450: (be, ue, E) => {
						E.d(ue, {
							l: () => p
						});
						const p = {
							now: () => (p.delegate || Date).now(),
							delegate: void 0
						}
					}, 7450: (be, ue, E) => {
						E.d(ue, {
							N: () => ee
						});
						var p = E(5168),
							D = E(4713);
						const ee = new class z extends D.v {}(class y extends p.o {
							constructor(Y, G) {
								super(Y, G), this.scheduler = Y, this.work = G
							}
							schedule(Y, G = 0) {
								return G > 0 ? super.schedule(Y, G) : (this.delay = G, this.state = Y, this.scheduler.flush(this), this)
							}
							execute(Y, G) {
								return G > 0 || this.closed ? super.execute(Y, G) : this._execute(Y, G)
							}
							requestAsyncId(Y, G, Q = 0) {
								return null != Q && Q > 0 || null == Q && this.delay > 0 ? super.requestAsyncId(Y, G, Q) : (Y.flush(this), 0)
							}
						})
					}, 2631: (be, ue, E) => {
						E.d(ue, {
							z: () => p
						});
						const p = {
							setTimeout(y, D, ...z) {
								const {
									delegate: ee
								} = p;
								return ee?.setTimeout ? ee.setTimeout(y, D, ...z) : setTimeout(y, D, ...z)
							},
							clearTimeout(y) {
								const {
									delegate: D
								} = p;
								return (D?.clearTimeout || clearTimeout)(y)
							},
							delegate: void 0
						}
					}, 1794: (be, ue, E) => {
						E.d(ue, {
							h: () => y
						});
						const y = function p() {
							return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator"
						}()
					}, 8268: (be, ue, E) => {
						E.d(ue, {
							L: () => p
						});
						const p = "function" == typeof Symbol && Symbol.observable || "@@observable"
					}, 8167: (be, ue, E) => {
						E.d(ue, {
							K: () => y
						});
						const y = (0, E(3922).d)(D => function() {
							D(this), this.name = "EmptyError", this.message = "no elements in sequence"
						})
					}, 3596: (be, ue, E) => {
						E.d(ue, {
							_6: () => P,
							jO: () => z,
							yG: () => ee
						});
						var p = E(7479),
							y = E(3088);

						function D(N) {
							return N[N.length - 1]
						}

						function z(N) {
							return (0, p.m)(D(N)) ? N.pop() : void 0
						}

						function ee(N) {
							return (0, y.K)(D(N)) ? N.pop() : void 0
						}

						function P(N, Y) {
							return "number" == typeof D(N) ? N.pop() : Y
						}
					}, 7227: (be, ue, E) => {
						E.d(ue, {
							D: () => ee
						});
						const {
							isArray: p
						} = Array, {
							getPrototypeOf: y,
							prototype: D,
							keys: z
						} = Object;

						function ee(N) {
							if (1 === N.length) {
								const Y = N[0];
								if (p(Y)) return {
									args: Y,
									keys: null
								};
								if (function P(N) {
										return N && "object" == typeof N && y(N) === D
									}(Y)) {
									const G = z(Y);
									return {
										args: G.map(Q => Y[Q]),
										keys: G
									}
								}
							}
							return {
								args: N,
								keys: null
							}
						}
					}, 5848: (be, ue, E) => {
						function p(y, D) {
							if (y) {
								const z = y.indexOf(D);
								0 <= z && y.splice(z, 1)
							}
						}
						E.d(ue, {
							P: () => p
						})
					}, 3922: (be, ue, E) => {
						function p(y) {
							const z = y(ee => {
								Error.call(ee), ee.stack = (new Error).stack
							});
							return z.prototype = Object.create(Error.prototype), z.prototype.constructor = z, z
						}
						E.d(ue, {
							d: () => p
						})
					}, 1391: (be, ue, E) => {
						function p(y, D) {
							return y.reduce((z, ee, P) => (z[ee] = D[P], z), {})
						}
						E.d(ue, {
							n: () => p
						})
					}, 9848: (be, ue, E) => {
						E.d(ue, {
							O: () => z,
							x: () => D
						});
						var p = E(3243);
						let y = null;

						function D(ee) {
							if (p.v.useDeprecatedSynchronousErrorHandling) {
								const P = !y;
								if (P && (y = {
										errorThrown: !1,
										error: null
									}), ee(), P) {
									const {
										errorThrown: N,
										error: Y
									} = y;
									if (y = null, N) throw Y
								}
							} else ee()
						}

						function z(ee) {
							p.v.useDeprecatedSynchronousErrorHandling && y && (y.errorThrown = !0, y.error = ee)
						}
					}, 1552: (be, ue, E) => {
						function p(y, D, z, ee = 0, P = !1) {
							const N = D.schedule(function() {
								z(), P ? y.add(this.schedule(null, ee)) : this.unsubscribe()
							}, ee);
							if (y.add(N), !P) return N
						}
						E.d(ue, {
							f: () => p
						})
					}, 4874: (be, ue, E) => {
						function p(y) {
							return y
						}
						E.d(ue, {
							y: () => p
						})
					}, 3901: (be, ue, E) => {
						E.d(ue, {
							z: () => p
						});
						const p = y => y && "number" == typeof y.length && "function" != typeof y
					}, 1009: (be, ue, E) => {
						E.d(ue, {
							D: () => y
						});
						var p = E(7479);

						function y(D) {
							return Symbol.asyncIterator && (0, p.m)(D?.[Symbol.asyncIterator])
						}
					}, 8662: (be, ue, E) => {
						function p(y) {
							return y instanceof Date && !isNaN(y)
						}
						E.d(ue, {
							q: () => p
						})
					}, 7479: (be, ue, E) => {
						function p(y) {
							return "function" == typeof y
						}
						E.d(ue, {
							m: () => p
						})
					}, 1828: (be, ue, E) => {
						E.d(ue, {
							c: () => D
						});
						var p = E(8268),
							y = E(7479);

						function D(z) {
							return (0, y.m)(z[p.L])
						}
					}, 3296: (be, ue, E) => {
						E.d(ue, {
							T: () => D
						});
						var p = E(1794),
							y = E(7479);

						function D(z) {
							return (0, y.m)(z?.[p.h])
						}
					}, 757: (be, ue, E) => {
						E.d(ue, {
							t: () => y
						});
						var p = E(7479);

						function y(D) {
							return (0, p.m)(D?.then)
						}
					}, 6401: (be, ue, E) => {
						E.d(ue, {
							L: () => z,
							Q: () => D
						});
						var p = E(4929),
							y = E(7479);

						function D(ee) {
							return (0, p.FC)(this, arguments, function*() {
								const N = ee.getReader();
								try {
									for (;;) {
										const {
											value: Y,
											done: G
										} = yield(0, p.qq)(N.read());
										if (G) return yield(0, p.qq)(void 0);
										yield yield(0, p.qq)(Y)
									}
								} finally {
									N.releaseLock()
								}
							})
						}

						function z(ee) {
							return (0, y.m)(ee?.getReader)
						}
					}, 3088: (be, ue, E) => {
						E.d(ue, {
							K: () => y
						});
						var p = E(7479);

						function y(D) {
							return D && (0, p.m)(D.schedule)
						}
					}, 9681: (be, ue, E) => {
						E.d(ue, {
							A: () => y,
							e: () => D
						});
						var p = E(7479);

						function y(z) {
							return (0, p.m)(z?.lift)
						}

						function D(z) {
							return ee => {
								if (y(ee)) return ee.lift(function(P) {
									try {
										return z(P, this)
									} catch (N) {
										this.error(N)
									}
								});
								throw new TypeError("Unable to lift unknown Observable type")
							}
						}
					}, 3159: (be, ue, E) => {
						E.d(ue, {
							Z: () => z
						});
						var p = E(7580);
						const {
							isArray: y
						} = Array;

						function z(ee) {
							return (0, p.U)(P => function D(ee, P) {
								return y(P) ? ee(...P) : ee(P)
							}(ee, P))
						}
					}, 222: (be, ue, E) => {
						function p() {}
						E.d(ue, {
							Z: () => p
						})
					}, 602: (be, ue, E) => {
						E.d(ue, {
							U: () => D,
							z: () => y
						});
						var p = E(4874);

						function y(...z) {
							return D(z)
						}

						function D(z) {
							return 0 === z.length ? p.y : 1 === z.length ? z[0] : function(P) {
								return z.reduce((N, Y) => Y(N), P)
							}
						}
					}, 3367: (be, ue, E) => {
						E.d(ue, {
							h: () => D
						});
						var p = E(3243),
							y = E(2631);

						function D(z) {
							y.z.setTimeout(() => {
								const {
									onUnhandledError: ee
								} = p.v;
								if (!ee) throw z;
								ee(z)
							})
						}
					}, 4704: (be, ue, E) => {
						function p(y) {
							return new TypeError(`You provided ${null!==y&&"object"==typeof y?"an invalid object":`'${y}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)
						}
						E.d(ue, {
							z: () => p
						})
					}, 4929: (be, ue, E) => {
						function te(Se, Be, ze, it) {
							return new(ze || (ze = Promise))(function(ht, Pe) {
								function pt(Vt) {
									try {
										ot(it.next(Vt))
									} catch (Qt) {
										Pe(Qt)
									}
								}

								function Bt(Vt) {
									try {
										ot(it.throw(Vt))
									} catch (Qt) {
										Pe(Qt)
									}
								}

								function ot(Vt) {
									Vt.done ? ht(Vt.value) : function ce(ht) {
										return ht instanceof ze ? ht : new ze(function(Pe) {
											Pe(ht)
										})
									}(Vt.value).then(pt, Bt)
								}
								ot((it = it.apply(Se, Be || [])).next())
							})
						}

						function xe(Se) {
							return this instanceof xe ? (this.v = Se, this) : new xe(Se)
						}

						function Ee(Se, Be, ze) {
							if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
							var ce, it = ze.apply(Se, Be || []),
								ht = [];
							return ce = {}, Pe("next"), Pe("throw"), Pe("return"), ce[Symbol.asyncIterator] = function() {
								return this
							}, ce;

							function Pe(cn) {
								it[cn] && (ce[cn] = function(Sn) {
									return new Promise(function(Pn, mn) {
										ht.push([cn, Sn, Pn, mn]) > 1 || pt(cn, Sn)
									})
								})
							}

							function pt(cn, Sn) {
								try {
									! function Bt(cn) {
										cn.value instanceof xe ? Promise.resolve(cn.value.v).then(ot, Vt) : Qt(ht[0][2], cn)
									}(it[cn](Sn))
								} catch (Pn) {
									Qt(ht[0][3], Pn)
								}
							}

							function ot(cn) {
								pt("next", cn)
							}

							function Vt(cn) {
								pt("throw", cn)
							}

							function Qt(cn, Sn) {
								cn(Sn), ht.shift(), ht.length && pt(ht[0][0], ht[0][1])
							}
						}

						function ke(Se) {
							if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
							var ze, Be = Se[Symbol.asyncIterator];
							return Be ? Be.call(Se) : (Se = function Fe(Se) {
								var Be = "function" == typeof Symbol && Symbol.iterator,
									ze = Be && Se[Be],
									it = 0;
								if (ze) return ze.call(Se);
								if (Se && "number" == typeof Se.length) return {
									next: function() {
										return Se && it >= Se.length && (Se = void 0), {
											value: Se && Se[it++],
											done: !Se
										}
									}
								};
								throw new TypeError(Be ? "Object is not iterable." : "Symbol.iterator is not defined.")
							}(Se), ze = {}, it("next"), it("throw"), it("return"), ze[Symbol.asyncIterator] = function() {
								return this
							}, ze);

							function it(ht) {
								ze[ht] = Se[ht] && function(Pe) {
									return new Promise(function(pt, Bt) {
										! function ce(ht, Pe, pt, Bt) {
											Promise.resolve(Bt).then(function(ot) {
												ht({
													value: ot,
													done: pt
												})
											}, Pe)
										}(pt, Bt, (Pe = Se[ht](Pe)).done, Pe.value)
									})
								}
							}
						}
						E.d(ue, {
							FC: () => Ee,
							KL: () => ke,
							mG: () => te,
							qq: () => xe
						})
					}, 6191: (be, ue, E) => {
						E.d(ue, {
							F4: () => Q,
							IO: () => we,
							LC: () => y,
							SB: () => G,
							X$: () => z,
							ZE: () => Ce,
							ZN: () => je,
							_j: () => p,
							eR: () => X,
							jt: () => ee,
							k1: () => F,
							l3: () => D,
							oB: () => Y,
							pV: () => ie,
							ru: () => P,
							vP: () => N
						});
						class p {}
						class y {}
						const D = "*";

						function z(xe, Ee) {
							return {
								type: 7,
								name: xe,
								definitions: Ee,
								options: {}
							}
						}

						function ee(xe, Ee = null) {
							return {
								type: 4,
								styles: Ee,
								timings: xe
							}
						}

						function P(xe, Ee = null) {
							return {
								type: 3,
								steps: xe,
								options: Ee
							}
						}

						function N(xe, Ee = null) {
							return {
								type: 2,
								steps: xe,
								options: Ee
							}
						}

						function Y(xe) {
							return {
								type: 6,
								styles: xe,
								offset: null
							}
						}

						function G(xe, Ee, Ue) {
							return {
								type: 0,
								name: xe,
								styles: Ee,
								options: Ue
							}
						}

						function Q(xe) {
							return {
								type: 5,
								steps: xe
							}
						}

						function X(xe, Ee, Ue = null) {
							return {
								type: 1,
								expr: xe,
								animation: Ee,
								options: Ue
							}
						}

						function ie(xe = null) {
							return {
								type: 9,
								options: xe
							}
						}

						function we(xe, Ee, Ue = null) {
							return {
								type: 11,
								selector: xe,
								animation: Ee,
								options: Ue
							}
						}

						function Le(xe) {
							Promise.resolve().then(xe)
						}
						class je {
							constructor(Ee = 0, Ue = 0) {
								this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._originalOnDoneFns = [], this._originalOnStartFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this._position = 0, this.parentPlayer = null, this.totalTime = Ee + Ue
							}
							_onFinish() {
								this._finished || (this._finished = !0, this._onDoneFns.forEach(Ee => Ee()), this._onDoneFns = [])
							}
							onStart(Ee) {
								this._originalOnStartFns.push(Ee), this._onStartFns.push(Ee)
							}
							onDone(Ee) {
								this._originalOnDoneFns.push(Ee), this._onDoneFns.push(Ee)
							}
							onDestroy(Ee) {
								this._onDestroyFns.push(Ee)
							}
							hasStarted() {
								return this._started
							}
							init() {}
							play() {
								this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0
							}
							triggerMicrotask() {
								Le(() => this._onFinish())
							}
							_onStart() {
								this._onStartFns.forEach(Ee => Ee()), this._onStartFns = []
							}
							pause() {}
							restart() {}
							finish() {
								this._onFinish()
							}
							destroy() {
								this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(Ee => Ee()), this._onDestroyFns = [])
							}
							reset() {
								this._started = !1, this._finished = !1, this._onStartFns = this._originalOnStartFns, this._onDoneFns = this._originalOnDoneFns
							}
							setPosition(Ee) {
								this._position = this.totalTime ? Ee * this.totalTime : 1
							}
							getPosition() {
								return this.totalTime ? this._position / this.totalTime : 1
							}
							triggerCallback(Ee) {
								const Ue = "start" == Ee ? this._onStartFns : this._onDoneFns;
								Ue.forEach(ke => ke()), Ue.length = 0
							}
						}
						class Ce {
							constructor(Ee) {
								this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = Ee;
								let Ue = 0,
									ke = 0,
									Ge = 0;
								const ft = this.players.length;
								0 == ft ? Le(() => this._onFinish()) : this.players.forEach(nt => {
									nt.onDone(() => {
										++Ue == ft && this._onFinish()
									}), nt.onDestroy(() => {
										++ke == ft && this._onDestroy()
									}), nt.onStart(() => {
										++Ge == ft && this._onStart()
									})
								}), this.totalTime = this.players.reduce((nt, Pt) => Math.max(nt, Pt.totalTime), 0)
							}
							_onFinish() {
								this._finished || (this._finished = !0, this._onDoneFns.forEach(Ee => Ee()), this._onDoneFns = [])
							}
							init() {
								this.players.forEach(Ee => Ee.init())
							}
							onStart(Ee) {
								this._onStartFns.push(Ee)
							}
							_onStart() {
								this.hasStarted() || (this._started = !0, this._onStartFns.forEach(Ee => Ee()), this._onStartFns = [])
							}
							onDone(Ee) {
								this._onDoneFns.push(Ee)
							}
							onDestroy(Ee) {
								this._onDestroyFns.push(Ee)
							}
							hasStarted() {
								return this._started
							}
							play() {
								this.parentPlayer || this.init(), this._onStart(), this.players.forEach(Ee => Ee.play())
							}
							pause() {
								this.players.forEach(Ee => Ee.pause())
							}
							restart() {
								this.players.forEach(Ee => Ee.restart())
							}
							finish() {
								this._onFinish(), this.players.forEach(Ee => Ee.finish())
							}
							destroy() {
								this._onDestroy()
							}
							_onDestroy() {
								this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(Ee => Ee.destroy()), this._onDestroyFns.forEach(Ee => Ee()), this._onDestroyFns = [])
							}
							reset() {
								this.players.forEach(Ee => Ee.reset()), this._destroyed = !1, this._finished = !1, this._started = !1
							}
							setPosition(Ee) {
								const Ue = Ee * this.totalTime;
								this.players.forEach(ke => {
									const Ge = ke.totalTime ? Math.min(1, Ue / ke.totalTime) : 1;
									ke.setPosition(Ge)
								})
							}
							getPosition() {
								const Ee = this.players.reduce((Ue, ke) => null === Ue || ke.totalTime > Ue.totalTime ? ke : Ue, null);
								return null != Ee ? Ee.getPosition() : 0
							}
							beforeDestroy() {
								this.players.forEach(Ee => {
									Ee.beforeDestroy && Ee.beforeDestroy()
								})
							}
							triggerCallback(Ee) {
								const Ue = "start" == Ee ? this._onStartFns : this._onDoneFns;
								Ue.forEach(ke => ke()), Ue.length = 0
							}
						}
						const F = "!"
					}, 7838: (be, ue, E) => {
						E.d(ue, {
							rt: () => De,
							tE: () => Ht,
							qV: () => mn,
							qm: () => ct,
							ic: () => Be,
							Kd: () => pe,
							X6: () => qt,
							yG: () => tn
						});
						var p = E(7774),
							y = E(3991),
							D = E(1329),
							z = E(3216),
							ee = E(8264),
							P = E(5195),
							N = E(849),
							Y = E(2653),
							G = E(4276),
							Q = E(354),
							X = E(3),
							te = E(5903);
						let ie = (() => {
								class B {
									create(k) {
										return typeof MutationObserver > "u" ? null : new MutationObserver(k)
									}
								}
								return B.\u0275fac = function(k) {
									return new(k || B)
								}, B.\u0275prov = y.Yz7({
									token: B,
									factory: B.\u0275fac,
									providedIn: "root"
								}), B
							})(),
							Fe = (() => {
								class B {}
								return B.\u0275fac = function(k) {
									return new(k || B)
								}, B.\u0275mod = y.oAB({
									type: B
								}), B.\u0275inj = y.cJS({
									providers: [ie]
								}), B
							})();
						var Le = E(5999);
						let Be = (() => {
							class B {
								constructor(k) {
									this._platform = k
								}
								isDisabled(k) {
									return k.hasAttribute("disabled")
								}
								isVisible(k) {
									return function it(B) {
										return !!(B.offsetWidth || B.offsetHeight || "function" == typeof B.getClientRects && B.getClientRects().length)
									}(k) && "visible" === getComputedStyle(k).visibility
								}
								isTabbable(k) {
									if (!this._platform.isBrowser) return !1;
									const H = function ze(B) {
										try {
											return B.frameElement
										} catch {
											return null
										}
									}(function Sn(B) {
										return B.ownerDocument && B.ownerDocument.defaultView || window
									}(k));
									if (H && (-1 === Vt(H) || !this.isVisible(H))) return !1;
									let ne = k.nodeName.toLowerCase(),
										Ne = Vt(k);
									return k.hasAttribute("contenteditable") ? -1 !== Ne : !("iframe" === ne || "object" === ne || this._platform.WEBKIT && this._platform.IOS && ! function Qt(B) {
										let J = B.nodeName.toLowerCase(),
											k = "input" === J && B.type;
										return "text" === k || "password" === k || "select" === J || "textarea" === J
									}(k)) && ("audio" === ne ? !!k.hasAttribute("controls") && -1 !== Ne : "video" === ne ? -1 !== Ne && (null !== Ne || this._platform.FIREFOX || k.hasAttribute("controls")) : k.tabIndex >= 0)
								}
								isFocusable(k, H) {
									return function cn(B) {
										return ! function ht(B) {
											return function pt(B) {
												return "input" == B.nodeName.toLowerCase()
											}(B) && "hidden" == B.type
										}(B) && (function ce(B) {
											let J = B.nodeName.toLowerCase();
											return "input" === J || "select" === J || "button" === J || "textarea" === J
										}(B) || function Pe(B) {
											return function Bt(B) {
												return "a" == B.nodeName.toLowerCase()
											}(B) && B.hasAttribute("href")
										}(B) || B.hasAttribute("contenteditable") || ot(B))
									}(k) && !this.isDisabled(k) && (H?.ignoreVisibility || this.isVisible(k))
								}
							}
							return B.\u0275fac = function(k) {
								return new(k || B)(y.LFG(D.t4))
							}, B.\u0275prov = y.Yz7({
								token: B,
								factory: B.\u0275fac,
								providedIn: "root"
							}), B
						})();

						function ot(B) {
							if (!B.hasAttribute("tabindex") || void 0 === B.tabIndex) return !1;
							let J = B.getAttribute("tabindex");
							return !(!J || isNaN(parseInt(J, 10)))
						}

						function Vt(B) {
							if (!ot(B)) return null;
							const J = parseInt(B.getAttribute("tabindex") || "", 10);
							return isNaN(J) ? -1 : J
						}
						class Pn {
							get enabled() {
								return this._enabled
							}
							set enabled(J) {
								this._enabled = J, this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(J, this._startAnchor), this._toggleAnchorTabIndex(J, this._endAnchor))
							}
							constructor(J, k, H, ne, Ne = !1) {
								this._element = J, this._checker = k, this._ngZone = H, this._document = ne, this._hasAttached = !1, this.startAnchorListener = () => this.focusLastTabbableElement(), this.endAnchorListener = () => this.focusFirstTabbableElement(), this._enabled = !0, Ne || this.attachAnchors()
							}
							destroy() {
								const J = this._startAnchor,
									k = this._endAnchor;
								J && (J.removeEventListener("focus", this.startAnchorListener), J.remove()), k && (k.removeEventListener("focus", this.endAnchorListener), k.remove()), this._startAnchor = this._endAnchor = null, this._hasAttached = !1
							}
							attachAnchors() {
								return !!this._hasAttached || (this._ngZone.runOutsideAngular(() => {
									this._startAnchor || (this._startAnchor = this._createAnchor(), this._startAnchor.addEventListener("focus", this.startAnchorListener)), this._endAnchor || (this._endAnchor = this._createAnchor(), this._endAnchor.addEventListener("focus", this.endAnchorListener))
								}), this._element.parentNode && (this._element.parentNode.insertBefore(this._startAnchor, this._element), this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling), this._hasAttached = !0), this._hasAttached)
							}
							focusInitialElementWhenReady(J) {
								return new Promise(k => {
									this._executeOnStable(() => k(this.focusInitialElement(J)))
								})
							}
							focusFirstTabbableElementWhenReady(J) {
								return new Promise(k => {
									this._executeOnStable(() => k(this.focusFirstTabbableElement(J)))
								})
							}
							focusLastTabbableElementWhenReady(J) {
								return new Promise(k => {
									this._executeOnStable(() => k(this.focusLastTabbableElement(J)))
								})
							}
							_getRegionBoundary(J) {
								const k = this._element.querySelectorAll(`[cdk-focus-region-${J}], [cdkFocusRegion${J}], [cdk-focus-${J}]`);
								return "start" == J ? k.length ? k[0] : this._getFirstTabbableElement(this._element) : k.length ? k[k.length - 1] : this._getLastTabbableElement(this._element)
							}
							focusInitialElement(J) {
								const k = this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]");
								if (k) {
									if (!this._checker.isFocusable(k)) {
										const H = this._getFirstTabbableElement(k);
										return H?.focus(J), !!H
									}
									return k.focus(J), !0
								}
								return this.focusFirstTabbableElement(J)
							}
							focusFirstTabbableElement(J) {
								const k = this._getRegionBoundary("start");
								return k && k.focus(J), !!k
							}
							focusLastTabbableElement(J) {
								const k = this._getRegionBoundary("end");
								return k && k.focus(J), !!k
							}
							hasAttached() {
								return this._hasAttached
							}
							_getFirstTabbableElement(J) {
								if (this._checker.isFocusable(J) && this._checker.isTabbable(J)) return J;
								const k = J.children;
								for (let H = 0; H < k.length; H++) {
									const ne = k[H].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(k[H]) : null;
									if (ne) return ne
								}
								return null
							}
							_getLastTabbableElement(J) {
								if (this._checker.isFocusable(J) && this._checker.isTabbable(J)) return J;
								const k = J.children;
								for (let H = k.length - 1; H >= 0; H--) {
									const ne = k[H].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(k[H]) : null;
									if (ne) return ne
								}
								return null
							}
							_createAnchor() {
								const J = this._document.createElement("div");
								return this._toggleAnchorTabIndex(this._enabled, J), J.classList.add("cdk-visually-hidden"), J.classList.add("cdk-focus-trap-anchor"), J.setAttribute("aria-hidden", "true"), J
							}
							_toggleAnchorTabIndex(J, k) {
								J ? k.setAttribute("tabindex", "0") : k.removeAttribute("tabindex")
							}
							toggleAnchors(J) {
								this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(J, this._startAnchor), this._toggleAnchorTabIndex(J, this._endAnchor))
							}
							_executeOnStable(J) {
								this._ngZone.isStable ? J() : this._ngZone.onStable.pipe((0, Y.q)(1)).subscribe(J)
							}
						}
						let mn = (() => {
							class B {
								constructor(k, H, ne) {
									this._checker = k, this._ngZone = H, this._document = ne
								}
								create(k, H = !1) {
									return new Pn(k, this._checker, this._ngZone, this._document, H)
								}
							}
							return B.\u0275fac = function(k) {
								return new(k || B)(y.LFG(Be), y.LFG(y.R0b), y.LFG(p.K0))
							}, B.\u0275prov = y.Yz7({
								token: B,
								factory: B.\u0275fac,
								providedIn: "root"
							}), B
						})();

						function qt(B) {
							return 0 === B.buttons || 0 === B.offsetX && 0 === B.offsetY
						}

						function tn(B) {
							const J = B.touches && B.touches[0] || B.changedTouches && B.changedTouches[0];
							return !(!J || -1 !== J.identifier || null != J.radiusX && 1 !== J.radiusX || null != J.radiusY && 1 !== J.radiusY)
						}
						const en = new y.OlP("cdk-input-modality-detector-options"),
							Qn = {
								ignoreKeys: [N.zL, N.jx, N.b2, N.MW, N.JU]
							},
							Nn = (0, D.i$)({
								passive: !0,
								capture: !0
							});
						let ar = (() => {
							class B {
								get mostRecentModality() {
									return this._modality.value
								}
								constructor(k, H, ne, Ne) {
									this._platform = k, this._mostRecentTarget = null, this._modality = new z.X(null), this._lastTouchMs = 0, this._onKeydown = Ye => {
										this._options?.ignoreKeys?.some(Ft => Ft === Ye.keyCode) || (this._modality.next("keyboard"), this._mostRecentTarget = (0, D.sA)(Ye))
									}, this._onMousedown = Ye => {
										Date.now() - this._lastTouchMs < 650 || (this._modality.next(qt(Ye) ? "keyboard" : "mouse"), this._mostRecentTarget = (0, D.sA)(Ye))
									}, this._onTouchstart = Ye => {
										tn(Ye) ? this._modality.next("keyboard") : (this._lastTouchMs = Date.now(), this._modality.next("touch"), this._mostRecentTarget = (0, D.sA)(Ye))
									}, this._options = {
										...Qn,
										...Ne
									}, this.modalityDetected = this._modality.pipe((0, G.T)(1)), this.modalityChanged = this.modalityDetected.pipe((0, Q.x)()), k.isBrowser && H.runOutsideAngular(() => {
										ne.addEventListener("keydown", this._onKeydown, Nn), ne.addEventListener("mousedown", this._onMousedown, Nn), ne.addEventListener("touchstart", this._onTouchstart, Nn)
									})
								}
								ngOnDestroy() {
									this._modality.complete(), this._platform.isBrowser && (document.removeEventListener("keydown", this._onKeydown, Nn), document.removeEventListener("mousedown", this._onMousedown, Nn), document.removeEventListener("touchstart", this._onTouchstart, Nn))
								}
							}
							return B.\u0275fac = function(k) {
								return new(k || B)(y.LFG(D.t4), y.LFG(y.R0b), y.LFG(p.K0), y.LFG(en, 8))
							}, B.\u0275prov = y.Yz7({
								token: B,
								factory: B.\u0275fac,
								providedIn: "root"
							}), B
						})();
						const hr = new y.OlP("liveAnnouncerElement", {
								providedIn: "root",
								factory: function un() {
									return null
								}
							}),
							Nt = new y.OlP("LIVE_ANNOUNCER_DEFAULT_OPTIONS");
						let Xe = 0,
							pe = (() => {
								class B {
									constructor(k, H, ne, Ne) {
										this._ngZone = H, this._defaultOptions = Ne, this._document = ne, this._liveElement = k || this._createLiveElement()
									}
									announce(k, ...H) {
										const ne = this._defaultOptions;
										let Ne, Ye;
										return 1 === H.length && "number" == typeof H[0] ? Ye = H[0] : [Ne, Ye] = H, this.clear(), clearTimeout(this._previousTimeout), Ne || (Ne = ne && ne.politeness ? ne.politeness : "polite"), null == Ye && ne && (Ye = ne.duration), this._liveElement.setAttribute("aria-live", Ne), this._liveElement.id && this._exposeAnnouncerToModals(this._liveElement.id), this._ngZone.runOutsideAngular(() => (this._currentPromise || (this._currentPromise = new Promise(Ft => this._currentResolve = Ft)), clearTimeout(this._previousTimeout), this._previousTimeout = setTimeout(() => {
											this._liveElement.textContent = k, "number" == typeof Ye && (this._previousTimeout = setTimeout(() => this.clear(), Ye)), this._currentResolve(), this._currentPromise = this._currentResolve = void 0
										}, 100), this._currentPromise))
									}
									clear() {
										this._liveElement && (this._liveElement.textContent = "")
									}
									ngOnDestroy() {
										clearTimeout(this._previousTimeout), this._liveElement?.remove(), this._liveElement = null, this._currentResolve?.(), this._currentPromise = this._currentResolve = void 0
									}
									_createLiveElement() {
										const k = "cdk-live-announcer-element",
											H = this._document.getElementsByClassName(k),
											ne = this._document.createElement("div");
										for (let Ne = 0; Ne < H.length; Ne++) H[Ne].remove();
										return ne.classList.add(k), ne.classList.add("cdk-visually-hidden"), ne.setAttribute("aria-atomic", "true"), ne.setAttribute("aria-live", "polite"), ne.id = "cdk-live-announcer-" + Xe++, this._document.body.appendChild(ne), ne
									}
									_exposeAnnouncerToModals(k) {
										const H = this._document.querySelectorAll('body > .cdk-overlay-container [aria-modal="true"]');
										for (let ne = 0; ne < H.length; ne++) {
											const Ne = H[ne],
												Ye = Ne.getAttribute("aria-owns");
											Ye ? -1 === Ye.indexOf(k) && Ne.setAttribute("aria-owns", Ye + " " + k) : Ne.setAttribute("aria-owns", k)
										}
									}
								}
								return B.\u0275fac = function(k) {
									return new(k || B)(y.LFG(hr, 8), y.LFG(y.R0b), y.LFG(p.K0), y.LFG(Nt, 8))
								}, B.\u0275prov = y.Yz7({
									token: B,
									factory: B.\u0275fac,
									providedIn: "root"
								}), B
							})();
						const Je = new y.OlP("cdk-focus-monitor-default-options"),
							yt = (0, D.i$)({
								passive: !0,
								capture: !0
							});
						let Ht = (() => {
							class B {
								constructor(k, H, ne, Ne, Ye) {
									this._ngZone = k, this._platform = H, this._inputModalityDetector = ne, this._origin = null, this._windowFocused = !1, this._originFromTouchInteraction = !1, this._elementInfo = new Map, this._monitoredElementCount = 0, this._rootNodeFocusListenerCount = new Map, this._windowFocusListener = () => {
										this._windowFocused = !0, this._windowFocusTimeoutId = window.setTimeout(() => this._windowFocused = !1)
									}, this._stopInputModalityDetector = new ee.x, this._rootNodeFocusAndBlurListener = Ft => {
										for (let xt = (0, D.sA)(Ft); xt; xt = xt.parentElement) "focus" === Ft.type ? this._onFocus(Ft, xt) : this._onBlur(Ft, xt)
									}, this._document = Ne, this._detectionMode = Ye?.detectionMode || 0
								}
								monitor(k, H = !1) {
									const ne = (0, te.fI)(k);
									if (!this._platform.isBrowser || 1 !== ne.nodeType) return (0, P.of)(null);
									const Ne = (0, D.kV)(ne) || this._getDocument(),
										Ye = this._elementInfo.get(ne);
									if (Ye) return H && (Ye.checkChildren = !0), Ye.subject;
									const Ft = {
										checkChildren: H,
										subject: new ee.x,
										rootNode: Ne
									};
									return this._elementInfo.set(ne, Ft), this._registerGlobalListeners(Ft), Ft.subject
								}
								stopMonitoring(k) {
									const H = (0, te.fI)(k),
										ne = this._elementInfo.get(H);
									ne && (ne.subject.complete(), this._setClasses(H), this._elementInfo.delete(H), this._removeGlobalListeners(ne))
								}
								focusVia(k, H, ne) {
									const Ne = (0, te.fI)(k);
									Ne === this._getDocument().activeElement ? this._getClosestElementsInfo(Ne).forEach(([Ft, an]) => this._originChanged(Ft, H, an)) : (this._setOrigin(H), "function" == typeof Ne.focus && Ne.focus(ne))
								}
								ngOnDestroy() {
									this._elementInfo.forEach((k, H) => this.stopMonitoring(H))
								}
								_getDocument() {
									return this._document || document
								}
								_getWindow() {
									return this._getDocument().defaultView || window
								}
								_getFocusOrigin(k) {
									return this._origin ? this._originFromTouchInteraction ? this._shouldBeAttributedToTouch(k) ? "touch" : "program" : this._origin : this._windowFocused && this._lastFocusOrigin ? this._lastFocusOrigin : k && this._isLastInteractionFromInputLabel(k) ? "mouse" : "program"
								}
								_shouldBeAttributedToTouch(k) {
									return 1 === this._detectionMode || !!k?.contains(this._inputModalityDetector._mostRecentTarget)
								}
								_setClasses(k, H) {
									k.classList.toggle("cdk-focused", !!H), k.classList.toggle("cdk-touch-focused", "touch" === H), k.classList.toggle("cdk-keyboard-focused", "keyboard" === H), k.classList.toggle("cdk-mouse-focused", "mouse" === H), k.classList.toggle("cdk-program-focused", "program" === H)
								}
								_setOrigin(k, H = !1) {
									this._ngZone.runOutsideAngular(() => {
										this._origin = k, this._originFromTouchInteraction = "touch" === k && H, 0 === this._detectionMode && (clearTimeout(this._originTimeoutId), this._originTimeoutId = setTimeout(() => this._origin = null, this._originFromTouchInteraction ? 650 : 1))
									})
								}
								_onFocus(k, H) {
									const ne = this._elementInfo.get(H),
										Ne = (0, D.sA)(k);
									!ne || !ne.checkChildren && H !== Ne || this._originChanged(H, this._getFocusOrigin(Ne), ne)
								}
								_onBlur(k, H) {
									const ne = this._elementInfo.get(H);
									!ne || ne.checkChildren && k.relatedTarget instanceof Node && H.contains(k.relatedTarget) || (this._setClasses(H), this._emitOrigin(ne, null))
								}
								_emitOrigin(k, H) {
									k.subject.observers.length && this._ngZone.run(() => k.subject.next(H))
								}
								_registerGlobalListeners(k) {
									if (!this._platform.isBrowser) return;
									const H = k.rootNode,
										ne = this._rootNodeFocusListenerCount.get(H) || 0;
									ne || this._ngZone.runOutsideAngular(() => {
										H.addEventListener("focus", this._rootNodeFocusAndBlurListener, yt), H.addEventListener("blur", this._rootNodeFocusAndBlurListener, yt)
									}), this._rootNodeFocusListenerCount.set(H, ne + 1), 1 == ++this._monitoredElementCount && (this._ngZone.runOutsideAngular(() => {
										this._getWindow().addEventListener("focus", this._windowFocusListener)
									}), this._inputModalityDetector.modalityDetected.pipe((0, X.R)(this._stopInputModalityDetector)).subscribe(Ne => {
										this._setOrigin(Ne, !0)
									}))
								}
								_removeGlobalListeners(k) {
									const H = k.rootNode;
									if (this._rootNodeFocusListenerCount.has(H)) {
										const ne = this._rootNodeFocusListenerCount.get(H);
										ne > 1 ? this._rootNodeFocusListenerCount.set(H, ne - 1) : (H.removeEventListener("focus", this._rootNodeFocusAndBlurListener, yt), H.removeEventListener("blur", this._rootNodeFocusAndBlurListener, yt), this._rootNodeFocusListenerCount.delete(H))
									}--this._monitoredElementCount || (this._getWindow().removeEventListener("focus", this._windowFocusListener), this._stopInputModalityDetector.next(), clearTimeout(this._windowFocusTimeoutId), clearTimeout(this._originTimeoutId))
								}
								_originChanged(k, H, ne) {
									this._setClasses(k, H), this._emitOrigin(ne, H), this._lastFocusOrigin = H
								}
								_getClosestElementsInfo(k) {
									const H = [];
									return this._elementInfo.forEach((ne, Ne) => {
										(Ne === k || ne.checkChildren && Ne.contains(k)) && H.push([Ne, ne])
									}), H
								}
								_isLastInteractionFromInputLabel(k) {
									const {
										_mostRecentTarget: H,
										mostRecentModality: ne
									} = this._inputModalityDetector;
									if ("mouse" !== ne || !H || H === k || "INPUT" !== k.nodeName && "TEXTAREA" !== k.nodeName || k.disabled) return !1;
									const Ne = k.labels;
									if (Ne)
										for (let Ye = 0; Ye < Ne.length; Ye++)
											if (Ne[Ye].contains(H)) return !0;
									return !1
								}
							}
							return B.\u0275fac = function(k) {
								return new(k || B)(y.LFG(y.R0b), y.LFG(D.t4), y.LFG(ar), y.LFG(p.K0, 8), y.LFG(Je, 8))
							}, B.\u0275prov = y.Yz7({
								token: B,
								factory: B.\u0275fac,
								providedIn: "root"
							}), B
						})();
						const $t = "cdk-high-contrast-black-on-white",
							hn = "cdk-high-contrast-white-on-black",
							kt = "cdk-high-contrast-active";
						let ct = (() => {
								class B {
									constructor(k, H) {
										this._platform = k, this._document = H, this._breakpointSubscription = (0, y.f3M)(Le.Yg).observe("(forced-colors: active)").subscribe(() => {
											this._hasCheckedHighContrastMode && (this._hasCheckedHighContrastMode = !1, this._applyBodyHighContrastModeCssClasses())
										})
									}
									getHighContrastMode() {
										if (!this._platform.isBrowser) return 0;
										const k = this._document.createElement("div");
										k.style.backgroundColor = "rgb(1,2,3)", k.style.position = "absolute", this._document.body.appendChild(k);
										const H = this._document.defaultView || window,
											ne = H && H.getComputedStyle ? H.getComputedStyle(k) : null,
											Ne = (ne && ne.backgroundColor || "").replace(/ /g, "");
										switch (k.remove(), Ne) {
											case "rgb(0,0,0)":
											case "rgb(45,50,54)":
											case "rgb(32,32,32)":
												return 2;
											case "rgb(255,255,255)":
											case "rgb(255,250,239)":
												return 1
										}
										return 0
									}
									ngOnDestroy() {
										this._breakpointSubscription.unsubscribe()
									}
									_applyBodyHighContrastModeCssClasses() {
										if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) {
											const k = this._document.body.classList;
											k.remove(kt, $t, hn), this._hasCheckedHighContrastMode = !0;
											const H = this.getHighContrastMode();
											1 === H ? k.add(kt, $t) : 2 === H && k.add(kt, hn)
										}
									}
								}
								return B.\u0275fac = function(k) {
									return new(k || B)(y.LFG(D.t4), y.LFG(p.K0))
								}, B.\u0275prov = y.Yz7({
									token: B,
									factory: B.\u0275fac,
									providedIn: "root"
								}), B
							})(),
							De = (() => {
								class B {
									constructor(k) {
										k._applyBodyHighContrastModeCssClasses()
									}
								}
								return B.\u0275fac = function(k) {
									return new(k || B)(y.LFG(ct))
								}, B.\u0275mod = y.oAB({
									type: B
								}), B.\u0275inj = y.cJS({
									imports: [Fe]
								}), B
							})()
					}, 8793: (be, ue, E) => {
						E.d(ue, {
							Is: () => N,
							vT: () => G
						});
						var p = E(3991),
							y = E(7774);
						const D = new p.OlP("cdk-dir-doc", {
								providedIn: "root",
								factory: function z() {
									return (0, p.f3M)(y.K0)
								}
							}),
							ee = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;
						let N = (() => {
								class Q {
									constructor(te) {
										this.value = "ltr", this.change = new p.vpe, te && (this.value = function P(Q) {
											const X = Q?.toLowerCase() || "";
											return "auto" === X && typeof navigator < "u" && navigator?.language ? ee.test(navigator.language) ? "rtl" : "ltr" : "rtl" === X ? "rtl" : "ltr"
										}((te.body ? te.body.dir : null) || (te.documentElement ? te.documentElement.dir : null) || "ltr"))
									}
									ngOnDestroy() {
										this.change.complete()
									}
								}
								return Q.\u0275fac = function(te) {
									return new(te || Q)(p.LFG(D, 8))
								}, Q.\u0275prov = p.Yz7({
									token: Q,
									factory: Q.\u0275fac,
									providedIn: "root"
								}), Q
							})(),
							G = (() => {
								class Q {}
								return Q.\u0275fac = function(te) {
									return new(te || Q)
								}, Q.\u0275mod = p.oAB({
									type: Q
								}), Q.\u0275inj = p.cJS({}), Q
							})()
					}, 5903: (be, ue, E) => {
						E.d(ue, {
							Eq: () => ee,
							HM: () => P,
							Ig: () => y,
							fI: () => N,
							su: () => D
						});
						var p = E(3991);

						function y(G) {
							return null != G && "false" != `${G}`
						}

						function D(G, Q = 0) {
							return function z(G) {
								return !isNaN(parseFloat(G)) && !isNaN(Number(G))
							}(G) ? Number(G) : Q
						}

						function ee(G) {
							return Array.isArray(G) ? G : [G]
						}

						function P(G) {
							return null == G ? "" : "string" == typeof G ? G : `${G}px`
						}

						function N(G) {
							return G instanceof p.SBq ? G.nativeElement : G
						}
					}, 849: (be, ue, E) => {
						E.d(ue, {
							JU: () => P,
							MW: () => pe,
							Vb: () => mt,
							b2: () => st,
							hY: () => X,
							jx: () => N,
							zL: () => Y
						});
						const P = 16,
							N = 17,
							Y = 18,
							X = 27,
							pe = 91,
							st = 224;

						function mt(Et, ...Gt) {
							return Gt.length ? Gt.some(Rt => Et[Rt]) : Et.altKey || Et.shiftKey || Et.ctrlKey || Et.metaKey
						}
					}, 5999: (be, ue, E) => {
						E.d(ue, {
							Yg: () => F,
							u3: () => Ee
						});
						var p = E(3991),
							y = E(5903),
							D = E(8264),
							z = E(754),
							ee = E(1785),
							P = E(4070),
							N = E(2653),
							Y = E(4276),
							G = E(9435),
							Q = E(7580),
							X = E(1743),
							te = E(3),
							ie = E(1329);
						const we = new Set;
						let Fe, Le = (() => {
							class Ue {
								constructor(Ge) {
									this._platform = Ge, this._matchMedia = this._platform.isBrowser && window.matchMedia ? window.matchMedia.bind(window) : Ce
								}
								matchMedia(Ge) {
									return (this._platform.WEBKIT || this._platform.BLINK) && function je(Ue) {
										if (!we.has(Ue)) try {
											Fe || (Fe = document.createElement("style"), Fe.setAttribute("type", "text/css"), document.head.appendChild(Fe)), Fe.sheet && (Fe.sheet.insertRule(`@media ${Ue} {body{ }}`, 0), we.add(Ue))
										} catch (ke) {
											console.error(ke)
										}
									}(Ge), this._matchMedia(Ge)
								}
							}
							return Ue.\u0275fac = function(Ge) {
								return new(Ge || Ue)(p.LFG(ie.t4))
							}, Ue.\u0275prov = p.Yz7({
								token: Ue,
								factory: Ue.\u0275fac,
								providedIn: "root"
							}), Ue
						})();

						function Ce(Ue) {
							return {
								matches: "all" === Ue || "" === Ue,
								media: Ue,
								addListener: () => {},
								removeListener: () => {}
							}
						}
						let F = (() => {
							class Ue {
								constructor(Ge, ft) {
									this._mediaMatcher = Ge, this._zone = ft, this._queries = new Map, this._destroySubject = new D.x
								}
								ngOnDestroy() {
									this._destroySubject.next(), this._destroySubject.complete()
								}
								isMatched(Ge) {
									return xe((0, y.Eq)(Ge)).some(nt => this._registerQuery(nt).mql.matches)
								}
								observe(Ge) {
									const nt = xe((0, y.Eq)(Ge)).map(at => this._registerQuery(at).observable);
									let Pt = (0, z.a)(nt);
									return Pt = (0, ee.z)(Pt.pipe((0, N.q)(1)), Pt.pipe((0, Y.T)(1), (0, G.b)(0))), Pt.pipe((0, Q.U)(at => {
										const lt = {
											matches: !1,
											breakpoints: {}
										};
										return at.forEach(({
											matches: et,
											query: Se
										}) => {
											lt.matches = lt.matches || et, lt.breakpoints[Se] = et
										}), lt
									}))
								}
								_registerQuery(Ge) {
									if (this._queries.has(Ge)) return this._queries.get(Ge);
									const ft = this._mediaMatcher.matchMedia(Ge),
										Pt = {
											observable: new P.y(at => {
												const lt = et => this._zone.run(() => at.next(et));
												return ft.addListener(lt), () => {
													ft.removeListener(lt)
												}
											}).pipe((0, X.O)(ft), (0, Q.U)(({
												matches: at
											}) => ({
												query: Ge,
												matches: at
											})), (0, te.R)(this._destroySubject)),
											mql: ft
										};
									return this._queries.set(Ge, Pt), Pt
								}
							}
							return Ue.\u0275fac = function(Ge) {
								return new(Ge || Ue)(p.LFG(Le), p.LFG(p.R0b))
							}, Ue.\u0275prov = p.Yz7({
								token: Ue,
								factory: Ue.\u0275fac,
								providedIn: "root"
							}), Ue
						})();

						function xe(Ue) {
							return Ue.map(ke => ke.split(",")).reduce((ke, Ge) => ke.concat(Ge)).map(ke => ke.trim())
						}
						const Ee = {
							XSmall: "(max-width: 599.98px)",
							Small: "(min-width: 600px) and (max-width: 959.98px)",
							Medium: "(min-width: 960px) and (max-width: 1279.98px)",
							Large: "(min-width: 1280px) and (max-width: 1919.98px)",
							XLarge: "(min-width: 1920px)",
							Handset: "(max-width: 599.98px) and (orientation: portrait), (max-width: 959.98px) and (orientation: landscape)",
							Tablet: "(min-width: 600px) and (max-width: 839.98px) and (orientation: portrait), (min-width: 960px) and (max-width: 1279.98px) and (orientation: landscape)",
							Web: "(min-width: 840px) and (orientation: portrait), (min-width: 1280px) and (orientation: landscape)",
							HandsetPortrait: "(max-width: 599.98px) and (orientation: portrait)",
							TabletPortrait: "(min-width: 600px) and (max-width: 839.98px) and (orientation: portrait)",
							WebPortrait: "(min-width: 840px) and (orientation: portrait)",
							HandsetLandscape: "(max-width: 959.98px) and (orientation: landscape)",
							TabletLandscape: "(min-width: 960px) and (max-width: 1279.98px) and (orientation: landscape)",
							WebLandscape: "(min-width: 1280px) and (orientation: landscape)"
						}
					}, 906: (be, ue, E) => {
						E.d(ue, {
							tR: () => B,
							aV: () => Zn,
							X_: () => De,
							Xj: () => an,
							U8: () => $r,
							Iu: () => xt
						});
						var p = E(5903),
							y = E(3991),
							D = E(8264),
							z = E(5195),
							ee = E(4070),
							P = E(4845),
							N = E(5168),
							Y = E(2292);
						const G = {
							schedule(Ve) {
								let V = requestAnimationFrame,
									U = cancelAnimationFrame;
								const {
									delegate: fe
								} = G;
								fe && (V = fe.requestAnimationFrame, U = fe.cancelAnimationFrame);
								const f = V(T => {
									U = void 0, Ve(T)
								});
								return new Y.w0(() => U?.(f))
							},
							requestAnimationFrame(...Ve) {
								const {
									delegate: V
								} = G;
								return (V?.requestAnimationFrame || requestAnimationFrame)(...Ve)
							},
							cancelAnimationFrame(...Ve) {
								const {
									delegate: V
								} = G;
								return (V?.cancelAnimationFrame || cancelAnimationFrame)(...Ve)
							},
							delegate: void 0
						};
						var X = E(4713);
						const ie = new class te extends X.v {
							flush(V) {
								this._active = !0;
								const U = this._scheduled;
								this._scheduled = void 0;
								const {
									actions: fe
								} = this;
								let f;
								V = V || fe.shift();
								do {
									if (f = V.execute(V.state, V.delay)) break
								} while ((V = fe[0]) && V.id === U && fe.shift());
								if (this._active = !1, f) {
									for (;
										(V = fe[0]) && V.id === U && fe.shift();) V.unsubscribe();
									throw f
								}
							}
						}(class Q extends N.o {
							constructor(V, U) {
								super(V, U), this.scheduler = V, this.work = U
							}
							requestAsyncId(V, U, fe = 0) {
								return null !== fe && fe > 0 ? super.requestAsyncId(V, U, fe) : (V.actions.push(this), V._scheduled || (V._scheduled = G.requestAnimationFrame(() => V.flush(void 0))))
							}
							recycleAsyncId(V, U, fe = 0) {
								var f;
								if (null != fe ? fe > 0 : this.delay > 0) return super.recycleAsyncId(V, U, fe);
								const {
									actions: T
								} = V;
								null != U && (null === (f = T[T.length - 1]) || void 0 === f ? void 0 : f.id) !== U && (G.cancelAnimationFrame(U), V._scheduled = void 0)
							}
						});
						let Fe, we = 1;
						const Le = {};

						function je(Ve) {
							return Ve in Le && (delete Le[Ve], !0)
						}
						const Ce = {
								setImmediate(Ve) {
									const V = we++;
									return Le[V] = !0, Fe || (Fe = Promise.resolve()), Fe.then(() => je(V) && Ve()), V
								},
								clearImmediate(Ve) {
									je(Ve)
								}
							},
							{
								setImmediate: xe,
								clearImmediate: Ee
							} = Ce,
							Ue = {
								setImmediate(...Ve) {
									const {
										delegate: V
									} = Ue;
									return (V?.setImmediate || xe)(...Ve)
								},
								clearImmediate(Ve) {
									const {
										delegate: V
									} = Ue;
									return (V?.clearImmediate || Ee)(Ve)
								},
								delegate: void 0
							},
							ft = new class Ge extends X.v {
								flush(V) {
									this._active = !0;
									const U = this._scheduled;
									this._scheduled = void 0;
									const {
										actions: fe
									} = this;
									let f;
									V = V || fe.shift();
									do {
										if (f = V.execute(V.state, V.delay)) break
									} while ((V = fe[0]) && V.id === U && fe.shift());
									if (this._active = !1, f) {
										for (;
											(V = fe[0]) && V.id === U && fe.shift();) V.unsubscribe();
										throw f
									}
								}
							}(class ke extends N.o {
								constructor(V, U) {
									super(V, U), this.scheduler = V, this.work = U
								}
								requestAsyncId(V, U, fe = 0) {
									return null !== fe && fe > 0 ? super.requestAsyncId(V, U, fe) : (V.actions.push(this), V._scheduled || (V._scheduled = Ue.setImmediate(V.flush.bind(V, void 0))))
								}
								recycleAsyncId(V, U, fe = 0) {
									var f;
									if (null != fe ? fe > 0 : this.delay > 0) return super.recycleAsyncId(V, U, fe);
									const {
										actions: T
									} = V;
									null != U && (null === (f = T[T.length - 1]) || void 0 === f ? void 0 : f.id) !== U && (Ue.clearImmediate(U), V._scheduled = void 0)
								}
							});
						var Pt = E(9615),
							at = E(9681),
							lt = E(3171),
							et = E(5694),
							Be = E(2159);

						function ze(Ve, V = Pt.z) {
							return function Se(Ve) {
								return (0, at.e)((V, U) => {
									let fe = !1,
										f = null,
										T = null,
										L = !1;
									const K = () => {
											if (T?.unsubscribe(), T = null, fe) {
												fe = !1;
												const ye = f;
												f = null, U.next(ye)
											}
											L && U.complete()
										},
										he = () => {
											T = null, L && U.complete()
										};
									V.subscribe((0, et.x)(U, ye => {
										fe = !0, f = ye, T || (0, lt.Xf)(Ve(ye)).subscribe(T = (0, et.x)(U, K, he))
									}, () => {
										L = !0, (!fe || !T || T.closed) && U.complete()
									}))
								})
							}(() => (0, Be.H)(Ve, V))
						}
						var it = E(9754),
							ce = E(3),
							ht = E(1743),
							Pe = E(1329),
							pt = E(7774),
							Bt = E(8793);
						const ot = ["contentWrapper"],
							Vt = ["*"],
							Qt = new y.OlP("VIRTUAL_SCROLL_STRATEGY");
						let Un = (() => {
								class Ve {
									constructor(U, fe, f) {
										this._ngZone = U, this._platform = fe, this._scrolled = new D.x, this._globalSubscription = null, this._scrolledCount = 0, this.scrollContainers = new Map, this._document = f
									}
									register(U) {
										this.scrollContainers.has(U) || this.scrollContainers.set(U, U.elementScrolled().subscribe(() => this._scrolled.next(U)))
									}
									deregister(U) {
										const fe = this.scrollContainers.get(U);
										fe && (fe.unsubscribe(), this.scrollContainers.delete(U))
									}
									scrolled(U = 20) {
										return this._platform.isBrowser ? new ee.y(fe => {
											this._globalSubscription || this._addGlobalListener();
											const f = U > 0 ? this._scrolled.pipe(ze(U)).subscribe(fe) : this._scrolled.subscribe(fe);
											return this._scrolledCount++, () => {
												f.unsubscribe(), this._scrolledCount--, this._scrolledCount || this._removeGlobalListener()
											}
										}) : (0, z.of)()
									}
									ngOnDestroy() {
										this._removeGlobalListener(), this.scrollContainers.forEach((U, fe) => this.deregister(fe)), this._scrolled.complete()
									}
									ancestorScrolled(U, fe) {
										const f = this.getAncestorScrollContainers(U);
										return this.scrolled(fe).pipe((0, it.h)(T => !T || f.indexOf(T) > -1))
									}
									getAncestorScrollContainers(U) {
										const fe = [];
										return this.scrollContainers.forEach((f, T) => {
											this._scrollableContainsElement(T, U) && fe.push(T)
										}), fe
									}
									_getWindow() {
										return this._document.defaultView || window
									}
									_scrollableContainsElement(U, fe) {
										let f = (0, p.fI)(fe),
											T = U.getElementRef().nativeElement;
										do {
											if (f == T) return !0
										} while (f = f.parentElement);
										return !1
									}
									_addGlobalListener() {
										this._globalSubscription = this._ngZone.runOutsideAngular(() => {
											const U = this._getWindow();
											return (0, P.R)(U.document, "scroll").subscribe(() => this._scrolled.next())
										})
									}
									_removeGlobalListener() {
										this._globalSubscription && (this._globalSubscription.unsubscribe(), this._globalSubscription = null)
									}
								}
								return Ve.\u0275fac = function(U) {
									return new(U || Ve)(y.LFG(y.R0b), y.LFG(Pe.t4), y.LFG(pt.K0, 8))
								}, Ve.\u0275prov = y.Yz7({
									token: Ve,
									factory: Ve.\u0275fac,
									providedIn: "root"
								}), Ve
							})(),
							Kn = (() => {
								class Ve {
									constructor(U, fe, f, T) {
										this.elementRef = U, this.scrollDispatcher = fe, this.ngZone = f, this.dir = T, this._destroyed = new D.x, this._elementScrolled = new ee.y(L => this.ngZone.runOutsideAngular(() => (0, P.R)(this.elementRef.nativeElement, "scroll").pipe((0, ce.R)(this._destroyed)).subscribe(L)))
									}
									ngOnInit() {
										this.scrollDispatcher.register(this)
									}
									ngOnDestroy() {
										this.scrollDispatcher.deregister(this), this._destroyed.next(), this._destroyed.complete()
									}
									elementScrolled() {
										return this._elementScrolled
									}
									getElementRef() {
										return this.elementRef
									}
									scrollTo(U) {
										const fe = this.elementRef.nativeElement,
											f = this.dir && "rtl" == this.dir.value;
										null == U.left && (U.left = f ? U.end : U.start), null == U.right && (U.right = f ? U.start : U.end), null != U.bottom && (U.top = fe.scrollHeight - fe.clientHeight - U.bottom), f && 0 != (0, Pe._i)() ? (null != U.left && (U.right = fe.scrollWidth - fe.clientWidth - U.left), 2 == (0, Pe._i)() ? U.left = U.right : 1 == (0, Pe._i)() && (U.left = U.right ? -U.right : U.right)) : null != U.right && (U.left = fe.scrollWidth - fe.clientWidth - U.right), this._applyScrollToOptions(U)
									}
									_applyScrollToOptions(U) {
										const fe = this.elementRef.nativeElement;
										(0, Pe.Mq)() ? fe.scrollTo(U): (null != U.top && (fe.scrollTop = U.top), null != U.left && (fe.scrollLeft = U.left))
									}
									measureScrollOffset(U) {
										const fe = "left",
											f = "right",
											T = this.elementRef.nativeElement;
										if ("top" == U) return T.scrollTop;
										if ("bottom" == U) return T.scrollHeight - T.clientHeight - T.scrollTop;
										const L = this.dir && "rtl" == this.dir.value;
										return "start" == U ? U = L ? f : fe : "end" == U && (U = L ? fe : f), L && 2 == (0, Pe._i)() ? U == fe ? T.scrollWidth - T.clientWidth - T.scrollLeft : T.scrollLeft : L && 1 == (0, Pe._i)() ? U == fe ? T.scrollLeft + T.scrollWidth - T.clientWidth : -T.scrollLeft : U == fe ? T.scrollLeft : T.scrollWidth - T.clientWidth - T.scrollLeft
									}
								}
								return Ve.\u0275fac = function(U) {
									return new(U || Ve)(y.Y36(y.SBq), y.Y36(Un), y.Y36(y.R0b), y.Y36(Bt.Is, 8))
								}, Ve.\u0275dir = y.lG2({
									type: Ve,
									selectors: [
										["", "cdk-scrollable", ""],
										["", "cdkScrollable", ""]
									],
									standalone: !0
								}), Ve
							})(),
							Zt = (() => {
								class Ve {
									constructor(U, fe, f) {
										this._platform = U, this._change = new D.x, this._changeListener = T => {
											this._change.next(T)
										}, this._document = f, fe.runOutsideAngular(() => {
											if (U.isBrowser) {
												const T = this._getWindow();
												T.addEventListener("resize", this._changeListener), T.addEventListener("orientationchange", this._changeListener)
											}
											this.change().subscribe(() => this._viewportSize = null)
										})
									}
									ngOnDestroy() {
										if (this._platform.isBrowser) {
											const U = this._getWindow();
											U.removeEventListener("resize", this._changeListener), U.removeEventListener("orientationchange", this._changeListener)
										}
										this._change.complete()
									}
									getViewportSize() {
										this._viewportSize || this._updateViewportSize();
										const U = {
											width: this._viewportSize.width,
											height: this._viewportSize.height
										};
										return this._platform.isBrowser || (this._viewportSize = null), U
									}
									getViewportRect() {
										const U = this.getViewportScrollPosition(),
											{
												width: fe,
												height: f
											} = this.getViewportSize();
										return {
											top: U.top,
											left: U.left,
											bottom: U.top + f,
											right: U.left + fe,
											height: f,
											width: fe
										}
									}
									getViewportScrollPosition() {
										if (!this._platform.isBrowser) return {
											top: 0,
											left: 0
										};
										const U = this._document,
											fe = this._getWindow(),
											f = U.documentElement,
											T = f.getBoundingClientRect();
										return {
											top: -T.top || U.body.scrollTop || fe.scrollY || f.scrollTop || 0,
											left: -T.left || U.body.scrollLeft || fe.scrollX || f.scrollLeft || 0
										}
									}
									change(U = 20) {
										return U > 0 ? this._change.pipe(ze(U)) : this._change
									}
									_getWindow() {
										return this._document.defaultView || window
									}
									_updateViewportSize() {
										const U = this._getWindow();
										this._viewportSize = this._platform.isBrowser ? {
											width: U.innerWidth,
											height: U.innerHeight
										} : {
											width: 0,
											height: 0
										}
									}
								}
								return Ve.\u0275fac = function(U) {
									return new(U || Ve)(y.LFG(Pe.t4), y.LFG(y.R0b), y.LFG(pt.K0, 8))
								}, Ve.\u0275prov = y.Yz7({
									token: Ve,
									factory: Ve.\u0275fac,
									providedIn: "root"
								}), Ve
							})();
						const bn = new y.OlP("VIRTUAL_SCROLLABLE");
						let Bn = (() => {
							class Ve extends Kn {
								constructor(U, fe, f, T) {
									super(U, fe, f, T)
								}
								measureViewportSize(U) {
									const fe = this.elementRef.nativeElement;
									return "horizontal" === U ? fe.clientWidth : fe.clientHeight
								}
							}
							return Ve.\u0275fac = function(U) {
								return new(U || Ve)(y.Y36(y.SBq), y.Y36(Un), y.Y36(y.R0b), y.Y36(Bt.Is, 8))
							}, Ve.\u0275dir = y.lG2({
								type: Ve,
								features: [y.qOj]
							}), Ve
						})();
						const tn = typeof requestAnimationFrame < "u" ? ie : ft;
						let en = (() => {
								class Ve extends Bn {
									get orientation() {
										return this._orientation
									}
									set orientation(U) {
										this._orientation !== U && (this._orientation = U, this._calculateSpacerSize())
									}
									get appendOnly() {
										return this._appendOnly
									}
									set appendOnly(U) {
										this._appendOnly = (0, p.Ig)(U)
									}
									constructor(U, fe, f, T, L, K, he, ye) {
										super(U, K, f, L), this.elementRef = U, this._changeDetectorRef = fe, this._scrollStrategy = T, this.scrollable = ye, this._platform = (0, y.f3M)(Pe.t4), this._detachedSubject = new D.x, this._renderedRangeSubject = new D.x, this._orientation = "vertical", this._appendOnly = !1, this.scrolledIndexChange = new ee.y(He => this._scrollStrategy.scrolledIndexChange.subscribe(gt => Promise.resolve().then(() => this.ngZone.run(() => He.next(gt))))), this.renderedRangeStream = this._renderedRangeSubject, this._totalContentSize = 0, this._totalContentWidth = "", this._totalContentHeight = "", this._renderedRange = {
											start: 0,
											end: 0
										}, this._dataLength = 0, this._viewportSize = 0, this._renderedContentOffset = 0, this._renderedContentOffsetNeedsRewrite = !1, this._isChangeDetectionPending = !1, this._runAfterChangeDetection = [], this._viewportChanges = Y.w0.EMPTY, this._viewportChanges = he.change().subscribe(() => {
											this.checkViewportSize()
										}), this.scrollable || (this.elementRef.nativeElement.classList.add("cdk-virtual-scrollable"), this.scrollable = this)
									}
									ngOnInit() {
										this._platform.isBrowser && (this.scrollable === this && super.ngOnInit(), this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {
											this._measureViewportSize(), this._scrollStrategy.attach(this), this.scrollable.elementScrolled().pipe((0, ht.O)(null), ze(0, tn)).subscribe(() => this._scrollStrategy.onContentScrolled()), this._markChangeDetectionNeeded()
										})))
									}
									ngOnDestroy() {
										this.detach(), this._scrollStrategy.detach(), this._renderedRangeSubject.complete(), this._detachedSubject.complete(), this._viewportChanges.unsubscribe(), super.ngOnDestroy()
									}
									attach(U) {
										this.ngZone.runOutsideAngular(() => {
											this._forOf = U, this._forOf.dataStream.pipe((0, ce.R)(this._detachedSubject)).subscribe(fe => {
												const f = fe.length;
												f !== this._dataLength && (this._dataLength = f, this._scrollStrategy.onDataLengthChanged()), this._doChangeDetection()
											})
										})
									}
									detach() {
										this._forOf = null, this._detachedSubject.next()
									}
									getDataLength() {
										return this._dataLength
									}
									getViewportSize() {
										return this._viewportSize
									}
									getRenderedRange() {
										return this._renderedRange
									}
									measureBoundingClientRectWithScrollOffset(U) {
										return this.getElementRef().nativeElement.getBoundingClientRect()[U]
									}
									setTotalContentSize(U) {
										this._totalContentSize !== U && (this._totalContentSize = U, this._calculateSpacerSize(), this._markChangeDetectionNeeded())
									}
									setRenderedRange(U) {
										(function qt(Ve, V) {
											return Ve.start == V.start && Ve.end == V.end
										})(this._renderedRange, U) || (this.appendOnly && (U = {
											start: 0,
											end: Math.max(this._renderedRange.end, U.end)
										}), this._renderedRangeSubject.next(this._renderedRange = U), this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered()))
									}
									getOffsetToRenderedContentStart() {
										return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset
									}
									setRenderedContentOffset(U, fe = "to-start") {
										U = this.appendOnly && "to-start" === fe ? 0 : U;
										const T = "horizontal" == this.orientation,
											L = T ? "X" : "Y";
										let he = `translate${L}(${Number((T&&this.dir&&"rtl"==this.dir.value?-1:1)*U)}px)`;
										this._renderedContentOffset = U, "to-end" === fe && (he += ` translate${L}(-100%)`, this._renderedContentOffsetNeedsRewrite = !0), this._renderedContentTransform != he && (this._renderedContentTransform = he, this._markChangeDetectionNeeded(() => {
											this._renderedContentOffsetNeedsRewrite ? (this._renderedContentOffset -= this.measureRenderedContentSize(), this._renderedContentOffsetNeedsRewrite = !1, this.setRenderedContentOffset(this._renderedContentOffset)) : this._scrollStrategy.onRenderedOffsetChanged()
										}))
									}
									scrollToOffset(U, fe = "auto") {
										const f = {
											behavior: fe
										};
										"horizontal" === this.orientation ? f.start = U : f.top = U, this.scrollable.scrollTo(f)
									}
									scrollToIndex(U, fe = "auto") {
										this._scrollStrategy.scrollToIndex(U, fe)
									}
									measureScrollOffset(U) {
										let fe;
										return fe = this.scrollable == this ? f => super.measureScrollOffset(f) : f => this.scrollable.measureScrollOffset(f), Math.max(0, fe(U ?? ("horizontal" === this.orientation ? "start" : "top")) - this.measureViewportOffset())
									}
									measureViewportOffset(U) {
										let fe;
										const f = "left",
											T = "right",
											L = "rtl" == this.dir?.value;
										fe = "start" == U ? L ? T : f : "end" == U ? L ? f : T : U || ("horizontal" === this.orientation ? "left" : "top");
										const K = this.scrollable.measureBoundingClientRectWithScrollOffset(fe);
										return this.elementRef.nativeElement.getBoundingClientRect()[fe] - K
									}
									measureRenderedContentSize() {
										const U = this._contentWrapper.nativeElement;
										return "horizontal" === this.orientation ? U.offsetWidth : U.offsetHeight
									}
									measureRangeSize(U) {
										return this._forOf ? this._forOf.measureRangeSize(U, this.orientation) : 0
									}
									checkViewportSize() {
										this._measureViewportSize(), this._scrollStrategy.onDataLengthChanged()
									}
									_measureViewportSize() {
										this._viewportSize = this.scrollable.measureViewportSize(this.orientation)
									}
									_markChangeDetectionNeeded(U) {
										U && this._runAfterChangeDetection.push(U), this._isChangeDetectionPending || (this._isChangeDetectionPending = !0, this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {
											this._doChangeDetection()
										})))
									}
									_doChangeDetection() {
										this._isChangeDetectionPending = !1, this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform, this.ngZone.run(() => this._changeDetectorRef.markForCheck());
										const U = this._runAfterChangeDetection;
										this._runAfterChangeDetection = [];
										for (const fe of U) fe()
									}
									_calculateSpacerSize() {
										this._totalContentHeight = "horizontal" === this.orientation ? "" : `${this._totalContentSize}px`, this._totalContentWidth = "horizontal" === this.orientation ? `${this._totalContentSize}px` : ""
									}
								}
								return Ve.\u0275fac = function(U) {
									return new(U || Ve)(y.Y36(y.SBq), y.Y36(y.sBO), y.Y36(y.R0b), y.Y36(Qt, 8), y.Y36(Bt.Is, 8), y.Y36(Un), y.Y36(Zt), y.Y36(bn, 8))
								}, Ve.\u0275cmp = y.Xpm({
									type: Ve,
									selectors: [
										["cdk-virtual-scroll-viewport"]
									],
									viewQuery: function(U, fe) {
										if (1 & U && y.Gf(ot, 7), 2 & U) {
											let f;
											y.iGM(f = y.CRH()) && (fe._contentWrapper = f.first)
										}
									},
									hostAttrs: [1, "cdk-virtual-scroll-viewport"],
									hostVars: 4,
									hostBindings: function(U, fe) {
										2 & U && y.ekj("cdk-virtual-scroll-orientation-horizontal", "horizontal" === fe.orientation)("cdk-virtual-scroll-orientation-vertical", "horizontal" !== fe.orientation)
									},
									inputs: {
										orientation: "orientation",
										appendOnly: "appendOnly"
									},
									outputs: {
										scrolledIndexChange: "scrolledIndexChange"
									},
									standalone: !0,
									features: [y._Bn([{
										provide: Kn,
										useFactory: (V, U) => V || U,
										deps: [
											[new y.FiY, new y.tBr(bn)], Ve
										]
									}]), y.qOj, y.jDz],
									ngContentSelectors: Vt,
									decls: 4,
									vars: 4,
									consts: [
										[1, "cdk-virtual-scroll-content-wrapper"],
										["contentWrapper", ""],
										[1, "cdk-virtual-scroll-spacer"]
									],
									template: function(U, fe) {
										1 & U && (y.F$t(), y.TgZ(0, "div", 0, 1), y.Hsn(2), y.qZA(), y._UZ(3, "div", 2)), 2 & U && (y.xp6(3), y.Udp("width", fe._totalContentWidth)("height", fe._totalContentHeight))
									},
									styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}"],
									encapsulation: 2,
									changeDetection: 0
								}), Ve
							})(),
							hr = (() => {
								class Ve {}
								return Ve.\u0275fac = function(U) {
									return new(U || Ve)
								}, Ve.\u0275mod = y.oAB({
									type: Ve
								}), Ve.\u0275inj = y.cJS({}), Ve
							})(),
							un = (() => {
								class Ve {}
								return Ve.\u0275fac = function(U) {
									return new(U || Ve)
								}, Ve.\u0275mod = y.oAB({
									type: Ve
								}), Ve.\u0275inj = y.cJS({
									imports: [Bt.vT, hr, en, Bt.vT, hr]
								}), Ve
							})();
						var Nt = E(7444),
							Xe = E(805),
							pe = E(2653);
						const Te = (0, Pe.Mq)();
						class Je {
							constructor(V, U) {
								this._viewportRuler = V, this._previousHTMLStyles = {
									top: "",
									left: ""
								}, this._isEnabled = !1, this._document = U
							}
							attach() {}
							enable() {
								if (this._canBeEnabled()) {
									const V = this._document.documentElement;
									this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition(), this._previousHTMLStyles.left = V.style.left || "", this._previousHTMLStyles.top = V.style.top || "", V.style.left = (0, p.HM)(-this._previousScrollPosition.left), V.style.top = (0, p.HM)(-this._previousScrollPosition.top), V.classList.add("cdk-global-scrollblock"), this._isEnabled = !0
								}
							}
							disable() {
								if (this._isEnabled) {
									const V = this._document.documentElement,
										fe = V.style,
										f = this._document.body.style,
										T = fe.scrollBehavior || "",
										L = f.scrollBehavior || "";
									this._isEnabled = !1, fe.left = this._previousHTMLStyles.left, fe.top = this._previousHTMLStyles.top, V.classList.remove("cdk-global-scrollblock"), Te && (fe.scrollBehavior = f.scrollBehavior = "auto"), window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top), Te && (fe.scrollBehavior = T, f.scrollBehavior = L)
								}
							}
							_canBeEnabled() {
								if (this._document.documentElement.classList.contains("cdk-global-scrollblock") || this._isEnabled) return !1;
								const U = this._document.body,
									fe = this._viewportRuler.getViewportSize();
								return U.scrollHeight > fe.height || U.scrollWidth > fe.width
							}
						}
						class Ht {
							constructor(V, U, fe, f) {
								this._scrollDispatcher = V, this._ngZone = U, this._viewportRuler = fe, this._config = f, this._scrollSubscription = null, this._detach = () => {
									this.disable(), this._overlayRef.hasAttached() && this._ngZone.run(() => this._overlayRef.detach())
								}
							}
							attach(V) {
								this._overlayRef = V
							}
							enable() {
								if (this._scrollSubscription) return;
								const V = this._scrollDispatcher.scrolled(0);
								this._config && this._config.threshold && this._config.threshold > 1 ? (this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top, this._scrollSubscription = V.subscribe(() => {
									const U = this._viewportRuler.getViewportScrollPosition().top;
									Math.abs(U - this._initialScrollPosition) > this._config.threshold ? this._detach() : this._overlayRef.updatePosition()
								})) : this._scrollSubscription = V.subscribe(this._detach)
							}
							disable() {
								this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null)
							}
							detach() {
								this.disable(), this._overlayRef = null
							}
						}
						class pn {
							enable() {}
							disable() {}
							attach() {}
						}

						function $t(Ve, V) {
							return V.some(U => Ve.bottom < U.top || Ve.top > U.bottom || Ve.right < U.left || Ve.left > U.right)
						}

						function hn(Ve, V) {
							return V.some(U => Ve.top < U.top || Ve.bottom > U.bottom || Ve.left < U.left || Ve.right > U.right)
						}
						class kt {
							constructor(V, U, fe, f) {
								this._scrollDispatcher = V, this._viewportRuler = U, this._ngZone = fe, this._config = f, this._scrollSubscription = null
							}
							attach(V) {
								this._overlayRef = V
							}
							enable() {
								this._scrollSubscription || (this._scrollSubscription = this._scrollDispatcher.scrolled(this._config ? this._config.scrollThrottle : 0).subscribe(() => {
									if (this._overlayRef.updatePosition(), this._config && this._config.autoClose) {
										const U = this._overlayRef.overlayElement.getBoundingClientRect(),
											{
												width: fe,
												height: f
											} = this._viewportRuler.getViewportSize();
										$t(U, [{
											width: fe,
											height: f,
											bottom: f,
											right: fe,
											top: 0,
											left: 0
										}]) && (this.disable(), this._ngZone.run(() => this._overlayRef.detach()))
									}
								}))
							}
							disable() {
								this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null)
							}
							detach() {
								this.disable(), this._overlayRef = null
							}
						}
						let ct = (() => {
							class Ve {
								constructor(U, fe, f, T) {
									this._scrollDispatcher = U, this._viewportRuler = fe, this._ngZone = f, this.noop = () => new pn, this.close = L => new Ht(this._scrollDispatcher, this._ngZone, this._viewportRuler, L), this.block = () => new Je(this._viewportRuler, this._document), this.reposition = L => new kt(this._scrollDispatcher, this._viewportRuler, this._ngZone, L), this._document = T
								}
							}
							return Ve.\u0275fac = function(U) {
								return new(U || Ve)(y.LFG(Un), y.LFG(Zt), y.LFG(y.R0b), y.LFG(pt.K0))
							}, Ve.\u0275prov = y.Yz7({
								token: Ve,
								factory: Ve.\u0275fac,
								providedIn: "root"
							}), Ve
						})();
						class De {
							constructor(V) {
								if (this.scrollStrategy = new pn, this.panelClass = "", this.hasBackdrop = !1, this.backdropClass = "cdk-overlay-dark-backdrop", this.disposeOnNavigation = !1, V) {
									const U = Object.keys(V);
									for (const fe of U) void 0 !== V[fe] && (this[fe] = V[fe])
								}
							}
						}
						class B {
							constructor(V, U, fe, f, T) {
								this.offsetX = fe, this.offsetY = f, this.panelClass = T, this.originX = V.originX, this.originY = V.originY, this.overlayX = U.overlayX, this.overlayY = U.overlayY
							}
						}
						class k {
							constructor(V, U) {
								this.connectionPair = V, this.scrollableViewProperties = U
							}
						}
						let Ne = (() => {
								class Ve {
									constructor(U) {
										this._attachedOverlays = [], this._document = U
									}
									ngOnDestroy() {
										this.detach()
									}
									add(U) {
										this.remove(U), this._attachedOverlays.push(U)
									}
									remove(U) {
										const fe = this._attachedOverlays.indexOf(U);
										fe > -1 && this._attachedOverlays.splice(fe, 1), 0 === this._attachedOverlays.length && this.detach()
									}
								}
								return Ve.\u0275fac = function(U) {
									return new(U || Ve)(y.LFG(pt.K0))
								}, Ve.\u0275prov = y.Yz7({
									token: Ve,
									factory: Ve.\u0275fac,
									providedIn: "root"
								}), Ve
							})(),
							Ye = (() => {
								class Ve extends Ne {
									constructor(U, fe) {
										super(U), this._ngZone = fe, this._keydownListener = f => {
											const T = this._attachedOverlays;
											for (let L = T.length - 1; L > -1; L--)
												if (T[L]._keydownEvents.observers.length > 0) {
													const K = T[L]._keydownEvents;
													this._ngZone ? this._ngZone.run(() => K.next(f)) : K.next(f);
													break
												}
										}
									}
									add(U) {
										super.add(U), this._isAttached || (this._ngZone ? this._ngZone.runOutsideAngular(() => this._document.body.addEventListener("keydown", this._keydownListener)) : this._document.body.addEventListener("keydown", this._keydownListener), this._isAttached = !0)
									}
									detach() {
										this._isAttached && (this._document.body.removeEventListener("keydown", this._keydownListener), this._isAttached = !1)
									}
								}
								return Ve.\u0275fac = function(U) {
									return new(U || Ve)(y.LFG(pt.K0), y.LFG(y.R0b, 8))
								}, Ve.\u0275prov = y.Yz7({
									token: Ve,
									factory: Ve.\u0275fac,
									providedIn: "root"
								}), Ve
							})(),
							Ft = (() => {
								class Ve extends Ne {
									constructor(U, fe, f) {
										super(U), this._platform = fe, this._ngZone = f, this._cursorStyleIsSet = !1, this._pointerDownListener = T => {
											this._pointerDownEventTarget = (0, Pe.sA)(T)
										}, this._clickListener = T => {
											const L = (0, Pe.sA)(T),
												K = "click" === T.type && this._pointerDownEventTarget ? this._pointerDownEventTarget : L;
											this._pointerDownEventTarget = null;
											const he = this._attachedOverlays.slice();
											for (let ye = he.length - 1; ye > -1; ye--) {
												const He = he[ye];
												if (He._outsidePointerEvents.observers.length < 1 || !He.hasAttached()) continue;
												if (He.overlayElement.contains(L) || He.overlayElement.contains(K)) break;
												const gt = He._outsidePointerEvents;
												this._ngZone ? this._ngZone.run(() => gt.next(T)) : gt.next(T)
											}
										}
									}
									add(U) {
										if (super.add(U), !this._isAttached) {
											const fe = this._document.body;
											this._ngZone ? this._ngZone.runOutsideAngular(() => this._addEventListeners(fe)) : this._addEventListeners(fe), this._platform.IOS && !this._cursorStyleIsSet && (this._cursorOriginalValue = fe.style.cursor, fe.style.cursor = "pointer", this._cursorStyleIsSet = !0), this._isAttached = !0
										}
									}
									detach() {
										if (this._isAttached) {
											const U = this._document.body;
											U.removeEventListener("pointerdown", this._pointerDownListener, !0), U.removeEventListener("click", this._clickListener, !0), U.removeEventListener("auxclick", this._clickListener, !0), U.removeEventListener("contextmenu", this._clickListener, !0), this._platform.IOS && this._cursorStyleIsSet && (U.style.cursor = this._cursorOriginalValue, this._cursorStyleIsSet = !1), this._isAttached = !1
										}
									}
									_addEventListeners(U) {
										U.addEventListener("pointerdown", this._pointerDownListener, !0), U.addEventListener("click", this._clickListener, !0), U.addEventListener("auxclick", this._clickListener, !0), U.addEventListener("contextmenu", this._clickListener, !0)
									}
								}
								return Ve.\u0275fac = function(U) {
									return new(U || Ve)(y.LFG(pt.K0), y.LFG(Pe.t4), y.LFG(y.R0b, 8))
								}, Ve.\u0275prov = y.Yz7({
									token: Ve,
									factory: Ve.\u0275fac,
									providedIn: "root"
								}), Ve
							})(),
							an = (() => {
								class Ve {
									constructor(U, fe) {
										this._platform = fe, this._document = U
									}
									ngOnDestroy() {
										this._containerElement?.remove()
									}
									getContainerElement() {
										return this._containerElement || this._createContainer(), this._containerElement
									}
									_createContainer() {
										const U = "cdk-overlay-container";
										if (this._platform.isBrowser || (0, Pe.Oy)()) {
											const f = this._document.querySelectorAll(`.${U}[platform="server"], .${U}[platform="test"]`);
											for (let T = 0; T < f.length; T++) f[T].remove()
										}
										const fe = this._document.createElement("div");
										fe.classList.add(U), (0, Pe.Oy)() ? fe.setAttribute("platform", "test") : this._platform.isBrowser || fe.setAttribute("platform", "server"), this._document.body.appendChild(fe), this._containerElement = fe
									}
								}
								return Ve.\u0275fac = function(U) {
									return new(U || Ve)(y.LFG(pt.K0), y.LFG(Pe.t4))
								}, Ve.\u0275prov = y.Yz7({
									token: Ve,
									factory: Ve.\u0275fac,
									providedIn: "root"
								}), Ve
							})();
						class xt {
							constructor(V, U, fe, f, T, L, K, he, ye, He = !1) {
								this._portalOutlet = V, this._host = U, this._pane = fe, this._config = f, this._ngZone = T, this._keyboardDispatcher = L, this._document = K, this._location = he, this._outsideClickDispatcher = ye, this._animationsDisabled = He, this._backdropElement = null, this._backdropClick = new D.x, this._attachments = new D.x, this._detachments = new D.x, this._locationChanges = Y.w0.EMPTY, this._backdropClickHandler = gt => this._backdropClick.next(gt), this._backdropTransitionendHandler = gt => {
									this._disposeBackdrop(gt.target)
								}, this._keydownEvents = new D.x, this._outsidePointerEvents = new D.x, f.scrollStrategy && (this._scrollStrategy = f.scrollStrategy, this._scrollStrategy.attach(this)), this._positionStrategy = f.positionStrategy
							}
							get overlayElement() {
								return this._pane
							}
							get backdropElement() {
								return this._backdropElement
							}
							get hostElement() {
								return this._host
							}
							attach(V) {
								!this._host.parentElement && this._previousHostParent && this._previousHostParent.appendChild(this._host);
								const U = this._portalOutlet.attach(V);
								return this._positionStrategy && this._positionStrategy.attach(this), this._updateStackingOrder(), this._updateElementSize(), this._updateElementDirection(), this._scrollStrategy && this._scrollStrategy.enable(), this._ngZone.onStable.pipe((0, pe.q)(1)).subscribe(() => {
									this.hasAttached() && this.updatePosition()
								}), this._togglePointerEvents(!0), this._config.hasBackdrop && this._attachBackdrop(), this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !0), this._attachments.next(), this._keyboardDispatcher.add(this), this._config.disposeOnNavigation && (this._locationChanges = this._location.subscribe(() => this.dispose())), this._outsideClickDispatcher.add(this), "function" == typeof U?.onDestroy && U.onDestroy(() => {
									this.hasAttached() && this._ngZone.runOutsideAngular(() => Promise.resolve().then(() => this.detach()))
								}), U
							}
							detach() {
								if (!this.hasAttached()) return;
								this.detachBackdrop(), this._togglePointerEvents(!1), this._positionStrategy && this._positionStrategy.detach && this._positionStrategy.detach(), this._scrollStrategy && this._scrollStrategy.disable();
								const V = this._portalOutlet.detach();
								return this._detachments.next(), this._keyboardDispatcher.remove(this), this._detachContentWhenStable(), this._locationChanges.unsubscribe(), this._outsideClickDispatcher.remove(this), V
							}
							dispose() {
								const V = this.hasAttached();
								this._positionStrategy && this._positionStrategy.dispose(), this._disposeScrollStrategy(), this._disposeBackdrop(this._backdropElement), this._locationChanges.unsubscribe(), this._keyboardDispatcher.remove(this), this._portalOutlet.dispose(), this._attachments.complete(), this._backdropClick.complete(), this._keydownEvents.complete(), this._outsidePointerEvents.complete(), this._outsideClickDispatcher.remove(this), this._host?.remove(), this._previousHostParent = this._pane = this._host = null, V && this._detachments.next(), this._detachments.complete()
							}
							hasAttached() {
								return this._portalOutlet.hasAttached()
							}
							backdropClick() {
								return this._backdropClick
							}
							attachments() {
								return this._attachments
							}
							detachments() {
								return this._detachments
							}
							keydownEvents() {
								return this._keydownEvents
							}
							outsidePointerEvents() {
								return this._outsidePointerEvents
							}
							getConfig() {
								return this._config
							}
							updatePosition() {
								this._positionStrategy && this._positionStrategy.apply()
							}
							updatePositionStrategy(V) {
								V !== this._positionStrategy && (this._positionStrategy && this._positionStrategy.dispose(), this._positionStrategy = V, this.hasAttached() && (V.attach(this), this.updatePosition()))
							}
							updateSize(V) {
								this._config = {
									...this._config,
									...V
								}, this._updateElementSize()
							}
							setDirection(V) {
								this._config = {
									...this._config,
									direction: V
								}, this._updateElementDirection()
							}
							addPanelClass(V) {
								this._pane && this._toggleClasses(this._pane, V, !0)
							}
							removePanelClass(V) {
								this._pane && this._toggleClasses(this._pane, V, !1)
							}
							getDirection() {
								const V = this._config.direction;
								return V ? "string" == typeof V ? V : V.value : "ltr"
							}
							updateScrollStrategy(V) {
								V !== this._scrollStrategy && (this._disposeScrollStrategy(), this._scrollStrategy = V, this.hasAttached() && (V.attach(this), V.enable()))
							}
							_updateElementDirection() {
								this._host.setAttribute("dir", this.getDirection())
							}
							_updateElementSize() {
								if (!this._pane) return;
								const V = this._pane.style;
								V.width = (0, p.HM)(this._config.width), V.height = (0, p.HM)(this._config.height), V.minWidth = (0, p.HM)(this._config.minWidth), V.minHeight = (0, p.HM)(this._config.minHeight), V.maxWidth = (0, p.HM)(this._config.maxWidth), V.maxHeight = (0, p.HM)(this._config.maxHeight)
							}
							_togglePointerEvents(V) {
								this._pane.style.pointerEvents = V ? "" : "none"
							}
							_attachBackdrop() {
								const V = "cdk-overlay-backdrop-showing";
								this._backdropElement = this._document.createElement("div"), this._backdropElement.classList.add("cdk-overlay-backdrop"), this._animationsDisabled && this._backdropElement.classList.add("cdk-overlay-backdrop-noop-animation"), this._config.backdropClass && this._toggleClasses(this._backdropElement, this._config.backdropClass, !0), this._host.parentElement.insertBefore(this._backdropElement, this._host), this._backdropElement.addEventListener("click", this._backdropClickHandler), !this._animationsDisabled && typeof requestAnimationFrame < "u" ? this._ngZone.runOutsideAngular(() => {
									requestAnimationFrame(() => {
										this._backdropElement && this._backdropElement.classList.add(V)
									})
								}) : this._backdropElement.classList.add(V)
							}
							_updateStackingOrder() {
								this._host.nextSibling && this._host.parentNode.appendChild(this._host)
							}
							detachBackdrop() {
								const V = this._backdropElement;
								if (V) {
									if (this._animationsDisabled) return void this._disposeBackdrop(V);
									V.classList.remove("cdk-overlay-backdrop-showing"), this._ngZone.runOutsideAngular(() => {
										V.addEventListener("transitionend", this._backdropTransitionendHandler)
									}), V.style.pointerEvents = "none", this._backdropTimeout = this._ngZone.runOutsideAngular(() => setTimeout(() => {
										this._disposeBackdrop(V)
									}, 500))
								}
							}
							_toggleClasses(V, U, fe) {
								const f = (0, p.Eq)(U || []).filter(T => !!T);
								f.length && (fe ? V.classList.add(...f) : V.classList.remove(...f))
							}
							_detachContentWhenStable() {
								this._ngZone.runOutsideAngular(() => {
									const V = this._ngZone.onStable.pipe((0, ce.R)((0, Xe.T)(this._attachments, this._detachments))).subscribe(() => {
										(!this._pane || !this._host || 0 === this._pane.children.length) && (this._pane && this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !1), this._host && this._host.parentElement && (this._previousHostParent = this._host.parentElement, this._host.remove()), V.unsubscribe())
									})
								})
							}
							_disposeScrollStrategy() {
								const V = this._scrollStrategy;
								V && (V.disable(), V.detach && V.detach())
							}
							_disposeBackdrop(V) {
								V && (V.removeEventListener("click", this._backdropClickHandler), V.removeEventListener("transitionend", this._backdropTransitionendHandler), V.remove(), this._backdropElement === V && (this._backdropElement = null)), this._backdropTimeout && (clearTimeout(this._backdropTimeout), this._backdropTimeout = void 0)
							}
						}
						const ln = "cdk-overlay-connected-position-bounding-box",
							yn = /([A-Za-z%]+)$/;
						class nr {
							get positions() {
								return this._preferredPositions
							}
							constructor(V, U, fe, f, T) {
								this._viewportRuler = U, this._document = fe, this._platform = f, this._overlayContainer = T, this._lastBoundingBoxSize = {
									width: 0,
									height: 0
								}, this._isPushed = !1, this._canPush = !0, this._growAfterOpen = !1, this._hasFlexibleDimensions = !0, this._positionLocked = !1, this._viewportMargin = 0, this._scrollables = [], this._preferredPositions = [], this._positionChanges = new D.x, this._resizeSubscription = Y.w0.EMPTY, this._offsetX = 0, this._offsetY = 0, this._appliedPanelClasses = [], this.positionChanges = this._positionChanges, this.setOrigin(V)
							}
							attach(V) {
								this._validatePositions(), V.hostElement.classList.add(ln), this._overlayRef = V, this._boundingBox = V.hostElement, this._pane = V.overlayElement, this._isDisposed = !1, this._isInitialRender = !0, this._lastPosition = null, this._resizeSubscription.unsubscribe(), this._resizeSubscription = this._viewportRuler.change().subscribe(() => {
									this._isInitialRender = !0, this.apply()
								})
							}
							apply() {
								if (this._isDisposed || !this._platform.isBrowser) return;
								if (!this._isInitialRender && this._positionLocked && this._lastPosition) return void this.reapplyLastPosition();
								this._clearPanelClasses(), this._resetOverlayElementStyles(), this._resetBoundingBoxStyles(), this._viewportRect = this._getNarrowedViewportRect(), this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(), this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect();
								const V = this._originRect,
									U = this._overlayRect,
									fe = this._viewportRect,
									f = this._containerRect,
									T = [];
								let L;
								for (let K of this._preferredPositions) {
									let he = this._getOriginPoint(V, f, K),
										ye = this._getOverlayPoint(he, U, K),
										He = this._getOverlayFit(ye, U, fe, K);
									if (He.isCompletelyWithinViewport) return this._isPushed = !1, void this._applyPosition(K, he);
									this._canFitWithFlexibleDimensions(He, ye, fe) ? T.push({
										position: K,
										origin: he,
										overlayRect: U,
										boundingBoxRect: this._calculateBoundingBoxRect(he, K)
									}) : (!L || L.overlayFit.visibleArea < He.visibleArea) && (L = {
										overlayFit: He,
										overlayPoint: ye,
										originPoint: he,
										position: K,
										overlayRect: U
									})
								}
								if (T.length) {
									let K = null,
										he = -1;
									for (const ye of T) {
										const He = ye.boundingBoxRect.width * ye.boundingBoxRect.height * (ye.position.weight || 1);
										He > he && (he = He, K = ye)
									}
									return this._isPushed = !1, void this._applyPosition(K.position, K.origin)
								}
								if (this._canPush) return this._isPushed = !0, void this._applyPosition(L.position, L.originPoint);
								this._applyPosition(L.position, L.originPoint)
							}
							detach() {
								this._clearPanelClasses(), this._lastPosition = null, this._previousPushAmount = null, this._resizeSubscription.unsubscribe()
							}
							dispose() {
								this._isDisposed || (this._boundingBox && Dn(this._boundingBox.style, {
									top: "",
									left: "",
									right: "",
									bottom: "",
									height: "",
									width: "",
									alignItems: "",
									justifyContent: ""
								}), this._pane && this._resetOverlayElementStyles(), this._overlayRef && this._overlayRef.hostElement.classList.remove(ln), this.detach(), this._positionChanges.complete(), this._overlayRef = this._boundingBox = null, this._isDisposed = !0)
							}
							reapplyLastPosition() {
								if (this._isDisposed || !this._platform.isBrowser) return;
								const V = this._lastPosition;
								if (V) {
									this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(), this._viewportRect = this._getNarrowedViewportRect(), this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect();
									const U = this._getOriginPoint(this._originRect, this._containerRect, V);
									this._applyPosition(V, U)
								} else this.apply()
							}
							withScrollableContainers(V) {
								return this._scrollables = V, this
							}
							withPositions(V) {
								return this._preferredPositions = V, -1 === V.indexOf(this._lastPosition) && (this._lastPosition = null), this._validatePositions(), this
							}
							withViewportMargin(V) {
								return this._viewportMargin = V, this
							}
							withFlexibleDimensions(V = !0) {
								return this._hasFlexibleDimensions = V, this
							}
							withGrowAfterOpen(V = !0) {
								return this._growAfterOpen = V, this
							}
							withPush(V = !0) {
								return this._canPush = V, this
							}
							withLockedPosition(V = !0) {
								return this._positionLocked = V, this
							}
							setOrigin(V) {
								return this._origin = V, this
							}
							withDefaultOffsetX(V) {
								return this._offsetX = V, this
							}
							withDefaultOffsetY(V) {
								return this._offsetY = V, this
							}
							withTransformOriginOn(V) {
								return this._transformOriginSelector = V, this
							}
							_getOriginPoint(V, U, fe) {
								let f, T;
								if ("center" == fe.originX) f = V.left + V.width / 2;
								else {
									const L = this._isRtl() ? V.right : V.left,
										K = this._isRtl() ? V.left : V.right;
									f = "start" == fe.originX ? L : K
								}
								return U.left < 0 && (f -= U.left), T = "center" == fe.originY ? V.top + V.height / 2 : "top" == fe.originY ? V.top : V.bottom, U.top < 0 && (T -= U.top), {
									x: f,
									y: T
								}
							}
							_getOverlayPoint(V, U, fe) {
								let f, T;
								return f = "center" == fe.overlayX ? -U.width / 2 : "start" === fe.overlayX ? this._isRtl() ? -U.width : 0 : this._isRtl() ? 0 : -U.width, T = "center" == fe.overlayY ? -U.height / 2 : "top" == fe.overlayY ? 0 : -U.height, {
									x: V.x + f,
									y: V.y + T
								}
							}
							_getOverlayFit(V, U, fe, f) {
								const T = Me(U);
								let {
									x: L,
									y: K
								} = V, he = this._getOffset(f, "x"), ye = this._getOffset(f, "y");
								he && (L += he), ye && (K += ye);
								let st = 0 - K,
									mt = K + T.height - fe.height,
									Et = this._subtractOverflows(T.width, 0 - L, L + T.width - fe.width),
									Gt = this._subtractOverflows(T.height, st, mt),
									Rt = Et * Gt;
								return {
									visibleArea: Rt,
									isCompletelyWithinViewport: T.width * T.height === Rt,
									fitsInViewportVertically: Gt === T.height,
									fitsInViewportHorizontally: Et == T.width
								}
							}
							_canFitWithFlexibleDimensions(V, U, fe) {
								if (this._hasFlexibleDimensions) {
									const f = fe.bottom - U.y,
										T = fe.right - U.x,
										L = En(this._overlayRef.getConfig().minHeight),
										K = En(this._overlayRef.getConfig().minWidth);
									return (V.fitsInViewportVertically || null != L && L <= f) && (V.fitsInViewportHorizontally || null != K && K <= T)
								}
								return !1
							}
							_pushOverlayOnScreen(V, U, fe) {
								if (this._previousPushAmount && this._positionLocked) return {
									x: V.x + this._previousPushAmount.x,
									y: V.y + this._previousPushAmount.y
								};
								const f = Me(U),
									T = this._viewportRect,
									L = Math.max(V.x + f.width - T.width, 0),
									K = Math.max(V.y + f.height - T.height, 0),
									he = Math.max(T.top - fe.top - V.y, 0),
									ye = Math.max(T.left - fe.left - V.x, 0);
								let He = 0,
									gt = 0;
								return He = f.width <= T.width ? ye || -L : V.x < this._viewportMargin ? T.left - fe.left - V.x : 0, gt = f.height <= T.height ? he || -K : V.y < this._viewportMargin ? T.top - fe.top - V.y : 0, this._previousPushAmount = {
									x: He,
									y: gt
								}, {
									x: V.x + He,
									y: V.y + gt
								}
							}
							_applyPosition(V, U) {
								if (this._setTransformOrigin(V), this._setOverlayElementStyles(U, V), this._setBoundingBoxStyles(U, V), V.panelClass && this._addPanelClasses(V.panelClass), this._lastPosition = V, this._positionChanges.observers.length) {
									const fe = this._getScrollVisibility(),
										f = new k(V, fe);
									this._positionChanges.next(f)
								}
								this._isInitialRender = !1
							}
							_setTransformOrigin(V) {
								if (!this._transformOriginSelector) return;
								const U = this._boundingBox.querySelectorAll(this._transformOriginSelector);
								let fe, f = V.overlayY;
								fe = "center" === V.overlayX ? "center" : this._isRtl() ? "start" === V.overlayX ? "right" : "left" : "start" === V.overlayX ? "left" : "right";
								for (let T = 0; T < U.length; T++) U[T].style.transformOrigin = `${fe} ${f}`
							}
							_calculateBoundingBoxRect(V, U) {
								const fe = this._viewportRect,
									f = this._isRtl();
								let T, L, K, He, gt, st;
								if ("top" === U.overlayY) L = V.y, T = fe.height - L + this._viewportMargin;
								else if ("bottom" === U.overlayY) K = fe.height - V.y + 2 * this._viewportMargin, T = fe.height - K + this._viewportMargin;
								else {
									const mt = Math.min(fe.bottom - V.y + fe.top, V.y),
										Et = this._lastBoundingBoxSize.height;
									T = 2 * mt, L = V.y - mt, T > Et && !this._isInitialRender && !this._growAfterOpen && (L = V.y - Et / 2)
								}
								if ("end" === U.overlayX && !f || "start" === U.overlayX && f) st = fe.width - V.x + this._viewportMargin, He = V.x - this._viewportMargin;
								else if ("start" === U.overlayX && !f || "end" === U.overlayX && f) gt = V.x, He = fe.right - V.x;
								else {
									const mt = Math.min(fe.right - V.x + fe.left, V.x),
										Et = this._lastBoundingBoxSize.width;
									He = 2 * mt, gt = V.x - mt, He > Et && !this._isInitialRender && !this._growAfterOpen && (gt = V.x - Et / 2)
								}
								return {
									top: L,
									left: gt,
									bottom: K,
									right: st,
									width: He,
									height: T
								}
							}
							_setBoundingBoxStyles(V, U) {
								const fe = this._calculateBoundingBoxRect(V, U);
								!this._isInitialRender && !this._growAfterOpen && (fe.height = Math.min(fe.height, this._lastBoundingBoxSize.height), fe.width = Math.min(fe.width, this._lastBoundingBoxSize.width));
								const f = {};
								if (this._hasExactPosition()) f.top = f.left = "0", f.bottom = f.right = f.maxHeight = f.maxWidth = "", f.width = f.height = "100%";
								else {
									const T = this._overlayRef.getConfig().maxHeight,
										L = this._overlayRef.getConfig().maxWidth;
									f.height = (0, p.HM)(fe.height), f.top = (0, p.HM)(fe.top), f.bottom = (0, p.HM)(fe.bottom), f.width = (0, p.HM)(fe.width), f.left = (0, p.HM)(fe.left), f.right = (0, p.HM)(fe.right), f.alignItems = "center" === U.overlayX ? "center" : "end" === U.overlayX ? "flex-end" : "flex-start", f.justifyContent = "center" === U.overlayY ? "center" : "bottom" === U.overlayY ? "flex-end" : "flex-start", T && (f.maxHeight = (0, p.HM)(T)), L && (f.maxWidth = (0, p.HM)(L))
								}
								this._lastBoundingBoxSize = fe, Dn(this._boundingBox.style, f)
							}
							_resetBoundingBoxStyles() {
								Dn(this._boundingBox.style, {
									top: "0",
									left: "0",
									right: "0",
									bottom: "0",
									height: "",
									width: "",
									alignItems: "",
									justifyContent: ""
								})
							}
							_resetOverlayElementStyles() {
								Dn(this._pane.style, {
									top: "",
									left: "",
									bottom: "",
									right: "",
									position: "",
									transform: ""
								})
							}
							_setOverlayElementStyles(V, U) {
								const fe = {},
									f = this._hasExactPosition(),
									T = this._hasFlexibleDimensions,
									L = this._overlayRef.getConfig();
								if (f) {
									const He = this._viewportRuler.getViewportScrollPosition();
									Dn(fe, this._getExactOverlayY(U, V, He)), Dn(fe, this._getExactOverlayX(U, V, He))
								} else fe.position = "static";
								let K = "",
									he = this._getOffset(U, "x"),
									ye = this._getOffset(U, "y");
								he && (K += `translateX(${he}px) `), ye && (K += `translateY(${ye}px)`), fe.transform = K.trim(), L.maxHeight && (f ? fe.maxHeight = (0, p.HM)(L.maxHeight) : T && (fe.maxHeight = "")), L.maxWidth && (f ? fe.maxWidth = (0, p.HM)(L.maxWidth) : T && (fe.maxWidth = "")), Dn(this._pane.style, fe)
							}
							_getExactOverlayY(V, U, fe) {
								let f = {
										top: "",
										bottom: ""
									},
									T = this._getOverlayPoint(U, this._overlayRect, V);
								return this._isPushed && (T = this._pushOverlayOnScreen(T, this._overlayRect, fe)), "bottom" === V.overlayY ? f.bottom = this._document.documentElement.clientHeight - (T.y + this._overlayRect.height) + "px" : f.top = (0, p.HM)(T.y), f
							}
							_getExactOverlayX(V, U, fe) {
								let L, f = {
										left: "",
										right: ""
									},
									T = this._getOverlayPoint(U, this._overlayRect, V);
								return this._isPushed && (T = this._pushOverlayOnScreen(T, this._overlayRect, fe)), L = this._isRtl() ? "end" === V.overlayX ? "left" : "right" : "end" === V.overlayX ? "right" : "left", "right" === L ? f.right = this._document.documentElement.clientWidth - (T.x + this._overlayRect.width) + "px" : f.left = (0, p.HM)(T.x), f
							}
							_getScrollVisibility() {
								const V = this._getOriginRect(),
									U = this._pane.getBoundingClientRect(),
									fe = this._scrollables.map(f => f.getElementRef().nativeElement.getBoundingClientRect());
								return {
									isOriginClipped: hn(V, fe),
									isOriginOutsideView: $t(V, fe),
									isOverlayClipped: hn(U, fe),
									isOverlayOutsideView: $t(U, fe)
								}
							}
							_subtractOverflows(V, ...U) {
								return U.reduce((fe, f) => fe - Math.max(f, 0), V)
							}
							_getNarrowedViewportRect() {
								const V = this._document.documentElement.clientWidth,
									U = this._document.documentElement.clientHeight,
									fe = this._viewportRuler.getViewportScrollPosition();
								return {
									top: fe.top + this._viewportMargin,
									left: fe.left + this._viewportMargin,
									right: fe.left + V - this._viewportMargin,
									bottom: fe.top + U - this._viewportMargin,
									width: V - 2 * this._viewportMargin,
									height: U - 2 * this._viewportMargin
								}
							}
							_isRtl() {
								return "rtl" === this._overlayRef.getDirection()
							}
							_hasExactPosition() {
								return !this._hasFlexibleDimensions || this._isPushed
							}
							_getOffset(V, U) {
								return "x" === U ? null == V.offsetX ? this._offsetX : V.offsetX : null == V.offsetY ? this._offsetY : V.offsetY
							}
							_validatePositions() {}
							_addPanelClasses(V) {
								this._pane && (0, p.Eq)(V).forEach(U => {
									"" !== U && -1 === this._appliedPanelClasses.indexOf(U) && (this._appliedPanelClasses.push(U), this._pane.classList.add(U))
								})
							}
							_clearPanelClasses() {
								this._pane && (this._appliedPanelClasses.forEach(V => {
									this._pane.classList.remove(V)
								}), this._appliedPanelClasses = [])
							}
							_getOriginRect() {
								const V = this._origin;
								if (V instanceof y.SBq) return V.nativeElement.getBoundingClientRect();
								if (V instanceof Element) return V.getBoundingClientRect();
								const U = V.width || 0,
									fe = V.height || 0;
								return {
									top: V.y,
									bottom: V.y + fe,
									left: V.x,
									right: V.x + U,
									height: fe,
									width: U
								}
							}
						}

						function Dn(Ve, V) {
							for (let U in V) V.hasOwnProperty(U) && (Ve[U] = V[U]);
							return Ve
						}

						function En(Ve) {
							if ("number" != typeof Ve && null != Ve) {
								const [V, U] = Ve.split(yn);
								return U && "px" !== U ? null : parseFloat(V)
							}
							return Ve || null
						}

						function Me(Ve) {
							return {
								top: Math.floor(Ve.top),
								right: Math.floor(Ve.right),
								bottom: Math.floor(Ve.bottom),
								left: Math.floor(Ve.left),
								width: Math.floor(Ve.width),
								height: Math.floor(Ve.height)
							}
						}
						const Ke = "cdk-global-overlay-wrapper";
						class Tt {
							constructor() {
								this._cssPosition = "static", this._topOffset = "", this._bottomOffset = "", this._alignItems = "", this._xPosition = "", this._xOffset = "", this._width = "", this._height = "", this._isDisposed = !1
							}
							attach(V) {
								const U = V.getConfig();
								this._overlayRef = V, this._width && !U.width && V.updateSize({
									width: this._width
								}), this._height && !U.height && V.updateSize({
									height: this._height
								}), V.hostElement.classList.add(Ke), this._isDisposed = !1
							}
							top(V = "") {
								return this._bottomOffset = "", this._topOffset = V, this._alignItems = "flex-start", this
							}
							left(V = "") {
								return this._xOffset = V, this._xPosition = "left", this
							}
							bottom(V = "") {
								return this._topOffset = "", this._bottomOffset = V, this._alignItems = "flex-end", this
							}
							right(V = "") {
								return this._xOffset = V, this._xPosition = "right", this
							}
							start(V = "") {
								return this._xOffset = V, this._xPosition = "start", this
							}
							end(V = "") {
								return this._xOffset = V, this._xPosition = "end", this
							}
							width(V = "") {
								return this._overlayRef ? this._overlayRef.updateSize({
									width: V
								}) : this._width = V, this
							}
							height(V = "") {
								return this._overlayRef ? this._overlayRef.updateSize({
									height: V
								}) : this._height = V, this
							}
							centerHorizontally(V = "") {
								return this.left(V), this._xPosition = "center", this
							}
							centerVertically(V = "") {
								return this.top(V), this._alignItems = "center", this
							}
							apply() {
								if (!this._overlayRef || !this._overlayRef.hasAttached()) return;
								const V = this._overlayRef.overlayElement.style,
									U = this._overlayRef.hostElement.style,
									fe = this._overlayRef.getConfig(),
									{
										width: f,
										height: T,
										maxWidth: L,
										maxHeight: K
									} = fe,
									he = !("100%" !== f && "100vw" !== f || L && "100%" !== L && "100vw" !== L),
									ye = !("100%" !== T && "100vh" !== T || K && "100%" !== K && "100vh" !== K),
									He = this._xPosition,
									gt = this._xOffset,
									st = "rtl" === this._overlayRef.getConfig().direction;
								let mt = "",
									Et = "",
									Gt = "";
								he ? Gt = "flex-start" : "center" === He ? (Gt = "center", st ? Et = gt : mt = gt) : st ? "left" === He || "end" === He ? (Gt = "flex-end", mt = gt) : ("right" === He || "start" === He) && (Gt = "flex-start", Et = gt) : "left" === He || "start" === He ? (Gt = "flex-start", mt = gt) : ("right" === He || "end" === He) && (Gt = "flex-end", Et = gt), V.position = this._cssPosition, V.marginLeft = he ? "0" : mt, V.marginTop = ye ? "0" : this._topOffset, V.marginBottom = this._bottomOffset, V.marginRight = he ? "0" : Et, U.justifyContent = Gt, U.alignItems = ye ? "flex-start" : this._alignItems
							}
							dispose() {
								if (this._isDisposed || !this._overlayRef) return;
								const V = this._overlayRef.overlayElement.style,
									U = this._overlayRef.hostElement,
									fe = U.style;
								U.classList.remove(Ke), fe.justifyContent = fe.alignItems = V.marginTop = V.marginBottom = V.marginLeft = V.marginRight = V.position = "", this._overlayRef = null, this._isDisposed = !0
							}
						}
						let Xt = (() => {
								class Ve {
									constructor(U, fe, f, T) {
										this._viewportRuler = U, this._document = fe, this._platform = f, this._overlayContainer = T
									}
									global() {
										return new Tt
									}
									flexibleConnectedTo(U) {
										return new nr(U, this._viewportRuler, this._document, this._platform, this._overlayContainer)
									}
								}
								return Ve.\u0275fac = function(U) {
									return new(U || Ve)(y.LFG(Zt), y.LFG(pt.K0), y.LFG(Pe.t4), y.LFG(an))
								}, Ve.\u0275prov = y.Yz7({
									token: Ve,
									factory: Ve.\u0275fac,
									providedIn: "root"
								}), Ve
							})(),
							Tn = 0,
							Zn = (() => {
								class Ve {
									constructor(U, fe, f, T, L, K, he, ye, He, gt, st, mt) {
										this.scrollStrategies = U, this._overlayContainer = fe, this._componentFactoryResolver = f, this._positionBuilder = T, this._keyboardDispatcher = L, this._injector = K, this._ngZone = he, this._document = ye, this._directionality = He, this._location = gt, this._outsideClickDispatcher = st, this._animationsModuleType = mt
									}
									create(U) {
										const fe = this._createHostElement(),
											f = this._createPaneElement(fe),
											T = this._createPortalOutlet(f),
											L = new De(U);
										return L.direction = L.direction || this._directionality.value, new xt(T, fe, f, L, this._ngZone, this._keyboardDispatcher, this._document, this._location, this._outsideClickDispatcher, "NoopAnimations" === this._animationsModuleType)
									}
									position() {
										return this._positionBuilder
									}
									_createPaneElement(U) {
										const fe = this._document.createElement("div");
										return fe.id = "cdk-overlay-" + Tn++, fe.classList.add("cdk-overlay-pane"), U.appendChild(fe), fe
									}
									_createHostElement() {
										const U = this._document.createElement("div");
										return this._overlayContainer.getContainerElement().appendChild(U), U
									}
									_createPortalOutlet(U) {
										return this._appRef || (this._appRef = this._injector.get(y.z2F)), new Nt.u0(U, this._componentFactoryResolver, this._appRef, this._injector, this._document)
									}
								}
								return Ve.\u0275fac = function(U) {
									return new(U || Ve)(y.LFG(ct), y.LFG(an), y.LFG(y._Vd), y.LFG(Xt), y.LFG(Ye), y.LFG(y.zs3), y.LFG(y.R0b), y.LFG(pt.K0), y.LFG(Bt.Is), y.LFG(pt.Ye), y.LFG(Ft), y.LFG(y.QbO, 8))
								}, Ve.\u0275prov = y.Yz7({
									token: Ve,
									factory: Ve.\u0275fac,
									providedIn: "root"
								}), Ve
							})();
						const Sr = {
							provide: new y.OlP("cdk-connected-overlay-scroll-strategy"),
							deps: [Zn],
							useFactory: function ti(Ve) {
								return () => Ve.scrollStrategies.reposition()
							}
						};
						let $r = (() => {
							class Ve {}
							return Ve.\u0275fac = function(U) {
								return new(U || Ve)
							}, Ve.\u0275mod = y.oAB({
								type: Ve
							}), Ve.\u0275inj = y.cJS({
								providers: [Zn, Sr],
								imports: [Bt.vT, Nt.eL, un, un]
							}), Ve
						})()
					}, 1329: (be, ue, E) => {
						E.d(ue, {
							Mq: () => oe,
							Oy: () => xe,
							_i: () => we,
							ht: () => Ce,
							i$: () => X,
							kV: () => je,
							sA: () => F,
							t4: () => z
						});
						var p = E(3991),
							y = E(7774);
						let D;
						try {
							D = typeof Intl < "u" && Intl.v8BreakIterator
						} catch {
							D = !1
						}
						let G, te, ie, Fe, z = (() => {
							class Ee {
								constructor(ke) {
									this._platformId = ke, this.isBrowser = this._platformId ? (0, y.NF)(this._platformId) : "object" == typeof document && !!document, this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), this.BLINK = this.isBrowser && !(!window.chrome && !D) && typeof CSS < "u" && !this.EDGE && !this.TRIDENT, this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT
								}
							}
							return Ee.\u0275fac = function(ke) {
								return new(ke || Ee)(p.LFG(p.Lbi))
							}, Ee.\u0275prov = p.Yz7({
								token: Ee,
								factory: Ee.\u0275fac,
								providedIn: "root"
							}), Ee
						})();

						function X(Ee) {
							return function Q() {
								if (null == G && typeof window < "u") try {
									window.addEventListener("test", null, Object.defineProperty({}, "passive", {
										get: () => G = !0
									}))
								} finally {
									G = G || !1
								}
								return G
							}() ? Ee : !!Ee.capture
						}

						function oe() {
							if (null == ie) {
								if ("object" != typeof document || !document || "function" != typeof Element || !Element) return ie = !1, ie;
								if ("scrollBehavior" in document.documentElement.style) ie = !0;
								else {
									const Ee = Element.prototype.scrollTo;
									ie = !!Ee && !/\{\s*\[native code\]\s*\}/.test(Ee.toString())
								}
							}
							return ie
						}

						function we() {
							if ("object" != typeof document || !document) return 0;
							if (null == te) {
								const Ee = document.createElement("div"),
									Ue = Ee.style;
								Ee.dir = "rtl", Ue.width = "1px", Ue.overflow = "auto", Ue.visibility = "hidden", Ue.pointerEvents = "none", Ue.position = "absolute";
								const ke = document.createElement("div"),
									Ge = ke.style;
								Ge.width = "2px", Ge.height = "1px", Ee.appendChild(ke), document.body.appendChild(Ee), te = 0, 0 === Ee.scrollLeft && (Ee.scrollLeft = 1, te = 0 === Ee.scrollLeft ? 1 : 2), Ee.remove()
							}
							return te
						}

						function je(Ee) {
							if (function Le() {
									if (null == Fe) {
										const Ee = typeof document < "u" ? document.head : null;
										Fe = !(!Ee || !Ee.createShadowRoot && !Ee.attachShadow)
									}
									return Fe
								}()) {
								const Ue = Ee.getRootNode ? Ee.getRootNode() : null;
								if (typeof ShadowRoot < "u" && ShadowRoot && Ue instanceof ShadowRoot) return Ue
							}
							return null
						}

						function Ce() {
							let Ee = typeof document < "u" && document ? document.activeElement : null;
							for (; Ee && Ee.shadowRoot;) {
								const Ue = Ee.shadowRoot.activeElement;
								if (Ue === Ee) break;
								Ee = Ue
							}
							return Ee
						}

						function F(Ee) {
							return Ee.composedPath ? Ee.composedPath()[0] : Ee.target
						}

						function xe() {
							return typeof __karma__ < "u" && !!__karma__ || typeof jasmine < "u" && !!jasmine || typeof jest < "u" && !!jest || typeof Mocha < "u" && !!Mocha
						}
					}, 7444: (be, ue, E) => {
						E.d(ue, {
							C5: () => Q,
							Pl: () => Ce,
							UE: () => X,
							eL: () => xe,
							en: () => ie,
							u0: () => we
						});
						var p = E(3991),
							y = E(7774);
						class G {
							attach(ke) {
								return this._attachedHost = ke, ke.attach(this)
							}
							detach() {
								let ke = this._attachedHost;
								null != ke && (this._attachedHost = null, ke.detach())
							}
							get isAttached() {
								return null != this._attachedHost
							}
							setAttachedHost(ke) {
								this._attachedHost = ke
							}
						}
						class Q extends G {
							constructor(ke, Ge, ft, nt, Pt) {
								super(), this.component = ke, this.viewContainerRef = Ge, this.injector = ft, this.componentFactoryResolver = nt, this.projectableNodes = Pt
							}
						}
						class X extends G {
							constructor(ke, Ge, ft, nt) {
								super(), this.templateRef = ke, this.viewContainerRef = Ge, this.context = ft, this.injector = nt
							}
							get origin() {
								return this.templateRef.elementRef
							}
							attach(ke, Ge = this.context) {
								return this.context = Ge, super.attach(ke)
							}
							detach() {
								return this.context = void 0, super.detach()
							}
						}
						class te extends G {
							constructor(ke) {
								super(), this.element = ke instanceof p.SBq ? ke.nativeElement : ke
							}
						}
						class ie {
							constructor() {
								this._isDisposed = !1, this.attachDomPortal = null
							}
							hasAttached() {
								return !!this._attachedPortal
							}
							attach(ke) {
								return ke instanceof Q ? (this._attachedPortal = ke, this.attachComponentPortal(ke)) : ke instanceof X ? (this._attachedPortal = ke, this.attachTemplatePortal(ke)) : this.attachDomPortal && ke instanceof te ? (this._attachedPortal = ke, this.attachDomPortal(ke)) : void 0
							}
							detach() {
								this._attachedPortal && (this._attachedPortal.setAttachedHost(null), this._attachedPortal = null), this._invokeDisposeFn()
							}
							dispose() {
								this.hasAttached() && this.detach(), this._invokeDisposeFn(), this._isDisposed = !0
							}
							setDisposeFn(ke) {
								this._disposeFn = ke
							}
							_invokeDisposeFn() {
								this._disposeFn && (this._disposeFn(), this._disposeFn = null)
							}
						}
						class we extends ie {
							constructor(ke, Ge, ft, nt, Pt) {
								super(), this.outletElement = ke, this._componentFactoryResolver = Ge, this._appRef = ft, this._defaultInjector = nt, this.attachDomPortal = at => {
									const lt = at.element,
										et = this._document.createComment("dom-portal");
									lt.parentNode.insertBefore(et, lt), this.outletElement.appendChild(lt), this._attachedPortal = at, super.setDisposeFn(() => {
										et.parentNode && et.parentNode.replaceChild(lt, et)
									})
								}, this._document = Pt
							}
							attachComponentPortal(ke) {
								const ft = (ke.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(ke.component);
								let nt;
								return ke.viewContainerRef ? (nt = ke.viewContainerRef.createComponent(ft, ke.viewContainerRef.length, ke.injector || ke.viewContainerRef.injector, ke.projectableNodes || void 0), this.setDisposeFn(() => nt.destroy())) : (nt = ft.create(ke.injector || this._defaultInjector || p.zs3.NULL), this._appRef.attachView(nt.hostView), this.setDisposeFn(() => {
									this._appRef.viewCount > 0 && this._appRef.detachView(nt.hostView), nt.destroy()
								})), this.outletElement.appendChild(this._getComponentRootNode(nt)), this._attachedPortal = ke, nt
							}
							attachTemplatePortal(ke) {
								let Ge = ke.viewContainerRef,
									ft = Ge.createEmbeddedView(ke.templateRef, ke.context, {
										injector: ke.injector
									});
								return ft.rootNodes.forEach(nt => this.outletElement.appendChild(nt)), ft.detectChanges(), this.setDisposeFn(() => {
									let nt = Ge.indexOf(ft); - 1 !== nt && Ge.remove(nt)
								}), this._attachedPortal = ke, ft
							}
							dispose() {
								super.dispose(), this.outletElement.remove()
							}
							_getComponentRootNode(ke) {
								return ke.hostView.rootNodes[0]
							}
						}
						let Ce = (() => {
								class Ue extends ie {
									constructor(Ge, ft, nt) {
										super(), this._componentFactoryResolver = Ge, this._viewContainerRef = ft, this._isInitialized = !1, this.attached = new p.vpe, this.attachDomPortal = Pt => {
											const at = Pt.element,
												lt = this._document.createComment("dom-portal");
											Pt.setAttachedHost(this), at.parentNode.insertBefore(lt, at), this._getRootNode().appendChild(at), this._attachedPortal = Pt, super.setDisposeFn(() => {
												lt.parentNode && lt.parentNode.replaceChild(at, lt)
											})
										}, this._document = nt
									}
									get portal() {
										return this._attachedPortal
									}
									set portal(Ge) {
										this.hasAttached() && !Ge && !this._isInitialized || (this.hasAttached() && super.detach(), Ge && super.attach(Ge), this._attachedPortal = Ge || null)
									}
									get attachedRef() {
										return this._attachedRef
									}
									ngOnInit() {
										this._isInitialized = !0
									}
									ngOnDestroy() {
										super.dispose(), this._attachedRef = this._attachedPortal = null
									}
									attachComponentPortal(Ge) {
										Ge.setAttachedHost(this);
										const ft = null != Ge.viewContainerRef ? Ge.viewContainerRef : this._viewContainerRef,
											Pt = (Ge.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(Ge.component),
											at = ft.createComponent(Pt, ft.length, Ge.injector || ft.injector, Ge.projectableNodes || void 0);
										return ft !== this._viewContainerRef && this._getRootNode().appendChild(at.hostView.rootNodes[0]), super.setDisposeFn(() => at.destroy()), this._attachedPortal = Ge, this._attachedRef = at, this.attached.emit(at), at
									}
									attachTemplatePortal(Ge) {
										Ge.setAttachedHost(this);
										const ft = this._viewContainerRef.createEmbeddedView(Ge.templateRef, Ge.context, {
											injector: Ge.injector
										});
										return super.setDisposeFn(() => this._viewContainerRef.clear()), this._attachedPortal = Ge, this._attachedRef = ft, this.attached.emit(ft), ft
									}
									_getRootNode() {
										const Ge = this._viewContainerRef.element.nativeElement;
										return Ge.nodeType === Ge.ELEMENT_NODE ? Ge : Ge.parentNode
									}
								}
								return Ue.\u0275fac = function(Ge) {
									return new(Ge || Ue)(p.Y36(p._Vd), p.Y36(p.s_b), p.Y36(y.K0))
								}, Ue.\u0275dir = p.lG2({
									type: Ue,
									selectors: [
										["", "cdkPortalOutlet", ""]
									],
									inputs: {
										portal: ["cdkPortalOutlet", "portal"]
									},
									outputs: {
										attached: "attached"
									},
									exportAs: ["cdkPortalOutlet"],
									features: [p.qOj]
								}), Ue
							})(),
							xe = (() => {
								class Ue {}
								return Ue.\u0275fac = function(Ge) {
									return new(Ge || Ue)
								}, Ue.\u0275mod = p.oAB({
									type: Ue
								}), Ue.\u0275inj = p.cJS({}), Ue
							})()
					}, 7774: (be, ue, E) => {
						E.d(ue, {
							Do: () => Ce,
							ED: () => xn,
							EM: () => ao,
							HT: () => z,
							JF: () => lc,
							K0: () => P,
							Mx: () => T,
							NF: () => so,
							Nd: () => Is,
							O5: () => Rt,
							Ov: () => $n,
							PC: () => qe,
							RF: () => Cn,
							S$: () => Fe,
							V_: () => G,
							Ye: () => F,
							b0: () => je,
							bD: () => ca,
							ez: () => ac,
							gd: () => gr,
							mk: () => he,
							n9: () => Jn,
							q: () => D,
							rS: () => lr,
							sg: () => mt,
							tP: () => dt,
							w_: () => ee
						});
						var p = E(3991);
						let y = null;

						function D() {
							return y
						}

						function z(I) {
							y || (y = I)
						}
						class ee {}
						const P = new p.OlP("DocumentToken");
						let N = (() => {
							class I {
								historyGo(M) {
									throw new Error("Not implemented")
								}
							}
							return I.\u0275fac = function(M) {
								return new(M || I)
							}, I.\u0275prov = p.Yz7({
								token: I,
								factory: function() {
									return function Y() {
										return (0, p.LFG)(Q)
									}()
								},
								providedIn: "platform"
							}), I
						})();
						const G = new p.OlP("Location Initialized");
						let Q = (() => {
							class I extends N {
								constructor(M) {
									super(), this._doc = M, this._location = window.location, this._history = window.history
								}
								getBaseHrefFromDOM() {
									return D().getBaseHref(this._doc)
								}
								onPopState(M) {
									const ae = D().getGlobalEventTarget(this._doc, "window");
									return ae.addEventListener("popstate", M, !1), () => ae.removeEventListener("popstate", M)
								}
								onHashChange(M) {
									const ae = D().getGlobalEventTarget(this._doc, "window");
									return ae.addEventListener("hashchange", M, !1), () => ae.removeEventListener("hashchange", M)
								}
								get href() {
									return this._location.href
								}
								get protocol() {
									return this._location.protocol
								}
								get hostname() {
									return this._location.hostname
								}
								get port() {
									return this._location.port
								}
								get pathname() {
									return this._location.pathname
								}
								get search() {
									return this._location.search
								}
								get hash() {
									return this._location.hash
								}
								set pathname(M) {
									this._location.pathname = M
								}
								pushState(M, ae, Oe) {
									X() ? this._history.pushState(M, ae, Oe) : this._location.hash = Oe
								}
								replaceState(M, ae, Oe) {
									X() ? this._history.replaceState(M, ae, Oe) : this._location.hash = Oe
								}
								forward() {
									this._history.forward()
								}
								back() {
									this._history.back()
								}
								historyGo(M = 0) {
									this._history.go(M)
								}
								getState() {
									return this._history.state
								}
							}
							return I.\u0275fac = function(M) {
								return new(M || I)(p.LFG(P))
							}, I.\u0275prov = p.Yz7({
								token: I,
								factory: function() {
									return function te() {
										return new Q((0, p.LFG)(P))
									}()
								},
								providedIn: "platform"
							}), I
						})();

						function X() {
							return !!window.history.pushState
						}

						function ie(I, W) {
							if (0 == I.length) return W;
							if (0 == W.length) return I;
							let M = 0;
							return I.endsWith("/") && M++, W.startsWith("/") && M++, 2 == M ? I + W.substring(1) : 1 == M ? I + W : I + "/" + W
						}

						function oe(I) {
							const W = I.match(/#|\?|$/),
								M = W && W.index || I.length;
							return I.slice(0, M - ("/" === I[M - 1] ? 1 : 0)) + I.slice(M)
						}

						function we(I) {
							return I && "?" !== I[0] ? "?" + I : I
						}
						let Fe = (() => {
							class I {
								historyGo(M) {
									throw new Error("Not implemented")
								}
							}
							return I.\u0275fac = function(M) {
								return new(M || I)
							}, I.\u0275prov = p.Yz7({
								token: I,
								factory: function() {
									return (0, p.f3M)(je)
								},
								providedIn: "root"
							}), I
						})();
						const Le = new p.OlP("appBaseHref");
						let je = (() => {
								class I extends Fe {
									constructor(M, ae) {
										super(), this._platformLocation = M, this._removeListenerFns = [], this._baseHref = ae ?? this._platformLocation.getBaseHrefFromDOM() ?? (0, p.f3M)(P).location?.origin ?? ""
									}
									ngOnDestroy() {
										for (; this._removeListenerFns.length;) this._removeListenerFns.pop()()
									}
									onPopState(M) {
										this._removeListenerFns.push(this._platformLocation.onPopState(M), this._platformLocation.onHashChange(M))
									}
									getBaseHref() {
										return this._baseHref
									}
									prepareExternalUrl(M) {
										return ie(this._baseHref, M)
									}
									path(M = !1) {
										const ae = this._platformLocation.pathname + we(this._platformLocation.search),
											Oe = this._platformLocation.hash;
										return Oe && M ? `${ae}${Oe}` : ae
									}
									pushState(M, ae, Oe, ut) {
										const It = this.prepareExternalUrl(Oe + we(ut));
										this._platformLocation.pushState(M, ae, It)
									}
									replaceState(M, ae, Oe, ut) {
										const It = this.prepareExternalUrl(Oe + we(ut));
										this._platformLocation.replaceState(M, ae, It)
									}
									forward() {
										this._platformLocation.forward()
									}
									back() {
										this._platformLocation.back()
									}
									getState() {
										return this._platformLocation.getState()
									}
									historyGo(M = 0) {
										this._platformLocation.historyGo?.(M)
									}
								}
								return I.\u0275fac = function(M) {
									return new(M || I)(p.LFG(N), p.LFG(Le, 8))
								}, I.\u0275prov = p.Yz7({
									token: I,
									factory: I.\u0275fac,
									providedIn: "root"
								}), I
							})(),
							Ce = (() => {
								class I extends Fe {
									constructor(M, ae) {
										super(), this._platformLocation = M, this._baseHref = "", this._removeListenerFns = [], null != ae && (this._baseHref = ae)
									}
									ngOnDestroy() {
										for (; this._removeListenerFns.length;) this._removeListenerFns.pop()()
									}
									onPopState(M) {
										this._removeListenerFns.push(this._platformLocation.onPopState(M), this._platformLocation.onHashChange(M))
									}
									getBaseHref() {
										return this._baseHref
									}
									path(M = !1) {
										let ae = this._platformLocation.hash;
										return null == ae && (ae = "#"), ae.length > 0 ? ae.substring(1) : ae
									}
									prepareExternalUrl(M) {
										const ae = ie(this._baseHref, M);
										return ae.length > 0 ? "#" + ae : ae
									}
									pushState(M, ae, Oe, ut) {
										let It = this.prepareExternalUrl(Oe + we(ut));
										0 == It.length && (It = this._platformLocation.pathname), this._platformLocation.pushState(M, ae, It)
									}
									replaceState(M, ae, Oe, ut) {
										let It = this.prepareExternalUrl(Oe + we(ut));
										0 == It.length && (It = this._platformLocation.pathname), this._platformLocation.replaceState(M, ae, It)
									}
									forward() {
										this._platformLocation.forward()
									}
									back() {
										this._platformLocation.back()
									}
									getState() {
										return this._platformLocation.getState()
									}
									historyGo(M = 0) {
										this._platformLocation.historyGo?.(M)
									}
								}
								return I.\u0275fac = function(M) {
									return new(M || I)(p.LFG(N), p.LFG(Le, 8))
								}, I.\u0275prov = p.Yz7({
									token: I,
									factory: I.\u0275fac
								}), I
							})(),
							F = (() => {
								class I {
									constructor(M) {
										this._subject = new p.vpe, this._urlChangeListeners = [], this._urlChangeSubscription = null, this._locationStrategy = M;
										const ae = this._locationStrategy.getBaseHref();
										this._basePath = function ke(I) {
											if (new RegExp("^(https?:)?//").test(I)) {
												const [, M] = I.split(/\/\/[^\/]+/);
												return M
											}
											return I
										}(oe(Ue(ae))), this._locationStrategy.onPopState(Oe => {
											this._subject.emit({
												url: this.path(!0),
												pop: !0,
												state: Oe.state,
												type: Oe.type
											})
										})
									}
									ngOnDestroy() {
										this._urlChangeSubscription?.unsubscribe(), this._urlChangeListeners = []
									}
									path(M = !1) {
										return this.normalize(this._locationStrategy.path(M))
									}
									getState() {
										return this._locationStrategy.getState()
									}
									isCurrentPathEqualTo(M, ae = "") {
										return this.path() == this.normalize(M + we(ae))
									}
									normalize(M) {
										return I.stripTrailingSlash(function Ee(I, W) {
											return I && new RegExp(`^${I}([/;?#]|$)`).test(W) ? W.substring(I.length) : W
										}(this._basePath, Ue(M)))
									}
									prepareExternalUrl(M) {
										return M && "/" !== M[0] && (M = "/" + M), this._locationStrategy.prepareExternalUrl(M)
									}
									go(M, ae = "", Oe = null) {
										this._locationStrategy.pushState(Oe, "", M, ae), this._notifyUrlChangeListeners(this.prepareExternalUrl(M + we(ae)), Oe)
									}
									replaceState(M, ae = "", Oe = null) {
										this._locationStrategy.replaceState(Oe, "", M, ae), this._notifyUrlChangeListeners(this.prepareExternalUrl(M + we(ae)), Oe)
									}
									forward() {
										this._locationStrategy.forward()
									}
									back() {
										this._locationStrategy.back()
									}
									historyGo(M = 0) {
										this._locationStrategy.historyGo?.(M)
									}
									onUrlChange(M) {
										return this._urlChangeListeners.push(M), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(ae => {
											this._notifyUrlChangeListeners(ae.url, ae.state)
										})), () => {
											const ae = this._urlChangeListeners.indexOf(M);
											this._urlChangeListeners.splice(ae, 1), 0 === this._urlChangeListeners.length && (this._urlChangeSubscription?.unsubscribe(), this._urlChangeSubscription = null)
										}
									}
									_notifyUrlChangeListeners(M = "", ae) {
										this._urlChangeListeners.forEach(Oe => Oe(M, ae))
									}
									subscribe(M, ae, Oe) {
										return this._subject.subscribe({
											next: M,
											error: ae,
											complete: Oe
										})
									}
								}
								return I.normalizeQueryParams = we, I.joinWithSlash = ie, I.stripTrailingSlash = oe, I.\u0275fac = function(M) {
									return new(M || I)(p.LFG(Fe))
								}, I.\u0275prov = p.Yz7({
									token: I,
									factory: function() {
										return function xe() {
											return new F((0, p.LFG)(Fe))
										}()
									},
									providedIn: "root"
								}), I
							})();

						function Ue(I) {
							return I.replace(/\/index.html$/, "")
						}

						function T(I, W) {
							W = encodeURIComponent(W);
							for (const M of I.split(";")) {
								const ae = M.indexOf("="),
									[Oe, ut] = -1 == ae ? [M, ""] : [M.slice(0, ae), M.slice(ae + 1)];
								if (Oe.trim() === W) return decodeURIComponent(ut)
							}
							return null
						}
						const L = /\s+/,
							K = [];
						let he = (() => {
							class I {
								constructor(M, ae, Oe, ut) {
									this._iterableDiffers = M, this._keyValueDiffers = ae, this._ngEl = Oe, this._renderer = ut, this.initialClasses = K, this.stateMap = new Map
								}
								set klass(M) {
									this.initialClasses = null != M ? M.trim().split(L) : K
								}
								set ngClass(M) {
									this.rawClass = "string" == typeof M ? M.trim().split(L) : M
								}
								ngDoCheck() {
									for (const ae of this.initialClasses) this._updateState(ae, !0);
									const M = this.rawClass;
									if (Array.isArray(M) || M instanceof Set)
										for (const ae of M) this._updateState(ae, !0);
									else if (null != M)
										for (const ae of Object.keys(M)) this._updateState(ae, Boolean(M[ae]));
									this._applyStateDiff()
								}
								_updateState(M, ae) {
									const Oe = this.stateMap.get(M);
									void 0 !== Oe ? (Oe.enabled !== ae && (Oe.changed = !0, Oe.enabled = ae), Oe.touched = !0) : this.stateMap.set(M, {
										enabled: ae,
										changed: !0,
										touched: !0
									})
								}
								_applyStateDiff() {
									for (const M of this.stateMap) {
										const ae = M[0],
											Oe = M[1];
										Oe.changed ? (this._toggleClass(ae, Oe.enabled), Oe.changed = !1) : Oe.touched || (Oe.enabled && this._toggleClass(ae, !1), this.stateMap.delete(ae)), Oe.touched = !1
									}
								}
								_toggleClass(M, ae) {
									(M = M.trim()).length > 0 && M.split(L).forEach(Oe => {
										ae ? this._renderer.addClass(this._ngEl.nativeElement, Oe) : this._renderer.removeClass(this._ngEl.nativeElement, Oe)
									})
								}
							}
							return I.\u0275fac = function(M) {
								return new(M || I)(p.Y36(p.ZZ4), p.Y36(p.aQg), p.Y36(p.SBq), p.Y36(p.Qsj))
							}, I.\u0275dir = p.lG2({
								type: I,
								selectors: [
									["", "ngClass", ""]
								],
								inputs: {
									klass: ["class", "klass"],
									ngClass: "ngClass"
								},
								standalone: !0
							}), I
						})();
						class st {
							constructor(W, M, ae, Oe) {
								this.$implicit = W, this.ngForOf = M, this.index = ae, this.count = Oe
							}
							get first() {
								return 0 === this.index
							}
							get last() {
								return this.index === this.count - 1
							}
							get even() {
								return this.index % 2 == 0
							}
							get odd() {
								return !this.even
							}
						}
						let mt = (() => {
							class I {
								set ngForOf(M) {
									this._ngForOf = M, this._ngForOfDirty = !0
								}
								set ngForTrackBy(M) {
									this._trackByFn = M
								}
								get ngForTrackBy() {
									return this._trackByFn
								}
								constructor(M, ae, Oe) {
									this._viewContainer = M, this._template = ae, this._differs = Oe, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null
								}
								set ngForTemplate(M) {
									M && (this._template = M)
								}
								ngDoCheck() {
									if (this._ngForOfDirty) {
										this._ngForOfDirty = !1;
										const M = this._ngForOf;
										!this._differ && M && (this._differ = this._differs.find(M).create(this.ngForTrackBy))
									}
									if (this._differ) {
										const M = this._differ.diff(this._ngForOf);
										M && this._applyChanges(M)
									}
								}
								_applyChanges(M) {
									const ae = this._viewContainer;
									M.forEachOperation((Oe, ut, It) => {
										if (null == Oe.previousIndex) ae.createEmbeddedView(this._template, new st(Oe.item, this._ngForOf, -1, -1), null === It ? void 0 : It);
										else if (null == It) ae.remove(null === ut ? void 0 : ut);
										else if (null !== ut) {
											const dn = ae.get(ut);
											ae.move(dn, It), Et(dn, Oe)
										}
									});
									for (let Oe = 0, ut = ae.length; Oe < ut; Oe++) {
										const dn = ae.get(Oe).context;
										dn.index = Oe, dn.count = ut, dn.ngForOf = this._ngForOf
									}
									M.forEachIdentityChange(Oe => {
										Et(ae.get(Oe.currentIndex), Oe)
									})
								}
								static ngTemplateContextGuard(M, ae) {
									return !0
								}
							}
							return I.\u0275fac = function(M) {
								return new(M || I)(p.Y36(p.s_b), p.Y36(p.Rgc), p.Y36(p.ZZ4))
							}, I.\u0275dir = p.lG2({
								type: I,
								selectors: [
									["", "ngFor", "", "ngForOf", ""]
								],
								inputs: {
									ngForOf: "ngForOf",
									ngForTrackBy: "ngForTrackBy",
									ngForTemplate: "ngForTemplate"
								},
								standalone: !0
							}), I
						})();

						function Et(I, W) {
							I.context.$implicit = W.item
						}
						let Rt = (() => {
							class I {
								constructor(M, ae) {
									this._viewContainer = M, this._context = new Ot, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = ae
								}
								set ngIf(M) {
									this._context.$implicit = this._context.ngIf = M, this._updateView()
								}
								set ngIfThen(M) {
									Jt("ngIfThen", M), this._thenTemplateRef = M, this._thenViewRef = null, this._updateView()
								}
								set ngIfElse(M) {
									Jt("ngIfElse", M), this._elseTemplateRef = M, this._elseViewRef = null, this._updateView()
								}
								_updateView() {
									this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context)))
								}
								static ngTemplateContextGuard(M, ae) {
									return !0
								}
							}
							return I.\u0275fac = function(M) {
								return new(M || I)(p.Y36(p.s_b), p.Y36(p.Rgc))
							}, I.\u0275dir = p.lG2({
								type: I,
								selectors: [
									["", "ngIf", ""]
								],
								inputs: {
									ngIf: "ngIf",
									ngIfThen: "ngIfThen",
									ngIfElse: "ngIfElse"
								},
								standalone: !0
							}), I
						})();
						class Ot {
							constructor() {
								this.$implicit = null, this.ngIf = null
							}
						}

						function Jt(I, W) {
							if (W && !W.createEmbeddedView) throw new Error(`${I} must be a TemplateRef, but received '${(0,p.AaK)(W)}'.`)
						}
						class Mn {
							constructor(W, M) {
								this._viewContainerRef = W, this._templateRef = M, this._created = !1
							}
							create() {
								this._created = !0, this._viewContainerRef.createEmbeddedView(this._templateRef)
							}
							destroy() {
								this._created = !1, this._viewContainerRef.clear()
							}
							enforceState(W) {
								W && !this._created ? this.create() : !W && this._created && this.destroy()
							}
						}
						let Cn = (() => {
								class I {
									constructor() {
										this._defaultViews = [], this._defaultUsed = !1, this._caseCount = 0, this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1
									}
									set ngSwitch(M) {
										this._ngSwitch = M, 0 === this._caseCount && this._updateDefaultCases(!0)
									}
									_addCase() {
										return this._caseCount++
									}
									_addDefault(M) {
										this._defaultViews.push(M)
									}
									_matchCase(M) {
										const ae = M == this._ngSwitch;
										return this._lastCasesMatched = this._lastCasesMatched || ae, this._lastCaseCheckIndex++, this._lastCaseCheckIndex === this._caseCount && (this._updateDefaultCases(!this._lastCasesMatched), this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1), ae
									}
									_updateDefaultCases(M) {
										if (this._defaultViews.length > 0 && M !== this._defaultUsed) {
											this._defaultUsed = M;
											for (const ae of this._defaultViews) ae.enforceState(M)
										}
									}
								}
								return I.\u0275fac = function(M) {
									return new(M || I)
								}, I.\u0275dir = p.lG2({
									type: I,
									selectors: [
										["", "ngSwitch", ""]
									],
									inputs: {
										ngSwitch: "ngSwitch"
									},
									standalone: !0
								}), I
							})(),
							Jn = (() => {
								class I {
									constructor(M, ae, Oe) {
										this.ngSwitch = Oe, Oe._addCase(), this._view = new Mn(M, ae)
									}
									ngDoCheck() {
										this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase))
									}
								}
								return I.\u0275fac = function(M) {
									return new(M || I)(p.Y36(p.s_b), p.Y36(p.Rgc), p.Y36(Cn, 9))
								}, I.\u0275dir = p.lG2({
									type: I,
									selectors: [
										["", "ngSwitchCase", ""]
									],
									inputs: {
										ngSwitchCase: "ngSwitchCase"
									},
									standalone: !0
								}), I
							})(),
							xn = (() => {
								class I {
									constructor(M, ae, Oe) {
										Oe._addDefault(new Mn(M, ae))
									}
								}
								return I.\u0275fac = function(M) {
									return new(M || I)(p.Y36(p.s_b), p.Y36(p.Rgc), p.Y36(Cn, 9))
								}, I.\u0275dir = p.lG2({
									type: I,
									selectors: [
										["", "ngSwitchDefault", ""]
									],
									standalone: !0
								}), I
							})(),
							qe = (() => {
								class I {
									constructor(M, ae, Oe) {
										this._ngEl = M, this._differs = ae, this._renderer = Oe, this._ngStyle = null, this._differ = null
									}
									set ngStyle(M) {
										this._ngStyle = M, !this._differ && M && (this._differ = this._differs.find(M).create())
									}
									ngDoCheck() {
										if (this._differ) {
											const M = this._differ.diff(this._ngStyle);
											M && this._applyChanges(M)
										}
									}
									_setStyle(M, ae) {
										const [Oe, ut] = M.split("."), It = -1 === Oe.indexOf("-") ? void 0 : p.JOm.DashCase;
										null != ae ? this._renderer.setStyle(this._ngEl.nativeElement, Oe, ut ? `${ae}${ut}` : ae, It) : this._renderer.removeStyle(this._ngEl.nativeElement, Oe, It)
									}
									_applyChanges(M) {
										M.forEachRemovedItem(ae => this._setStyle(ae.key, null)), M.forEachAddedItem(ae => this._setStyle(ae.key, ae.currentValue)), M.forEachChangedItem(ae => this._setStyle(ae.key, ae.currentValue))
									}
								}
								return I.\u0275fac = function(M) {
									return new(M || I)(p.Y36(p.SBq), p.Y36(p.aQg), p.Y36(p.Qsj))
								}, I.\u0275dir = p.lG2({
									type: I,
									selectors: [
										["", "ngStyle", ""]
									],
									inputs: {
										ngStyle: "ngStyle"
									},
									standalone: !0
								}), I
							})(),
							dt = (() => {
								class I {
									constructor(M) {
										this._viewContainerRef = M, this._viewRef = null, this.ngTemplateOutletContext = null, this.ngTemplateOutlet = null, this.ngTemplateOutletInjector = null
									}
									ngOnChanges(M) {
										if (M.ngTemplateOutlet || M.ngTemplateOutletInjector) {
											const ae = this._viewContainerRef;
											if (this._viewRef && ae.remove(ae.indexOf(this._viewRef)), this.ngTemplateOutlet) {
												const {
													ngTemplateOutlet: Oe,
													ngTemplateOutletContext: ut,
													ngTemplateOutletInjector: It
												} = this;
												this._viewRef = ae.createEmbeddedView(Oe, ut, It ? {
													injector: It
												} : void 0)
											} else this._viewRef = null
										} else this._viewRef && M.ngTemplateOutletContext && this.ngTemplateOutletContext && (this._viewRef.context = this.ngTemplateOutletContext)
									}
								}
								return I.\u0275fac = function(M) {
									return new(M || I)(p.Y36(p.s_b))
								}, I.\u0275dir = p.lG2({
									type: I,
									selectors: [
										["", "ngTemplateOutlet", ""]
									],
									inputs: {
										ngTemplateOutletContext: "ngTemplateOutletContext",
										ngTemplateOutlet: "ngTemplateOutlet",
										ngTemplateOutletInjector: "ngTemplateOutletInjector"
									},
									standalone: !0,
									features: [p.TTD]
								}), I
							})();

						function Mt(I, W) {
							return new p.vHH(2100, !1)
						}
						class Fn {
							createSubscription(W, M) {
								return W.subscribe({
									next: M,
									error: ae => {
										throw ae
									}
								})
							}
							dispose(W) {
								W.unsubscribe()
							}
						}
						class ir {
							createSubscription(W, M) {
								return W.then(M, ae => {
									throw ae
								})
							}
							dispose(W) {}
						}
						const cr = new ir,
							br = new Fn;
						let $n = (() => {
							class I {
								constructor(M) {
									this._latestValue = null, this._subscription = null, this._obj = null, this._strategy = null, this._ref = M
								}
								ngOnDestroy() {
									this._subscription && this._dispose(), this._ref = null
								}
								transform(M) {
									return this._obj ? M !== this._obj ? (this._dispose(), this.transform(M)) : this._latestValue : (M && this._subscribe(M), this._latestValue)
								}
								_subscribe(M) {
									this._obj = M, this._strategy = this._selectStrategy(M), this._subscription = this._strategy.createSubscription(M, ae => this._updateLatestValue(M, ae))
								}
								_selectStrategy(M) {
									if ((0, p.QGY)(M)) return cr;
									if ((0, p.F4k)(M)) return br;
									throw Mt()
								}
								_dispose() {
									this._strategy.dispose(this._subscription), this._latestValue = null, this._subscription = null, this._obj = null
								}
								_updateLatestValue(M, ae) {
									M === this._obj && (this._latestValue = ae, this._ref.markForCheck())
								}
							}
							return I.\u0275fac = function(M) {
								return new(M || I)(p.Y36(p.sBO, 16))
							}, I.\u0275pipe = p.Yjl({
								name: "async",
								type: I,
								pure: !1,
								standalone: !0
							}), I
						})();
						const No = /(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])\S*/g;
						let lr = (() => {
								class I {
									transform(M) {
										if (null == M) return null;
										if ("string" != typeof M) throw Mt();
										return M.replace(No, ae => ae[0].toUpperCase() + ae.slice(1).toLowerCase())
									}
								}
								return I.\u0275fac = function(M) {
									return new(M || I)
								}, I.\u0275pipe = p.Yjl({
									name: "titlecase",
									type: I,
									pure: !0,
									standalone: !0
								}), I
							})(),
							gr = (() => {
								class I {
									transform(M) {
										if (null == M) return null;
										if ("string" != typeof M) throw Mt();
										return M.toUpperCase()
									}
								}
								return I.\u0275fac = function(M) {
									return new(M || I)
								}, I.\u0275pipe = p.Yjl({
									name: "uppercase",
									type: I,
									pure: !0,
									standalone: !0
								}), I
							})(),
							Is = (() => {
								class I {
									constructor(M) {
										this.differs = M, this.keyValues = [], this.compareFn = Jo
									}
									transform(M, ae = Jo) {
										if (!M || !(M instanceof Map) && "object" != typeof M) return null;
										this.differ || (this.differ = this.differs.find(M).create());
										const Oe = this.differ.diff(M),
											ut = ae !== this.compareFn;
										return Oe && (this.keyValues = [], Oe.forEachItem(It => {
											this.keyValues.push(function Qo(I, W) {
												return {
													key: I,
													value: W
												}
											}(It.key, It.currentValue))
										})), (Oe || ut) && (this.keyValues.sort(ae), this.compareFn = ae), this.keyValues
									}
								}
								return I.\u0275fac = function(M) {
									return new(M || I)(p.Y36(p.aQg, 16))
								}, I.\u0275pipe = p.Yjl({
									name: "keyvalue",
									type: I,
									pure: !1,
									standalone: !0
								}), I
							})();

						function Jo(I, W) {
							const M = I.key,
								ae = W.key;
							if (M === ae) return 0;
							if (void 0 === M) return 1;
							if (void 0 === ae) return -1;
							if (null === M) return 1;
							if (null === ae) return -1;
							if ("string" == typeof M && "string" == typeof ae) return M < ae ? -1 : 1;
							if ("number" == typeof M && "number" == typeof ae) return M - ae;
							if ("boolean" == typeof M && "boolean" == typeof ae) return M < ae ? -1 : 1;
							const Oe = String(M),
								ut = String(ae);
							return Oe == ut ? 0 : Oe < ut ? -1 : 1
						}
						let ac = (() => {
							class I {}
							return I.\u0275fac = function(M) {
								return new(M || I)
							}, I.\u0275mod = p.oAB({
								type: I
							}), I.\u0275inj = p.cJS({}), I
						})();
						const ca = "browser";

						function so(I) {
							return I === ca
						}
						let ao = (() => {
							class I {}
							return I.\u0275prov = (0, p.Yz7)({
								token: I,
								providedIn: "root",
								factory: () => new Rs((0, p.LFG)(P), window)
							}), I
						})();
						class Rs {
							constructor(W, M) {
								this.document = W, this.window = M, this.offset = () => [0, 0]
							}
							setOffset(W) {
								this.offset = Array.isArray(W) ? () => W : W
							}
							getScrollPosition() {
								return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0]
							}
							scrollToPosition(W) {
								this.supportsScrolling() && this.window.scrollTo(W[0], W[1])
							}
							scrollToAnchor(W) {
								if (!this.supportsScrolling()) return;
								const M = function cc(I, W) {
									const M = I.getElementById(W) || I.getElementsByName(W)[0];
									if (M) return M;
									if ("function" == typeof I.createTreeWalker && I.body && (I.body.createShadowRoot || I.body.attachShadow)) {
										const ae = I.createTreeWalker(I.body, NodeFilter.SHOW_ELEMENT);
										let Oe = ae.currentNode;
										for (; Oe;) {
											const ut = Oe.shadowRoot;
											if (ut) {
												const It = ut.getElementById(W) || ut.querySelector(`[name="${W}"]`);
												if (It) return It
											}
											Oe = ae.nextNode()
										}
									}
									return null
								}(this.document, W);
								M && (this.scrollToElement(M), M.focus())
							}
							setHistoryScrollRestoration(W) {
								if (this.supportScrollRestoration()) {
									const M = this.window.history;
									M && M.scrollRestoration && (M.scrollRestoration = W)
								}
							}
							scrollToElement(W) {
								const M = W.getBoundingClientRect(),
									ae = M.left + this.window.pageXOffset,
									Oe = M.top + this.window.pageYOffset,
									ut = this.offset();
								this.window.scrollTo(ae - ut[0], Oe - ut[1])
							}
							supportScrollRestoration() {
								try {
									if (!this.supportsScrolling()) return !1;
									const W = da(this.window.history) || da(Object.getPrototypeOf(this.window.history));
									return !(!W || !W.writable && !W.set)
								} catch {
									return !1
								}
							}
							supportsScrolling() {
								try {
									return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window
								} catch {
									return !1
								}
							}
						}

						function da(I) {
							return Object.getOwnPropertyDescriptor(I, "scrollRestoration")
						}
						class lc {}
					}, 5734: (be, ue, E) => {
						E.d(ue, {
							JF: () => De,
							TP: () => ht,
							UA: () => et,
							eN: () => Be
						});
						var p = E(7774),
							y = E(3991),
							D = E(5195),
							z = E(4070),
							ee = E(6424),
							P = E(9754),
							N = E(7580);
						class Y {}
						class G {}
						class Q {
							constructor(H) {
								this.normalizedNames = new Map, this.lazyUpdate = null, H ? this.lazyInit = "string" == typeof H ? () => {
									this.headers = new Map, H.split("\n").forEach(ne => {
										const Ne = ne.indexOf(":");
										if (Ne > 0) {
											const Ye = ne.slice(0, Ne),
												Ft = Ye.toLowerCase(),
												an = ne.slice(Ne + 1).trim();
											this.maybeSetNormalizedName(Ye, Ft), this.headers.has(Ft) ? this.headers.get(Ft).push(an) : this.headers.set(Ft, [an])
										}
									})
								} : () => {
									this.headers = new Map, Object.keys(H).forEach(ne => {
										let Ne = H[ne];
										const Ye = ne.toLowerCase();
										"string" == typeof Ne && (Ne = [Ne]), Ne.length > 0 && (this.headers.set(Ye, Ne), this.maybeSetNormalizedName(ne, Ye))
									})
								} : this.headers = new Map
							}
							has(H) {
								return this.init(), this.headers.has(H.toLowerCase())
							}
							get(H) {
								this.init();
								const ne = this.headers.get(H.toLowerCase());
								return ne && ne.length > 0 ? ne[0] : null
							}
							keys() {
								return this.init(), Array.from(this.normalizedNames.values())
							}
							getAll(H) {
								return this.init(), this.headers.get(H.toLowerCase()) || null
							}
							append(H, ne) {
								return this.clone({
									name: H,
									value: ne,
									op: "a"
								})
							}
							set(H, ne) {
								return this.clone({
									name: H,
									value: ne,
									op: "s"
								})
							}
							delete(H, ne) {
								return this.clone({
									name: H,
									value: ne,
									op: "d"
								})
							}
							maybeSetNormalizedName(H, ne) {
								this.normalizedNames.has(ne) || this.normalizedNames.set(ne, H)
							}
							init() {
								this.lazyInit && (this.lazyInit instanceof Q ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(H => this.applyUpdate(H)), this.lazyUpdate = null))
							}
							copyFrom(H) {
								H.init(), Array.from(H.headers.keys()).forEach(ne => {
									this.headers.set(ne, H.headers.get(ne)), this.normalizedNames.set(ne, H.normalizedNames.get(ne))
								})
							}
							clone(H) {
								const ne = new Q;
								return ne.lazyInit = this.lazyInit && this.lazyInit instanceof Q ? this.lazyInit : this, ne.lazyUpdate = (this.lazyUpdate || []).concat([H]), ne
							}
							applyUpdate(H) {
								const ne = H.name.toLowerCase();
								switch (H.op) {
									case "a":
									case "s":
										let Ne = H.value;
										if ("string" == typeof Ne && (Ne = [Ne]), 0 === Ne.length) return;
										this.maybeSetNormalizedName(H.name, ne);
										const Ye = ("a" === H.op ? this.headers.get(ne) : void 0) || [];
										Ye.push(...Ne), this.headers.set(ne, Ye);
										break;
									case "d":
										const Ft = H.value;
										if (Ft) {
											let an = this.headers.get(ne);
											if (!an) return;
											an = an.filter(xt => -1 === Ft.indexOf(xt)), 0 === an.length ? (this.headers.delete(ne), this.normalizedNames.delete(ne)) : this.headers.set(ne, an)
										} else this.headers.delete(ne), this.normalizedNames.delete(ne)
								}
							}
							forEach(H) {
								this.init(), Array.from(this.normalizedNames.keys()).forEach(ne => H(this.normalizedNames.get(ne), this.headers.get(ne)))
							}
						}
						class te {
							encodeKey(H) {
								return Fe(H)
							}
							encodeValue(H) {
								return Fe(H)
							}
							decodeKey(H) {
								return decodeURIComponent(H)
							}
							decodeValue(H) {
								return decodeURIComponent(H)
							}
						}
						const oe = /%(\d[a-f0-9])/gi,
							we = {
								40: "@",
								"3A": ":",
								24: "$",
								"2C": ",",
								"3B": ";",
								"3D": "=",
								"3F": "?",
								"2F": "/"
							};

						function Fe(k) {
							return encodeURIComponent(k).replace(oe, (H, ne) => we[ne] ?? H)
						}

						function Le(k) {
							return `${k}`
						}
						class je {
							constructor(H = {}) {
								if (this.updates = null, this.cloneFrom = null, this.encoder = H.encoder || new te, H.fromString) {
									if (H.fromObject) throw new Error("Cannot specify both fromString and fromObject.");
									this.map = function ie(k, H) {
										const ne = new Map;
										return k.length > 0 && k.replace(/^\?/, "").split("&").forEach(Ye => {
											const Ft = Ye.indexOf("="),
												[an, xt] = -1 == Ft ? [H.decodeKey(Ye), ""] : [H.decodeKey(Ye.slice(0, Ft)), H.decodeValue(Ye.slice(Ft + 1))],
												ln = ne.get(an) || [];
											ln.push(xt), ne.set(an, ln)
										}), ne
									}(H.fromString, this.encoder)
								} else H.fromObject ? (this.map = new Map, Object.keys(H.fromObject).forEach(ne => {
									const Ne = H.fromObject[ne],
										Ye = Array.isArray(Ne) ? Ne.map(Le) : [Le(Ne)];
									this.map.set(ne, Ye)
								})) : this.map = null
							}
							has(H) {
								return this.init(), this.map.has(H)
							}
							get(H) {
								this.init();
								const ne = this.map.get(H);
								return ne ? ne[0] : null
							}
							getAll(H) {
								return this.init(), this.map.get(H) || null
							}
							keys() {
								return this.init(), Array.from(this.map.keys())
							}
							append(H, ne) {
								return this.clone({
									param: H,
									value: ne,
									op: "a"
								})
							}
							appendAll(H) {
								const ne = [];
								return Object.keys(H).forEach(Ne => {
									const Ye = H[Ne];
									Array.isArray(Ye) ? Ye.forEach(Ft => {
										ne.push({
											param: Ne,
											value: Ft,
											op: "a"
										})
									}) : ne.push({
										param: Ne,
										value: Ye,
										op: "a"
									})
								}), this.clone(ne)
							}
							set(H, ne) {
								return this.clone({
									param: H,
									value: ne,
									op: "s"
								})
							}
							delete(H, ne) {
								return this.clone({
									param: H,
									value: ne,
									op: "d"
								})
							}
							toString() {
								return this.init(), this.keys().map(H => {
									const ne = this.encoder.encodeKey(H);
									return this.map.get(H).map(Ne => ne + "=" + this.encoder.encodeValue(Ne)).join("&")
								}).filter(H => "" !== H).join("&")
							}
							clone(H) {
								const ne = new je({
									encoder: this.encoder
								});
								return ne.cloneFrom = this.cloneFrom || this, ne.updates = (this.updates || []).concat(H), ne
							}
							init() {
								null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(H => this.map.set(H, this.cloneFrom.map.get(H))), this.updates.forEach(H => {
									switch (H.op) {
										case "a":
										case "s":
											const ne = ("a" === H.op ? this.map.get(H.param) : void 0) || [];
											ne.push(Le(H.value)), this.map.set(H.param, ne);
											break;
										case "d":
											if (void 0 === H.value) {
												this.map.delete(H.param);
												break
											} {
												let Ne = this.map.get(H.param) || [];
												const Ye = Ne.indexOf(Le(H.value)); - 1 !== Ye && Ne.splice(Ye, 1), Ne.length > 0 ? this.map.set(H.param, Ne) : this.map.delete(H.param)
											}
									}
								}), this.cloneFrom = this.updates = null)
							}
						}
						class F {
							constructor() {
								this.map = new Map
							}
							set(H, ne) {
								return this.map.set(H, ne), this
							}
							get(H) {
								return this.map.has(H) || this.map.set(H, H.defaultValue()), this.map.get(H)
							}
							delete(H) {
								return this.map.delete(H), this
							}
							has(H) {
								return this.map.has(H)
							}
							keys() {
								return this.map.keys()
							}
						}

						function Ee(k) {
							return typeof ArrayBuffer < "u" && k instanceof ArrayBuffer
						}

						function Ue(k) {
							return typeof Blob < "u" && k instanceof Blob
						}

						function ke(k) {
							return typeof FormData < "u" && k instanceof FormData
						}
						class ft {
							constructor(H, ne, Ne, Ye) {
								let Ft;
								if (this.url = ne, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = H.toUpperCase(), function xe(k) {
										switch (k) {
											case "DELETE":
											case "GET":
											case "HEAD":
											case "OPTIONS":
											case "JSONP":
												return !1;
											default:
												return !0
										}
									}(this.method) || Ye ? (this.body = void 0 !== Ne ? Ne : null, Ft = Ye) : Ft = Ne, Ft && (this.reportProgress = !!Ft.reportProgress, this.withCredentials = !!Ft.withCredentials, Ft.responseType && (this.responseType = Ft.responseType), Ft.headers && (this.headers = Ft.headers), Ft.context && (this.context = Ft.context), Ft.params && (this.params = Ft.params)), this.headers || (this.headers = new Q), this.context || (this.context = new F), this.params) {
									const an = this.params.toString();
									if (0 === an.length) this.urlWithParams = ne;
									else {
										const xt = ne.indexOf("?");
										this.urlWithParams = ne + (-1 === xt ? "?" : xt < ne.length - 1 ? "&" : "") + an
									}
								} else this.params = new je, this.urlWithParams = ne
							}
							serializeBody() {
								return null === this.body ? null : Ee(this.body) || Ue(this.body) || ke(this.body) || function Ge(k) {
									return typeof URLSearchParams < "u" && k instanceof URLSearchParams
								}(this.body) || "string" == typeof this.body ? this.body : this.body instanceof je ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString()
							}
							detectContentTypeHeader() {
								return null === this.body || ke(this.body) ? null : Ue(this.body) ? this.body.type || null : Ee(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof je ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body ? "application/json" : null
							}
							clone(H = {}) {
								const ne = H.method || this.method,
									Ne = H.url || this.url,
									Ye = H.responseType || this.responseType,
									Ft = void 0 !== H.body ? H.body : this.body,
									an = void 0 !== H.withCredentials ? H.withCredentials : this.withCredentials,
									xt = void 0 !== H.reportProgress ? H.reportProgress : this.reportProgress;
								let ln = H.headers || this.headers,
									yn = H.params || this.params;
								const nr = H.context ?? this.context;
								return void 0 !== H.setHeaders && (ln = Object.keys(H.setHeaders).reduce((Dn, En) => Dn.set(En, H.setHeaders[En]), ln)), H.setParams && (yn = Object.keys(H.setParams).reduce((Dn, En) => Dn.set(En, H.setParams[En]), yn)), new ft(ne, Ne, Ft, {
									params: yn,
									headers: ln,
									context: nr,
									reportProgress: xt,
									responseType: Ye,
									withCredentials: an
								})
							}
						}
						var nt = (() => ((nt = nt || {})[nt.Sent = 0] = "Sent", nt[nt.UploadProgress = 1] = "UploadProgress", nt[nt.ResponseHeader = 2] = "ResponseHeader", nt[nt.DownloadProgress = 3] = "DownloadProgress", nt[nt.Response = 4] = "Response", nt[nt.User = 5] = "User", nt))();
						class Pt {
							constructor(H, ne = 200, Ne = "OK") {
								this.headers = H.headers || new Q, this.status = void 0 !== H.status ? H.status : ne, this.statusText = H.statusText || Ne, this.url = H.url || null, this.ok = this.status >= 200 && this.status < 300
							}
						}
						class at extends Pt {
							constructor(H = {}) {
								super(H), this.type = nt.ResponseHeader
							}
							clone(H = {}) {
								return new at({
									headers: H.headers || this.headers,
									status: void 0 !== H.status ? H.status : this.status,
									statusText: H.statusText || this.statusText,
									url: H.url || this.url || void 0
								})
							}
						}
						class lt extends Pt {
							constructor(H = {}) {
								super(H), this.type = nt.Response, this.body = void 0 !== H.body ? H.body : null
							}
							clone(H = {}) {
								return new lt({
									body: void 0 !== H.body ? H.body : this.body,
									headers: H.headers || this.headers,
									status: void 0 !== H.status ? H.status : this.status,
									statusText: H.statusText || this.statusText,
									url: H.url || this.url || void 0
								})
							}
						}
						class et extends Pt {
							constructor(H) {
								super(H, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${H.url||"(unknown url)"}` : `Http failure response for ${H.url||"(unknown url)"}: ${H.status} ${H.statusText}`, this.error = H.error || null
							}
						}

						function Se(k, H) {
							return {
								body: H,
								headers: k.headers,
								context: k.context,
								observe: k.observe,
								params: k.params,
								reportProgress: k.reportProgress,
								responseType: k.responseType,
								withCredentials: k.withCredentials
							}
						}
						let Be = (() => {
							class k {
								constructor(ne) {
									this.handler = ne
								}
								request(ne, Ne, Ye = {}) {
									let Ft;
									if (ne instanceof ft) Ft = ne;
									else {
										let ln, yn;
										ln = Ye.headers instanceof Q ? Ye.headers : new Q(Ye.headers), Ye.params && (yn = Ye.params instanceof je ? Ye.params : new je({
											fromObject: Ye.params
										})), Ft = new ft(ne, Ne, void 0 !== Ye.body ? Ye.body : null, {
											headers: ln,
											context: Ye.context,
											params: yn,
											reportProgress: Ye.reportProgress,
											responseType: Ye.responseType || "json",
											withCredentials: Ye.withCredentials
										})
									}
									const an = (0, D.of)(Ft).pipe((0, ee.b)(ln => this.handler.handle(ln)));
									if (ne instanceof ft || "events" === Ye.observe) return an;
									const xt = an.pipe((0, P.h)(ln => ln instanceof lt));
									switch (Ye.observe || "body") {
										case "body":
											switch (Ft.responseType) {
												case "arraybuffer":
													return xt.pipe((0, N.U)(ln => {
														if (null !== ln.body && !(ln.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer.");
														return ln.body
													}));
												case "blob":
													return xt.pipe((0, N.U)(ln => {
														if (null !== ln.body && !(ln.body instanceof Blob)) throw new Error("Response is not a Blob.");
														return ln.body
													}));
												case "text":
													return xt.pipe((0, N.U)(ln => {
														if (null !== ln.body && "string" != typeof ln.body) throw new Error("Response is not a string.");
														return ln.body
													}));
												default:
													return xt.pipe((0, N.U)(ln => ln.body))
											}
										case "response":
											return xt;
										default:
											throw new Error(`Unreachable: unhandled observe type ${Ye.observe}}`)
									}
								}
								delete(ne, Ne = {}) {
									return this.request("DELETE", ne, Ne)
								}
								get(ne, Ne = {}) {
									return this.request("GET", ne, Ne)
								}
								head(ne, Ne = {}) {
									return this.request("HEAD", ne, Ne)
								}
								jsonp(ne, Ne) {
									return this.request("JSONP", ne, {
										params: (new je).append(Ne, "JSONP_CALLBACK"),
										observe: "body",
										responseType: "json"
									})
								}
								options(ne, Ne = {}) {
									return this.request("OPTIONS", ne, Ne)
								}
								patch(ne, Ne, Ye = {}) {
									return this.request("PATCH", ne, Se(Ye, Ne))
								}
								post(ne, Ne, Ye = {}) {
									return this.request("POST", ne, Se(Ye, Ne))
								}
								put(ne, Ne, Ye = {}) {
									return this.request("PUT", ne, Se(Ye, Ne))
								}
							}
							return k.\u0275fac = function(ne) {
								return new(ne || k)(y.LFG(Y))
							}, k.\u0275prov = y.Yz7({
								token: k,
								factory: k.\u0275fac
							}), k
						})();

						function ze(k, H) {
							return H(k)
						}

						function it(k, H) {
							return (ne, Ne) => H.intercept(ne, {
								handle: Ye => k(Ye, Ne)
							})
						}
						const ht = new y.OlP("HTTP_INTERCEPTORS"),
							Pe = new y.OlP("HTTP_INTERCEPTOR_FNS");

						function pt() {
							let k = null;
							return (H, ne) => (null === k && (k = ((0, y.f3M)(ht, {
								optional: !0
							}) ?? []).reduceRight(it, ze)), k(H, ne))
						}
						let Bt = (() => {
							class k extends Y {
								constructor(ne, Ne) {
									super(), this.backend = ne, this.injector = Ne, this.chain = null
								}
								handle(ne) {
									if (null === this.chain) {
										const Ne = Array.from(new Set(this.injector.get(Pe)));
										this.chain = Ne.reduceRight((Ye, Ft) => function ce(k, H, ne) {
											return (Ne, Ye) => ne.runInContext(() => H(Ne, Ft => k(Ft, Ye)))
										}(Ye, Ft, this.injector), ze)
									}
									return this.chain(ne, Ne => this.backend.handle(Ne))
								}
							}
							return k.\u0275fac = function(ne) {
								return new(ne || k)(y.LFG(G), y.LFG(y.lqb))
							}, k.\u0275prov = y.Yz7({
								token: k,
								factory: k.\u0275fac
							}), k
						})();
						const bn = /^\)\]\}',?\n/;
						let qt = (() => {
							class k {
								constructor(ne) {
									this.xhrFactory = ne
								}
								handle(ne) {
									if ("JSONP" === ne.method) throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed.");
									return new z.y(Ne => {
										const Ye = this.xhrFactory.build();
										if (Ye.open(ne.method, ne.urlWithParams), ne.withCredentials && (Ye.withCredentials = !0), ne.headers.forEach((Me, Ie) => Ye.setRequestHeader(Me, Ie.join(","))), ne.headers.has("Accept") || Ye.setRequestHeader("Accept", "application/json, text/plain, */*"), !ne.headers.has("Content-Type")) {
											const Me = ne.detectContentTypeHeader();
											null !== Me && Ye.setRequestHeader("Content-Type", Me)
										}
										if (ne.responseType) {
											const Me = ne.responseType.toLowerCase();
											Ye.responseType = "json" !== Me ? Me : "text"
										}
										const Ft = ne.serializeBody();
										let an = null;
										const xt = () => {
												if (null !== an) return an;
												const Me = Ye.statusText || "OK",
													Ie = new Q(Ye.getAllResponseHeaders()),
													ge = function Bn(k) {
														return "responseURL" in k && k.responseURL ? k.responseURL : /^X-Request-URL:/m.test(k.getAllResponseHeaders()) ? k.getResponseHeader("X-Request-URL") : null
													}(Ye) || ne.url;
												return an = new at({
													headers: Ie,
													status: Ye.status,
													statusText: Me,
													url: ge
												}), an
											},
											ln = () => {
												let {
													headers: Me,
													status: Ie,
													statusText: ge,
													url: Ke
												} = xt(), Tt = null;
												204 !== Ie && (Tt = typeof Ye.response > "u" ? Ye.responseText : Ye.response), 0 === Ie && (Ie = Tt ? 200 : 0);
												let Xt = Ie >= 200 && Ie < 300;
												if ("json" === ne.responseType && "string" == typeof Tt) {
													const Tn = Tt;
													Tt = Tt.replace(bn, "");
													try {
														Tt = "" !== Tt ? JSON.parse(Tt) : null
													} catch (Zn) {
														Tt = Tn, Xt && (Xt = !1, Tt = {
															error: Zn,
															text: Tt
														})
													}
												}
												Xt ? (Ne.next(new lt({
													body: Tt,
													headers: Me,
													status: Ie,
													statusText: ge,
													url: Ke || void 0
												})), Ne.complete()) : Ne.error(new et({
													error: Tt,
													headers: Me,
													status: Ie,
													statusText: ge,
													url: Ke || void 0
												}))
											},
											yn = Me => {
												const {
													url: Ie
												} = xt(), ge = new et({
													error: Me,
													status: Ye.status || 0,
													statusText: Ye.statusText || "Unknown Error",
													url: Ie || void 0
												});
												Ne.error(ge)
											};
										let nr = !1;
										const Dn = Me => {
												nr || (Ne.next(xt()), nr = !0);
												let Ie = {
													type: nt.DownloadProgress,
													loaded: Me.loaded
												};
												Me.lengthComputable && (Ie.total = Me.total), "text" === ne.responseType && Ye.responseText && (Ie.partialText = Ye.responseText), Ne.next(Ie)
											},
											En = Me => {
												let Ie = {
													type: nt.UploadProgress,
													loaded: Me.loaded
												};
												Me.lengthComputable && (Ie.total = Me.total), Ne.next(Ie)
											};
										return Ye.addEventListener("load", ln), Ye.addEventListener("error", yn), Ye.addEventListener("timeout", yn), Ye.addEventListener("abort", yn), ne.reportProgress && (Ye.addEventListener("progress", Dn), null !== Ft && Ye.upload && Ye.upload.addEventListener("progress", En)), Ye.send(Ft), Ne.next({
											type: nt.Sent
										}), () => {
											Ye.removeEventListener("error", yn), Ye.removeEventListener("abort", yn), Ye.removeEventListener("load", ln), Ye.removeEventListener("timeout", yn), ne.reportProgress && (Ye.removeEventListener("progress", Dn), null !== Ft && Ye.upload && Ye.upload.removeEventListener("progress", En)), Ye.readyState !== Ye.DONE && Ye.abort()
										}
									})
								}
							}
							return k.\u0275fac = function(ne) {
								return new(ne || k)(y.LFG(p.JF))
							}, k.\u0275prov = y.Yz7({
								token: k,
								factory: k.\u0275fac
							}), k
						})();
						const tn = new y.OlP("XSRF_ENABLED"),
							en = "XSRF-TOKEN",
							Qn = new y.OlP("XSRF_COOKIE_NAME", {
								providedIn: "root",
								factory: () => en
							}),
							Wn = "X-XSRF-TOKEN",
							Nn = new y.OlP("XSRF_HEADER_NAME", {
								providedIn: "root",
								factory: () => Wn
							});
						class ar {}
						let hr = (() => {
							class k {
								constructor(ne, Ne, Ye) {
									this.doc = ne, this.platform = Ne, this.cookieName = Ye, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0
								}
								getToken() {
									if ("server" === this.platform) return null;
									const ne = this.doc.cookie || "";
									return ne !== this.lastCookieString && (this.parseCount++, this.lastToken = (0, p.Mx)(ne, this.cookieName), this.lastCookieString = ne), this.lastToken
								}
							}
							return k.\u0275fac = function(ne) {
								return new(ne || k)(y.LFG(p.K0), y.LFG(y.Lbi), y.LFG(Qn))
							}, k.\u0275prov = y.Yz7({
								token: k,
								factory: k.\u0275fac
							}), k
						})();

						function un(k, H) {
							const ne = k.url.toLowerCase();
							if (!(0, y.f3M)(tn) || "GET" === k.method || "HEAD" === k.method || ne.startsWith("http://") || ne.startsWith("https://")) return H(k);
							const Ne = (0, y.f3M)(ar).getToken(),
								Ye = (0, y.f3M)(Nn);
							return null != Ne && !k.headers.has(Ye) && (k = k.clone({
								headers: k.headers.set(Ye, Ne)
							})), H(k)
						}
						var Xe = (() => ((Xe = Xe || {})[Xe.Interceptors = 0] = "Interceptors", Xe[Xe.LegacyInterceptors = 1] = "LegacyInterceptors", Xe[Xe.CustomXsrfConfiguration = 2] = "CustomXsrfConfiguration", Xe[Xe.NoXsrfProtection = 3] = "NoXsrfProtection", Xe[Xe.JsonpSupport = 4] = "JsonpSupport", Xe[Xe.RequestsMadeViaParent = 5] = "RequestsMadeViaParent", Xe))();

						function pe(k, H) {
							return {
								\u0275kind: k,
								\u0275providers: H
							}
						}

						function Te(...k) {
							const H = [Be, qt, Bt, {
								provide: Y,
								useExisting: Bt
							}, {
								provide: G,
								useExisting: qt
							}, {
								provide: Pe,
								useValue: un,
								multi: !0
							}, {
								provide: tn,
								useValue: !0
							}, {
								provide: ar,
								useClass: hr
							}];
							for (const ne of k) H.push(...ne.\u0275providers);
							return (0, y.MR2)(H)
						}
						const yt = new y.OlP("LEGACY_INTERCEPTOR_FN");

						function pn({
							cookieName: k,
							headerName: H
						}) {
							const ne = [];
							return void 0 !== k && ne.push({
								provide: Qn,
								useValue: k
							}), void 0 !== H && ne.push({
								provide: Nn,
								useValue: H
							}), pe(Xe.CustomXsrfConfiguration, ne)
						}
						let De = (() => {
							class k {}
							return k.\u0275fac = function(ne) {
								return new(ne || k)
							}, k.\u0275mod = y.oAB({
								type: k
							}), k.\u0275inj = y.cJS({
								providers: [Te(pe(Xe.LegacyInterceptors, [{
									provide: yt,
									useFactory: pt
								}, {
									provide: Pe,
									useExisting: yt,
									multi: !0
								}]), pn({
									cookieName: en,
									headerName: Wn
								}))]
							}), k
						})()
					}, 3991: (be, ue, E) => {
						E.d(ue, {
							$8M: () => Aa,
							$WT: () => f,
							$Z: () => _d,
							AFp: () => By,
							ALo: () => oy,
							AaK: () => Y,
							AsE: () => Di,
							BQk: () => Xs,
							CHM: () => uo,
							CRH: () => gy,
							CZH: () => bp,
							CqO: () => iu,
							D6c: () => ET,
							DdM: () => Wv,
							EJc: () => FS,
							EiD: () => Qh,
							EpF: () => Zc,
							F$t: () => Or,
							F4k: () => ip,
							FYo: () => id,
							FiY: () => Io,
							Gf: () => fy,
							GfV: () => hf,
							Gpc: () => X,
							Hsn: () => vo,
							Ikx: () => xm,
							JOm: () => Do,
							JVY: () => _r,
							JZr: () => Fe,
							Jf7: () => gf,
							KtG: () => cl,
							L6k: () => Vh,
							LAX: () => w_,
							LFG: () => B,
							LSH: () => kl,
							Lbi: () => PS,
							Lck: () => kC,
							MAs: () => vr,
							MGl: () => au,
							MMx: () => zm,
							MR2: () => R_,
							NdJ: () => $d,
							OlP: () => mr,
							Oqu: () => Xr,
							P3R: () => Zh,
							PXZ: () => JS,
							Q6J: () => Gd,
							QGY: () => Vd,
							QbO: () => NS,
							Qsj: () => od,
							R0b: () => Po,
							RDi: () => Hs,
							Rgc: () => sh,
							SBq: () => Kc,
							Sil: () => US,
							Suo: () => py,
							TTD: () => ko,
							TgZ: () => nu,
							Tol: () => wt,
							Udp: () => le,
							VKq: () => qv,
							W1O: () => yy,
							WFA: () => ou,
							WLB: () => Qv,
							X6Q: () => nT,
							XFs: () => en,
							Xpm: () => pr,
							Xts: () => Zu,
							Y36: () => Qa,
							YKP: () => Bv,
							YNc: () => Hd,
							Yjl: () => Ve,
							Yz7: () => Qt,
							Z0I: () => mn,
							ZZ4: () => m_,
							_Bn: () => Uv,
							_UZ: () => ru,
							_Vd: () => zc,
							_c5: () => vT,
							_uU: () => tr,
							aQg: () => __,
							c2e: () => kS,
							cJS: () => Sn,
							cg1: () => Lm,
							d8E: () => Fm,
							dDg: () => YS,
							dqk: () => un,
							eBb: () => T_,
							eFA: () => Xy,
							ekj: () => Re,
							eoX: () => qy,
							evT: () => cd,
							f3M: () => k,
							g9A: () => Gy,
							h0i: () => du,
							hGG: () => yT,
							hij: () => Ki,
							iGM: () => hy,
							ifc: () => Dn,
							ip1: () => Uy,
							jDz: () => Gv,
							kEZ: () => Jv,
							kL8: () => uv,
							kYT: () => Sr,
							l5B: () => Xv,
							lG2: () => Ur,
							lcZ: () => sy,
							lqb: () => mi,
							lri: () => Yy,
							mCW: () => Ol,
							n5z: () => Da,
							oAB: () => ti,
							oJD: () => Xu,
							oxw: () => zd,
							pB0: () => b_,
							q3G: () => Gr,
							q4F: () => ff,
							qLn: () => Ks,
							qOj: () => Md,
							qZA: () => Xc,
							qbA: () => Zv,
							qzn: () => ro,
							rWj: () => Wy,
							s9C: () => ea,
							sBO: () => rT,
							s_b: () => Sp,
							soG: () => Ip,
							tBr: () => as,
							tb: () => jy,
							tp0: () => Ra,
							uIk: () => Ld,
							vHH: () => Le,
							vpe: () => ws,
							wAp: () => Rn,
							xp6: () => Sf,
							ynx: () => Cs,
							z2F: () => Dp,
							z3N: () => _o,
							zSh: () => Vo,
							zs3: () => Wa
						});
						var p = E(8264),
							y = E(2292),
							D = E(4070),
							z = E(805),
							ee = E(7957);

						function P(n) {
							for (let r in n)
								if (n[r] === P) return r;
							throw Error("Could not find renamed property on target object.")
						}

						function N(n, r) {
							for (const o in r) r.hasOwnProperty(o) && !n.hasOwnProperty(o) && (n[o] = r[o])
						}

						function Y(n) {
							if ("string" == typeof n) return n;
							if (Array.isArray(n)) return "[" + n.map(Y).join(", ") + "]";
							if (null == n) return "" + n;
							if (n.overriddenName) return `${n.overriddenName}`;
							if (n.name) return `${n.name}`;
							const r = n.toString();
							if (null == r) return "" + r;
							const o = r.indexOf("\n");
							return -1 === o ? r : r.substring(0, o)
						}

						function G(n, r) {
							return null == n || "" === n ? null === r ? "" : r : null == r || "" === r ? n : n + " " + r
						}
						const Q = P({
							__forward_ref__: P
						});

						function X(n) {
							return n.__forward_ref__ = X, n.toString = function() {
								return Y(this())
							}, n
						}

						function te(n) {
							return ie(n) ? n() : n
						}

						function ie(n) {
							return "function" == typeof n && n.hasOwnProperty(Q) && n.__forward_ref__ === X
						}

						function oe(n) {
							return n && !!n.\u0275providers
						}
						const Fe = "https://g.co/ng/security#xss";
						class Le extends Error {
							constructor(r, o) {
								super(je(r, o)), this.code = r
							}
						}

						function je(n, r) {
							return `NG0${Math.abs(n)}${r?": "+r.trim():""}`
						}

						function Ce(n) {
							return "string" == typeof n ? n : null == n ? "" : String(n)
						}

						function ke(n, r) {
							throw new Le(-201, !1)
						}

						function Pe(n, r) {
							null == n && function pt(n, r, o, a) {
								throw new Error(`ASSERTION ERROR: ${n}` + (null == a ? "" : ` [Expected=> ${o} ${a} ${r} <=Actual]`))
							}(r, n, null, "!=")
						}

						function Qt(n) {
							return {
								token: n.token,
								providedIn: n.providedIn || null,
								factory: n.factory,
								value: void 0
							}
						}

						function Sn(n) {
							return {
								providers: n.providers || [],
								imports: n.imports || []
							}
						}

						function Pn(n) {
							return Un(n, bn) || Un(n, qt)
						}

						function mn(n) {
							return null !== Pn(n)
						}

						function Un(n, r) {
							return n.hasOwnProperty(r) ? n[r] : null
						}

						function Zt(n) {
							return n && (n.hasOwnProperty(Bn) || n.hasOwnProperty(tn)) ? n[Bn] : null
						}
						const bn = P({
								\u0275prov: P
							}),
							Bn = P({
								\u0275inj: P
							}),
							qt = P({
								ngInjectableDef: P
							}),
							tn = P({
								ngInjectorDef: P
							});
						var en = (() => ((en = en || {})[en.Default = 0] = "Default", en[en.Host = 1] = "Host", en[en.Self = 2] = "Self", en[en.SkipSelf = 4] = "SkipSelf", en[en.Optional = 8] = "Optional", en))();
						let Qn;

						function Nn(n) {
							const r = Qn;
							return Qn = n, r
						}

						function ar(n, r, o) {
							const a = Pn(n);
							return a && "root" == a.providedIn ? void 0 === a.value ? a.value = a.factory() : a.value : o & en.Optional ? null : void 0 !== r ? r : void ke(Y(n))
						}
						const un = (() => typeof globalThis < "u" && globalThis || typeof global < "u" && global || typeof window < "u" && window || typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self)(),
							Te = {},
							Je = "__NG_DI_FLAG__",
							yt = "ngTempTokenPath",
							Ht = "ngTokenPath",
							pn = /\n/gm,
							$t = "\u0275",
							hn = "__source";
						let kt;

						function ct(n) {
							const r = kt;
							return kt = n, r
						}

						function De(n, r = en.Default) {
							if (void 0 === kt) throw new Le(-203, !1);
							return null === kt ? ar(n, void 0, r) : kt.get(n, r & en.Optional ? null : void 0, r)
						}

						function B(n, r = en.Default) {
							return (function Wn() {
								return Qn
							}() || De)(te(n), r)
						}

						function k(n, r = en.Default) {
							return B(n, H(r))
						}

						function H(n) {
							return typeof n > "u" || "number" == typeof n ? n : 0 | (n.optional && 8) | (n.host && 1) | (n.self && 2) | (n.skipSelf && 4)
						}

						function ne(n) {
							const r = [];
							for (let o = 0; o < n.length; o++) {
								const a = te(n[o]);
								if (Array.isArray(a)) {
									if (0 === a.length) throw new Le(900, !1);
									let l, d = en.Default;
									for (let _ = 0; _ < a.length; _++) {
										const w = a[_],
											R = Ye(w);
										"number" == typeof R ? -1 === R ? l = w.token : d |= R : l = w
									}
									r.push(B(l, d))
								} else r.push(B(a))
							}
							return r
						}

						function Ne(n, r) {
							return n[Je] = r, n.prototype[Je] = r, n
						}

						function Ye(n) {
							return n[Je]
						}

						function xt(n) {
							return {
								toString: n
							}.toString()
						}
						var ln = (() => ((ln = ln || {})[ln.OnPush = 0] = "OnPush", ln[ln.Default = 1] = "Default", ln))(),
							Dn = (() => {
								return (n = Dn || (Dn = {}))[n.Emulated = 0] = "Emulated", n[n.None = 2] = "None", n[n.ShadowDom = 3] = "ShadowDom", Dn;
								var n
							})();
						const En = {},
							Me = [],
							Ie = P({
								\u0275cmp: P
							}),
							ge = P({
								\u0275dir: P
							}),
							Ke = P({
								\u0275pipe: P
							}),
							Tt = P({
								\u0275mod: P
							}),
							Xt = P({
								\u0275fac: P
							}),
							Tn = P({
								__NG_ELEMENT_ID__: P
							});
						let Zn = 0;

						function pr(n) {
							return xt(() => {
								const o = !0 === n.standalone,
									a = {},
									l = {
										type: n.type,
										providersResolver: null,
										decls: n.decls,
										vars: n.vars,
										factory: null,
										template: n.template || null,
										consts: n.consts || null,
										ngContentSelectors: n.ngContentSelectors,
										hostBindings: n.hostBindings || null,
										hostVars: n.hostVars || 0,
										hostAttrs: n.hostAttrs || null,
										contentQueries: n.contentQueries || null,
										declaredInputs: a,
										inputs: null,
										outputs: null,
										exportAs: n.exportAs || null,
										onPush: n.changeDetection === ln.OnPush,
										directiveDefs: null,
										pipeDefs: null,
										standalone: o,
										dependencies: o && n.dependencies || null,
										getStandaloneInjector: null,
										selectors: n.selectors || Me,
										viewQuery: n.viewQuery || null,
										features: n.features || null,
										data: n.data || {},
										encapsulation: n.encapsulation || Dn.Emulated,
										id: "c" + Zn++,
										styles: n.styles || Me,
										_: null,
										setInput: null,
										schemas: n.schemas || null,
										tView: null,
										findHostDirectiveDefs: null,
										hostDirectives: null
									},
									d = n.dependencies,
									_ = n.features;
								return l.inputs = $r(n.inputs, a), l.outputs = $r(n.outputs), _ && _.forEach(w => w(l)), l.directiveDefs = d ? () => ("function" == typeof d ? d() : d).map(vt).filter(ei) : null, l.pipeDefs = d ? () => ("function" == typeof d ? d() : d).map(fe).filter(ei) : null, l
							})
						}

						function vt(n) {
							return V(n) || U(n)
						}

						function ei(n) {
							return null !== n
						}

						function ti(n) {
							return xt(() => ({
								type: n.type,
								bootstrap: n.bootstrap || Me,
								declarations: n.declarations || Me,
								imports: n.imports || Me,
								exports: n.exports || Me,
								transitiveCompileScopes: null,
								schemas: n.schemas || null,
								id: n.id || null
							}))
						}

						function Sr(n, r) {
							return xt(() => {
								const o = T(n, !0);
								o.declarations = r.declarations || Me, o.imports = r.imports || Me, o.exports = r.exports || Me
							})
						}

						function $r(n, r) {
							if (null == n) return En;
							const o = {};
							for (const a in n)
								if (n.hasOwnProperty(a)) {
									let l = n[a],
										d = l;
									Array.isArray(l) && (d = l[1], l = l[0]), o[l] = a, r && (r[l] = d)
								} return o
						}
						const Ur = pr;

						function Ve(n) {
							return {
								type: n.type,
								name: n.name,
								factory: null,
								pure: !1 !== n.pure,
								standalone: !0 === n.standalone,
								onDestroy: n.type.prototype.ngOnDestroy || null
							}
						}

						function V(n) {
							return n[Ie] || null
						}

						function U(n) {
							return n[ge] || null
						}

						function fe(n) {
							return n[Ke] || null
						}

						function f(n) {
							const r = V(n) || U(n) || fe(n);
							return null !== r && r.standalone
						}

						function T(n, r) {
							const o = n[Tt] || null;
							if (!o && !0 === r) throw new Error(`Type ${Y(n)} does not have '\u0275mod' property.`);
							return o
						}
						const L = 0,
							K = 1,
							he = 2,
							ye = 3,
							He = 4,
							gt = 5,
							st = 6,
							mt = 7,
							Et = 8,
							Gt = 9,
							Rt = 10,
							Ot = 11,
							Jt = 12,
							Mn = 13,
							Cn = 14,
							Jn = 15,
							xn = 16,
							Br = 17,
							me = 18,
							tt = 19,
							qe = 20,
							dt = 21,
							Dt = 22,
							Fn = 1,
							ir = 2,
							cr = 7,
							br = 8,
							$n = 9,
							or = 10;

						function lr(n) {
							return Array.isArray(n) && "object" == typeof n[Fn]
						}

						function gr(n) {
							return Array.isArray(n) && !0 === n[Fn]
						}

						function xi(n) {
							return 0 != (4 & n.flags)
						}

						function ni(n) {
							return n.componentOffset > -1
						}

						function Si(n) {
							return 1 == (1 & n.flags)
						}

						function ri(n) {
							return null !== n.template
						}

						function oo(n) {
							return 0 != (256 & n[he])
						}

						function Qi(n, r) {
							return n.hasOwnProperty(Xt) ? n[Xt] : null
						}
						class ol {
							constructor(r, o, a) {
								this.previousValue = r, this.currentValue = o, this.firstChange = a
							}
							isFirstChange() {
								return this.firstChange
							}
						}

						function ko() {
							return ao
						}

						function ao(n) {
							return n.type.prototype.ngOnChanges && (n.setInput = da), Rs
						}

						function Rs() {
							const n = ha(this),
								r = n?.current;
							if (r) {
								const o = n.previous;
								if (o === En) n.previous = r;
								else
									for (let a in r) o[a] = r[a];
								n.current = null, this.ngOnChanges(r)
							}
						}

						function da(n, r, o, a) {
							const l = this.declaredInputs[o],
								d = ha(n) || function lc(n, r) {
									return n[cc] = r
								}(n, {
									previous: En,
									current: null
								}),
								_ = d.current || (d.current = {}),
								w = d.previous,
								R = w[l];
							_[l] = new ol(R && R.currentValue, r, w === En), n[a] = r
						}
						ko.ngInherit = !0;
						const cc = "__ngSimpleChanges__";

						function ha(n) {
							return n[cc] || null
						}
						const Ti = function(n, r, o) {};

						function sr(n) {
							for (; Array.isArray(n);) n = n[L];
							return n
						}

						function Ai(n, r) {
							return sr(r[n])
						}

						function kr(n, r) {
							return sr(r[n.index])
						}

						function Os(n, r) {
							return n.data[r]
						}

						function Ji(n, r) {
							return n[r]
						}

						function di(n, r) {
							const o = r[n];
							return lr(o) ? o : o[L]
						}

						function Li(n) {
							return 64 == (64 & n[he])
						}

						function lo(n, r) {
							return null == r ? null : n[r]
						}

						function xo(n) {
							n[me] = 0
						}

						function Ui(n, r) {
							n[gt] += r;
							let o = n,
								a = n[ye];
							for (; null !== a && (1 === r && 1 === o[gt] || -1 === r && 0 === o[gt]);) a[gt] += r, o = a, a = a[ye]
						}
						const wn = {
							lFrame: vc(null),
							bindingsEnabled: !0
						};

						function hc() {
							return wn.bindingsEnabled
						}

						function Ct() {
							return wn.lFrame.lView
						}

						function Gn() {
							return wn.lFrame.tView
						}

						function uo(n) {
							return wn.lFrame.contextLView = n, n[Et]
						}

						function cl(n) {
							return wn.lFrame.contextLView = null, n
						}

						function zr() {
							let n = pc();
							for (; null !== n && 64 === n.type;) n = n.parent;
							return n
						}

						function pc() {
							return wn.lFrame.currentTNode
						}

						function Ri(n, r) {
							const o = wn.lFrame;
							o.currentTNode = n, o.isParent = r
						}

						function ga() {
							return wn.lFrame.isParent
						}

						function ma() {
							wn.lFrame.isParent = !1
						}

						function Kr() {
							const n = wn.lFrame;
							let r = n.bindingRootIndex;
							return -1 === r && (r = n.bindingRootIndex = n.tView.bindingStartIndex), r
						}

						function ho() {
							return wn.lFrame.bindingIndex++
						}

						function wi(n) {
							const r = wn.lFrame,
								o = r.bindingIndex;
							return r.bindingIndex = r.bindingIndex + n, o
						}

						function _c(n, r) {
							const o = wn.lFrame;
							o.bindingIndex = o.bindingRootIndex = n, Hr(r)
						}

						function Hr(n) {
							wn.lFrame.currentDirectiveIndex = n
						}

						function fo(n) {
							const r = wn.lFrame.currentDirectiveIndex;
							return -1 === r ? null : n[r]
						}

						function Eo() {
							return wn.lFrame.currentQueryIndex
						}

						function po(n) {
							wn.lFrame.currentQueryIndex = n
						}

						function xs(n) {
							const r = n[K];
							return 2 === r.type ? r.declTNode : 1 === r.type ? n[st] : null
						}

						function va(n, r, o) {
							if (o & en.SkipSelf) {
								let l = r,
									d = n;
								for (; !(l = l.parent, null !== l || o & en.Host || (l = xs(d), null === l || (d = d[Jn], 10 & l.type))););
								if (null === l) return !1;
								r = l, n = d
							}
							const a = wn.lFrame = ya();
							return a.currentTNode = r, a.lView = n, !0
						}

						function Xi(n) {
							const r = ya(),
								o = n[K];
							wn.lFrame = r, r.currentTNode = o.firstChild, r.lView = n, r.tView = o, r.contextLView = n, r.bindingIndex = o.bindingStartIndex, r.inI18n = !1
						}

						function ya() {
							const n = wn.lFrame,
								r = null === n ? null : n.child;
							return null === r ? vc(n) : r
						}

						function vc(n) {
							const r = {
								currentTNode: null,
								isParent: !0,
								lView: null,
								tView: null,
								selectedIndex: -1,
								contextLView: null,
								elementDepthCount: 0,
								currentNamespace: null,
								currentDirectiveIndex: -1,
								bindingRootIndex: -1,
								bindingIndex: -1,
								currentQueryIndex: 0,
								parent: n,
								child: null,
								inI18n: !1
							};
							return null !== n && (n.child = r), r
						}

						function rs() {
							const n = wn.lFrame;
							return wn.lFrame = n.parent, n.currentTNode = null, n.lView = null, n
						}
						const yc = rs;

						function Fs() {
							const n = rs();
							n.isParent = !0, n.tView = null, n.selectedIndex = -1, n.contextLView = null, n.elementDepthCount = 0, n.currentDirectiveIndex = -1, n.currentNamespace = null, n.bindingRootIndex = -1, n.bindingIndex = -1, n.currentQueryIndex = 0
						}

						function ur() {
							return wn.lFrame.selectedIndex
						}

						function yi(n) {
							wn.lFrame.selectedIndex = n
						}

						function yr() {
							const n = wn.lFrame;
							return Os(n.tView, n.selectedIndex)
						}

						function os(n, r) {
							for (let o = r.directiveStart, a = r.directiveEnd; o < a; o++) {
								const d = n.data[o].type.prototype,
									{
										ngAfterContentInit: _,
										ngAfterContentChecked: w,
										ngAfterViewInit: R,
										ngAfterViewChecked: j,
										ngOnDestroy: se
									} = d;
								_ && (n.contentHooks || (n.contentHooks = [])).push(-o, _), w && ((n.contentHooks || (n.contentHooks = [])).push(o, w), (n.contentCheckHooks || (n.contentCheckHooks = [])).push(o, w)), R && (n.viewHooks || (n.viewHooks = [])).push(-o, R), j && ((n.viewHooks || (n.viewHooks = [])).push(o, j), (n.viewCheckHooks || (n.viewCheckHooks = [])).push(o, j)), null != se && (n.destroyHooks || (n.destroyHooks = [])).push(o, se)
							}
						}

						function I(n, r, o) {
							ae(n, r, 3, o)
						}

						function W(n, r, o, a) {
							(3 & n[he]) === o && ae(n, r, o, a)
						}

						function M(n, r) {
							let o = n[he];
							(3 & o) === r && (o &= 2047, o += 1, n[he] = o)
						}

						function ae(n, r, o, a) {
							const d = a ?? -1,
								_ = r.length - 1;
							let w = 0;
							for (let R = void 0 !== a ? 65535 & n[me] : 0; R < _; R++)
								if ("number" == typeof r[R + 1]) {
									if (w = r[R], null != a && w >= a) break
								} else r[R] < 0 && (n[me] += 65536), (w < d || -1 == d) && (Oe(n, o, r, R), n[me] = (4294901760 & n[me]) + R + 2), R++
						}

						function Oe(n, r, o, a) {
							const l = o[a] < 0,
								d = o[a + 1],
								w = n[l ? -o[a] : o[a]];
							if (l) {
								if (n[he] >> 11 < n[me] >> 16 && (3 & n[he]) === r) {
									n[he] += 2048, Ti(4, w, d);
									try {
										d.call(w)
									} finally {
										Ti(5, w, d)
									}
								}
							} else {
								Ti(4, w, d);
								try {
									d.call(w)
								} finally {
									Ti(5, w, d)
								}
							}
						}
						const ut = -1;
						class It {
							constructor(r, o, a) {
								this.factory = r, this.resolving = !1, this.canSeeViewProviders = o, this.injectImpl = a
							}
						}

						function bi(n, r, o) {
							let a = 0;
							for (; a < o.length;) {
								const l = o[a];
								if ("number" == typeof l) {
									if (0 !== l) break;
									a++;
									const d = o[a++],
										_ = o[a++],
										w = o[a++];
									n.setAttribute(r, _, w, d)
								} else {
									const d = l,
										_ = o[++a];
									Hi(d) ? n.setProperty(r, d, _) : n.setAttribute(r, d, _), a++
								}
							}
							return a
						}

						function Ii(n) {
							return 3 === n || 4 === n || 6 === n
						}

						function Hi(n) {
							return 64 === n.charCodeAt(0)
						}

						function Yr(n, r) {
							if (null !== r && 0 !== r.length)
								if (null === n || 0 === n.length) n = r.slice();
								else {
									let o = -1;
									for (let a = 0; a < r.length; a++) {
										const l = r[a];
										"number" == typeof l ? o = l : 0 === o || Mi(n, o, l, null, -1 === o || 2 === o ? r[++a] : null)
									}
								} return n
						}

						function Mi(n, r, o, a, l) {
							let d = 0,
								_ = n.length;
							if (-1 === r) _ = -1;
							else
								for (; d < n.length;) {
									const w = n[d++];
									if ("number" == typeof w) {
										if (w === r) {
											_ = -1;
											break
										}
										if (w > r) {
											_ = d - 1;
											break
										}
									}
								}
							for (; d < n.length;) {
								const w = n[d];
								if ("number" == typeof w) break;
								if (w === o) {
									if (null === a) return void(null !== l && (n[d + 1] = l));
									if (a === n[d + 1]) return void(n[d + 2] = l)
								}
								d++, null !== a && d++, null !== l && d++
							} - 1 !== _ && (n.splice(_, 0, r), d = _ + 1), n.splice(d++, 0, o), null !== a && n.splice(d++, 0, a), null !== l && n.splice(d++, 0, l)
						}

						function Co(n) {
							return n !== ut
						}

						function So(n) {
							return 32767 & n
						}

						function Sc(n, r) {
							let o = function ch(n) {
									return n >> 16
								}(n),
								a = r;
							for (; o > 0;) a = a[Jn], o--;
							return a
						}
						let fl = !0;

						function Sa(n) {
							const r = fl;
							return fl = n, r
						}
						const Ls = 255,
							_e = 5;
						let St = 0;
						const fi = {};

						function q(n, r) {
							const o = vn(n, r);
							if (-1 !== o) return o;
							const a = r[K];
							a.firstCreatePass && (n.injectorIndex = r.length, _t(a.data, n), _t(r, null), _t(a.blueprint, null));
							const l = Ir(n, r),
								d = n.injectorIndex;
							if (Co(l)) {
								const _ = So(l),
									w = Sc(l, r),
									R = w[K].data;
								for (let j = 0; j < 8; j++) r[d + j] = w[_ + j] | R[_ + j]
							}
							return r[d + 8] = l, d
						}

						function _t(n, r) {
							n.push(0, 0, 0, 0, 0, 0, 0, 0, r)
						}

						function vn(n, r) {
							return -1 === n.injectorIndex || n.parent && n.parent.injectorIndex === n.injectorIndex || null === r[n.injectorIndex + 8] ? -1 : n.injectorIndex
						}

						function Ir(n, r) {
							if (n.parent && -1 !== n.parent.injectorIndex) return n.parent.injectorIndex;
							let o = 0,
								a = null,
								l = r;
							for (; null !== l;) {
								if (a = vu(l), null === a) return ut;
								if (o++, l = l[Jn], -1 !== a.injectorIndex) return a.injectorIndex | o << 16
							}
							return ut
						}

						function Ta(n, r, o) {
							! function mu(n, r, o) {
								let a;
								"string" == typeof o ? a = o.charCodeAt(0) || 0 : o.hasOwnProperty(Tn) && (a = o[Tn]), null == a && (a = o[Tn] = St++);
								const l = a & Ls;
								r.data[n + (l >> _e)] |= 1 << l
							}(n, r, o)
						}

						function Fo(n, r, o) {
							if (o & en.Optional || void 0 !== n) return n;
							ke()
						}

						function Oi(n, r, o, a) {
							if (o & en.Optional && void 0 === a && (a = null), !(o & (en.Self | en.Host))) {
								const l = n[Gt],
									d = Nn(void 0);
								try {
									return l ? l.get(r, a, o & en.Optional) : ar(r, a, o & en.Optional)
								} finally {
									Nn(d)
								}
							}
							return Fo(a, 0, o)
						}

						function Qe(n, r, o, a = en.Default, l) {
							if (null !== n) {
								if (1024 & r[he]) {
									const _ = function uh(n, r, o, a, l) {
										let d = n,
											_ = r;
										for (; null !== d && null !== _ && 1024 & _[he] && !(256 & _[he]);) {
											const w = ba(d, _, o, a | en.Self, fi);
											if (w !== fi) return w;
											let R = d.parent;
											if (!R) {
												const j = _[dt];
												if (j) {
													const se = j.get(o, fi, a);
													if (se !== fi) return se
												}
												R = vu(_), _ = _[Jn]
											}
											d = R
										}
										return l
									}(n, r, o, a, fi);
									if (_ !== fi) return _
								}
								const d = ba(n, r, o, a, fi);
								if (d !== fi) return d
							}
							return Oi(r, o, a, l)
						}

						function ba(n, r, o, a, l) {
							const d = function Tc(n) {
								if ("string" == typeof n) return n.charCodeAt(0) || 0;
								const r = n.hasOwnProperty(Tn) ? n[Tn] : void 0;
								return "number" == typeof r ? r >= 0 ? r & Ls : rn : r
							}(o);
							if ("function" == typeof d) {
								if (!va(r, n, a)) return a & en.Host ? Fo(l, 0, a) : Oi(r, o, a, l);
								try {
									const _ = d(a);
									if (null != _ || a & en.Optional) return _;
									ke()
								} finally {
									yc()
								}
							} else if ("number" == typeof d) {
								let _ = null,
									w = vn(n, r),
									R = ut,
									j = a & en.Host ? r[xn][st] : null;
								for ((-1 === w || a & en.SkipSelf) && (R = -1 === w ? Ir(n, r) : r[w + 8], R !== ut && pl(a, !1) ? (_ = r[K], w = So(R), r = Sc(R, r)) : w = -1); - 1 !== w;) {
									const se = r[K];
									if (pi(d, w, se.data)) {
										const ve = _u(w, r, o, _, a, j);
										if (ve !== fi) return ve
									}
									R = r[w + 8], R !== ut && pl(a, r[K].data[w + 8] === j) && pi(d, w, r) ? (_ = se, w = So(R), r = Sc(R, r)) : w = -1
								}
							}
							return l
						}

						function _u(n, r, o, a, l, d) {
							const _ = r[K],
								w = _.data[n + 8],
								se = Ia(w, _, o, null == a ? ni(w) && fl : a != _ && 0 != (3 & w.type), l & en.Host && d === w);
							return null !== se ? Er(r, _, se, w) : fi
						}

						function Ia(n, r, o, a, l) {
							const d = n.providerIndexes,
								_ = r.data,
								w = 1048575 & d,
								R = n.directiveStart,
								se = d >> 20,
								$e = l ? w + se : n.directiveEnd;
							for (let rt = a ? w : w + se; rt < $e; rt++) {
								const At = _[rt];
								if (rt < R && o === At || rt >= R && At.type === o) return rt
							}
							if (l) {
								const rt = _[R];
								if (rt && ri(rt) && rt.type === o) return R
							}
							return null
						}

						function Er(n, r, o, a) {
							let l = n[o];
							const d = r.data;
							if (function dn(n) {
									return n instanceof It
								}(l)) {
								const _ = l;
								_.resolving && function xe(n, r) {
									const o = r ? `. Dependency path: ${r.join(" > ")} > ${n}` : "";
									throw new Le(-200, `Circular dependency in DI detected for ${n}${o}`)
								}(function F(n) {
									return "function" == typeof n ? n.name || n.toString() : "object" == typeof n && null != n && "function" == typeof n.type ? n.type.name || n.type.toString() : Ce(n)
								}(d[o]));
								const w = Sa(_.canSeeViewProviders);
								_.resolving = !0;
								const R = _.injectImpl ? Nn(_.injectImpl) : null;
								va(n, a, en.Default);
								try {
									l = n[o] = _.factory(void 0, d, n, a), r.firstCreatePass && o >= a.directiveStart && function hl(n, r, o) {
										const {
											ngOnChanges: a,
											ngOnInit: l,
											ngDoCheck: d
										} = r.type.prototype;
										if (a) {
											const _ = ao(r);
											(o.preOrderHooks || (o.preOrderHooks = [])).push(n, _), (o.preOrderCheckHooks || (o.preOrderCheckHooks = [])).push(n, _)
										}
										l && (o.preOrderHooks || (o.preOrderHooks = [])).push(0 - n, l), d && ((o.preOrderHooks || (o.preOrderHooks = [])).push(n, d), (o.preOrderCheckHooks || (o.preOrderCheckHooks = [])).push(n, d))
									}(o, d[o], r)
								} finally {
									null !== R && Nn(R), Sa(w), _.resolving = !1, yc()
								}
							}
							return l
						}

						function pi(n, r, o) {
							return !!(o[r + (n >> _e)] & 1 << n)
						}

						function pl(n, r) {
							return !(n & en.Self || n & en.Host && r)
						}
						class Lo {
							constructor(r, o) {
								this._tNode = r, this._lView = o
							}
							get(r, o, a) {
								return Qe(this._tNode, this._lView, r, H(a), o)
							}
						}

						function rn() {
							return new Lo(zr(), Ct())
						}

						function Da(n) {
							return xt(() => {
								const r = n.prototype.constructor,
									o = r[Xt] || wc(r),
									a = Object.prototype;
								let l = Object.getPrototypeOf(n.prototype).constructor;
								for (; l && l !== a;) {
									const d = l[Xt] || wc(l);
									if (d && d !== o) return d;
									l = Object.getPrototypeOf(l)
								}
								return d => new d
							})
						}

						function wc(n) {
							return ie(n) ? () => {
								const r = wc(te(n));
								return r && r()
							} : Qi(n)
						}

						function vu(n) {
							const r = n[K],
								o = r.type;
							return 2 === o ? r.declTNode : 1 === o ? n[st] : null
						}

						function Aa(n) {
							return function wa(n, r) {
								if ("class" === r) return n.classes;
								if ("style" === r) return n.styles;
								const o = n.attrs;
								if (o) {
									const a = o.length;
									let l = 0;
									for (; l < a;) {
										const d = o[l];
										if (Ii(d)) break;
										if (0 === d) l += 2;
										else if ("number" == typeof d)
											for (l++; l < a && "string" == typeof o[l];) l++;
										else {
											if (d === r) return o[l + 1];
											l += 2
										}
									}
								}
								return null
							}(zr(), n)
						}
						const To = "__parameters__";

						function wo(n, r, o) {
							return xt(() => {
								const a = function bc(n) {
									return function(...o) {
										if (n) {
											const a = n(...o);
											for (const l in a) this[l] = a[l]
										}
									}
								}(r);

								function l(...d) {
									if (this instanceof l) return a.apply(this, d), this;
									const _ = new l(...d);
									return w.annotation = _, w;

									function w(R, j, se) {
										const ve = R.hasOwnProperty(To) ? R[To] : Object.defineProperty(R, To, {
											value: []
										})[To];
										for (; ve.length <= se;) ve.push(null);
										return (ve[se] = ve[se] || []).push(_), R
									}
								}
								return o && (l.prototype = Object.create(o.prototype)), l.prototype.ngMetadataName = n, l.annotationCls = l, l
							})
						}
						class mr {
							constructor(r, o) {
								this._desc = r, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof o ? this.__NG_ELEMENT_ID__ = o : void 0 !== o && (this.\u0275prov = Qt({
									token: this,
									providedIn: o.providedIn || "root",
									factory: o.factory
								}))
							}
							get multi() {
								return this
							}
							toString() {
								return `InjectionToken ${this._desc}`
							}
						}

						function C(n, r) {
							n.forEach(o => Array.isArray(o) ? C(o, r) : r(o))
						}

						function g(n, r, o) {
							r >= n.length ? n.push(o) : n.splice(r, 0, o)
						}

						function b(n, r) {
							return r >= n.length - 1 ? n.pop() : n.splice(r, 1)[0]
						}

						function x(n, r) {
							const o = [];
							for (let a = 0; a < n; a++) o.push(r);
							return o
						}

						function Kt(n, r, o) {
							let a = zn(n, r);
							return a >= 0 ? n[1 | a] = o : (a = ~a, function We(n, r, o, a) {
								let l = n.length;
								if (l == r) n.push(o, a);
								else if (1 === l) n.push(a, n[0]), n[0] = o;
								else {
									for (l--, n.push(n[l - 1], n[l]); l > r;) n[l] = n[l - 2], l--;
									n[r] = o, n[r + 1] = a
								}
							}(n, a, r, o)), a
						}

						function on(n, r) {
							const o = zn(n, r);
							if (o >= 0) return n[1 | o]
						}

						function zn(n, r) {
							return function Gi(n, r, o) {
								let a = 0,
									l = n.length >> o;
								for (; l !== a;) {
									const d = a + (l - a >> 1),
										_ = n[d << o];
									if (r === _) return d << o;
									_ > r ? l = d : a = d + 1
								}
								return ~(l << o)
							}(n, r, 1)
						}
						const as = Ne(wo("Inject", n => ({
								token: n
							})), -1),
							Io = Ne(wo("Optional"), 8),
							Ra = Ne(wo("SkipSelf"), 4);
						var Do = (() => ((Do = Do || {})[Do.Important = 1] = "Important", Do[Do.DashCase = 2] = "DashCase", Do))();
						const ji = new Map;
						let Ch = 0;
						const Tl = "__ngContext__";

						function Ei(n, r) {
							lr(r) ? (n[Tl] = r[qe], function Sh(n) {
								ji.set(n[qe], n)
							}(r)) : n[Tl] = r
						}
						let Nu;

						function ku(n, r) {
							return Nu(n, r)
						}

						function Lc(n) {
							const r = n[ye];
							return gr(r) ? r[ye] : r
						}

						function cs(n) {
							return xu(n[Mn])
						}

						function wl(n) {
							return xu(n[He])
						}

						function xu(n) {
							for (; null !== n && !gr(n);) n = n[He];
							return n
						}

						function xa(n, r, o, a, l) {
							if (null != a) {
								let d, _ = !1;
								gr(a) ? d = a : lr(a) && (_ = !0, a = a[L]);
								const w = sr(a);
								0 === n && null !== o ? null == l ? Uu(r, o, w) : Ba(r, o, w, l || null, !0) : 1 === n && null !== o ? Ba(r, o, w, l || null, !0) : 2 === n ? function Ao(n, r, o) {
									const a = Ha(n, r);
									a && function Bc(n, r, o, a) {
										n.removeChild(r, o, a)
									}(n, a, r, o)
								}(r, w, _) : 3 === n && r.destroyNode(w), null != d && function Zp(n, r, o, a, l) {
									const d = o[cr];
									d !== sr(o) && xa(r, n, a, d, l);
									for (let w = or; w < o.length; w++) {
										const R = o[w];
										no(R[K], R, n, r, a, d)
									}
								}(r, n, d, o, l)
							}
						}

						function Uc(n, r, o) {
							return n.createElement(r, o)
						}

						function qr(n, r) {
							const o = n[$n],
								a = o.indexOf(r),
								l = r[ye];
							512 & r[he] && (r[he] &= -513, Ui(l, -1)), o.splice(a, 1)
						}

						function La(n, r) {
							if (n.length <= or) return;
							const o = or + r,
								a = n[o];
							if (a) {
								const l = a[Br];
								null !== l && l !== n && qr(l, a), r > 0 && (n[o - 1][He] = a[He]);
								const d = b(n, or + r);
								! function Wp(n, r) {
									no(n, r, r[Ot], 2, null, null), r[L] = null, r[st] = null
								}(a[K], a);
								const _ = d[tt];
								null !== _ && _.detachView(d[K]), a[ye] = null, a[He] = null, a[he] &= -65
							}
							return a
						}

						function Oh(n, r) {
							if (!(128 & r[he])) {
								const o = r[Ot];
								o.destroyNode && no(n, r, o, 3, null, null),
									function Qp(n) {
										let r = n[Mn];
										if (!r) return us(n[K], n);
										for (; r;) {
											let o = null;
											if (lr(r)) o = r[Mn];
											else {
												const a = r[or];
												a && (o = a)
											}
											if (!o) {
												for (; r && !r[He] && r !== n;) lr(r) && us(r[K], r), r = r[ye];
												null === r && (r = n), lr(r) && us(r[K], r), o = r && r[He]
											}
											r = o
										}
									}(r)
							}
						}

						function us(n, r) {
							if (!(128 & r[he])) {
								r[he] &= -65, r[he] |= 128,
									function Xp(n, r) {
										let o;
										if (null != n && null != (o = n.destroyHooks))
											for (let a = 0; a < o.length; a += 2) {
												const l = r[o[a]];
												if (!(l instanceof It)) {
													const d = o[a + 1];
													if (Array.isArray(d))
														for (let _ = 0; _ < d.length; _ += 2) {
															const w = l[d[_]],
																R = d[_ + 1];
															Ti(4, w, R);
															try {
																R.call(w)
															} finally {
																Ti(5, w, R)
															}
														} else {
															Ti(4, l, d);
															try {
																d.call(l)
															} finally {
																Ti(5, l, d)
															}
														}
												}
											}
									}(n, r),
									function Jp(n, r) {
										const o = n.cleanup,
											a = r[mt];
										let l = -1;
										if (null !== o)
											for (let d = 0; d < o.length - 1; d += 2)
												if ("string" == typeof o[d]) {
													const _ = o[d + 3];
													_ >= 0 ? a[l = _]() : a[l = -_].unsubscribe(), d += 2
												} else {
													const _ = a[l = o[d + 1]];
													o[d].call(_)
												} if (null !== a) {
											for (let d = l + 1; d < a.length; d++)(0, a[d])();
											r[mt] = null
										}
									}(n, r), 1 === r[K].type && r[Ot].destroy();
								const o = r[Br];
								if (null !== o && gr(r[ye])) {
									o !== r[ye] && qr(o, r);
									const a = r[tt];
									null !== a && a.detachView(n)
								}! function Bs(n) {
									ji.delete(n[qe])
								}(r)
							}
						}

						function Ph(n, r, o) {
							return function Ua(n, r, o) {
								let a = r;
								for (; null !== a && 40 & a.type;) a = (r = a).parent;
								if (null === a) return o[L];
								{
									const {
										componentOffset: l
									} = a;
									if (l > -1) {
										const {
											encapsulation: d
										} = n.data[a.directiveStart + l];
										if (d === Dn.None || d === Dn.Emulated) return null
									}
									return kr(a, o)
								}
							}(n, r.parent, o)
						}

						function Ba(n, r, o, a, l) {
							n.insertBefore(r, o, a, l)
						}

						function Uu(n, r, o) {
							n.appendChild(r, o)
						}

						function Nh(n, r, o, a, l) {
							null !== a ? Ba(n, r, o, a, l) : Uu(n, r, o)
						}

						function Ha(n, r) {
							return n.parentNode(r)
						}

						function bl(n, r, o) {
							return Bu(n, r, o)
						}
						let Il, Fr, mo, ai, Bu = function xh(n, r, o) {
							return 40 & n.type ? kr(n, o) : null
						};

						function Dl(n, r, o, a) {
							const l = Ph(n, a, r),
								d = r[Ot],
								w = bl(a.parent || r[st], a, r);
							if (null != l)
								if (Array.isArray(o))
									for (let R = 0; R < o.length; R++) Nh(d, l, o[R], w, !1);
								else Nh(d, l, o, w, !1);
							void 0 !== Il && Il(d, a, r, o, l)
						}

						function go(n, r) {
							if (null !== r) {
								const o = r.type;
								if (3 & o) return kr(r, n);
								if (4 & o) return Fh(-1, n[r.index]);
								if (8 & o) {
									const a = r.child;
									if (null !== a) return go(n, a);
									{
										const l = n[r.index];
										return gr(l) ? Fh(-1, l) : sr(l)
									}
								}
								if (32 & o) return ku(r, n)() || sr(n[r.index]);
								{
									const a = Al(n, r);
									return null !== a ? Array.isArray(a) ? a[0] : go(Lc(n[xn]), a) : go(n, r.next)
								}
							}
							return null
						}

						function Al(n, r) {
							return null !== r ? n[xn][st].projection[r.projection] : null
						}

						function Fh(n, r) {
							const o = or + n + 1;
							if (o < r.length) {
								const a = r[o],
									l = a[K].firstChild;
								if (null !== l) return go(a, l)
							}
							return r[cr]
						}

						function Rl(n, r, o, a, l, d, _) {
							for (; null != o;) {
								const w = a[o.index],
									R = o.type;
								if (_ && 0 === r && (w && Ei(sr(w), a), o.flags |= 2), 32 != (32 & o.flags))
									if (8 & R) Rl(n, r, o.child, a, l, d, !1), xa(r, n, l, w, d);
									else if (32 & R) {
									const j = ku(o, a);
									let se;
									for (; se = j();) xa(r, n, l, se, d);
									xa(r, n, l, w, d)
								} else 16 & R ? ds(n, r, a, o, l, d) : xa(r, n, l, w, d);
								o = _ ? o.projectionNext : o.next
							}
						}

						function no(n, r, o, a, l, d) {
							Rl(o, a, n.firstChild, r, l, d, !1)
						}

						function ds(n, r, o, a, l, d) {
							const _ = o[xn],
								R = _[st].projection[a.projection];
							if (Array.isArray(R))
								for (let j = 0; j < R.length; j++) xa(r, n, l, R[j], d);
							else Rl(n, r, R, _[ye], l, d, !0)
						}

						function ju(n, r, o) {
							"" === o ? n.removeAttribute(r, "class") : n.setAttribute(r, "class", o)
						}

						function Vu(n, r, o) {
							const {
								mergedAttrs: a,
								classes: l,
								styles: d
							} = o;
							null !== a && bi(n, r, a), null !== l && ju(n, r, l), null !== d && function S_(n, r, o) {
								n.setAttribute(r, "style", o)
							}(n, r, d)
						}

						function Ro(n) {
							return function $u() {
								if (void 0 === Fr && (Fr = null, un.trustedTypes)) try {
									Fr = un.trustedTypes.createPolicy("angular", {
										createHTML: n => n,
										createScript: n => n,
										createScriptURL: n => n
									})
								} catch {}
								return Fr
							}()?.createHTML(n) || n
						}

						function Hs(n) {
							mo = n
						}

						function Ku() {
							if (void 0 === ai && (ai = null, un.trustedTypes)) try {
								ai = un.trustedTypes.createPolicy("angular#unsafe-bypass", {
									createHTML: n => n,
									createScript: n => n,
									createScriptURL: n => n
								})
							} catch {}
							return ai
						}

						function Gs(n) {
							return Ku()?.createHTML(n) || n
						}

						function Hh(n) {
							return Ku()?.createScriptURL(n) || n
						}
						class js {
							constructor(r) {
								this.changingThisBreaksApplicationSecurity = r
							}
							toString() {
								return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${Fe})`
							}
						}
						class Vs extends js {
							getTypeName() {
								return "HTML"
							}
						}
						class Gh extends js {
							getTypeName() {
								return "Style"
							}
						}
						class Yu extends js {
							getTypeName() {
								return "Script"
							}
						}
						class Wu extends js {
							getTypeName() {
								return "URL"
							}
						}
						class eg extends js {
							getTypeName() {
								return "ResourceURL"
							}
						}

						function _o(n) {
							return n instanceof js ? n.changingThisBreaksApplicationSecurity : n
						}

						function ro(n, r) {
							const o = function jh(n) {
								return n instanceof js && n.getTypeName() || null
							}(n);
							if (null != o && o !== r) {
								if ("ResourceURL" === o && "URL" === r) return !0;
								throw new Error(`Required a safe ${r}, got a ${o} (see ${Fe})`)
							}
							return o === r
						}

						function _r(n) {
							return new Vs(n)
						}

						function Vh(n) {
							return new Gh(n)
						}

						function T_(n) {
							return new Yu(n)
						}

						function w_(n) {
							return new Wu(n)
						}

						function b_(n) {
							return new eg(n)
						}
						class Ml {
							constructor(r) {
								this.inertDocumentHelper = r
							}
							getInertBodyElement(r) {
								r = "<body><remove></remove>" + r;
								try {
									const o = (new window.DOMParser).parseFromString(Ro(r), "text/html").body;
									return null === o ? this.inertDocumentHelper.getInertBodyElement(r) : (o.removeChild(o.firstChild), o)
								} catch {
									return null
								}
							}
						}
						class Qu {
							constructor(r) {
								if (this.defaultDoc = r, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"), null == this.inertDocument.body) {
									const o = this.inertDocument.createElement("html");
									this.inertDocument.appendChild(o);
									const a = this.inertDocument.createElement("body");
									o.appendChild(a)
								}
							}
							getInertBodyElement(r) {
								const o = this.inertDocument.createElement("template");
								if ("content" in o) return o.innerHTML = Ro(r), o;
								const a = this.inertDocument.createElement("body");
								return a.innerHTML = Ro(r), this.defaultDoc.documentMode && this.stripCustomNsAttrs(a), a
							}
							stripCustomNsAttrs(r) {
								const o = r.attributes;
								for (let l = o.length - 1; 0 < l; l--) {
									const _ = o.item(l).name;
									("xmlns:ns1" === _ || 0 === _.indexOf("ns1:")) && r.removeAttribute(_)
								}
								let a = r.firstChild;
								for (; a;) a.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(a), a = a.nextSibling
							}
						}
						const Ga = /^(?:(?:https?|mailto|data|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi;

						function Ol(n) {
							return (n = String(n)).match(Ga) ? n : "unsafe:" + n
						}

						function Go(n) {
							const r = {};
							for (const o of n.split(",")) r[o] = !0;
							return r
						}

						function Gc(...n) {
							const r = {};
							for (const o of n)
								for (const a in o) o.hasOwnProperty(a) && (r[a] = !0);
							return r
						}
						const $h = Go("area,br,col,hr,img,wbr"),
							zh = Go("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
							Kh = Go("rp,rt"),
							ja = Gc($h, Gc(zh, Go("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), Gc(Kh, Go("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), Gc(Kh, zh)),
							Pl = Go("background,cite,href,itemtype,longdesc,poster,src,xlink:href"),
							Yh = Gc(Pl, Go("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), Go("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")),
							rg = Go("script,style,template");
						class ig {
							constructor() {
								this.sanitizedSomething = !1, this.buf = []
							}
							sanitizeChildren(r) {
								let o = r.firstChild,
									a = !0;
								for (; o;)
									if (o.nodeType === Node.ELEMENT_NODE ? a = this.startElement(o) : o.nodeType === Node.TEXT_NODE ? this.chars(o.nodeValue) : this.sanitizedSomething = !0, a && o.firstChild) o = o.firstChild;
									else
										for (; o;) {
											o.nodeType === Node.ELEMENT_NODE && this.endElement(o);
											let l = this.checkClobberedElement(o, o.nextSibling);
											if (l) {
												o = l;
												break
											}
											o = this.checkClobberedElement(o, o.parentNode)
										}
								return this.buf.join("")
							}
							startElement(r) {
								const o = r.nodeName.toLowerCase();
								if (!ja.hasOwnProperty(o)) return this.sanitizedSomething = !0, !rg.hasOwnProperty(o);
								this.buf.push("<"), this.buf.push(o);
								const a = r.attributes;
								for (let l = 0; l < a.length; l++) {
									const d = a.item(l),
										_ = d.name,
										w = _.toLowerCase();
									if (!Yh.hasOwnProperty(w)) {
										this.sanitizedSomething = !0;
										continue
									}
									let R = d.value;
									Pl[w] && (R = Ol(R)), this.buf.push(" ", _, '="', qh(R), '"')
								}
								return this.buf.push(">"), !0
							}
							endElement(r) {
								const o = r.nodeName.toLowerCase();
								ja.hasOwnProperty(o) && !$h.hasOwnProperty(o) && (this.buf.push("</"), this.buf.push(o), this.buf.push(">"))
							}
							chars(r) {
								this.buf.push(qh(r))
							}
							checkClobberedElement(r, o) {
								if (o && (r.compareDocumentPosition(o) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${r.outerHTML}`);
								return o
							}
						}
						const Wh = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
							og = /([^\#-~ |!])/g;

						function qh(n) {
							return n.replace(/&/g, "&amp;").replace(Wh, function(r) {
								return "&#" + (1024 * (r.charCodeAt(0) - 55296) + (r.charCodeAt(1) - 56320) + 65536) + ";"
							}).replace(og, function(r) {
								return "&#" + r.charCodeAt(0) + ";"
							}).replace(/</g, "&lt;").replace(/>/g, "&gt;")
						}
						let ii;

						function Qh(n, r) {
							let o = null;
							try {
								ii = ii || function qu(n) {
									const r = new Qu(n);
									return function tg() {
										try {
											return !!(new window.DOMParser).parseFromString(Ro(""), "text/html")
										} catch {
											return !1
										}
									}() ? new Ml(r) : r
								}(n);
								let a = r ? String(r) : "";
								o = ii.getInertBodyElement(a);
								let l = 5,
									d = a;
								do {
									if (0 === l) throw new Error("Failed to sanitize html because the input is unstable");
									l--, a = d, d = o.innerHTML, o = ii.getInertBodyElement(a)
								} while (a !== d);
								return Ro((new ig).sanitizeChildren(Ju(o) || o))
							} finally {
								if (o) {
									const a = Ju(o) || o;
									for (; a.firstChild;) a.removeChild(a.firstChild)
								}
							}
						}

						function Ju(n) {
							return "content" in n && function jc(n) {
								return n.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === n.nodeName
							}(n) ? n.content : null
						}
						var Gr = (() => ((Gr = Gr || {})[Gr.NONE = 0] = "NONE", Gr[Gr.HTML = 1] = "HTML", Gr[Gr.STYLE = 2] = "STYLE", Gr[Gr.SCRIPT = 3] = "SCRIPT", Gr[Gr.URL = 4] = "URL", Gr[Gr.RESOURCE_URL = 5] = "RESOURCE_URL", Gr))();

						function Xu(n) {
							const r = Va();
							return r ? Gs(r.sanitize(Gr.HTML, n) || "") : ro(n, "HTML") ? Gs(_o(n)) : Qh(function Hc() {
								return void 0 !== mo ? mo : typeof document < "u" ? document : void 0
							}(), Ce(n))
						}

						function kl(n) {
							const r = Va();
							return r ? r.sanitize(Gr.URL, n) || "" : ro(n, "URL") ? _o(n) : Ol(Ce(n))
						}

						function Jh(n) {
							const r = Va();
							if (r) return Hh(r.sanitize(Gr.RESOURCE_URL, n) || "");
							if (ro(n, "ResourceURL")) return Hh(_o(n));
							throw new Le(904, !1)
						}

						function Zh(n, r, o) {
							return function lg(n, r) {
								return "src" === r && ("embed" === n || "frame" === n || "iframe" === n || "media" === n || "script" === n) || "href" === r && ("base" === n || "link" === n) ? Jh : kl
							}(r, o)(n)
						}

						function Va() {
							const n = Ct();
							return n && n[Jt]
						}
						const Zu = new mr("ENVIRONMENT_INITIALIZER"),
							ef = new mr("INJECTOR", -1),
							xl = new mr("INJECTOR_DEF_TYPES");
						class jo {
							get(r, o = Te) {
								if (o === Te) {
									const a = new Error(`NullInjectorError: No provider for ${Y(r)}!`);
									throw a.name = "NullInjectorError", a
								}
								return o
							}
						}

						function R_(n) {
							return {
								\u0275providers: n
							}
						}

						function Fl(...n) {
							return {
								\u0275providers: hg(0, n),
								\u0275fromNgModule: !0
							}
						}

						function hg(n, ...r) {
							const o = [],
								a = new Set;
							let l;
							return C(r, d => {
								const _ = d;
								tf(_, o, [], a) && (l || (l = []), l.push(_))
							}), void 0 !== l && fg(l, o), o
						}

						function fg(n, r) {
							for (let o = 0; o < n.length; o++) {
								const {
									providers: l
								} = n[o];
								Vc(l, d => {
									r.push(d)
								})
							}
						}

						function tf(n, r, o, a) {
							if (!(n = te(n))) return !1;
							let l = null,
								d = Zt(n);
							const _ = !d && V(n);
							if (d || _) {
								if (_ && !_.standalone) return !1;
								l = n
							} else {
								const R = n.ngModule;
								if (d = Zt(R), !d) return !1;
								l = R
							}
							const w = a.has(l);
							if (_) {
								if (w) return !1;
								if (a.add(l), _.dependencies) {
									const R = "function" == typeof _.dependencies ? _.dependencies() : _.dependencies;
									for (const j of R) tf(j, r, o, a)
								}
							} else {
								if (!d) return !1;
								{
									if (null != d.imports && !w) {
										let j;
										a.add(l);
										try {
											C(d.imports, se => {
												tf(se, r, o, a) && (j || (j = []), j.push(se))
											})
										} finally {}
										void 0 !== j && fg(j, r)
									}
									if (!w) {
										const j = Qi(l) || (() => new l);
										r.push({
											provide: l,
											useFactory: j,
											deps: Me
										}, {
											provide: xl,
											useValue: l,
											multi: !0
										}, {
											provide: Zu,
											useValue: () => B(l),
											multi: !0
										})
									}
									const R = d.providers;
									null == R || w || Vc(R, se => {
										r.push(se)
									})
								}
							}
							return l !== n && void 0 !== n.providers
						}

						function Vc(n, r) {
							for (let o of n) oe(o) && (o = o.\u0275providers), Array.isArray(o) ? Vc(o, r) : r(o)
						}
						const rf = P({
							provide: String,
							useValue: P
						});

						function sf(n) {
							return null !== n && "object" == typeof n && rf in n
						}

						function $s(n) {
							return "function" == typeof n
						}
						const Vo = new mr("Set Injector scope."),
							hs = {},
							af = {};
						let ed;

						function ci() {
							return void 0 === ed && (ed = new jo), ed
						}
						class mi {}
						class cf extends mi {
							get destroyed() {
								return this._destroyed
							}
							constructor(r, o, a, l) {
								super(), this.parent = o, this.source = a, this.scopes = l, this.records = new Map, this._ngOnDestroyHooks = new Set, this._onDestroyHooks = [], this._destroyed = !1, za(r, _ => this.processProvider(_)), this.records.set(ef, $a(void 0, this)), l.has("environment") && this.records.set(mi, $a(void 0, this));
								const d = this.records.get(Vo);
								null != d && "string" == typeof d.value && this.scopes.add(d.value), this.injectorDefTypes = new Set(this.get(xl.multi, Me, en.Self))
							}
							destroy() {
								this.assertNotDestroyed(), this._destroyed = !0;
								try {
									for (const r of this._ngOnDestroyHooks) r.ngOnDestroy();
									for (const r of this._onDestroyHooks) r()
								} finally {
									this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear(), this._onDestroyHooks.length = 0
								}
							}
							onDestroy(r) {
								this._onDestroyHooks.push(r)
							}
							runInContext(r) {
								this.assertNotDestroyed();
								const o = ct(this),
									a = Nn(void 0);
								try {
									return r()
								} finally {
									ct(o), Nn(a)
								}
							}
							get(r, o = Te, a = en.Default) {
								this.assertNotDestroyed(), a = H(a);
								const l = ct(this),
									d = Nn(void 0);
								try {
									if (!(a & en.SkipSelf)) {
										let w = this.records.get(r);
										if (void 0 === w) {
											const R = function mg(n) {
												return "function" == typeof n || "object" == typeof n && n instanceof mr
											}(r) && Pn(r);
											w = R && this.injectableDefInScope(R) ? $a(td(r), hs) : null, this.records.set(r, w)
										}
										if (null != w) return this.hydrate(r, w)
									}
									return (a & en.Self ? ci() : this.parent).get(r, o = a & en.Optional && o === Te ? null : o)
								} catch (_) {
									if ("NullInjectorError" === _.name) {
										if ((_[yt] = _[yt] || []).unshift(Y(r)), l) throw _;
										return function Ft(n, r, o, a) {
											const l = n[yt];
											throw r[hn] && l.unshift(r[hn]), n.message = function an(n, r, o, a = null) {
												n = n && "\n" === n.charAt(0) && n.charAt(1) == $t ? n.slice(2) : n;
												let l = Y(r);
												if (Array.isArray(r)) l = r.map(Y).join(" -> ");
												else if ("object" == typeof r) {
													let d = [];
													for (let _ in r)
														if (r.hasOwnProperty(_)) {
															let w = r[_];
															d.push(_ + ":" + ("string" == typeof w ? JSON.stringify(w) : Y(w)))
														} l = `{${d.join(", ")}}`
												}
												return `${o}${a?"("+a+")":""}[${l}]: ${n.replace(pn,"\n  ")}`
											}("\n" + n.message, l, o, a), n[Ht] = l, n[yt] = null, n
										}(_, r, "R3InjectorError", this.source)
									}
									throw _
								} finally {
									Nn(d), ct(l)
								}
							}
							resolveInjectorInitializers() {
								const r = ct(this),
									o = Nn(void 0);
								try {
									const a = this.get(Zu.multi, Me, en.Self);
									for (const l of a) l()
								} finally {
									ct(r), Nn(o)
								}
							}
							toString() {
								const r = [],
									o = this.records;
								for (const a of o.keys()) r.push(Y(a));
								return `R3Injector[${r.join(", ")}]`
							}
							assertNotDestroyed() {
								if (this._destroyed) throw new Le(205, !1)
							}
							processProvider(r) {
								let o = $s(r = te(r)) ? r : te(r && r.provide);
								const a = function lf(n) {
									return sf(n) ? $a(void 0, n.useValue) : $a(uf(n), hs)
								}(r);
								if ($s(r) || !0 !== r.multi) this.records.get(o);
								else {
									let l = this.records.get(o);
									l || (l = $a(void 0, hs, !0), l.factory = () => ne(l.multi), this.records.set(o, l)), o = r, l.multi.push(r)
								}
								this.records.set(o, a)
							}
							hydrate(r, o) {
								return o.value === hs && (o.value = af, o.value = o.factory()), "object" == typeof o.value && o.value && function gg(n) {
									return null !== n && "object" == typeof n && "function" == typeof n.ngOnDestroy
								}(o.value) && this._ngOnDestroyHooks.add(o.value), o.value
							}
							injectableDefInScope(r) {
								if (!r.providedIn) return !1;
								const o = te(r.providedIn);
								return "string" == typeof o ? "any" === o || this.scopes.has(o) : this.injectorDefTypes.has(o)
							}
						}

						function td(n) {
							const r = Pn(n),
								o = null !== r ? r.factory : Qi(n);
							if (null !== o) return o;
							if (n instanceof mr) throw new Le(204, !1);
							if (n instanceof Function) return function nd(n) {
								const r = n.length;
								if (r > 0) throw x(r, "?"), new Le(204, !1);
								const o = function Kn(n) {
									const r = n && (n[bn] || n[qt]);
									if (r) {
										const o = function Vn(n) {
											if (n.hasOwnProperty("name")) return n.name;
											const r = ("" + n).match(/^function\s*([^\s(]+)/);
											return null === r ? "" : r[1]
										}(n);
										return console.warn(`DEPRECATED: DI is instantiating a token "${o}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${o}" class.`), r
									}
									return null
								}(n);
								return null !== o ? () => o.factory(n) : () => new n
							}(n);
							throw new Le(204, !1)
						}

						function uf(n, r, o) {
							let a;
							if ($s(n)) {
								const l = te(n);
								return Qi(l) || td(l)
							}
							if (sf(n)) a = () => te(n.useValue);
							else if (function $c(n) {
									return !(!n || !n.useFactory)
								}(n)) a = () => n.useFactory(...ne(n.deps || []));
							else if (function pg(n) {
									return !(!n || !n.useExisting)
								}(n)) a = () => B(te(n.useExisting));
							else {
								const l = te(n && (n.useClass || n.provide));
								if (! function Ll(n) {
										return !!n.deps
									}(n)) return Qi(l) || td(l);
								a = () => new l(...ne(n.deps))
							}
							return a
						}

						function $a(n, r, o = !1) {
							return {
								factory: n,
								value: r,
								multi: o ? [] : void 0
							}
						}

						function za(n, r) {
							for (const o of n) Array.isArray(o) ? za(o, r) : o && oe(o) ? za(o.\u0275providers, r) : r(o)
						}
						class Ul {}
						class df {}
						class Bl {
							resolveComponentFactory(r) {
								throw function _g(n) {
									const r = Error(`No component factory found for ${Y(n)}. Did you add it to @NgModule.entryComponents?`);
									return r.ngComponent = n, r
								}(r)
							}
						}
						let zc = (() => {
							class n {}
							return n.NULL = new Bl, n
						})();

						function Hl() {
							return Ka(zr(), Ct())
						}

						function Ka(n, r) {
							return new Kc(kr(n, r))
						}
						let Kc = (() => {
							class n {
								constructor(o) {
									this.nativeElement = o
								}
							}
							return n.__NG_ELEMENT_ID__ = Hl, n
						})();

						function fs(n) {
							return n instanceof Kc ? n.nativeElement : n
						}
						class id {}
						let od = (() => {
								class n {}
								return n.__NG_ELEMENT_ID__ = () => function vg() {
									const n = Ct(),
										o = di(zr().index, n);
									return (lr(o) ? o : n)[Ot]
								}(), n
							})(),
							yg = (() => {
								class n {}
								return n.\u0275prov = Qt({
									token: n,
									providedIn: "root",
									factory: () => null
								}), n
							})();
						class hf {
							constructor(r) {
								this.full = r, this.major = r.split(".")[0], this.minor = r.split(".")[1], this.patch = r.split(".").slice(2).join(".")
							}
						}
						const ff = new hf("15.1.2"),
							zs = {},
							sd = "ngOriginalError";

						function pf(n) {
							return n[sd]
						}
						class Ks {
							constructor() {
								this._console = console
							}
							handleError(r) {
								const o = this._findOriginalError(r);
								this._console.error("ERROR", r), o && this._console.error("ORIGINAL ERROR", o)
							}
							_findOriginalError(r) {
								let o = r && pf(r);
								for (; o && pf(o);) o = pf(o);
								return o || null
							}
						}

						function gf(n) {
							return n.ownerDocument.defaultView
						}

						function cd(n) {
							return n.ownerDocument
						}

						function $o(n) {
							return n instanceof Function ? n() : n
						}

						function _f(n, r, o) {
							let a = n.length;
							for (;;) {
								const l = n.indexOf(r, o);
								if (-1 === l) return l;
								if (0 === l || n.charCodeAt(l - 1) <= 32) {
									const d = r.length;
									if (l + d === a || n.charCodeAt(l + d) <= 32) return l
								}
								o = l + 1
							}
						}
						const vf = "ng-template";

						function yf(n, r, o) {
							let a = 0;
							for (; a < n.length;) {
								let l = n[a++];
								if (o && "class" === l) {
									if (l = n[a], -1 !== _f(l.toLowerCase(), r, 0)) return !0
								} else if (1 === l) {
									for (; a < n.length && "string" == typeof(l = n[a++]);)
										if (l.toLowerCase() === r) return !0;
									return !1
								}
							}
							return !1
						}

						function ps(n) {
							return 4 === n.type && n.value !== vf
						}

						function bg(n, r, o) {
							return r === (4 !== n.type || o ? n.value : vf)
						}

						function Ig(n, r, o) {
							let a = 4;
							const l = n.attrs || [],
								d = function Ag(n) {
									for (let r = 0; r < n.length; r++)
										if (Ii(n[r])) return r;
									return n.length
								}(l);
							let _ = !1;
							for (let w = 0; w < r.length; w++) {
								const R = r[w];
								if ("number" != typeof R) {
									if (!_)
										if (4 & a) {
											if (a = 2 | 1 & a, "" !== R && !bg(n, R, o) || "" === R && 1 === r.length) {
												if (io(a)) return !1;
												_ = !0
											}
										} else {
											const j = 8 & a ? R : r[++w];
											if (8 & a && null !== n.attrs) {
												if (!yf(n.attrs, j, o)) {
													if (io(a)) return !1;
													_ = !0
												}
												continue
											}
											const ve = Ef(8 & a ? "class" : R, l, ps(n), o);
											if (-1 === ve) {
												if (io(a)) return !1;
												_ = !0;
												continue
											}
											if ("" !== j) {
												let $e;
												$e = ve > d ? "" : l[ve + 1].toLowerCase();
												const rt = 8 & a ? $e : null;
												if (rt && -1 !== _f(rt, j, 0) || 2 & a && j !== $e) {
													if (io(a)) return !1;
													_ = !0
												}
											}
										}
								} else {
									if (!_ && !io(a) && !io(R)) return !1;
									if (_ && io(R)) continue;
									_ = !1, a = R | 1 & a
								}
							}
							return io(a) || _
						}

						function io(n) {
							return 0 == (1 & n)
						}

						function Ef(n, r, o, a) {
							if (null === r) return -1;
							let l = 0;
							if (a || !o) {
								let d = !1;
								for (; l < r.length;) {
									const _ = r[l];
									if (_ === n) return l;
									if (3 === _ || 6 === _) d = !0;
									else {
										if (1 === _ || 2 === _) {
											let w = r[++l];
											for (;
												"string" == typeof w;) w = r[++l];
											continue
										}
										if (4 === _) break;
										if (0 === _) {
											l += 4;
											continue
										}
									}
									l += d ? 1 : 2
								}
								return -1
							}
							return function Cf(n, r) {
								let o = n.indexOf(4);
								if (o > -1)
									for (o++; o < n.length;) {
										const a = n[o];
										if ("number" == typeof a) return -1;
										if (a === r) return o;
										o++
									}
								return -1
							}(r, n)
						}

						function Yc(n, r, o = !1) {
							for (let a = 0; a < r.length; a++)
								if (Ig(n, r[a], o)) return !0;
							return !1
						}

						function Rg(n, r) {
							e: for (let o = 0; o < r.length; o++) {
								const a = r[o];
								if (n.length === a.length) {
									for (let l = 0; l < n.length; l++)
										if (n[l] !== a[l]) continue e;
									return !0
								}
							}
							return !1
						}

						function Gl(n, r) {
							return n ? ":not(" + r.trim() + ")" : r
						}

						function ud(n) {
							let r = n[0],
								o = 1,
								a = 2,
								l = "",
								d = !1;
							for (; o < n.length;) {
								let _ = n[o];
								if ("string" == typeof _)
									if (2 & a) {
										const w = n[++o];
										l += "[" + _ + (w.length > 0 ? '="' + w + '"' : "") + "]"
									} else 8 & a ? l += "." + _ : 4 & a && (l += " " + _);
								else "" !== l && !io(_) && (r += Gl(d, l), l = ""), a = _, d = d || !io(a);
								o++
							}
							return "" !== l && (r += Gl(d, l)), r
						}
						const Ln = {};

						function Sf(n) {
							Tf(Gn(), Ct(), ur() + n, !1)
						}

						function Tf(n, r, o, a) {
							if (!a)
								if (3 == (3 & r[he])) {
									const d = n.preOrderCheckHooks;
									null !== d && I(r, d, o)
								} else {
									const d = n.preOrderHooks;
									null !== d && W(r, d, 0, o)
								} yi(o)
						}

						function xg(n, r = null, o = null, a) {
							const l = Fg(n, r, o, a);
							return l.resolveInjectorInitializers(), l
						}

						function Fg(n, r = null, o = null, a, l = new Set) {
							const d = [o || Me, Fl(n)];
							return a = a || ("object" == typeof n ? void 0 : Y(n)), new cf(d, r || ci(), a || null, l)
						}
						let Wa = (() => {
							class n {
								static create(o, a) {
									if (Array.isArray(o)) return xg({
										name: ""
									}, a, o, "");
									{
										const l = o.name ?? "";
										return xg({
											name: l
										}, o.parent, o.providers, l)
									}
								}
							}
							return n.THROW_IF_NOT_FOUND = Te, n.NULL = new jo, n.\u0275prov = Qt({
								token: n,
								providedIn: "any",
								factory: () => B(ef)
							}), n.__NG_ELEMENT_ID__ = -1, n
						})();

						function Qa(n, r = en.Default) {
							const o = Ct();
							return null === o ? B(n, r) : Qe(zr(), o, te(n), r)
						}

						function _d() {
							throw new Error("invalid")
						}

						function vd(n, r) {
							const o = n.contentQueries;
							if (null !== o)
								for (let a = 0; a < o.length; a += 2) {
									const d = o[a + 1];
									if (-1 !== d) {
										const _ = n.data[d];
										po(o[a]), _.contentQueries(2, r[d], d)
									}
								}
						}

						function ms(n, r, o, a, l, d, _, w, R, j, se) {
							const ve = r.blueprint.slice();
							return ve[L] = l, ve[he] = 76 | a, (null !== se || n && 1024 & n[he]) && (ve[he] |= 1024), xo(ve), ve[ye] = ve[Jn] = n, ve[Et] = o, ve[Rt] = _ || n && n[Rt], ve[Ot] = w || n && n[Ot], ve[Jt] = R || n && n[Jt] || null, ve[Gt] = j || n && n[Gt] || null, ve[st] = d, ve[qe] = function jp() {
								return Ch++
							}(), ve[dt] = se, ve[xn] = 2 == r.type ? n[xn] : ve, ve
						}

						function Ws(n, r, o, a, l) {
							let d = n.data[r];
							if (null === d) d = function yd(n, r, o, a, l) {
									const d = pc(),
										_ = ga(),
										R = n.data[r] = function xf(n, r, o, a, l, d) {
											return {
												type: o,
												index: a,
												insertBeforeIndex: null,
												injectorIndex: r ? r.injectorIndex : -1,
												directiveStart: -1,
												directiveEnd: -1,
												directiveStylingLast: -1,
												componentOffset: -1,
												propertyBindings: null,
												flags: 0,
												providerIndexes: 0,
												value: l,
												attrs: d,
												mergedAttrs: null,
												localNames: null,
												initialInputs: void 0,
												inputs: null,
												outputs: null,
												tViews: null,
												next: null,
												projectionNext: null,
												child: null,
												parent: r,
												projection: null,
												styles: null,
												stylesWithoutHost: null,
												residualStyles: void 0,
												classes: null,
												classesWithoutHost: null,
												residualClasses: void 0,
												classBindings: 0,
												styleBindings: 0
											}
										}(0, _ ? d : d && d.parent, o, r, a, l);
									return null === n.firstChild && (n.firstChild = R), null !== d && (_ ? null == d.child && null !== R.parent && (d.child = R) : null === d.next && (d.next = R)), R
								}(n, r, o, a, l),
								function _a() {
									return wn.lFrame.inI18n
								}() && (d.flags |= 32);
							else if (64 & d.type) {
								d.type = o, d.value = a, d.attrs = l;
								const _ = function ns() {
									const n = wn.lFrame,
										r = n.currentTNode;
									return n.isParent ? r : r.parent
								}();
								d.injectorIndex = null === _ ? -1 : _.injectorIndex
							}
							return Ri(d, !0), d
						}

						function qc(n, r, o, a) {
							if (0 === o) return -1;
							const l = r.length;
							for (let d = 0; d < o; d++) r.push(a), n.blueprint.push(a), n.data.push(null);
							return l
						}

						function Ed(n, r, o) {
							Xi(r);
							try {
								const a = n.viewQuery;
								null !== a && Wl(1, a, o);
								const l = n.template;
								null !== l && Nf(n, r, l, 1, o), n.firstCreatePass && (n.firstCreatePass = !1), n.staticContentQueries && vd(n, r), n.staticViewQueries && Wl(2, n.viewQuery, o);
								const d = n.components;
								null !== d && function Yg(n, r) {
									for (let o = 0; o < r.length; o++) cm(n, r[o])
								}(r, d)
							} catch (a) {
								throw n.firstCreatePass && (n.incompleteFirstPass = !0, n.firstCreatePass = !1), a
							} finally {
								r[he] &= -5, Fs()
							}
						}

						function $l(n, r, o, a) {
							const l = r[he];
							if (128 != (128 & l)) {
								Xi(r);
								try {
									xo(r),
										function Bi(n) {
											return wn.lFrame.bindingIndex = n
										}(n.bindingStartIndex), null !== o && Nf(n, r, o, 2, a);
									const _ = 3 == (3 & l);
									if (_) {
										const j = n.preOrderCheckHooks;
										null !== j && I(r, j, null)
									} else {
										const j = n.preOrderHooks;
										null !== j && W(r, j, 0, null), M(r, 0)
									}
									if (function am(n) {
											for (let r = cs(n); null !== r; r = wl(r)) {
												if (!r[ir]) continue;
												const o = r[$n];
												for (let a = 0; a < o.length; a++) {
													const l = o[a];
													512 & l[he] || Ui(l[ye], 1), l[he] |= 512
												}
											}
										}(r), function $_(n) {
											for (let r = cs(n); null !== r; r = wl(r))
												for (let o = or; o < r.length; o++) {
													const a = r[o],
														l = a[K];
													Li(a) && $l(l, a, l.template, a[Et])
												}
										}(r), null !== n.contentQueries && vd(n, r), _) {
										const j = n.contentCheckHooks;
										null !== j && I(r, j)
									} else {
										const j = n.contentHooks;
										null !== j && W(r, j, 1), M(r, 1)
									}! function Kg(n, r) {
										const o = n.hostBindingOpCodes;
										if (null !== o) try {
											for (let a = 0; a < o.length; a++) {
												const l = o[a];
												if (l < 0) yi(~l);
												else {
													const d = l,
														_ = o[++a],
														w = o[++a];
													_c(_, d), w(2, r[d])
												}
											}
										} finally {
											yi(-1)
										}
									}(n, r);
									const w = n.components;
									null !== w && function Pf(n, r) {
										for (let o = 0; o < r.length; o++) Gf(n, r[o])
									}(r, w);
									const R = n.viewQuery;
									if (null !== R && Wl(2, R, a), _) {
										const j = n.viewCheckHooks;
										null !== j && I(r, j)
									} else {
										const j = n.viewHooks;
										null !== j && W(r, j, 2), M(r, 2)
									}!0 === n.firstUpdatePass && (n.firstUpdatePass = !1), r[he] &= -41, 512 & r[he] && (r[he] &= -513, Ui(r[ye], -1))
								} finally {
									Fs()
								}
							}
						}

						function Nf(n, r, o, a, l) {
							const d = ur(),
								_ = 2 & a;
							try {
								yi(-1), _ && r.length > Dt && Tf(n, r, Dt, !1), Ti(_ ? 2 : 0, l), o(a, l)
							} finally {
								yi(d), Ti(_ ? 3 : 1, l)
							}
						}

						function _s(n, r, o) {
							if (xi(r)) {
								const l = r.directiveEnd;
								for (let d = r.directiveStart; d < l; d++) {
									const _ = n.data[d];
									_.contentQueries && _.contentQueries(1, o[d], d)
								}
							}
						}

						function Cd(n, r, o) {
							hc() && (function G_(n, r, o, a) {
								const l = o.directiveStart,
									d = o.directiveEnd;
								ni(o) && function im(n, r, o) {
									const a = kr(r, n),
										l = qs(o),
										d = n[Rt],
										_ = Kl(n, ms(n, l, null, o.onPush ? 32 : 16, a, r, d, d.createRenderer(a, o), null, null, null));
									n[r.index] = _
								}(r, o, n.data[l + o.componentOffset]), n.firstCreatePass || q(o, r), Ei(a, r);
								const _ = o.initialInputs;
								for (let w = l; w < d; w++) {
									const R = n.data[w],
										j = Er(r, n, w, o);
									Ei(j, r), null !== _ && om(0, w - l, j, R, 0, _), ri(R) && (di(o.index, r)[Et] = Er(r, n, w, o))
								}
							}(n, r, o, kr(o, r)), 64 == (64 & o.flags) && Uf(n, r, o))
						}

						function zl(n, r, o = kr) {
							const a = r.localNames;
							if (null !== a) {
								let l = r.index + 1;
								for (let d = 0; d < a.length; d += 2) {
									const _ = a[d + 1],
										w = -1 === _ ? o(r, n) : n[_];
									n[l++] = w
								}
							}
						}

						function qs(n) {
							const r = n.tView;
							return null === r || r.incompleteFirstPass ? n.tView = vs(1, null, n.template, n.decls, n.vars, n.directiveDefs, n.pipeDefs, n.viewQuery, n.schemas, n.consts) : r
						}

						function vs(n, r, o, a, l, d, _, w, R, j) {
							const se = Dt + a,
								ve = se + l,
								$e = function Wg(n, r) {
									const o = [];
									for (let a = 0; a < r; a++) o.push(a < n ? null : Ln);
									return o
								}(se, ve),
								rt = "function" == typeof j ? j() : j;
							return $e[K] = {
								type: n,
								blueprint: $e,
								template: o,
								queries: null,
								viewQuery: w,
								declTNode: r,
								data: $e.slice().fill(null, se),
								bindingStartIndex: se,
								expandoStartIndex: ve,
								hostBindingOpCodes: null,
								firstCreatePass: !0,
								firstUpdatePass: !0,
								staticViewQueries: !1,
								staticContentQueries: !1,
								preOrderHooks: null,
								preOrderCheckHooks: null,
								contentHooks: null,
								contentCheckHooks: null,
								viewHooks: null,
								viewCheckHooks: null,
								destroyHooks: null,
								cleanup: null,
								contentQueries: null,
								components: null,
								directiveRegistry: "function" == typeof d ? d() : d,
								pipeRegistry: "function" == typeof _ ? _() : _,
								firstChild: null,
								schemas: R,
								consts: rt,
								incompleteFirstPass: !1
							}
						}

						function kf(n, r, o, a) {
							const l = Za(r);
							null === o ? l.push(a) : (l.push(o), n.firstCreatePass && jf(n).push(a, l.length - 1))
						}

						function Sd(n, r, o, a) {
							for (let l in n)
								if (n.hasOwnProperty(l)) {
									o = null === o ? {} : o;
									const d = n[l];
									null === a ? Td(o, r, l, d) : a.hasOwnProperty(l) && Td(o, r, a[l], d)
								} return o
						}

						function Td(n, r, o, a) {
							n.hasOwnProperty(o) ? n[o].push(r, a) : n[o] = [r, a]
						}

						function Vi(n, r, o, a, l, d, _, w) {
							const R = kr(r, o);
							let se, j = r.inputs;
							!w && null != j && (se = j[a]) ? (Dd(n, o, se, a, l), ni(r) && Lf(o, r.index)) : 3 & r.type && (a = function Ja(n) {
								return "class" === n ? "className" : "for" === n ? "htmlFor" : "formaction" === n ? "formAction" : "innerHtml" === n ? "innerHTML" : "readonly" === n ? "readOnly" : "tabindex" === n ? "tabIndex" : n
							}(a), l = null != _ ? _(l, r.value || "", a) : l, d.setProperty(R, a, l))
						}

						function Lf(n, r) {
							const o = di(r, n);
							16 & o[he] || (o[he] |= 32)
						}

						function wd(n, r, o, a) {
							let l = !1;
							if (hc()) {
								const d = null === a ? null : {
										"": -1
									},
									_ = function em(n, r) {
										const o = n.directiveRegistry;
										let a = null,
											l = null;
										if (o)
											for (let d = 0; d < o.length; d++) {
												const _ = o[d];
												if (Yc(r, _.selectors, !1))
													if (a || (a = []), ri(_))
														if (null !== _.findHostDirectiveDefs) {
															const w = [];
															l = l || new Map, _.findHostDirectiveDefs(_, w, l), a.unshift(...w, _), Bf(n, r, w.length)
														} else a.unshift(_), Bf(n, r, 0);
												else l = l || new Map, _.findHostDirectiveDefs?.(_, a, l), a.push(_)
											}
										return null === a ? null : [a, l]
									}(n, o);
								let w, R;
								null === _ ? w = R = null : [w, R] = _, null !== w && (l = !0, Xa(n, r, o, w, d, R)), d && function tm(n, r, o) {
									if (r) {
										const a = n.localNames = [];
										for (let l = 0; l < r.length; l += 2) {
											const d = o[r[l + 1]];
											if (null == d) throw new Le(-301, !1);
											a.push(r[l], d)
										}
									}
								}(o, a, d)
							}
							return o.mergedAttrs = Yr(o.mergedAttrs, o.attrs), l
						}

						function Xa(n, r, o, a, l, d) {
							for (let j = 0; j < a.length; j++) Ta(q(o, r), n, a[j].type);
							! function j_(n, r, o) {
								n.flags |= 1, n.directiveStart = r, n.directiveEnd = r + o, n.providerIndexes = r
							}(o, n.data.length, a.length);
							for (let j = 0; j < a.length; j++) {
								const se = a[j];
								se.providersResolver && se.providersResolver(se)
							}
							let _ = !1,
								w = !1,
								R = qc(n, r, a.length, null);
							for (let j = 0; j < a.length; j++) {
								const se = a[j];
								o.mergedAttrs = Yr(o.mergedAttrs, se.hostAttrs), rm(n, o, r, R, se), nm(R, se, l), null !== se.contentQueries && (o.flags |= 4), (null !== se.hostBindings || null !== se.hostAttrs || 0 !== se.hostVars) && (o.flags |= 64);
								const ve = se.type.prototype;
								!_ && (ve.ngOnChanges || ve.ngOnInit || ve.ngDoCheck) && ((n.preOrderHooks || (n.preOrderHooks = [])).push(o.index), _ = !0), !w && (ve.ngOnChanges || ve.ngDoCheck) && ((n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(o.index), w = !0), R++
							}! function Ff(n, r, o) {
								const l = r.directiveEnd,
									d = n.data,
									_ = r.attrs,
									w = [];
								let R = null,
									j = null;
								for (let se = r.directiveStart; se < l; se++) {
									const ve = d[se],
										$e = o ? o.get(ve) : null,
										At = $e ? $e.outputs : null;
									R = Sd(ve.inputs, se, R, $e ? $e.inputs : null), j = Sd(ve.outputs, se, j, At);
									const jt = null === R || null === _ || ps(r) ? null : V_(R, se, _);
									w.push(jt)
								}
								null !== R && (R.hasOwnProperty("class") && (r.flags |= 8), R.hasOwnProperty("style") && (r.flags |= 16)), r.initialInputs = w, r.inputs = R, r.outputs = j
							}(n, o, d)
						}

						function Uf(n, r, o) {
							const a = o.directiveStart,
								l = o.directiveEnd,
								d = o.index,
								_ = function ll() {
									return wn.lFrame.currentDirectiveIndex
								}();
							try {
								yi(d);
								for (let w = a; w < l; w++) {
									const R = n.data[w],
										j = r[w];
									Hr(w), (null !== R.hostBindings || 0 !== R.hostVars || null !== R.hostAttrs) && Zg(R, j)
								}
							} finally {
								yi(-1), Hr(_)
							}
						}

						function Zg(n, r) {
							null !== n.hostBindings && n.hostBindings(1, r)
						}

						function Bf(n, r, o) {
							r.componentOffset = o, (n.components || (n.components = [])).push(r.index)
						}

						function nm(n, r, o) {
							if (o) {
								if (r.exportAs)
									for (let a = 0; a < r.exportAs.length; a++) o[r.exportAs[a]] = n;
								ri(r) && (o[""] = n)
							}
						}

						function rm(n, r, o, a, l) {
							n.data[a] = l;
							const d = l.factory || (l.factory = Qi(l.type)),
								_ = new It(d, ri(l), Qa);
							n.blueprint[a] = _, o[a] = _,
								function Jg(n, r, o, a, l) {
									const d = l.hostBindings;
									if (d) {
										let _ = n.hostBindingOpCodes;
										null === _ && (_ = n.hostBindingOpCodes = []);
										const w = ~r.index;
										(function Xg(n) {
											let r = n.length;
											for (; r > 0;) {
												const o = n[--r];
												if ("number" == typeof o && o < 0) return o
											}
											return 0
										})(_) != w && _.push(w), _.push(o, a, d)
									}
								}(n, r, a, qc(n, o, l.hostVars, Ln), l)
						}

						function zo(n, r, o, a, l, d) {
							const _ = kr(n, r);
							! function Hf(n, r, o, a, l, d, _) {
								if (null == d) n.removeAttribute(r, l, o);
								else {
									const w = null == _ ? Ce(d) : _(d, a || "", l);
									n.setAttribute(r, l, w, o)
								}
							}(r[Ot], _, d, n.value, o, a, l)
						}

						function om(n, r, o, a, l, d) {
							const _ = d[r];
							if (null !== _) {
								const w = a.setInput;
								for (let R = 0; R < _.length;) {
									const j = _[R++],
										se = _[R++],
										ve = _[R++];
									null !== w ? a.setInput(o, ve, j, se) : o[se] = ve
								}
							}
						}

						function V_(n, r, o) {
							let a = null,
								l = 0;
							for (; l < o.length;) {
								const d = o[l];
								if (0 !== d)
									if (5 !== d) {
										if ("number" == typeof d) break;
										if (n.hasOwnProperty(d)) {
											null === a && (a = []);
											const _ = n[d];
											for (let w = 0; w < _.length; w += 2)
												if (_[w] === r) {
													a.push(d, _[w + 1], o[l + 1]);
													break
												}
										}
										l += 2
									} else l += 2;
								else l += 4
							}
							return a
						}

						function sm(n, r, o, a) {
							return [n, !0, !1, r, null, 0, a, o, null, null]
						}

						function Gf(n, r) {
							const o = di(r, n);
							if (Li(o)) {
								const a = o[K];
								48 & o[he] ? $l(a, o, a.template, o[Et]) : o[gt] > 0 && bd(o)
							}
						}

						function bd(n) {
							for (let a = cs(n); null !== a; a = wl(a))
								for (let l = or; l < a.length; l++) {
									const d = a[l];
									if (Li(d))
										if (512 & d[he]) {
											const _ = d[K];
											$l(_, d, _.template, d[Et])
										} else d[gt] > 0 && bd(d)
								}
							const o = n[K].components;
							if (null !== o)
								for (let a = 0; a < o.length; a++) {
									const l = di(o[a], n);
									Li(l) && l[gt] > 0 && bd(l)
								}
						}

						function cm(n, r) {
							const o = di(r, n),
								a = o[K];
							(function lm(n, r) {
								for (let o = r.length; o < n.blueprint.length; o++) r.push(n.blueprint[o])
							})(a, o), Ed(a, o, o[Et])
						}

						function Kl(n, r) {
							return n[Mn] ? n[Cn][He] = r : n[Mn] = r, n[Cn] = r, r
						}

						function Id(n) {
							for (; n;) {
								n[he] |= 32;
								const r = Lc(n);
								if (oo(n) && !r) return n;
								n = r
							}
							return null
						}

						function Yl(n, r, o, a = !0) {
							const l = r[Rt];
							l.begin && l.begin();
							try {
								$l(n, r, n.template, o)
							} catch (_) {
								throw a && $f(r, _), _
							} finally {
								l.end && l.end()
							}
						}

						function Wl(n, r, o) {
							po(0), r(n, o)
						}

						function Za(n) {
							return n[mt] || (n[mt] = [])
						}

						function jf(n) {
							return n.cleanup || (n.cleanup = [])
						}

						function Vf(n, r, o) {
							return (null === n || ri(n)) && (o = function Fi(n) {
								for (; Array.isArray(n);) {
									if ("object" == typeof n[Fn]) return n;
									n = n[L]
								}
								return null
							}(o[r.index])), o[Ot]
						}

						function $f(n, r) {
							const o = n[Gt],
								a = o ? o.get(Ks, null) : null;
							a && a.handleError(r)
						}

						function Dd(n, r, o, a, l) {
							for (let d = 0; d < o.length;) {
								const _ = o[d++],
									w = o[d++],
									R = r[_],
									j = n.data[_];
								null !== j.setInput ? j.setInput(R, l, a, w) : R[w] = l
							}
						}

						function Ko(n, r, o) {
							const a = Ai(r, n);
							! function Fu(n, r, o) {
								n.setValue(r, o)
							}(n[Ot], a, o)
						}

						function ql(n, r, o) {
							let a = o ? n.styles : null,
								l = o ? n.classes : null,
								d = 0;
							if (null !== r)
								for (let _ = 0; _ < r.length; _++) {
									const w = r[_];
									"number" == typeof w ? d = w : 1 == d ? l = G(l, w) : 2 == d && (a = G(a, w + ": " + r[++_] + ";"))
								}
							o ? n.styles = a : n.stylesWithoutHost = a, o ? n.classes = l : n.classesWithoutHost = l
						}

						function Ql(n, r, o, a, l = !1) {
							for (; null !== o;) {
								const d = r[o.index];
								if (null !== d && a.push(sr(d)), gr(d))
									for (let w = or; w < d.length; w++) {
										const R = d[w],
											j = R[K].firstChild;
										null !== j && Ql(R[K], R, j, a)
									}
								const _ = o.type;
								if (8 & _) Ql(n, r, o.child, a);
								else if (32 & _) {
									const w = ku(o, r);
									let R;
									for (; R = w();) a.push(R)
								} else if (16 & _) {
									const w = Al(r, o);
									if (Array.isArray(w)) a.push(...w);
									else {
										const R = Lc(r[xn]);
										Ql(R[K], R, w, a, !0)
									}
								}
								o = l ? o.projectionNext : o.next
							}
							return a
						}
						class ec {
							get rootNodes() {
								const r = this._lView,
									o = r[K];
								return Ql(o, r, o.firstChild, [])
							}
							constructor(r, o) {
								this._lView = r, this._cdRefInjectingView = o, this._appRef = null, this._attachedToViewContainer = !1
							}
							get context() {
								return this._lView[Et]
							}
							set context(r) {
								this._lView[Et] = r
							}
							get destroyed() {
								return 128 == (128 & this._lView[he])
							}
							destroy() {
								if (this._appRef) this._appRef.detachView(this);
								else if (this._attachedToViewContainer) {
									const r = this._lView[ye];
									if (gr(r)) {
										const o = r[br],
											a = o ? o.indexOf(this) : -1;
										a > -1 && (La(r, a), b(o, a))
									}
									this._attachedToViewContainer = !1
								}
								Oh(this._lView[K], this._lView)
							}
							onDestroy(r) {
								kf(this._lView[K], this._lView, null, r)
							}
							markForCheck() {
								Id(this._cdRefInjectingView || this._lView)
							}
							detach() {
								this._lView[he] &= -65
							}
							reattach() {
								this._lView[he] |= 64
							}
							detectChanges() {
								Yl(this._lView[K], this._lView, this.context)
							}
							checkNoChanges() {}
							attachToViewContainerRef() {
								if (this._appRef) throw new Le(902, !1);
								this._attachedToViewContainer = !0
							}
							detachFromAppRef() {
								this._appRef = null,
									function Lu(n, r) {
										no(n, r, r[Ot], 2, null, null)
									}(this._lView[K], this._lView)
							}
							attachToAppRef(r) {
								if (this._attachedToViewContainer) throw new Le(902, !1);
								this._appRef = r
							}
						}
						class K_ extends ec {
							constructor(r) {
								super(r), this._view = r
							}
							detectChanges() {
								const r = this._view;
								Yl(r[K], r, r[Et], !1)
							}
							checkNoChanges() {}
							get context() {
								return null
							}
						}
						class dm extends zc {
							constructor(r) {
								super(), this.ngModule = r
							}
							resolveComponentFactory(r) {
								const o = V(r);
								return new Jl(o, this.ngModule)
							}
						}

						function hm(n) {
							const r = [];
							for (let o in n) n.hasOwnProperty(o) && r.push({
								propName: n[o],
								templateName: o
							});
							return r
						}
						class W_ {
							constructor(r, o) {
								this.injector = r, this.parentInjector = o
							}
							get(r, o, a) {
								a = H(a);
								const l = this.injector.get(r, zs, a);
								return l !== zs || o === zs ? l : this.parentInjector.get(r, o, a)
							}
						}
						class Jl extends df {
							get inputs() {
								return hm(this.componentDef.inputs)
							}
							get outputs() {
								return hm(this.componentDef.outputs)
							}
							constructor(r, o) {
								super(), this.componentDef = r, this.ngModule = o, this.componentType = r.type, this.selector = function Mg(n) {
									return n.map(ud).join(",")
								}(r.selectors), this.ngContentSelectors = r.ngContentSelectors ? r.ngContentSelectors : [], this.isBoundToModule = !!o
							}
							create(r, o, a, l) {
								let d = (l = l || this.ngModule) instanceof mi ? l : l?.injector;
								d && null !== this.componentDef.getStandaloneInjector && (d = this.componentDef.getStandaloneInjector(d) || d);
								const _ = d ? new W_(r, d) : r,
									w = _.get(id, null);
								if (null === w) throw new Le(407, !1);
								const R = _.get(yg, null),
									j = w.createRenderer(null, this.componentDef),
									se = this.componentDef.selectors[0][0] || "div",
									ve = a ? function qg(n, r, o) {
										return n.selectRootElement(r, o === Dn.ShadowDom)
									}(j, a, this.componentDef.encapsulation) : Uc(j, se, function Y_(n) {
										const r = n.toLowerCase();
										return "svg" === r ? "svg" : "math" === r ? "math" : null
									}(se)),
									$e = this.componentDef.onPush ? 288 : 272,
									rt = vs(0, null, null, 1, 0, null, null, null, null, null),
									At = ms(null, rt, null, $e, null, null, w, j, R, _, null);
								let jt, nn;
								Xi(At);
								try {
									const gn = this.componentDef;
									let On, Lt = null;
									gn.findHostDirectiveDefs ? (On = [], Lt = new Map, gn.findHostDirectiveDefs(gn, On, Lt), On.push(gn)) : On = [gn];
									const Hn = function Q_(n, r) {
											const o = n[K],
												a = Dt;
											return n[a] = r, Ws(o, a, 2, "#host", null)
										}(At, ve),
										Lr = function fm(n, r, o, a, l, d, _, w) {
											const R = l[K];
											! function Ad(n, r, o, a) {
												for (const l of n) r.mergedAttrs = Yr(r.mergedAttrs, l.hostAttrs);
												null !== r.mergedAttrs && (ql(r, r.mergedAttrs, !0), null !== o && Vu(a, o, r))
											}(a, n, r, _);
											const j = d.createRenderer(r, o),
												se = ms(l, qs(o), null, o.onPush ? 32 : 16, l[n.index], n, d, j, w || null, null, null);
											return R.firstCreatePass && Bf(R, n, a.length - 1), Kl(l, se), l[n.index] = se
										}(Hn, ve, gn, On, At, w, j);
									nn = Os(rt, Dt), ve && function pm(n, r, o, a) {
										if (a) bi(n, o, ["ng-version", ff.full]);
										else {
											const {
												attrs: l,
												classes: d
											} = function Og(n) {
												const r = [],
													o = [];
												let a = 1,
													l = 2;
												for (; a < n.length;) {
													let d = n[a];
													if ("string" == typeof d) 2 === l ? "" !== d && r.push(d, n[++a]) : 8 === l && o.push(d);
													else {
														if (!io(l)) break;
														l = d
													}
													a++
												}
												return {
													attrs: r,
													classes: o
												}
											}(r.selectors[0]);
											l && bi(n, o, l), d && d.length > 0 && ju(n, o, d.join(" "))
										}
									}(j, gn, ve, a), void 0 !== o && function gm(n, r, o) {
										const a = n.projection = [];
										for (let l = 0; l < r.length; l++) {
											const d = o[l];
											a.push(null != d ? Array.from(d) : null)
										}
									}(nn, this.ngContentSelectors, o), jt = function Kf(n, r, o, a, l, d) {
										const _ = zr(),
											w = l[K],
											R = kr(_, l);
										Xa(w, l, _, o, null, a);
										for (let se = 0; se < o.length; se++) Ei(Er(l, w, _.directiveStart + se, _), l);
										Uf(w, l, _), R && Ei(R, l);
										const j = Er(l, w, _.directiveStart + _.componentOffset, _);
										if (n[Et] = l[Et] = j, null !== d)
											for (const se of d) se(j, r);
										return _s(w, _, n), j
									}(Lr, gn, On, Lt, At, [mm]), Ed(rt, At, null)
								} finally {
									Fs()
								}
								return new zf(this.componentType, jt, Ka(nn, At), At, nn)
							}
						}
						class zf extends Ul {
							constructor(r, o, a, l, d) {
								super(), this.location = a, this._rootLView = l, this._tNode = d, this.instance = o, this.hostView = this.changeDetectorRef = new K_(l), this.componentType = r
							}
							setInput(r, o) {
								const a = this._tNode.inputs;
								let l;
								if (null !== a && (l = a[r])) {
									const d = this._rootLView;
									Dd(d[K], d, l, r, o), Lf(d, this._tNode.index)
								}
							}
							get injector() {
								return new Lo(this._tNode, this._rootLView)
							}
							destroy() {
								this.hostView.destroy()
							}
							onDestroy(r) {
								this.hostView.onDestroy(r)
							}
						}

						function mm() {
							const n = zr();
							os(Ct()[K], n)
						}

						function Md(n) {
							let r = function Rd(n) {
									return Object.getPrototypeOf(n.prototype).constructor
								}(n.type),
								o = !0;
							const a = [n];
							for (; r;) {
								let l;
								if (ri(n)) l = r.\u0275cmp || r.\u0275dir;
								else {
									if (r.\u0275cmp) throw new Le(903, !1);
									l = r.\u0275dir
								}
								if (l) {
									if (o) {
										a.push(l);
										const _ = n;
										_.inputs = Xl(n.inputs), _.declaredInputs = Xl(n.declaredInputs), _.outputs = Xl(n.outputs);
										const w = l.hostBindings;
										w && Em(n, w);
										const R = l.viewQuery,
											j = l.contentQueries;
										if (R && vm(n, R), j && ym(n, j), N(n.inputs, l.inputs), N(n.declaredInputs, l.declaredInputs), N(n.outputs, l.outputs), ri(l) && l.data.animation) {
											const se = n.data;
											se.animation = (se.animation || []).concat(l.data.animation)
										}
									}
									const d = l.features;
									if (d)
										for (let _ = 0; _ < d.length; _++) {
											const w = d[_];
											w && w.ngInherit && w(n), w === Md && (o = !1)
										}
								}
								r = Object.getPrototypeOf(r)
							}! function _m(n) {
								let r = 0,
									o = null;
								for (let a = n.length - 1; a >= 0; a--) {
									const l = n[a];
									l.hostVars = r += l.hostVars, l.hostAttrs = Yr(l.hostAttrs, o = Yr(o, l.hostAttrs))
								}
							}(a)
						}

						function Xl(n) {
							return n === En ? {} : n === Me ? [] : n
						}

						function vm(n, r) {
							const o = n.viewQuery;
							n.viewQuery = o ? (a, l) => {
								r(a, l), o(a, l)
							} : r
						}

						function ym(n, r) {
							const o = n.contentQueries;
							n.contentQueries = o ? (a, l, d) => {
								r(a, l, d), o(a, l, d)
							} : r
						}

						function Em(n, r) {
							const o = n.hostBindings;
							n.hostBindings = o ? (a, l) => {
								r(a, l), o(a, l)
							} : r
						}
						let kd = null;

						function tc() {
							if (!kd) {
								const n = un.Symbol;
								if (n && n.iterator) kd = n.iterator;
								else {
									const r = Object.getOwnPropertyNames(Map.prototype);
									for (let o = 0; o < r.length; ++o) {
										const a = r[o];
										"entries" !== a && "size" !== a && Map.prototype[a] === Map.prototype.entries && (kd = a)
									}
								}
							}
							return kd
						}

						function xd(n) {
							return !!Fd(n) && (Array.isArray(n) || !(n instanceof Map) && tc() in n)
						}

						function Fd(n) {
							return null !== n && ("function" == typeof n || "object" == typeof n)
						}

						function li(n, r, o) {
							return n[r] = o
						}

						function Qc(n, r) {
							return n[r]
						}

						function jr(n, r, o) {
							return !Object.is(n[r], o) && (n[r] = o, !0)
						}

						function Mo(n, r, o, a) {
							const l = jr(n, r, o);
							return jr(n, r + 1, a) || l
						}

						function _i(n, r, o, a, l, d) {
							const _ = Mo(n, r, o, a);
							return Mo(n, r + 2, l, d) || _
						}

						function Ld(n, r, o, a) {
							const l = Ct();
							return jr(l, ho(), r) && (Gn(), zo(yr(), l, n, r, o, a)), Ld
						}

						function ys(n, r, o, a) {
							return jr(n, ho(), o) ? r + Ce(o) + a : Ln
						}

						function Oo(n, r, o, a, l, d) {
							const w = Mo(n, function hi() {
								return wn.lFrame.bindingIndex
							}(), o, l);
							return wi(2), w ? r + Ce(o) + a + Ce(l) + d : Ln
						}

						function Hd(n, r, o, a, l, d, _, w) {
							const R = Ct(),
								j = Gn(),
								se = n + Dt,
								ve = j.firstCreatePass ? function np(n, r, o, a, l, d, _, w, R) {
									const j = r.consts,
										se = Ws(r, n, 4, _ || null, lo(j, w));
									wd(r, o, se, lo(j, R)), os(r, se);
									const ve = se.tViews = vs(2, se, a, l, d, r.directiveRegistry, r.pipeRegistry, null, r.schemas, j);
									return null !== r.queries && (r.queries.template(r, se), ve.queries = r.queries.embeddedTView(se)), se
								}(se, j, R, r, o, a, l, d, _) : j.data[se];
							Ri(ve, !1);
							const $e = R[Ot].createComment("");
							Dl(j, R, $e, ve), Ei($e, R), Kl(R, R[se] = sm($e, R, $e, ve)), Si(ve) && Cd(j, R, ve), null != _ && zl(R, ve, w)
						}

						function vr(n) {
							return Ji(function gc() {
								return wn.lFrame.contextLView
							}(), Dt + n)
						}

						function Gd(n, r, o) {
							const a = Ct();
							return jr(a, ho(), r) && Vi(Gn(), yr(), a, n, r, a[Ot], o, !1), Gd
						}

						function Jc(n, r, o, a, l) {
							const _ = l ? "class" : "style";
							Dd(n, o, r.inputs[_], _, a)
						}

						function nu(n, r, o, a) {
							const l = Ct(),
								d = Gn(),
								_ = Dt + n,
								w = l[Ot],
								R = l[_] = Uc(w, r, function is() {
									return wn.lFrame.currentNamespace
								}()),
								j = d.firstCreatePass ? function Im(n, r, o, a, l, d, _) {
									const w = r.consts,
										j = Ws(r, n, 2, l, lo(w, d));
									return wd(r, o, j, lo(w, _)), null !== j.attrs && ql(j, j.attrs, !1), null !== j.mergedAttrs && ql(j, j.mergedAttrs, !0), null !== r.queries && r.queries.elementStart(r, j), j
								}(_, d, l, 0, r, o, a) : d.data[_];
							return Ri(j, !0), Vu(w, R, j), 32 != (32 & j.flags) && Dl(d, l, R, j), 0 === function dc() {
									return wn.lFrame.elementDepthCount
								}() && Ei(R, l),
								function al() {
									wn.lFrame.elementDepthCount++
								}(), Si(j) && (Cd(d, l, j), _s(d, j, l)), null !== a && zl(l, j), nu
						}

						function Xc() {
							let n = zr();
							ga() ? ma() : (n = n.parent, Ri(n, !1));
							const r = n;
							! function Ps() {
								wn.lFrame.elementDepthCount--
							}();
							const o = Gn();
							return o.firstCreatePass && (os(o, n), xi(n) && o.queries.elementEnd(n)), null != r.classesWithoutHost && function jn(n) {
								return 0 != (8 & n.flags)
							}(r) && Jc(o, r, Ct(), r.classesWithoutHost, !0), null != r.stylesWithoutHost && function Rr(n) {
								return 0 != (16 & n.flags)
							}(r) && Jc(o, r, Ct(), r.stylesWithoutHost, !1), Xc
						}

						function ru(n, r, o, a) {
							return nu(n, r, o, a), Xc(), ru
						}

						function Cs(n, r, o) {
							const a = Ct(),
								l = Gn(),
								d = n + Dt,
								_ = l.firstCreatePass ? function jd(n, r, o, a, l) {
									const d = r.consts,
										_ = lo(d, a),
										w = Ws(r, n, 8, "ng-container", _);
									return null !== _ && ql(w, _, !0), wd(r, o, w, lo(d, l)), null !== r.queries && r.queries.elementStart(r, w), w
								}(d, l, a, r, o) : l.data[d];
							Ri(_, !0);
							const w = a[d] = a[Ot].createComment("");
							return Dl(l, a, w, _), Ei(w, a), Si(_) && (Cd(l, a, _), _s(l, _, a)), null != o && zl(a, _), Cs
						}

						function Xs() {
							let n = zr();
							const r = Gn();
							return ga() ? ma() : (n = n.parent, Ri(n, !1)), r.firstCreatePass && (os(r, n), xi(n) && r.queries.elementEnd(n)), Xs
						}

						function Zc() {
							return Ct()
						}

						function Vd(n) {
							return !!n && "function" == typeof n.then
						}

						function ip(n) {
							return !!n && "function" == typeof n.subscribe
						}
						const iu = ip;

						function $d(n, r, o, a) {
							const l = Ct(),
								d = Gn(),
								_ = zr();
							return su(d, l, l[Ot], _, n, r, a), $d
						}

						function ou(n, r) {
							const o = zr(),
								a = Ct(),
								l = Gn();
							return su(l, a, Vf(fo(l.data), o, a), o, n, r), ou
						}

						function su(n, r, o, a, l, d, _) {
							const w = Si(a),
								j = n.firstCreatePass && jf(n),
								se = r[Et],
								ve = Za(r);
							let $e = !0;
							if (3 & a.type || _) {
								const jt = kr(a, r),
									nn = _ ? _(jt) : jt,
									gn = ve.length,
									On = _ ? Hn => _(sr(Hn[a.index])) : a.index;
								let Lt = null;
								if (!_ && w && (Lt = function Dm(n, r, o, a) {
										const l = n.cleanup;
										if (null != l)
											for (let d = 0; d < l.length - 1; d += 2) {
												const _ = l[d];
												if (_ === o && l[d + 1] === a) {
													const w = r[mt],
														R = l[d + 2];
													return w.length > R ? w[R] : null
												}
												"string" == typeof _ && (d += 2)
											}
										return null
									}(n, r, l, a.index)), null !== Lt)(Lt.__ngLastListenerFn__ || Lt).__ngNextListenerFn__ = d, Lt.__ngLastListenerFn__ = d, $e = !1;
								else {
									d = Qr(a, r, se, d, !1);
									const Hn = o.listen(nn, l, d);
									ve.push(d, Hn), j && j.push(l, On, gn, gn + 1)
								}
							} else d = Qr(a, r, se, d, !1);
							const rt = a.outputs;
							let At;
							if ($e && null !== rt && (At = rt[l])) {
								const jt = At.length;
								if (jt)
									for (let nn = 0; nn < jt; nn += 2) {
										const Lr = r[At[nn]][At[nn + 1]].subscribe(d),
											si = ve.length;
										ve.push(d, Lr), j && j.push(l, a.index, si, -(si + 1))
									}
							}
						}

						function Zs(n, r, o, a) {
							try {
								return Ti(6, r, o), !1 !== o(a)
							} catch (l) {
								return $f(n, l), !1
							} finally {
								Ti(7, r, o)
							}
						}

						function Qr(n, r, o, a, l) {
							return function d(_) {
								if (_ === Function) return a;
								Id(n.componentOffset > -1 ? di(n.index, r) : r);
								let R = Zs(r, o, a, _),
									j = d.__ngNextListenerFn__;
								for (; j;) R = Zs(r, o, j, _) && R, j = j.__ngNextListenerFn__;
								return l && !1 === R && (_.preventDefault(), _.returnValue = !1), R
							}
						}

						function zd(n = 1) {
							return function Ea(n) {
								return (wn.lFrame.contextLView = function Ca(n, r) {
									for (; n > 0;) r = r[Jn], n--;
									return r
								}(n, wn.lFrame.contextLView))[Et]
							}(n)
						}

						function op(n, r) {
							let o = null;
							const a = function Dg(n) {
								const r = n.attrs;
								if (null != r) {
									const o = r.indexOf(5);
									if (!(1 & o)) return r[o + 1]
								}
								return null
							}(n);
							for (let l = 0; l < r.length; l++) {
								const d = r[l];
								if ("*" !== d) {
									if (null === a ? Yc(n, d, !0) : Rg(a, d)) return l
								} else o = l
							}
							return o
						}

						function Or(n) {
							const r = Ct()[xn][st];
							if (!r.projection) {
								const a = r.projection = x(n ? n.length : 1, null),
									l = a.slice();
								let d = r.child;
								for (; null !== d;) {
									const _ = n ? op(d, n) : 0;
									null !== _ && (l[_] ? l[_].projectionNext = d : a[_] = d, l[_] = d), d = d.next
								}
							}
						}

						function vo(n, r = 0, o) {
							const a = Ct(),
								l = Gn(),
								d = Ws(l, Dt + n, 16, null, o || null);
							null === d.projection && (d.projection = r), ma(), 32 != (32 & d.flags) && function Gu(n, r, o) {
								ds(r[Ot], 0, r, o, Ph(n, o, r), bl(o.parent || r[st], o, r))
							}(l, a, d)
						}

						function ea(n, r, o) {
							return au(n, "", r, "", o), ea
						}

						function au(n, r, o, a, l) {
							const d = Ct(),
								_ = ys(d, r, o, a);
							return _ !== Ln && Vi(Gn(), yr(), d, n, _, d[Ot], l, !1), au
						}

						function ta(n, r) {
							return n << 17 | r << 2
						}

						function Ss(n) {
							return n >> 17 & 32767
						}

						function Kd(n) {
							return 2 | n
						}

						function Yo(n) {
							return (131068 & n) >> 2
						}

						function el(n, r) {
							return -131069 & n | r << 2
						}

						function Yd(n) {
							return 1 | n
						}

						function pp(n, r, o, a, l) {
							const d = n[o + 1],
								_ = null === r;
							let w = a ? Ss(d) : Yo(d),
								R = !1;
							for (; 0 !== w && (!1 === R || _);) {
								const se = n[w + 1];
								Nm(n[w], r) && (R = !0, n[w + 1] = a ? Yd(se) : Kd(se)), w = a ? Ss(se) : Yo(se)
							}
							R && (n[o + 1] = a ? Kd(d) : Yd(d))
						}

						function Nm(n, r) {
							return null === n || null == r || (Array.isArray(n) ? n[1] : n) === r || !(!Array.isArray(n) || "string" != typeof r) && zn(n, r) >= 0
						}
						const Vr = {
							textEnd: 0,
							key: 0,
							keyEnd: 0,
							value: 0,
							valueEnd: 0
						};

						function Wd(n) {
							return n.substring(Vr.key, Vr.keyEnd)
						}

						function i(n, r) {
							const o = Vr.textEnd;
							return o === r ? -1 : (r = Vr.keyEnd = function u(n, r, o) {
								for (; r < o && n.charCodeAt(r) > 32;) r++;
								return r
							}(n, Vr.key = r, o), c(n, r, o))
						}

						function c(n, r, o) {
							for (; r < o && n.charCodeAt(r) <= 32;) r++;
							return r
						}

						function le(n, r, o) {
							return Yt(n, r, o, !1), le
						}

						function Re(n, r) {
							return Yt(n, r, null, !0), Re
						}

						function wt(n) {
							! function sn(n, r, o, a) {
								const l = Gn(),
									d = wi(2);
								l.firstUpdatePass && fr(l, null, d, a);
								const _ = Ct();
								if (o !== Ln && jr(_, d, o)) {
									const w = l.data[ur()];
									if (An(w, a) && !kn(l, d)) {
										let R = a ? w.classesWithoutHost : w.stylesWithoutHost;
										null !== R && (o = G(R, o || "")), Jc(l, w, _, o, a)
									} else ! function na(n, r, o, a, l, d, _, w) {
										l === Ln && (l = Me);
										let R = 0,
											j = 0,
											se = 0 < l.length ? l[0] : null,
											ve = 0 < d.length ? d[0] : null;
										for (; null !== se || null !== ve;) {
											const $e = R < l.length ? l[R + 1] : void 0,
												rt = j < d.length ? d[j + 1] : void 0;
											let jt, At = null;
											se === ve ? (R += 2, j += 2, $e !== rt && (At = ve, jt = rt)) : null === ve || null !== se && se < ve ? (R += 2, At = se) : (j += 2, At = ve, jt = rt), null !== At && qd(n, r, o, a, At, jt, _, w), se = R < l.length ? l[R] : null, ve = j < d.length ? d[j] : null
										}
									}(l, w, _, _[Ot], _[d + 1], _[d + 1] = function gp(n, r, o) {
										if (null == o || "" === o) return Me;
										const a = [],
											l = _o(o);
										if (Array.isArray(l))
											for (let d = 0; d < l.length; d++) n(a, l[d], !0);
										else if ("object" == typeof l)
											for (const d in l) l.hasOwnProperty(d) && n(a, d, l[d]);
										else "string" == typeof l && r(a, l);
										return a
									}(n, r, o), a, d)
								}
							}(Kt, Wt, n, !0)
						}

						function Wt(n, r) {
							for (let o = function km(n) {
									return function s(n) {
										Vr.key = 0, Vr.keyEnd = 0, Vr.value = 0, Vr.valueEnd = 0, Vr.textEnd = n.length
									}(n), i(n, c(n, 0, Vr.textEnd))
								}(r); o >= 0; o = i(r, o)) Kt(n, Wd(r), !0)
						}

						function Yt(n, r, o, a) {
							const l = Ct(),
								d = Gn(),
								_ = wi(2);
							d.firstUpdatePass && fr(d, n, _, a), r !== Ln && jr(l, _, r) && qd(d, d.data[ur()], l, l[Ot], n, l[_ + 1] = function In(n, r) {
								return null == n || ("string" == typeof r ? n += r : "object" == typeof n && (n = Y(_o(n)))), n
							}(r, o), a, _)
						}

						function kn(n, r) {
							return r >= n.expandoStartIndex
						}

						function fr(n, r, o, a) {
							const l = n.data;
							if (null === l[o + 1]) {
								const d = l[ur()],
									_ = kn(n, o);
								An(d, a) && null === r && !_ && (r = !1), r = function ui(n, r, o, a) {
										const l = fo(n);
										let d = a ? r.residualClasses : r.residualStyles;
										if (null === l) 0 === (a ? r.classBindings : r.styleBindings) && (o = zi(o = yo(null, n, r, o, a), r.attrs, a), d = null);
										else {
											const _ = r.directiveStylingLast;
											if (-1 === _ || n[_] !== l)
												if (o = yo(l, n, r, o, a), null === d) {
													let R = function oi(n, r, o) {
														const a = o ? r.classBindings : r.styleBindings;
														if (0 !== Yo(a)) return n[Ss(a)]
													}(n, r, a);
													void 0 !== R && Array.isArray(R) && (R = yo(null, n, r, R[1], a), R = zi(R, r.attrs, a), function Jr(n, r, o, a) {
														n[Ss(o ? r.classBindings : r.styleBindings)] = a
													}(n, r, a, R))
												} else d = function wr(n, r, o) {
													let a;
													const l = r.directiveEnd;
													for (let d = 1 + r.directiveStylingLast; d < l; d++) a = zi(a, n[d].hostAttrs, o);
													return zi(a, r.attrs, o)
												}(n, r, a)
										}
										return void 0 !== d && (a ? r.residualClasses = d : r.residualStyles = d), o
									}(l, d, r, a),
									function Om(n, r, o, a, l, d) {
										let _ = d ? r.classBindings : r.styleBindings,
											w = Ss(_),
											R = Yo(_);
										n[a] = o;
										let se, j = !1;
										if (Array.isArray(o) ? (se = o[1], (null === se || zn(o, se) > 0) && (j = !0)) : se = o, l)
											if (0 !== R) {
												const $e = Ss(n[w + 1]);
												n[a + 1] = ta($e, w), 0 !== $e && (n[$e + 1] = el(n[$e + 1], a)), n[w + 1] = function Rm(n, r) {
													return 131071 & n | r << 17
												}(n[w + 1], a)
											} else n[a + 1] = ta(w, 0), 0 !== w && (n[w + 1] = el(n[w + 1], a)), w = a;
										else n[a + 1] = ta(R, 0), 0 === w ? w = a : n[R + 1] = el(n[R + 1], a), R = a;
										j && (n[a + 1] = Kd(n[a + 1])), pp(n, se, a, !0), pp(n, se, a, !1),
											function Pm(n, r, o, a, l) {
												const d = l ? n.residualClasses : n.residualStyles;
												null != d && "string" == typeof r && zn(d, r) >= 0 && (o[a + 1] = Yd(o[a + 1]))
											}(r, se, n, a, d), _ = ta(w, R), d ? r.classBindings = _ : r.styleBindings = _
									}(l, d, r, o, _, a)
							}
						}

						function yo(n, r, o, a, l) {
							let d = null;
							const _ = o.directiveEnd;
							let w = o.directiveStylingLast;
							for (-1 === w ? w = o.directiveStart : w++; w < _ && (d = r[w], a = zi(a, d.hostAttrs, l), d !== n);) w++;
							return null !== n && (o.directiveStylingLast = w), a
						}

						function zi(n, r, o) {
							const a = o ? 1 : 2;
							let l = -1;
							if (null !== r)
								for (let d = 0; d < r.length; d++) {
									const _ = r[d];
									"number" == typeof _ ? l = _ : l === a && (Array.isArray(n) || (n = void 0 === n ? [] : ["", n]), Kt(n, _, !!o || r[++d]))
								}
							return void 0 === n ? null : n
						}

						function qd(n, r, o, a, l, d, _, w) {
							if (!(3 & r.type)) return;
							const R = n.data,
								j = R[w + 1],
								se = function Mm(n) {
									return 1 == (1 & n)
								}(j) ? Qd(R, r, o, l, Yo(j), _) : void 0;
							fn(se) || (fn(d) || function Am(n) {
								return 2 == (2 & n)
							}(j) && (d = Qd(R, null, o, l, w, _)), function C_(n, r, o, a, l) {
								if (r) l ? n.addClass(o, a) : n.removeClass(o, a);
								else {
									let d = -1 === a.indexOf("-") ? void 0 : Do.DashCase;
									null == l ? n.removeStyle(o, a, d) : ("string" == typeof l && l.endsWith("!important") && (l = l.slice(0, -10), d |= Do.Important), n.setStyle(o, a, l, d))
								}
							}(a, _, Ai(ur(), o), l, d))
						}

						function Qd(n, r, o, a, l, d) {
							const _ = null === r;
							let w;
							for (; l > 0;) {
								const R = n[l],
									j = Array.isArray(R),
									se = j ? R[1] : R,
									ve = null === se;
								let $e = o[l + 1];
								$e === Ln && ($e = ve ? Me : void 0);
								let rt = ve ? on($e, a) : se === a ? $e : void 0;
								if (j && !fn(rt) && (rt = on(R, a)), fn(rt) && (w = rt, _)) return w;
								const At = n[l + 1];
								l = _ ? Ss(At) : Yo(At)
							}
							if (null !== r) {
								let R = d ? r.residualClasses : r.residualStyles;
								null != R && (w = on(R, a))
							}
							return w
						}

						function fn(n) {
							return void 0 !== n
						}

						function An(n, r) {
							return 0 != (n.flags & (r ? 8 : 16))
						}

						function tr(n, r = "") {
							const o = Ct(),
								a = Gn(),
								l = n + Dt,
								d = a.firstCreatePass ? Ws(a, l, 1, r, null) : a.data[l],
								_ = o[l] = function ki(n, r) {
									return n.createText(r)
								}(o[Ot], r);
							Dl(a, o, _, d), Ri(d, !1)
						}

						function Xr(n) {
							return Ki("", n, ""), Xr
						}

						function Ki(n, r, o) {
							const a = Ct(),
								l = ys(a, n, r, o);
							return l !== Ln && Ko(a, ur(), l), Ki
						}

						function Di(n, r, o, a, l) {
							const d = Ct(),
								_ = Oo(d, n, r, o, a, l);
							return _ !== Ln && Ko(d, ur(), _), Di
						}

						function xm(n, r, o) {
							const a = Ct();
							return jr(a, ho(), r) && Vi(Gn(), yr(), a, n, r, a[Ot], o, !0), xm
						}

						function Fm(n, r, o) {
							const a = Ct();
							if (jr(a, ho(), r)) {
								const d = Gn(),
									_ = yr();
								Vi(d, _, a, n, r, Vf(fo(d.data), _, a), o, !0)
							}
							return Fm
						}
						const nl = void 0;
						var xE = ["en", [
								["a", "p"],
								["AM", "PM"], nl
							],
							[
								["AM", "PM"], nl, nl
							],
							[
								["S", "M", "T", "W", "T", "F", "S"],
								["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
								["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
								["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]
							], nl, [
								["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
								["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
								["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
							], nl, [
								["B", "A"],
								["BC", "AD"],
								["Before Christ", "Anno Domini"]
							], 0, [6, 0],
							["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"],
							["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"],
							["{1}, {0}", nl, "{1} 'at' {0}", nl],
							[".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"],
							["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr",
							function kE(n) {
								const o = Math.floor(Math.abs(n)),
									a = n.toString().replace(/^[^.]*\.?/, "").length;
								return 1 === o && 0 === a ? 1 : 5
							}
						];
						let lu = {};

						function Lm(n) {
							const r = function FE(n) {
								return n.toLowerCase().replace(/_/g, "-")
							}(n);
							let o = dv(r);
							if (o) return o;
							const a = r.split("-")[0];
							if (o = dv(a), o) return o;
							if ("en" === a) return xE;
							throw new Le(701, !1)
						}

						function uv(n) {
							return Lm(n)[Rn.PluralCase]
						}

						function dv(n) {
							return n in lu || (lu[n] = un.ng && un.ng.common && un.ng.common.locales && un.ng.common.locales[n]), lu[n]
						}
						var Rn = (() => ((Rn = Rn || {})[Rn.LocaleId = 0] = "LocaleId", Rn[Rn.DayPeriodsFormat = 1] = "DayPeriodsFormat", Rn[Rn.DayPeriodsStandalone = 2] = "DayPeriodsStandalone", Rn[Rn.DaysFormat = 3] = "DaysFormat", Rn[Rn.DaysStandalone = 4] = "DaysStandalone", Rn[Rn.MonthsFormat = 5] = "MonthsFormat", Rn[Rn.MonthsStandalone = 6] = "MonthsStandalone", Rn[Rn.Eras = 7] = "Eras", Rn[Rn.FirstDayOfWeek = 8] = "FirstDayOfWeek", Rn[Rn.WeekendRange = 9] = "WeekendRange", Rn[Rn.DateFormat = 10] = "DateFormat", Rn[Rn.TimeFormat = 11] = "TimeFormat", Rn[Rn.DateTimeFormat = 12] = "DateTimeFormat", Rn[Rn.NumberSymbols = 13] = "NumberSymbols", Rn[Rn.NumberFormats = 14] = "NumberFormats", Rn[Rn.CurrencyCode = 15] = "CurrencyCode", Rn[Rn.CurrencySymbol = 16] = "CurrencySymbol", Rn[Rn.CurrencyName = 17] = "CurrencyName", Rn[Rn.Currencies = 18] = "Currencies", Rn[Rn.Directionality = 19] = "Directionality", Rn[Rn.PluralCase = 20] = "PluralCase", Rn[Rn.ExtraData = 21] = "ExtraData", Rn))();
						const uu = "en-US";
						let hv = uu;

						function Hm(n, r, o, a, l) {
							if (n = te(n), Array.isArray(n))
								for (let d = 0; d < n.length; d++) Hm(n[d], r, o, a, l);
							else {
								const d = Gn(),
									_ = Ct();
								let w = $s(n) ? n : te(n.provide),
									R = uf(n);
								const j = zr(),
									se = 1048575 & j.providerIndexes,
									ve = j.directiveStart,
									$e = j.providerIndexes >> 20;
								if ($s(n) || !n.multi) {
									const rt = new It(R, l, Qa),
										At = jm(w, r, l ? se : se + $e, ve); - 1 === At ? (Ta(q(j, _), d, w), Gm(d, n, r.length), r.push(w), j.directiveStart++, j.directiveEnd++, l && (j.providerIndexes += 1048576), o.push(rt), _.push(rt)) : (o[At] = rt, _[At] = rt)
								} else {
									const rt = jm(w, r, se + $e, ve),
										At = jm(w, r, se, se + $e),
										nn = At >= 0 && o[At];
									if (l && !nn || !l && !(rt >= 0 && o[rt])) {
										Ta(q(j, _), d, w);
										const gn = function NC(n, r, o, a, l) {
											const d = new It(n, o, Qa);
											return d.multi = [], d.index = r, d.componentProviders = 0, Lv(d, l, a && !o), d
										}(l ? PC : OC, o.length, l, a, R);
										!l && nn && (o[At].providerFactory = gn), Gm(d, n, r.length, 0), r.push(w), j.directiveStart++, j.directiveEnd++, l && (j.providerIndexes += 1048576), o.push(gn), _.push(gn)
									} else Gm(d, n, rt > -1 ? rt : At, Lv(o[l ? At : rt], R, !l && a));
									!l && a && nn && o[At].componentProviders++
								}
							}
						}

						function Gm(n, r, o, a) {
							const l = $s(r),
								d = function Dr(n) {
									return !!n.useClass
								}(r);
							if (l || d) {
								const R = (d ? te(r.useClass) : r).prototype.ngOnDestroy;
								if (R) {
									const j = n.destroyHooks || (n.destroyHooks = []);
									if (!l && r.multi) {
										const se = j.indexOf(o); - 1 === se ? j.push(o, [a, R]) : j[se + 1].push(a, R)
									} else j.push(o, R)
								}
							}
						}

						function Lv(n, r, o) {
							return o && n.componentProviders++, n.multi.push(r) - 1
						}

						function jm(n, r, o, a) {
							for (let l = o; l < a; l++)
								if (r[l] === n) return l;
							return -1
						}

						function OC(n, r, o, a) {
							return Vm(this.multi, [])
						}

						function PC(n, r, o, a) {
							const l = this.multi;
							let d;
							if (this.providerFactory) {
								const _ = this.providerFactory.componentProviders,
									w = Er(o, o[K], this.providerFactory.index, a);
								d = w.slice(0, _), Vm(l, d);
								for (let R = _; R < w.length; R++) d.push(w[R])
							} else d = [], Vm(l, d);
							return d
						}

						function Vm(n, r) {
							for (let o = 0; o < n.length; o++) r.push((0, n[o])());
							return r
						}

						function Uv(n, r = []) {
							return o => {
								o.providersResolver = (a, l) => function MC(n, r, o) {
									const a = Gn();
									if (a.firstCreatePass) {
										const l = ri(n);
										Hm(o, a.data, a.blueprint, l, !0), Hm(r, a.data, a.blueprint, l, !1)
									}
								}(a, l ? l(n) : n, r)
							}
						}
						class du {}
						class Bv {}

						function kC(n, r) {
							return new Hv(n, r ?? null)
						}
						class Hv extends du {
							constructor(r, o) {
								super(), this._parent = o, this._bootstrapComponents = [], this.destroyCbs = [], this.componentFactoryResolver = new dm(this);
								const a = T(r);
								this._bootstrapComponents = $o(a.bootstrap), this._r3Injector = Fg(r, o, [{
									provide: du,
									useValue: this
								}, {
									provide: zc,
									useValue: this.componentFactoryResolver
								}], Y(r), new Set(["environment"])), this._r3Injector.resolveInjectorInitializers(), this.instance = this._r3Injector.get(r)
							}
							get injector() {
								return this._r3Injector
							}
							destroy() {
								const r = this._r3Injector;
								!r.destroyed && r.destroy(), this.destroyCbs.forEach(o => o()), this.destroyCbs = null
							}
							onDestroy(r) {
								this.destroyCbs.push(r)
							}
						}
						class $m extends Bv {
							constructor(r) {
								super(), this.moduleType = r
							}
							create(r) {
								return new Hv(this.moduleType, r)
							}
						}
						class xC extends du {
							constructor(r, o, a) {
								super(), this.componentFactoryResolver = new dm(this), this.instance = null;
								const l = new cf([...r, {
									provide: du,
									useValue: this
								}, {
									provide: zc,
									useValue: this.componentFactoryResolver
								}], o || ci(), a, new Set(["environment"]));
								this.injector = l, l.resolveInjectorInitializers()
							}
							destroy() {
								this.injector.destroy()
							}
							onDestroy(r) {
								this.injector.onDestroy(r)
							}
						}

						function zm(n, r, o = null) {
							return new xC(n, r, o).injector
						}
						let FC = (() => {
							class n {
								constructor(o) {
									this._injector = o, this.cachedInjectors = new Map
								}
								getOrCreateStandaloneInjector(o) {
									if (!o.standalone) return null;
									if (!this.cachedInjectors.has(o.id)) {
										const a = hg(0, o.type),
											l = a.length > 0 ? zm([a], this._injector, `Standalone[${o.type.name}]`) : null;
										this.cachedInjectors.set(o.id, l)
									}
									return this.cachedInjectors.get(o.id)
								}
								ngOnDestroy() {
									try {
										for (const o of this.cachedInjectors.values()) null !== o && o.destroy()
									} finally {
										this.cachedInjectors.clear()
									}
								}
							}
							return n.\u0275prov = Qt({
								token: n,
								providedIn: "environment",
								factory: () => new n(B(mi))
							}), n
						})();

						function Gv(n) {
							n.getStandaloneInjector = r => r.get(FC).getOrCreateStandaloneInjector(n)
						}

						function Wv(n, r, o) {
							const a = Kr() + n,
								l = Ct();
							return l[a] === Ln ? li(l, a, o ? r.call(o) : r()) : Qc(l, a)
						}

						function qv(n, r, o, a) {
							return ey(Ct(), Kr(), n, r, o, a)
						}

						function Qv(n, r, o, a, l) {
							return function ty(n, r, o, a, l, d, _) {
								const w = r + o;
								return Mo(n, w, l, d) ? li(n, w + 2, _ ? a.call(_, l, d) : a(l, d)) : ih(n, w + 2)
							}(Ct(), Kr(), n, r, o, a, l)
						}

						function Jv(n, r, o, a, l, d) {
							return function ny(n, r, o, a, l, d, _, w) {
								const R = r + o;
								return function eu(n, r, o, a, l) {
									const d = Mo(n, r, o, a);
									return jr(n, r + 2, l) || d
								}(n, R, l, d, _) ? li(n, R + 3, w ? a.call(w, l, d, _) : a(l, d, _)) : ih(n, R + 3)
							}(Ct(), Kr(), n, r, o, a, l, d)
						}

						function Xv(n, r, o, a, l, d, _) {
							return function ry(n, r, o, a, l, d, _, w, R) {
								const j = r + o;
								return _i(n, j, l, d, _, w) ? li(n, j + 4, R ? a.call(R, l, d, _, w) : a(l, d, _, w)) : ih(n, j + 4)
							}(Ct(), Kr(), n, r, o, a, l, d, _)
						}

						function Zv(n, r, o, a, l, d, _, w) {
							const R = Kr() + n,
								j = Ct(),
								se = _i(j, R, o, a, l, d);
							return jr(j, R + 4, _) || se ? li(j, R + 5, w ? r.call(w, o, a, l, d, _) : r(o, a, l, d, _)) : Qc(j, R + 5)
						}

						function ih(n, r) {
							const o = n[r];
							return o === Ln ? void 0 : o
						}

						function ey(n, r, o, a, l, d) {
							const _ = r + o;
							return jr(n, _, l) ? li(n, _ + 1, d ? a.call(d, l) : a(l)) : ih(n, _ + 1)
						}

						function oy(n, r) {
							const o = Gn();
							let a;
							const l = n + Dt;
							o.firstCreatePass ? (a = function qC(n, r) {
								if (r)
									for (let o = r.length - 1; o >= 0; o--) {
										const a = r[o];
										if (n === a.name) return a
									}
							}(r, o.pipeRegistry), o.data[l] = a, a.onDestroy && (o.destroyHooks || (o.destroyHooks = [])).push(l, a.onDestroy)) : a = o.data[l];
							const d = a.factory || (a.factory = Qi(a.type)),
								_ = Nn(Qa);
							try {
								const w = Sa(!1),
									R = d();
								return Sa(w),
									function bm(n, r, o, a) {
										o >= n.data.length && (n.data[o] = null, n.blueprint[o] = null), r[o] = a
									}(o, Ct(), l, R), R
							} finally {
								Nn(_)
							}
						}

						function sy(n, r, o) {
							const a = n + Dt,
								l = Ct(),
								d = Ji(l, a);
							return function oh(n, r) {
								return n[K].data[r].pure
							}(l, a) ? ey(l, Kr(), r, d.transform, o, d) : d.transform(o)
						}

						function Ym(n) {
							return r => {
								setTimeout(n, void 0, r)
							}
						}
						const ws = class eS extends p.x {
							constructor(r = !1) {
								super(), this.__isAsync = r
							}
							emit(r) {
								super.next(r)
							}
							subscribe(r, o, a) {
								let l = r,
									d = o || (() => null),
									_ = a;
								if (r && "object" == typeof r) {
									const R = r;
									l = R.next?.bind(R), d = R.error?.bind(R), _ = R.complete?.bind(R)
								}
								this.__isAsync && (d = Ym(d), l && (l = Ym(l)), _ && (_ = Ym(_)));
								const w = super.subscribe({
									next: l,
									error: d,
									complete: _
								});
								return r instanceof y.w0 && r.add(w), w
							}
						};

						function tS() {
							return this._results[tc()]()
						}
						class Wm {
							get changes() {
								return this._changes || (this._changes = new ws)
							}
							constructor(r = !1) {
								this._emitDistinctChangesOnly = r, this.dirty = !0, this._results = [], this._changesDetected = !1, this._changes = null, this.length = 0, this.first = void 0, this.last = void 0;
								const o = tc(),
									a = Wm.prototype;
								a[o] || (a[o] = tS)
							}
							get(r) {
								return this._results[r]
							}
							map(r) {
								return this._results.map(r)
							}
							filter(r) {
								return this._results.filter(r)
							}
							find(r) {
								return this._results.find(r)
							}
							reduce(r, o) {
								return this._results.reduce(r, o)
							}
							forEach(r) {
								this._results.forEach(r)
							}
							some(r) {
								return this._results.some(r)
							}
							toArray() {
								return this._results.slice()
							}
							toString() {
								return this._results.toString()
							}
							reset(r, o) {
								const a = this;
								a.dirty = !1;
								const l = function v(n) {
									return n.flat(Number.POSITIVE_INFINITY)
								}(r);
								(this._changesDetected = ! function Pi(n, r, o) {
									if (n.length !== r.length) return !1;
									for (let a = 0; a < n.length; a++) {
										let l = n[a],
											d = r[a];
										if (o && (l = o(l), d = o(d)), d !== l) return !1
									}
									return !0
								}(a._results, l, o)) && (a._results = l, a.length = l.length, a.last = l[this.length - 1], a.first = l[0])
							}
							notifyOnChanges() {
								this._changes && (this._changesDetected || !this._emitDistinctChangesOnly) && this._changes.emit(this)
							}
							setDirty() {
								this.dirty = !0
							}
							destroy() {
								this.changes.complete(), this.changes.unsubscribe()
							}
						}
						let sh = (() => {
							class n {}
							return n.__NG_ELEMENT_ID__ = iS, n
						})();
						const nS = sh,
							rS = class extends nS {
								constructor(r, o, a) {
									super(), this._declarationLView = r, this._declarationTContainer = o, this.elementRef = a
								}
								createEmbeddedView(r, o) {
									const a = this._declarationTContainer.tViews,
										l = ms(this._declarationLView, a, r, 16, null, a.declTNode, null, null, null, null, o || null);
									l[Br] = this._declarationLView[this._declarationTContainer.index];
									const _ = this._declarationLView[tt];
									return null !== _ && (l[tt] = _.createEmbeddedView(a)), Ed(a, l, r), new ec(l)
								}
							};

						function iS() {
							return Cp(zr(), Ct())
						}

						function Cp(n, r) {
							return 4 & n.type ? new rS(r, n, Ka(n, r)) : null
						}
						let Sp = (() => {
							class n {}
							return n.__NG_ELEMENT_ID__ = oS, n
						})();

						function oS() {
							return ly(zr(), Ct())
						}
						const sS = Sp,
							ay = class extends sS {
								constructor(r, o, a) {
									super(), this._lContainer = r, this._hostTNode = o, this._hostLView = a
								}
								get element() {
									return Ka(this._hostTNode, this._hostLView)
								}
								get injector() {
									return new Lo(this._hostTNode, this._hostLView)
								}
								get parentInjector() {
									const r = Ir(this._hostTNode, this._hostLView);
									if (Co(r)) {
										const o = Sc(r, this._hostLView),
											a = So(r);
										return new Lo(o[K].data[a + 8], o)
									}
									return new Lo(null, this._hostLView)
								}
								clear() {
									for (; this.length > 0;) this.remove(this.length - 1)
								}
								get(r) {
									const o = cy(this._lContainer);
									return null !== o && o[r] || null
								}
								get length() {
									return this._lContainer.length - or
								}
								createEmbeddedView(r, o, a) {
									let l, d;
									"number" == typeof a ? l = a : null != a && (l = a.index, d = a.injector);
									const _ = r.createEmbeddedView(o || {}, d);
									return this.insert(_, l), _
								}
								createComponent(r, o, a, l, d) {
									const _ = r && ! function eo(n) {
										return "function" == typeof n
									}(r);
									let w;
									if (_) w = o;
									else {
										const ve = o || {};
										w = ve.index, a = ve.injector, l = ve.projectableNodes, d = ve.environmentInjector || ve.ngModuleRef
									}
									const R = _ ? r : new Jl(V(r)),
										j = a || this.parentInjector;
									if (!d && null == R.ngModule) {
										const $e = (_ ? j : this.parentInjector).get(mi, null);
										$e && (d = $e)
									}
									const se = R.create(j, l, void 0, d);
									return this.insert(se.hostView, w), se
								}
								insert(r, o) {
									const a = r._lView,
										l = a[K];
									if (function co(n) {
											return gr(n[ye])
										}(a)) {
										const se = this.indexOf(r);
										if (-1 !== se) this.detach(se);
										else {
											const ve = a[ye],
												$e = new ay(ve, ve[st], ve[ye]);
											$e.detach($e.indexOf(r))
										}
									}
									const d = this._adjustIndex(o),
										_ = this._lContainer;
									! function Mh(n, r, o, a) {
										const l = or + a,
											d = o.length;
										a > 0 && (o[l - 1][He] = r), a < d - or ? (r[He] = o[l], g(o, or + a, r)) : (o.push(r), r[He] = null), r[ye] = o;
										const _ = r[Br];
										null !== _ && o !== _ && function ls(n, r) {
											const o = n[$n];
											r[xn] !== r[ye][ye][xn] && (n[ir] = !0), null === o ? n[$n] = [r] : o.push(r)
										}(_, r);
										const w = r[tt];
										null !== w && w.insertView(n), r[he] |= 64
									}(l, a, _, d);
									const w = Fh(d, _),
										R = a[Ot],
										j = Ha(R, _[cr]);
									return null !== j && function qp(n, r, o, a, l, d) {
										a[L] = l, a[st] = r, no(n, a, o, 1, l, d)
									}(l, _[st], R, a, j, w), r.attachToViewContainerRef(), g(qm(_), d, r), r
								}
								move(r, o) {
									return this.insert(r, o)
								}
								indexOf(r) {
									const o = cy(this._lContainer);
									return null !== o ? o.indexOf(r) : -1
								}
								remove(r) {
									const o = this._adjustIndex(r, -1),
										a = La(this._lContainer, o);
									a && (b(qm(this._lContainer), o), Oh(a[K], a))
								}
								detach(r) {
									const o = this._adjustIndex(r, -1),
										a = La(this._lContainer, o);
									return a && null != b(qm(this._lContainer), o) ? new ec(a) : null
								}
								_adjustIndex(r, o = 0) {
									return r ?? this.length + o
								}
							};

						function cy(n) {
							return n[br]
						}

						function qm(n) {
							return n[br] || (n[br] = [])
						}

						function ly(n, r) {
							let o;
							const a = r[n.index];
							if (gr(a)) o = a;
							else {
								let l;
								if (8 & n.type) l = sr(a);
								else {
									const d = r[Ot];
									l = d.createComment("");
									const _ = kr(n, r);
									Ba(d, Ha(d, _), l, function kh(n, r) {
										return n.nextSibling(r)
									}(d, _), !1)
								}
								r[n.index] = o = sm(a, r, l, n), Kl(r, o)
							}
							return new ay(o, n, r)
						}
						class Qm {
							constructor(r) {
								this.queryList = r, this.matches = null
							}
							clone() {
								return new Qm(this.queryList)
							}
							setDirty() {
								this.queryList.setDirty()
							}
						}
						class Jm {
							constructor(r = []) {
								this.queries = r
							}
							createEmbeddedView(r) {
								const o = r.queries;
								if (null !== o) {
									const a = null !== r.contentQueries ? r.contentQueries[0] : o.length,
										l = [];
									for (let d = 0; d < a; d++) {
										const _ = o.getByIndex(d);
										l.push(this.queries[_.indexInDeclarationView].clone())
									}
									return new Jm(l)
								}
								return null
							}
							insertView(r) {
								this.dirtyQueriesWithMatches(r)
							}
							detachView(r) {
								this.dirtyQueriesWithMatches(r)
							}
							dirtyQueriesWithMatches(r) {
								for (let o = 0; o < this.queries.length; o++) null !== vy(r, o).matches && this.queries[o].setDirty()
							}
						}
						class uy {
							constructor(r, o, a = null) {
								this.predicate = r, this.flags = o, this.read = a
							}
						}
						class Xm {
							constructor(r = []) {
								this.queries = r
							}
							elementStart(r, o) {
								for (let a = 0; a < this.queries.length; a++) this.queries[a].elementStart(r, o)
							}
							elementEnd(r) {
								for (let o = 0; o < this.queries.length; o++) this.queries[o].elementEnd(r)
							}
							embeddedTView(r) {
								let o = null;
								for (let a = 0; a < this.length; a++) {
									const l = null !== o ? o.length : 0,
										d = this.getByIndex(a).embeddedTView(r, l);
									d && (d.indexInDeclarationView = a, null !== o ? o.push(d) : o = [d])
								}
								return null !== o ? new Xm(o) : null
							}
							template(r, o) {
								for (let a = 0; a < this.queries.length; a++) this.queries[a].template(r, o)
							}
							getByIndex(r) {
								return this.queries[r]
							}
							get length() {
								return this.queries.length
							}
							track(r) {
								this.queries.push(r)
							}
						}
						class Zm {
							constructor(r, o = -1) {
								this.metadata = r, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = o
							}
							elementStart(r, o) {
								this.isApplyingToNode(o) && this.matchTNode(r, o)
							}
							elementEnd(r) {
								this._declarationNodeIndex === r.index && (this._appliesToNextNode = !1)
							}
							template(r, o) {
								this.elementStart(r, o)
							}
							embeddedTView(r, o) {
								return this.isApplyingToNode(r) ? (this.crossesNgTemplate = !0, this.addMatch(-r.index, o), new Zm(this.metadata)) : null
							}
							isApplyingToNode(r) {
								if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) {
									const o = this._declarationNodeIndex;
									let a = r.parent;
									for (; null !== a && 8 & a.type && a.index !== o;) a = a.parent;
									return o === (null !== a ? a.index : -1)
								}
								return this._appliesToNextNode
							}
							matchTNode(r, o) {
								const a = this.metadata.predicate;
								if (Array.isArray(a))
									for (let l = 0; l < a.length; l++) {
										const d = a[l];
										this.matchTNodeWithReadOption(r, o, aS(o, d)), this.matchTNodeWithReadOption(r, o, Ia(o, r, d, !1, !1))
									} else a === sh ? 4 & o.type && this.matchTNodeWithReadOption(r, o, -1) : this.matchTNodeWithReadOption(r, o, Ia(o, r, a, !1, !1))
							}
							matchTNodeWithReadOption(r, o, a) {
								if (null !== a) {
									const l = this.metadata.read;
									if (null !== l)
										if (l === Kc || l === Sp || l === sh && 4 & o.type) this.addMatch(o.index, -2);
										else {
											const d = Ia(o, r, l, !1, !1);
											null !== d && this.addMatch(o.index, d)
										}
									else this.addMatch(o.index, a)
								}
							}
							addMatch(r, o) {
								null === this.matches ? this.matches = [r, o] : this.matches.push(r, o)
							}
						}

						function aS(n, r) {
							const o = n.localNames;
							if (null !== o)
								for (let a = 0; a < o.length; a += 2)
									if (o[a] === r) return o[a + 1];
							return null
						}

						function lS(n, r, o, a) {
							return -1 === o ? function cS(n, r) {
								return 11 & n.type ? Ka(n, r) : 4 & n.type ? Cp(n, r) : null
							}(r, n) : -2 === o ? function uS(n, r, o) {
								return o === Kc ? Ka(r, n) : o === sh ? Cp(r, n) : o === Sp ? ly(r, n) : void 0
							}(n, r, a) : Er(n, n[K], o, r)
						}

						function dy(n, r, o, a) {
							const l = r[tt].queries[a];
							if (null === l.matches) {
								const d = n.data,
									_ = o.matches,
									w = [];
								for (let R = 0; R < _.length; R += 2) {
									const j = _[R];
									w.push(j < 0 ? null : lS(r, d[j], _[R + 1], o.metadata.read))
								}
								l.matches = w
							}
							return l.matches
						}

						function e_(n, r, o, a) {
							const l = n.queries.getByIndex(o),
								d = l.matches;
							if (null !== d) {
								const _ = dy(n, r, l, o);
								for (let w = 0; w < d.length; w += 2) {
									const R = d[w];
									if (R > 0) a.push(_[w / 2]);
									else {
										const j = d[w + 1],
											se = r[-R];
										for (let ve = or; ve < se.length; ve++) {
											const $e = se[ve];
											$e[Br] === $e[ye] && e_($e[K], $e, j, a)
										}
										if (null !== se[$n]) {
											const ve = se[$n];
											for (let $e = 0; $e < ve.length; $e++) {
												const rt = ve[$e];
												e_(rt[K], rt, j, a)
											}
										}
									}
								}
							}
							return a
						}

						function hy(n) {
							const r = Ct(),
								o = Gn(),
								a = Eo();
							po(a + 1);
							const l = vy(o, a);
							if (n.dirty && function uc(n) {
									return 4 == (4 & n[he])
								}(r) === (2 == (2 & l.metadata.flags))) {
								if (null === l.matches) n.reset([]);
								else {
									const d = l.crossesNgTemplate ? e_(o, r, a, []) : dy(o, r, l, a);
									n.reset(d, fs), n.notifyOnChanges()
								}
								return !0
							}
							return !1
						}

						function fy(n, r, o) {
							const a = Gn();
							a.firstCreatePass && (_y(a, new uy(n, r, o), -1), 2 == (2 & r) && (a.staticViewQueries = !0)), my(a, Ct(), r)
						}

						function py(n, r, o, a) {
							const l = Gn();
							if (l.firstCreatePass) {
								const d = zr();
								_y(l, new uy(r, o, a), d.index),
									function hS(n, r) {
										const o = n.contentQueries || (n.contentQueries = []);
										r !== (o.length ? o[o.length - 1] : -1) && o.push(n.queries.length - 1, r)
									}(l, n), 2 == (2 & o) && (l.staticContentQueries = !0)
							}
							my(l, Ct(), o)
						}

						function gy() {
							return function dS(n, r) {
								return n[tt].queries[r].queryList
							}(Ct(), Eo())
						}

						function my(n, r, o) {
							const a = new Wm(4 == (4 & o));
							kf(n, r, a, a.destroy), null === r[tt] && (r[tt] = new Jm), r[tt].queries.push(new Qm(a))
						}

						function _y(n, r, o) {
							null === n.queries && (n.queries = new Xm), n.queries.track(new Zm(r, o))
						}

						function vy(n, r) {
							return n.queries.getByIndex(r)
						}

						function yy(n, r) {
							return Cp(n, r)
						}

						function wp(...n) {}
						const Uy = new mr("Application Initializer");
						let bp = (() => {
							class n {
								constructor(o) {
									this.appInits = o, this.resolve = wp, this.reject = wp, this.initialized = !1, this.done = !1, this.donePromise = new Promise((a, l) => {
										this.resolve = a, this.reject = l
									})
								}
								runInitializers() {
									if (this.initialized) return;
									const o = [],
										a = () => {
											this.done = !0, this.resolve()
										};
									if (this.appInits)
										for (let l = 0; l < this.appInits.length; l++) {
											const d = this.appInits[l]();
											if (Vd(d)) o.push(d);
											else if (iu(d)) {
												const _ = new Promise((w, R) => {
													d.subscribe({
														complete: w,
														error: R
													})
												});
												o.push(_)
											}
										}
									Promise.all(o).then(() => {
										a()
									}).catch(l => {
										this.reject(l)
									}), 0 === o.length && a(), this.initialized = !0
								}
							}
							return n.\u0275fac = function(o) {
								return new(o || n)(B(Uy, 8))
							}, n.\u0275prov = Qt({
								token: n,
								factory: n.\u0275fac,
								providedIn: "root"
							}), n
						})();
						const By = new mr("AppId", {
							providedIn: "root",
							factory: function Hy() {
								return `${o_()}${o_()}${o_()}`
							}
						});

						function o_() {
							return String.fromCharCode(97 + Math.floor(25 * Math.random()))
						}
						const Gy = new mr("Platform Initializer"),
							PS = new mr("Platform ID", {
								providedIn: "platform",
								factory: () => "unknown"
							}),
							jy = new mr("appBootstrapListener"),
							NS = new mr("AnimationModuleType");
						let kS = (() => {
							class n {
								log(o) {
									console.log(o)
								}
								warn(o) {
									console.warn(o)
								}
							}
							return n.\u0275fac = function(o) {
								return new(o || n)
							}, n.\u0275prov = Qt({
								token: n,
								factory: n.\u0275fac,
								providedIn: "platform"
							}), n
						})();
						const Ip = new mr("LocaleId", {
								providedIn: "root",
								factory: () => k(Ip, en.Optional | en.SkipSelf) || function xS() {
									return typeof $localize < "u" && $localize.locale || uu
								}()
							}),
							FS = new mr("DefaultCurrencyCode", {
								providedIn: "root",
								factory: () => "USD"
							});
						class LS {
							constructor(r, o) {
								this.ngModuleFactory = r, this.componentFactories = o
							}
						}
						let US = (() => {
							class n {
								compileModuleSync(o) {
									return new $m(o)
								}
								compileModuleAsync(o) {
									return Promise.resolve(this.compileModuleSync(o))
								}
								compileModuleAndAllComponentsSync(o) {
									const a = this.compileModuleSync(o),
										d = $o(T(o).declarations).reduce((_, w) => {
											const R = V(w);
											return R && _.push(new Jl(R)), _
										}, []);
									return new LS(a, d)
								}
								compileModuleAndAllComponentsAsync(o) {
									return Promise.resolve(this.compileModuleAndAllComponentsSync(o))
								}
								clearCache() {}
								clearCacheFor(o) {}
								getModuleId(o) {}
							}
							return n.\u0275fac = function(o) {
								return new(o || n)
							}, n.\u0275prov = Qt({
								token: n,
								factory: n.\u0275fac,
								providedIn: "root"
							}), n
						})();
						const GS = (() => Promise.resolve(0))();

						function s_(n) {
							typeof Zone > "u" ? GS.then(() => {
								n && n.apply(null, null)
							}) : Zone.current.scheduleMicroTask("scheduleMicrotask", n)
						}
						class Po {
							constructor({
								enableLongStackTrace: r = !1,
								shouldCoalesceEventChangeDetection: o = !1,
								shouldCoalesceRunChangeDetection: a = !1
							}) {
								if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new ws(!1), this.onMicrotaskEmpty = new ws(!1), this.onStable = new ws(!1), this.onError = new ws(!1), typeof Zone > "u") throw new Le(908, !1);
								Zone.assertZonePatched();
								const l = this;
								l._nesting = 0, l._outer = l._inner = Zone.current, Zone.TaskTrackingZoneSpec && (l._inner = l._inner.fork(new Zone.TaskTrackingZoneSpec)), r && Zone.longStackTraceZoneSpec && (l._inner = l._inner.fork(Zone.longStackTraceZoneSpec)), l.shouldCoalesceEventChangeDetection = !a && o, l.shouldCoalesceRunChangeDetection = a, l.lastRequestAnimationFrameId = -1, l.nativeRequestAnimationFrame = function jS() {
										let n = un.requestAnimationFrame,
											r = un.cancelAnimationFrame;
										if (typeof Zone < "u" && n && r) {
											const o = n[Zone.__symbol__("OriginalDelegate")];
											o && (n = o);
											const a = r[Zone.__symbol__("OriginalDelegate")];
											a && (r = a)
										}
										return {
											nativeRequestAnimationFrame: n,
											nativeCancelAnimationFrame: r
										}
									}().nativeRequestAnimationFrame,
									function zS(n) {
										const r = () => {
											! function $S(n) {
												n.isCheckStableRunning || -1 !== n.lastRequestAnimationFrameId || (n.lastRequestAnimationFrameId = n.nativeRequestAnimationFrame.call(un, () => {
													n.fakeTopEventTask || (n.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => {
														n.lastRequestAnimationFrameId = -1, c_(n), n.isCheckStableRunning = !0, a_(n), n.isCheckStableRunning = !1
													}, void 0, () => {}, () => {})), n.fakeTopEventTask.invoke()
												}), c_(n))
											}(n)
										};
										n._inner = n._inner.fork({
											name: "angular",
											properties: {
												isAngularZone: !0
											},
											onInvokeTask: (o, a, l, d, _, w) => {
												try {
													return zy(n), o.invokeTask(l, d, _, w)
												} finally {
													(n.shouldCoalesceEventChangeDetection && "eventTask" === d.type || n.shouldCoalesceRunChangeDetection) && r(), Ky(n)
												}
											},
											onInvoke: (o, a, l, d, _, w, R) => {
												try {
													return zy(n), o.invoke(l, d, _, w, R)
												} finally {
													n.shouldCoalesceRunChangeDetection && r(), Ky(n)
												}
											},
											onHasTask: (o, a, l, d) => {
												o.hasTask(l, d), a === l && ("microTask" == d.change ? (n._hasPendingMicrotasks = d.microTask, c_(n), a_(n)) : "macroTask" == d.change && (n.hasPendingMacrotasks = d.macroTask))
											},
											onHandleError: (o, a, l, d) => (o.handleError(l, d), n.runOutsideAngular(() => n.onError.emit(d)), !1)
										})
									}(l)
							}
							static isInAngularZone() {
								return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone")
							}
							static assertInAngularZone() {
								if (!Po.isInAngularZone()) throw new Le(909, !1)
							}
							static assertNotInAngularZone() {
								if (Po.isInAngularZone()) throw new Le(909, !1)
							}
							run(r, o, a) {
								return this._inner.run(r, o, a)
							}
							runTask(r, o, a, l) {
								const d = this._inner,
									_ = d.scheduleEventTask("NgZoneEvent: " + l, r, VS, wp, wp);
								try {
									return d.runTask(_, o, a)
								} finally {
									d.cancelTask(_)
								}
							}
							runGuarded(r, o, a) {
								return this._inner.runGuarded(r, o, a)
							}
							runOutsideAngular(r) {
								return this._outer.run(r)
							}
						}
						const VS = {};

						function a_(n) {
							if (0 == n._nesting && !n.hasPendingMicrotasks && !n.isStable) try {
								n._nesting++, n.onMicrotaskEmpty.emit(null)
							} finally {
								if (n._nesting--, !n.hasPendingMicrotasks) try {
									n.runOutsideAngular(() => n.onStable.emit(null))
								} finally {
									n.isStable = !0
								}
							}
						}

						function c_(n) {
							n.hasPendingMicrotasks = !!(n._hasPendingMicrotasks || (n.shouldCoalesceEventChangeDetection || n.shouldCoalesceRunChangeDetection) && -1 !== n.lastRequestAnimationFrameId)
						}

						function zy(n) {
							n._nesting++, n.isStable && (n.isStable = !1, n.onUnstable.emit(null))
						}

						function Ky(n) {
							n._nesting--, a_(n)
						}
						class KS {
							constructor() {
								this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new ws, this.onMicrotaskEmpty = new ws, this.onStable = new ws, this.onError = new ws
							}
							run(r, o, a) {
								return r.apply(o, a)
							}
							runGuarded(r, o, a) {
								return r.apply(o, a)
							}
							runOutsideAngular(r) {
								return r()
							}
							runTask(r, o, a, l) {
								return r.apply(o, a)
							}
						}
						const Yy = new mr(""),
							Wy = new mr("");
						let l_, YS = (() => {
								class n {
									constructor(o, a, l) {
										this._ngZone = o, this.registry = a, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, l_ || (function WS(n) {
											l_ = n
										}(l), l.addToWindow(a)), this._watchAngularEvents(), o.run(() => {
											this.taskTrackingZone = typeof Zone > "u" ? null : Zone.current.get("TaskTrackingZone")
										})
									}
									_watchAngularEvents() {
										this._ngZone.onUnstable.subscribe({
											next: () => {
												this._didWork = !0, this._isZoneStable = !1
											}
										}), this._ngZone.runOutsideAngular(() => {
											this._ngZone.onStable.subscribe({
												next: () => {
													Po.assertNotInAngularZone(), s_(() => {
														this._isZoneStable = !0, this._runCallbacksIfReady()
													})
												}
											})
										})
									}
									increasePendingRequestCount() {
										return this._pendingCount += 1, this._didWork = !0, this._pendingCount
									}
									decreasePendingRequestCount() {
										if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero");
										return this._runCallbacksIfReady(), this._pendingCount
									}
									isStable() {
										return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks
									}
									_runCallbacksIfReady() {
										if (this.isStable()) s_(() => {
											for (; 0 !== this._callbacks.length;) {
												let o = this._callbacks.pop();
												clearTimeout(o.timeoutId), o.doneCb(this._didWork)
											}
											this._didWork = !1
										});
										else {
											let o = this.getPendingTasks();
											this._callbacks = this._callbacks.filter(a => !a.updateCb || !a.updateCb(o) || (clearTimeout(a.timeoutId), !1)), this._didWork = !0
										}
									}
									getPendingTasks() {
										return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(o => ({
											source: o.source,
											creationLocation: o.creationLocation,
											data: o.data
										})) : []
									}
									addCallback(o, a, l) {
										let d = -1;
										a && a > 0 && (d = setTimeout(() => {
											this._callbacks = this._callbacks.filter(_ => _.timeoutId !== d), o(this._didWork, this.getPendingTasks())
										}, a)), this._callbacks.push({
											doneCb: o,
											timeoutId: d,
											updateCb: l
										})
									}
									whenStable(o, a, l) {
										if (l && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');
										this.addCallback(o, a, l), this._runCallbacksIfReady()
									}
									getPendingRequestCount() {
										return this._pendingCount
									}
									registerApplication(o) {
										this.registry.registerApplication(o, this)
									}
									unregisterApplication(o) {
										this.registry.unregisterApplication(o)
									}
									findProviders(o, a, l) {
										return []
									}
								}
								return n.\u0275fac = function(o) {
									return new(o || n)(B(Po), B(qy), B(Wy))
								}, n.\u0275prov = Qt({
									token: n,
									factory: n.\u0275fac
								}), n
							})(),
							qy = (() => {
								class n {
									constructor() {
										this._applications = new Map
									}
									registerApplication(o, a) {
										this._applications.set(o, a)
									}
									unregisterApplication(o) {
										this._applications.delete(o)
									}
									unregisterAllApplications() {
										this._applications.clear()
									}
									getTestability(o) {
										return this._applications.get(o) || null
									}
									getAllTestabilities() {
										return Array.from(this._applications.values())
									}
									getAllRootElements() {
										return Array.from(this._applications.keys())
									}
									findTestabilityInTree(o, a = !0) {
										return l_?.findTestabilityInTree(this, o, a) ?? null
									}
								}
								return n.\u0275fac = function(o) {
									return new(o || n)
								}, n.\u0275prov = Qt({
									token: n,
									factory: n.\u0275fac,
									providedIn: "platform"
								}), n
							})(),
							sc = null;
						const Qy = new mr("AllowMultipleToken"),
							u_ = new mr("PlatformDestroyListeners"),
							ra = !1;
						class JS {
							constructor(r, o) {
								this.name = r, this.token = o
							}
						}

						function Xy(n, r, o = []) {
							const a = `Platform: ${r}`,
								l = new mr(a);
							return (d = []) => {
								let _ = d_();
								if (!_ || _.injector.get(Qy, !1)) {
									const w = [...o, ...d, {
										provide: l,
										useValue: !0
									}];
									n ? n(w) : function XS(n) {
										if (sc && !sc.get(Qy, !1)) throw new Le(400, !1);
										sc = n;
										const r = n.get(eE);
										(function Jy(n) {
											const r = n.get(Gy, null);
											r && r.forEach(o => o())
										})(n)
									}(function Zy(n = [], r) {
										return Wa.create({
											name: r,
											providers: [{
												provide: Vo,
												useValue: "platform"
											}, {
												provide: u_,
												useValue: new Set([() => sc = null])
											}, ...n]
										})
									}(w, a))
								}
								return function eT(n) {
									const r = d_();
									if (!r) throw new Le(401, !1);
									return r
								}()
							}
						}

						function d_() {
							return sc?.get(eE) ?? null
						}
						let eE = (() => {
							class n {
								constructor(o) {
									this._injector = o, this._modules = [], this._destroyListeners = [], this._destroyed = !1
								}
								bootstrapModuleFactory(o, a) {
									const l = function nE(n, r) {
											let o;
											return o = "noop" === n ? new KS : ("zone.js" === n ? void 0 : n) || new Po(r), o
										}(a?.ngZone, function tE(n) {
											return {
												enableLongStackTrace: !1,
												shouldCoalesceEventChangeDetection: !(!n || !n.ngZoneEventCoalescing) || !1,
												shouldCoalesceRunChangeDetection: !(!n || !n.ngZoneRunCoalescing) || !1
											}
										}(a)),
										d = [{
											provide: Po,
											useValue: l
										}];
									return l.run(() => {
										const _ = Wa.create({
												providers: d,
												parent: this.injector,
												name: o.moduleType.name
											}),
											w = o.create(_),
											R = w.injector.get(Ks, null);
										if (!R) throw new Le(402, !1);
										return l.runOutsideAngular(() => {
												const j = l.onError.subscribe({
													next: se => {
														R.handleError(se)
													}
												});
												w.onDestroy(() => {
													Ap(this._modules, w), j.unsubscribe()
												})
											}),
											function rE(n, r, o) {
												try {
													const a = o();
													return Vd(a) ? a.catch(l => {
														throw r.runOutsideAngular(() => n.handleError(l)), l
													}) : a
												} catch (a) {
													throw r.runOutsideAngular(() => n.handleError(a)), a
												}
											}(R, l, () => {
												const j = w.injector.get(bp);
												return j.runInitializers(), j.donePromise.then(() => (function fv(n) {
													Pe(n, "Expected localeId to be defined"), "string" == typeof n && (hv = n.toLowerCase().replace(/_/g, "-"))
												}(w.injector.get(Ip, uu) || uu), this._moduleDoBootstrap(w), w))
											})
									})
								}
								bootstrapModule(o, a = []) {
									const l = iE({}, a);
									return function qS(n, r, o) {
										const a = new $m(o);
										return Promise.resolve(a)
									}(0, 0, o).then(d => this.bootstrapModuleFactory(d, l))
								}
								_moduleDoBootstrap(o) {
									const a = o.injector.get(Dp);
									if (o._bootstrapComponents.length > 0) o._bootstrapComponents.forEach(l => a.bootstrap(l));
									else {
										if (!o.instance.ngDoBootstrap) throw new Le(-403, !1);
										o.instance.ngDoBootstrap(a)
									}
									this._modules.push(o)
								}
								onDestroy(o) {
									this._destroyListeners.push(o)
								}
								get injector() {
									return this._injector
								}
								destroy() {
									if (this._destroyed) throw new Le(404, !1);
									this._modules.slice().forEach(a => a.destroy()), this._destroyListeners.forEach(a => a());
									const o = this._injector.get(u_, null);
									o && (o.forEach(a => a()), o.clear()), this._destroyed = !0
								}
								get destroyed() {
									return this._destroyed
								}
							}
							return n.\u0275fac = function(o) {
								return new(o || n)(B(Wa))
							}, n.\u0275prov = Qt({
								token: n,
								factory: n.\u0275fac,
								providedIn: "platform"
							}), n
						})();

						function iE(n, r) {
							return Array.isArray(r) ? r.reduce(iE, n) : {
								...n,
								...r
							}
						}
						let Dp = (() => {
							class n {
								get destroyed() {
									return this._destroyed
								}
								get injector() {
									return this._injector
								}
								constructor(o, a, l) {
									this._zone = o, this._injector = a, this._exceptionHandler = l, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this._destroyed = !1, this._destroyListeners = [], this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({
										next: () => {
											this._zone.run(() => {
												this.tick()
											})
										}
									});
									const d = new D.y(w => {
											this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => {
												w.next(this._stable), w.complete()
											})
										}),
										_ = new D.y(w => {
											let R;
											this._zone.runOutsideAngular(() => {
												R = this._zone.onStable.subscribe(() => {
													Po.assertNotInAngularZone(), s_(() => {
														!this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks && (this._stable = !0, w.next(!0))
													})
												})
											});
											const j = this._zone.onUnstable.subscribe(() => {
												Po.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => {
													w.next(!1)
												}))
											});
											return () => {
												R.unsubscribe(), j.unsubscribe()
											}
										});
									this.isStable = (0, z.T)(d, _.pipe((0, ee.B)()))
								}
								bootstrap(o, a) {
									const l = o instanceof df;
									if (!this._injector.get(bp).done) {
										!l && f(o);
										throw new Le(405, ra)
									}
									let _;
									_ = l ? o : this._injector.get(zc).resolveComponentFactory(o), this.componentTypes.push(_.componentType);
									const w = function QS(n) {
											return n.isBoundToModule
										}(_) ? void 0 : this._injector.get(du),
										j = _.create(Wa.NULL, [], a || _.selector, w),
										se = j.location.nativeElement,
										ve = j.injector.get(Yy, null);
									return ve?.registerApplication(se), j.onDestroy(() => {
										this.detachView(j.hostView), Ap(this.components, j), ve?.unregisterApplication(se)
									}), this._loadComponent(j), j
								}
								tick() {
									if (this._runningTick) throw new Le(101, !1);
									try {
										this._runningTick = !0;
										for (let o of this._views) o.detectChanges()
									} catch (o) {
										this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(o))
									} finally {
										this._runningTick = !1
									}
								}
								attachView(o) {
									const a = o;
									this._views.push(a), a.attachToAppRef(this)
								}
								detachView(o) {
									const a = o;
									Ap(this._views, a), a.detachFromAppRef()
								}
								_loadComponent(o) {
									this.attachView(o.hostView), this.tick(), this.components.push(o);
									const a = this._injector.get(jy, []);
									a.push(...this._bootstrapListeners), a.forEach(l => l(o))
								}
								ngOnDestroy() {
									if (!this._destroyed) try {
										this._destroyListeners.forEach(o => o()), this._views.slice().forEach(o => o.destroy()), this._onMicrotaskEmptySubscription.unsubscribe()
									} finally {
										this._destroyed = !0, this._views = [], this._bootstrapListeners = [], this._destroyListeners = []
									}
								}
								onDestroy(o) {
									return this._destroyListeners.push(o), () => Ap(this._destroyListeners, o)
								}
								destroy() {
									if (this._destroyed) throw new Le(406, !1);
									const o = this._injector;
									o.destroy && !o.destroyed && o.destroy()
								}
								get viewCount() {
									return this._views.length
								}
								warnIfDestroyed() {}
							}
							return n.\u0275fac = function(o) {
								return new(o || n)(B(Po), B(mi), B(Ks))
							}, n.\u0275prov = Qt({
								token: n,
								factory: n.\u0275fac,
								providedIn: "root"
							}), n
						})();

						function Ap(n, r) {
							const o = n.indexOf(r);
							o > -1 && n.splice(o, 1)
						}

						function nT() {
							return !1
						}
						let rT = (() => {
							class n {}
							return n.__NG_ELEMENT_ID__ = iT, n
						})();

						function iT(n) {
							return function oT(n, r, o) {
								if (ni(n) && !o) {
									const a = di(n.index, r);
									return new ec(a, a)
								}
								return 47 & n.type ? new ec(r[xn], r) : null
							}(zr(), Ct(), 16 == (16 & n))
						}
						class lE {
							constructor() {}
							supports(r) {
								return xd(r)
							}
							create(r) {
								return new dT(r)
							}
						}
						const uT = (n, r) => r;
						class dT {
							constructor(r) {
								this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = r || uT
							}
							forEachItem(r) {
								let o;
								for (o = this._itHead; null !== o; o = o._next) r(o)
							}
							forEachOperation(r) {
								let o = this._itHead,
									a = this._removalsHead,
									l = 0,
									d = null;
								for (; o || a;) {
									const _ = !a || o && o.currentIndex < dE(a, l, d) ? o : a,
										w = dE(_, l, d),
										R = _.currentIndex;
									if (_ === a) l--, a = a._nextRemoved;
									else if (o = o._next, null == _.previousIndex) l++;
									else {
										d || (d = []);
										const j = w - l,
											se = R - l;
										if (j != se) {
											for (let $e = 0; $e < j; $e++) {
												const rt = $e < d.length ? d[$e] : d[$e] = 0,
													At = rt + $e;
												se <= At && At < j && (d[$e] = rt + 1)
											}
											d[_.previousIndex] = se - j
										}
									}
									w !== R && r(_, w, R)
								}
							}
							forEachPreviousItem(r) {
								let o;
								for (o = this._previousItHead; null !== o; o = o._nextPrevious) r(o)
							}
							forEachAddedItem(r) {
								let o;
								for (o = this._additionsHead; null !== o; o = o._nextAdded) r(o)
							}
							forEachMovedItem(r) {
								let o;
								for (o = this._movesHead; null !== o; o = o._nextMoved) r(o)
							}
							forEachRemovedItem(r) {
								let o;
								for (o = this._removalsHead; null !== o; o = o._nextRemoved) r(o)
							}
							forEachIdentityChange(r) {
								let o;
								for (o = this._identityChangesHead; null !== o; o = o._nextIdentityChange) r(o)
							}
							diff(r) {
								if (null == r && (r = []), !xd(r)) throw new Le(900, !1);
								return this.check(r) ? this : null
							}
							onDestroy() {}
							check(r) {
								this._reset();
								let l, d, _, o = this._itHead,
									a = !1;
								if (Array.isArray(r)) {
									this.length = r.length;
									for (let w = 0; w < this.length; w++) d = r[w], _ = this._trackByFn(w, d), null !== o && Object.is(o.trackById, _) ? (a && (o = this._verifyReinsertion(o, d, _, w)), Object.is(o.item, d) || this._addIdentityChange(o, d)) : (o = this._mismatch(o, d, _, w), a = !0), o = o._next
								} else l = 0,
									function Tm(n, r) {
										if (Array.isArray(n))
											for (let o = 0; o < n.length; o++) r(n[o]);
										else {
											const o = n[tc()]();
											let a;
											for (; !(a = o.next()).done;) r(a.value)
										}
									}(r, w => {
										_ = this._trackByFn(l, w), null !== o && Object.is(o.trackById, _) ? (a && (o = this._verifyReinsertion(o, w, _, l)), Object.is(o.item, w) || this._addIdentityChange(o, w)) : (o = this._mismatch(o, w, _, l), a = !0), o = o._next, l++
									}), this.length = l;
								return this._truncate(o), this.collection = r, this.isDirty
							}
							get isDirty() {
								return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead
							}
							_reset() {
								if (this.isDirty) {
									let r;
									for (r = this._previousItHead = this._itHead; null !== r; r = r._next) r._nextPrevious = r._next;
									for (r = this._additionsHead; null !== r; r = r._nextAdded) r.previousIndex = r.currentIndex;
									for (this._additionsHead = this._additionsTail = null, r = this._movesHead; null !== r; r = r._nextMoved) r.previousIndex = r.currentIndex;
									this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null
								}
							}
							_mismatch(r, o, a, l) {
								let d;
								return null === r ? d = this._itTail : (d = r._prev, this._remove(r)), null !== (r = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(a, null)) ? (Object.is(r.item, o) || this._addIdentityChange(r, o), this._reinsertAfter(r, d, l)) : null !== (r = null === this._linkedRecords ? null : this._linkedRecords.get(a, l)) ? (Object.is(r.item, o) || this._addIdentityChange(r, o), this._moveAfter(r, d, l)) : r = this._addAfter(new hT(o, a), d, l), r
							}
							_verifyReinsertion(r, o, a, l) {
								let d = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(a, null);
								return null !== d ? r = this._reinsertAfter(d, r._prev, l) : r.currentIndex != l && (r.currentIndex = l, this._addToMoves(r, l)), r
							}
							_truncate(r) {
								for (; null !== r;) {
									const o = r._next;
									this._addToRemovals(this._unlink(r)), r = o
								}
								null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null)
							}
							_reinsertAfter(r, o, a) {
								null !== this._unlinkedRecords && this._unlinkedRecords.remove(r);
								const l = r._prevRemoved,
									d = r._nextRemoved;
								return null === l ? this._removalsHead = d : l._nextRemoved = d, null === d ? this._removalsTail = l : d._prevRemoved = l, this._insertAfter(r, o, a), this._addToMoves(r, a), r
							}
							_moveAfter(r, o, a) {
								return this._unlink(r), this._insertAfter(r, o, a), this._addToMoves(r, a), r
							}
							_addAfter(r, o, a) {
								return this._insertAfter(r, o, a), this._additionsTail = null === this._additionsTail ? this._additionsHead = r : this._additionsTail._nextAdded = r, r
							}
							_insertAfter(r, o, a) {
								const l = null === o ? this._itHead : o._next;
								return r._next = l, r._prev = o, null === l ? this._itTail = r : l._prev = r, null === o ? this._itHead = r : o._next = r, null === this._linkedRecords && (this._linkedRecords = new uE), this._linkedRecords.put(r), r.currentIndex = a, r
							}
							_remove(r) {
								return this._addToRemovals(this._unlink(r))
							}
							_unlink(r) {
								null !== this._linkedRecords && this._linkedRecords.remove(r);
								const o = r._prev,
									a = r._next;
								return null === o ? this._itHead = a : o._next = a, null === a ? this._itTail = o : a._prev = o, r
							}
							_addToMoves(r, o) {
								return r.previousIndex === o || (this._movesTail = null === this._movesTail ? this._movesHead = r : this._movesTail._nextMoved = r), r
							}
							_addToRemovals(r) {
								return null === this._unlinkedRecords && (this._unlinkedRecords = new uE), this._unlinkedRecords.put(r), r.currentIndex = null, r._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = r, r._prevRemoved = null) : (r._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = r), r
							}
							_addIdentityChange(r, o) {
								return r.item = o, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = r : this._identityChangesTail._nextIdentityChange = r, r
							}
						}
						class hT {
							constructor(r, o) {
								this.item = r, this.trackById = o, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null
							}
						}
						class fT {
							constructor() {
								this._head = null, this._tail = null
							}
							add(r) {
								null === this._head ? (this._head = this._tail = r, r._nextDup = null, r._prevDup = null) : (this._tail._nextDup = r, r._prevDup = this._tail, r._nextDup = null, this._tail = r)
							}
							get(r, o) {
								let a;
								for (a = this._head; null !== a; a = a._nextDup)
									if ((null === o || o <= a.currentIndex) && Object.is(a.trackById, r)) return a;
								return null
							}
							remove(r) {
								const o = r._prevDup,
									a = r._nextDup;
								return null === o ? this._head = a : o._nextDup = a, null === a ? this._tail = o : a._prevDup = o, null === this._head
							}
						}
						class uE {
							constructor() {
								this.map = new Map
							}
							put(r) {
								const o = r.trackById;
								let a = this.map.get(o);
								a || (a = new fT, this.map.set(o, a)), a.add(r)
							}
							get(r, o) {
								const l = this.map.get(r);
								return l ? l.get(r, o) : null
							}
							remove(r) {
								const o = r.trackById;
								return this.map.get(o).remove(r) && this.map.delete(o), r
							}
							get isEmpty() {
								return 0 === this.map.size
							}
							clear() {
								this.map.clear()
							}
						}

						function dE(n, r, o) {
							const a = n.previousIndex;
							if (null === a) return a;
							let l = 0;
							return o && a < o.length && (l = o[a]), a + r + l
						}
						class hE {
							constructor() {}
							supports(r) {
								return r instanceof Map || Fd(r)
							}
							create() {
								return new pT
							}
						}
						class pT {
							constructor() {
								this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null
							}
							get isDirty() {
								return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead
							}
							forEachItem(r) {
								let o;
								for (o = this._mapHead; null !== o; o = o._next) r(o)
							}
							forEachPreviousItem(r) {
								let o;
								for (o = this._previousMapHead; null !== o; o = o._nextPrevious) r(o)
							}
							forEachChangedItem(r) {
								let o;
								for (o = this._changesHead; null !== o; o = o._nextChanged) r(o)
							}
							forEachAddedItem(r) {
								let o;
								for (o = this._additionsHead; null !== o; o = o._nextAdded) r(o)
							}
							forEachRemovedItem(r) {
								let o;
								for (o = this._removalsHead; null !== o; o = o._nextRemoved) r(o)
							}
							diff(r) {
								if (r) {
									if (!(r instanceof Map || Fd(r))) throw new Le(900, !1)
								} else r = new Map;
								return this.check(r) ? this : null
							}
							onDestroy() {}
							check(r) {
								this._reset();
								let o = this._mapHead;
								if (this._appendAfter = null, this._forEach(r, (a, l) => {
										if (o && o.key === l) this._maybeAddToChanges(o, a), this._appendAfter = o, o = o._next;
										else {
											const d = this._getOrCreateRecordForKey(l, a);
											o = this._insertBeforeOrAppend(o, d)
										}
									}), o) {
									o._prev && (o._prev._next = null), this._removalsHead = o;
									for (let a = o; null !== a; a = a._nextRemoved) a === this._mapHead && (this._mapHead = null), this._records.delete(a.key), a._nextRemoved = a._next, a.previousValue = a.currentValue, a.currentValue = null, a._prev = null, a._next = null
								}
								return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty
							}
							_insertBeforeOrAppend(r, o) {
								if (r) {
									const a = r._prev;
									return o._next = r, o._prev = a, r._prev = o, a && (a._next = o), r === this._mapHead && (this._mapHead = o), this._appendAfter = r, r
								}
								return this._appendAfter ? (this._appendAfter._next = o, o._prev = this._appendAfter) : this._mapHead = o, this._appendAfter = o, null
							}
							_getOrCreateRecordForKey(r, o) {
								if (this._records.has(r)) {
									const l = this._records.get(r);
									this._maybeAddToChanges(l, o);
									const d = l._prev,
										_ = l._next;
									return d && (d._next = _), _ && (_._prev = d), l._next = null, l._prev = null, l
								}
								const a = new gT(r);
								return this._records.set(r, a), a.currentValue = o, this._addToAdditions(a), a
							}
							_reset() {
								if (this.isDirty) {
									let r;
									for (this._previousMapHead = this._mapHead, r = this._previousMapHead; null !== r; r = r._next) r._nextPrevious = r._next;
									for (r = this._changesHead; null !== r; r = r._nextChanged) r.previousValue = r.currentValue;
									for (r = this._additionsHead; null != r; r = r._nextAdded) r.previousValue = r.currentValue;
									this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null
								}
							}
							_maybeAddToChanges(r, o) {
								Object.is(o, r.currentValue) || (r.previousValue = r.currentValue, r.currentValue = o, this._addToChanges(r))
							}
							_addToAdditions(r) {
								null === this._additionsHead ? this._additionsHead = this._additionsTail = r : (this._additionsTail._nextAdded = r, this._additionsTail = r)
							}
							_addToChanges(r) {
								null === this._changesHead ? this._changesHead = this._changesTail = r : (this._changesTail._nextChanged = r, this._changesTail = r)
							}
							_forEach(r, o) {
								r instanceof Map ? r.forEach(o) : Object.keys(r).forEach(a => o(r[a], a))
							}
						}
						class gT {
							constructor(r) {
								this.key = r, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null
							}
						}

						function fE() {
							return new m_([new lE])
						}
						let m_ = (() => {
							class n {
								constructor(o) {
									this.factories = o
								}
								static create(o, a) {
									if (null != a) {
										const l = a.factories.slice();
										o = o.concat(l)
									}
									return new n(o)
								}
								static extend(o) {
									return {
										provide: n,
										useFactory: a => n.create(o, a || fE()),
										deps: [
											[n, new Ra, new Io]
										]
									}
								}
								find(o) {
									const a = this.factories.find(l => l.supports(o));
									if (null != a) return a;
									throw new Le(901, !1)
								}
							}
							return n.\u0275prov = Qt({
								token: n,
								providedIn: "root",
								factory: fE
							}), n
						})();

						function pE() {
							return new __([new hE])
						}
						let __ = (() => {
							class n {
								constructor(o) {
									this.factories = o
								}
								static create(o, a) {
									if (a) {
										const l = a.factories.slice();
										o = o.concat(l)
									}
									return new n(o)
								}
								static extend(o) {
									return {
										provide: n,
										useFactory: a => n.create(o, a || pE()),
										deps: [
											[n, new Ra, new Io]
										]
									}
								}
								find(o) {
									const a = this.factories.find(l => l.supports(o));
									if (a) return a;
									throw new Le(901, !1)
								}
							}
							return n.\u0275prov = Qt({
								token: n,
								providedIn: "root",
								factory: pE
							}), n
						})();
						const vT = Xy(null, "core", []);
						let yT = (() => {
							class n {
								constructor(o) {}
							}
							return n.\u0275fac = function(o) {
								return new(o || n)(B(Dp))
							}, n.\u0275mod = ti({
								type: n
							}), n.\u0275inj = Sn({}), n
						})();

						function ET(n) {
							return "boolean" == typeof n ? n : null != n && "false" !== n
						}
					}, 2051: (be, ue, E) => {
						E.d(ue, {
							BQ: () => F,
							wG: () => Qn,
							si: () => Wn,
							pj: () => Ge,
							Kr: () => ft,
							Id: () => ke
						});
						var p = E(3991),
							y = E(7838),
							D = E(8793),
							ee = E(7774),
							P = E(1329),
							N = E(5903);
						const Ce = new p.OlP("mat-sanity-checks", {
							providedIn: "root",
							factory: function je() {
								return !0
							}
						});
						let F = (() => {
							class ct {
								constructor(B, J, k) {
									this._sanityChecks = J, this._document = k, this._hasDoneGlobalChecks = !1, B._applyBodyHighContrastModeCssClasses(), this._hasDoneGlobalChecks || (this._hasDoneGlobalChecks = !0)
								}
								_checkIsEnabled(B) {
									return !(0, P.Oy)() && ("boolean" == typeof this._sanityChecks ? this._sanityChecks : !!this._sanityChecks[B])
								}
							}
							return ct.\u0275fac = function(B) {
								return new(B || ct)(p.LFG(y.qm), p.LFG(Ce, 8), p.LFG(ee.K0))
							}, ct.\u0275mod = p.oAB({
								type: ct
							}), ct.\u0275inj = p.cJS({
								imports: [D.vT, D.vT]
							}), ct
						})();

						function ke(ct) {
							return class extends ct {
								get disabled() {
									return this._disabled
								}
								set disabled(De) {
									this._disabled = (0, N.Ig)(De)
								}
								constructor(...De) {
									super(...De), this._disabled = !1
								}
							}
						}

						function Ge(ct, De) {
							return class extends ct {
								get color() {
									return this._color
								}
								set color(B) {
									const J = B || this.defaultColor;
									J !== this._color && (this._color && this._elementRef.nativeElement.classList.remove(`mat-${this._color}`), J && this._elementRef.nativeElement.classList.add(`mat-${J}`), this._color = J)
								}
								constructor(...B) {
									super(...B), this.defaultColor = De, this.color = De
								}
							}
						}

						function ft(ct) {
							return class extends ct {
								get disableRipple() {
									return this._disableRipple
								}
								set disableRipple(De) {
									this._disableRipple = (0, N.Ig)(De)
								}
								constructor(...De) {
									super(...De), this._disableRipple = !1
								}
							}
						}
						class Pn {
							constructor(De, B, J, k = !1) {
								this._renderer = De, this.element = B, this.config = J, this._animationForciblyDisabledThroughCss = k, this.state = 3
							}
							fadeOut() {
								this._renderer.fadeOutRipple(this)
							}
						}
						const mn = (0, P.i$)({
							passive: !0,
							capture: !0
						});
						class Un {
							constructor() {
								this._events = new Map, this._delegateEventHandler = De => {
									const B = (0, P.sA)(De);
									B && this._events.get(De.type)?.forEach((J, k) => {
										(k === B || k.contains(B)) && J.forEach(H => H.handleEvent(De))
									})
								}
							}
							addHandler(De, B, J, k) {
								const H = this._events.get(B);
								if (H) {
									const ne = H.get(J);
									ne ? ne.add(k) : H.set(J, new Set([k]))
								} else this._events.set(B, new Map([
									[J, new Set([k])]
								])), De.runOutsideAngular(() => {
									document.addEventListener(B, this._delegateEventHandler, mn)
								})
							}
							removeHandler(De, B, J) {
								const k = this._events.get(De);
								if (!k) return;
								const H = k.get(B);
								H && (H.delete(J), 0 === H.size && k.delete(B), 0 === k.size && (this._events.delete(De), document.removeEventListener(De, this._delegateEventHandler, mn)))
							}
						}
						const Kn = {
								enterDuration: 225,
								exitDuration: 150
							},
							Zt = (0, P.i$)({
								passive: !0,
								capture: !0
							}),
							bn = ["mousedown", "touchstart"],
							Bn = ["mouseup", "mouseleave", "touchend", "touchcancel"];
						class qt {
							constructor(De, B, J, k) {
								this._target = De, this._ngZone = B, this._platform = k, this._isPointerDown = !1, this._activeRipples = new Map, this._pointerUpEventsRegistered = !1, k.isBrowser && (this._containerElement = (0, N.fI)(J))
							}
							fadeInRipple(De, B, J = {}) {
								const k = this._containerRect = this._containerRect || this._containerElement.getBoundingClientRect(),
									H = {
										...Kn,
										...J.animation
									};
								J.centered && (De = k.left + k.width / 2, B = k.top + k.height / 2);
								const ne = J.radius || function tn(ct, De, B) {
										const J = Math.max(Math.abs(ct - B.left), Math.abs(ct - B.right)),
											k = Math.max(Math.abs(De - B.top), Math.abs(De - B.bottom));
										return Math.sqrt(J * J + k * k)
									}(De, B, k),
									Ne = De - k.left,
									Ye = B - k.top,
									Ft = H.enterDuration,
									an = document.createElement("div");
								an.classList.add("mat-ripple-element"), an.style.left = Ne - ne + "px", an.style.top = Ye - ne + "px", an.style.height = 2 * ne + "px", an.style.width = 2 * ne + "px", null != J.color && (an.style.backgroundColor = J.color), an.style.transitionDuration = `${Ft}ms`, this._containerElement.appendChild(an);
								const xt = window.getComputedStyle(an),
									yn = xt.transitionDuration,
									nr = "none" === xt.transitionProperty || "0s" === yn || "0s, 0s" === yn || 0 === k.width && 0 === k.height,
									Dn = new Pn(this, an, J, nr);
								an.style.transform = "scale3d(1, 1, 1)", Dn.state = 0, J.persistent || (this._mostRecentTransientRipple = Dn);
								let En = null;
								return !nr && (Ft || H.exitDuration) && this._ngZone.runOutsideAngular(() => {
									const Me = () => this._finishRippleTransition(Dn),
										Ie = () => this._destroyRipple(Dn);
									an.addEventListener("transitionend", Me), an.addEventListener("transitioncancel", Ie), En = {
										onTransitionEnd: Me,
										onTransitionCancel: Ie
									}
								}), this._activeRipples.set(Dn, En), (nr || !Ft) && this._finishRippleTransition(Dn), Dn
							}
							fadeOutRipple(De) {
								if (2 === De.state || 3 === De.state) return;
								const B = De.element,
									J = {
										...Kn,
										...De.config.animation
									};
								B.style.transitionDuration = `${J.exitDuration}ms`, B.style.opacity = "0", De.state = 2, (De._animationForciblyDisabledThroughCss || !J.exitDuration) && this._finishRippleTransition(De)
							}
							fadeOutAll() {
								this._getActiveRipples().forEach(De => De.fadeOut())
							}
							fadeOutAllNonPersistent() {
								this._getActiveRipples().forEach(De => {
									De.config.persistent || De.fadeOut()
								})
							}
							setupTriggerEvents(De) {
								const B = (0, N.fI)(De);
								!this._platform.isBrowser || !B || B === this._triggerElement || (this._removeTriggerEvents(), this._triggerElement = B, bn.forEach(J => {
									qt._eventManager.addHandler(this._ngZone, J, B, this)
								}))
							}
							handleEvent(De) {
								"mousedown" === De.type ? this._onMousedown(De) : "touchstart" === De.type ? this._onTouchStart(De) : this._onPointerUp(), this._pointerUpEventsRegistered || (this._ngZone.runOutsideAngular(() => {
									Bn.forEach(B => {
										this._triggerElement.addEventListener(B, this, Zt)
									})
								}), this._pointerUpEventsRegistered = !0)
							}
							_finishRippleTransition(De) {
								0 === De.state ? this._startFadeOutTransition(De) : 2 === De.state && this._destroyRipple(De)
							}
							_startFadeOutTransition(De) {
								const B = De === this._mostRecentTransientRipple,
									{
										persistent: J
									} = De.config;
								De.state = 1, !J && (!B || !this._isPointerDown) && De.fadeOut()
							}
							_destroyRipple(De) {
								const B = this._activeRipples.get(De) ?? null;
								this._activeRipples.delete(De), this._activeRipples.size || (this._containerRect = null), De === this._mostRecentTransientRipple && (this._mostRecentTransientRipple = null), De.state = 3, null !== B && (De.element.removeEventListener("transitionend", B.onTransitionEnd), De.element.removeEventListener("transitioncancel", B.onTransitionCancel)), De.element.remove()
							}
							_onMousedown(De) {
								const B = (0, y.X6)(De),
									J = this._lastTouchStartEvent && Date.now() < this._lastTouchStartEvent + 800;
								!this._target.rippleDisabled && !B && !J && (this._isPointerDown = !0, this.fadeInRipple(De.clientX, De.clientY, this._target.rippleConfig))
							}
							_onTouchStart(De) {
								if (!this._target.rippleDisabled && !(0, y.yG)(De)) {
									this._lastTouchStartEvent = Date.now(), this._isPointerDown = !0;
									const B = De.changedTouches;
									for (let J = 0; J < B.length; J++) this.fadeInRipple(B[J].clientX, B[J].clientY, this._target.rippleConfig)
								}
							}
							_onPointerUp() {
								this._isPointerDown && (this._isPointerDown = !1, this._getActiveRipples().forEach(De => {
									!De.config.persistent && (1 === De.state || De.config.terminateOnPointerUp && 0 === De.state) && De.fadeOut()
								}))
							}
							_getActiveRipples() {
								return Array.from(this._activeRipples.keys())
							}
							_removeTriggerEvents() {
								const De = this._triggerElement;
								De && (bn.forEach(B => qt._eventManager.removeHandler(B, De, this)), this._pointerUpEventsRegistered && Bn.forEach(B => De.removeEventListener(B, this, Zt)))
							}
						}
						qt._eventManager = new Un;
						const en = new p.OlP("mat-ripple-global-options");
						let Qn = (() => {
								class ct {
									get disabled() {
										return this._disabled
									}
									set disabled(B) {
										B && this.fadeOutAllNonPersistent(), this._disabled = B, this._setupTriggerEventsIfEnabled()
									}
									get trigger() {
										return this._trigger || this._elementRef.nativeElement
									}
									set trigger(B) {
										this._trigger = B, this._setupTriggerEventsIfEnabled()
									}
									constructor(B, J, k, H, ne) {
										this._elementRef = B, this._animationMode = ne, this.radius = 0, this._disabled = !1, this._isInitialized = !1, this._globalOptions = H || {}, this._rippleRenderer = new qt(this, J, B, k)
									}
									ngOnInit() {
										this._isInitialized = !0, this._setupTriggerEventsIfEnabled()
									}
									ngOnDestroy() {
										this._rippleRenderer._removeTriggerEvents()
									}
									fadeOutAll() {
										this._rippleRenderer.fadeOutAll()
									}
									fadeOutAllNonPersistent() {
										this._rippleRenderer.fadeOutAllNonPersistent()
									}
									get rippleConfig() {
										return {
											centered: this.centered,
											radius: this.radius,
											color: this.color,
											animation: {
												...this._globalOptions.animation,
												..."NoopAnimations" === this._animationMode ? {
													enterDuration: 0,
													exitDuration: 0
												} : {},
												...this.animation
											},
											terminateOnPointerUp: this._globalOptions.terminateOnPointerUp
										}
									}
									get rippleDisabled() {
										return this.disabled || !!this._globalOptions.disabled
									}
									_setupTriggerEventsIfEnabled() {
										!this.disabled && this._isInitialized && this._rippleRenderer.setupTriggerEvents(this.trigger)
									}
									launch(B, J = 0, k) {
										return "number" == typeof B ? this._rippleRenderer.fadeInRipple(B, J, {
											...this.rippleConfig,
											...k
										}) : this._rippleRenderer.fadeInRipple(0, 0, {
											...this.rippleConfig,
											...B
										})
									}
								}
								return ct.\u0275fac = function(B) {
									return new(B || ct)(p.Y36(p.SBq), p.Y36(p.R0b), p.Y36(P.t4), p.Y36(en, 8), p.Y36(p.QbO, 8))
								}, ct.\u0275dir = p.lG2({
									type: ct,
									selectors: [
										["", "mat-ripple", ""],
										["", "matRipple", ""]
									],
									hostAttrs: [1, "mat-ripple"],
									hostVars: 2,
									hostBindings: function(B, J) {
										2 & B && p.ekj("mat-ripple-unbounded", J.unbounded)
									},
									inputs: {
										color: ["matRippleColor", "color"],
										unbounded: ["matRippleUnbounded", "unbounded"],
										centered: ["matRippleCentered", "centered"],
										radius: ["matRippleRadius", "radius"],
										animation: ["matRippleAnimation", "animation"],
										disabled: ["matRippleDisabled", "disabled"],
										trigger: ["matRippleTrigger", "trigger"]
									},
									exportAs: ["matRipple"]
								}), ct
							})(),
							Wn = (() => {
								class ct {}
								return ct.\u0275fac = function(B) {
									return new(B || ct)
								}, ct.\u0275mod = p.oAB({
									type: ct
								}), ct.\u0275inj = p.cJS({
									imports: [F, F]
								}), ct
							})()
					}, 5391: (be, ue, E) => {
						E.d(ue, {
							WI: () => Pn,
							uw: () => qt,
							Is: () => hr,
							so: () => cn
						});
						var p = E(906),
							y = E(7774),
							D = E(3991),
							z = E(7838),
							ee = E(1329),
							P = E(7444),
							N = E(849),
							Y = E(8264),
							G = E(2588),
							Q = E(5195),
							X = E(8793),
							te = E(1743);

						function ie(Xe, pe) {}
						class oe {
							constructor() {
								this.role = "dialog", this.panelClass = "", this.hasBackdrop = !0, this.backdropClass = "", this.disableClose = !1, this.width = "", this.height = "", this.data = null, this.ariaDescribedBy = null, this.ariaLabelledBy = null, this.ariaLabel = null, this.ariaModal = !0, this.autoFocus = "first-tabbable", this.restoreFocus = !0, this.closeOnNavigation = !0, this.closeOnDestroy = !0
							}
						}
						let Fe = (() => {
							class Xe extends P.en {
								constructor(Te, Je, yt, Ht, pn, $t, hn, kt) {
									super(), this._elementRef = Te, this._focusTrapFactory = Je, this._config = Ht, this._interactivityChecker = pn, this._ngZone = $t, this._overlayRef = hn, this._focusMonitor = kt, this._elementFocusedBeforeDialogWasOpened = null, this._closeInteractionType = null, this.attachDomPortal = ct => {
										this._portalOutlet.hasAttached();
										const De = this._portalOutlet.attachDomPortal(ct);
										return this._contentAttached(), De
									}, this._ariaLabelledBy = this._config.ariaLabelledBy || null, this._document = yt
								}
								_contentAttached() {
									this._initializeFocusTrap(), this._handleBackdropClicks(), this._captureInitialFocus()
								}
								_captureInitialFocus() {
									this._trapFocus()
								}
								ngOnDestroy() {
									this._restoreFocus()
								}
								attachComponentPortal(Te) {
									this._portalOutlet.hasAttached();
									const Je = this._portalOutlet.attachComponentPortal(Te);
									return this._contentAttached(), Je
								}
								attachTemplatePortal(Te) {
									this._portalOutlet.hasAttached();
									const Je = this._portalOutlet.attachTemplatePortal(Te);
									return this._contentAttached(), Je
								}
								_recaptureFocus() {
									this._containsFocus() || this._trapFocus()
								}
								_forceFocus(Te, Je) {
									this._interactivityChecker.isFocusable(Te) || (Te.tabIndex = -1, this._ngZone.runOutsideAngular(() => {
										const yt = () => {
											Te.removeEventListener("blur", yt), Te.removeEventListener("mousedown", yt), Te.removeAttribute("tabindex")
										};
										Te.addEventListener("blur", yt), Te.addEventListener("mousedown", yt)
									})), Te.focus(Je)
								}
								_focusByCssSelector(Te, Je) {
									let yt = this._elementRef.nativeElement.querySelector(Te);
									yt && this._forceFocus(yt, Je)
								}
								_trapFocus() {
									const Te = this._elementRef.nativeElement;
									switch (this._config.autoFocus) {
										case !1:
										case "dialog":
											this._containsFocus() || Te.focus();
											break;
										case !0:
										case "first-tabbable":
											this._focusTrap.focusInitialElementWhenReady().then(Je => {
												Je || this._focusDialogContainer()
											});
											break;
										case "first-heading":
											this._focusByCssSelector('h1, h2, h3, h4, h5, h6, [role="heading"]');
											break;
										default:
											this._focusByCssSelector(this._config.autoFocus)
									}
								}
								_restoreFocus() {
									const Te = this._config.restoreFocus;
									let Je = null;
									if ("string" == typeof Te ? Je = this._document.querySelector(Te) : "boolean" == typeof Te ? Je = Te ? this._elementFocusedBeforeDialogWasOpened : null : Te && (Je = Te), this._config.restoreFocus && Je && "function" == typeof Je.focus) {
										const yt = (0, ee.ht)(),
											Ht = this._elementRef.nativeElement;
										(!yt || yt === this._document.body || yt === Ht || Ht.contains(yt)) && (this._focusMonitor ? (this._focusMonitor.focusVia(Je, this._closeInteractionType), this._closeInteractionType = null) : Je.focus())
									}
									this._focusTrap && this._focusTrap.destroy()
								}
								_focusDialogContainer() {
									this._elementRef.nativeElement.focus && this._elementRef.nativeElement.focus()
								}
								_containsFocus() {
									const Te = this._elementRef.nativeElement,
										Je = (0, ee.ht)();
									return Te === Je || Te.contains(Je)
								}
								_initializeFocusTrap() {
									this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement), this._document && (this._elementFocusedBeforeDialogWasOpened = (0, ee.ht)())
								}
								_handleBackdropClicks() {
									this._overlayRef.backdropClick().subscribe(() => {
										this._config.disableClose && this._recaptureFocus()
									})
								}
							}
							return Xe.\u0275fac = function(Te) {
								return new(Te || Xe)(D.Y36(D.SBq), D.Y36(z.qV), D.Y36(y.K0, 8), D.Y36(oe), D.Y36(z.ic), D.Y36(D.R0b), D.Y36(p.Iu), D.Y36(z.tE))
							}, Xe.\u0275cmp = D.Xpm({
								type: Xe,
								selectors: [
									["cdk-dialog-container"]
								],
								viewQuery: function(Te, Je) {
									if (1 & Te && D.Gf(P.Pl, 7), 2 & Te) {
										let yt;
										D.iGM(yt = D.CRH()) && (Je._portalOutlet = yt.first)
									}
								},
								hostAttrs: ["tabindex", "-1", 1, "cdk-dialog-container"],
								hostVars: 6,
								hostBindings: function(Te, Je) {
									2 & Te && D.uIk("id", Je._config.id || null)("role", Je._config.role)("aria-modal", Je._config.ariaModal)("aria-labelledby", Je._config.ariaLabel ? null : Je._ariaLabelledBy)("aria-label", Je._config.ariaLabel)("aria-describedby", Je._config.ariaDescribedBy || null)
								},
								features: [D.qOj],
								decls: 1,
								vars: 0,
								consts: [
									["cdkPortalOutlet", ""]
								],
								template: function(Te, Je) {
									1 & Te && D.YNc(0, ie, 0, 0, "ng-template", 0)
								},
								dependencies: [P.Pl],
								styles: [".cdk-dialog-container{display:block;width:100%;height:100%;min-height:inherit;max-height:inherit}"],
								encapsulation: 2
							}), Xe
						})();
						class Le {
							constructor(pe, Te) {
								this.overlayRef = pe, this.config = Te, this.closed = new Y.x, this.disableClose = Te.disableClose, this.backdropClick = pe.backdropClick(), this.keydownEvents = pe.keydownEvents(), this.outsidePointerEvents = pe.outsidePointerEvents(), this.id = Te.id, this.keydownEvents.subscribe(Je => {
									Je.keyCode === N.hY && !this.disableClose && !(0, N.Vb)(Je) && (Je.preventDefault(), this.close(void 0, {
										focusOrigin: "keyboard"
									}))
								}), this.backdropClick.subscribe(() => {
									this.disableClose || this.close(void 0, {
										focusOrigin: "mouse"
									})
								})
							}
							close(pe, Te) {
								if (this.containerInstance) {
									const Je = this.closed;
									this.containerInstance._closeInteractionType = Te?.focusOrigin || "program", this.overlayRef.dispose(), Je.next(pe), Je.complete(), this.componentInstance = this.containerInstance = null
								}
							}
							updatePosition() {
								return this.overlayRef.updatePosition(), this
							}
							updateSize(pe = "", Te = "") {
								return this.overlayRef.updateSize({
									width: pe,
									height: Te
								}), this
							}
							addPanelClass(pe) {
								return this.overlayRef.addPanelClass(pe), this
							}
							removePanelClass(pe) {
								return this.overlayRef.removePanelClass(pe), this
							}
						}
						const je = new D.OlP("DialogScrollStrategy"),
							Ce = new D.OlP("DialogData"),
							F = new D.OlP("DefaultDialogConfig"),
							Ee = {
								provide: je,
								deps: [p.aV],
								useFactory: function xe(Xe) {
									return () => Xe.scrollStrategies.block()
								}
							};
						let Ue = 0,
							ke = (() => {
								class Xe {
									get openDialogs() {
										return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel
									}
									get afterOpened() {
										return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel
									}
									constructor(Te, Je, yt, Ht, pn, $t) {
										this._overlay = Te, this._injector = Je, this._defaultOptions = yt, this._parentDialog = Ht, this._overlayContainer = pn, this._openDialogsAtThisLevel = [], this._afterAllClosedAtThisLevel = new Y.x, this._afterOpenedAtThisLevel = new Y.x, this._ariaHiddenElements = new Map, this.afterAllClosed = (0, G.P)(() => this.openDialogs.length ? this._getAfterAllClosed() : this._getAfterAllClosed().pipe((0, te.O)(void 0))), this._scrollStrategy = $t
									}
									open(Te, Je) {
										(Je = {
											...this._defaultOptions || new oe,
											...Je
										}).id = Je.id || "cdk-dialog-" + Ue++, Je.id && this.getDialogById(Je.id);
										const Ht = this._getOverlayConfig(Je),
											pn = this._overlay.create(Ht),
											$t = new Le(pn, Je),
											hn = this._attachContainer(pn, $t, Je);
										return $t.containerInstance = hn, this._attachDialogContent(Te, $t, hn, Je), this.openDialogs.length || this._hideNonDialogContentFromAssistiveTechnology(), this.openDialogs.push($t), $t.closed.subscribe(() => this._removeOpenDialog($t, !0)), this.afterOpened.next($t), $t
									}
									closeAll() {
										Ge(this.openDialogs, Te => Te.close())
									}
									getDialogById(Te) {
										return this.openDialogs.find(Je => Je.id === Te)
									}
									ngOnDestroy() {
										Ge(this._openDialogsAtThisLevel, Te => {
											!1 === Te.config.closeOnDestroy && this._removeOpenDialog(Te, !1)
										}), Ge(this._openDialogsAtThisLevel, Te => Te.close()), this._afterAllClosedAtThisLevel.complete(), this._afterOpenedAtThisLevel.complete(), this._openDialogsAtThisLevel = []
									}
									_getOverlayConfig(Te) {
										const Je = new p.X_({
											positionStrategy: Te.positionStrategy || this._overlay.position().global().centerHorizontally().centerVertically(),
											scrollStrategy: Te.scrollStrategy || this._scrollStrategy(),
											panelClass: Te.panelClass,
											hasBackdrop: Te.hasBackdrop,
											direction: Te.direction,
											minWidth: Te.minWidth,
											minHeight: Te.minHeight,
											maxWidth: Te.maxWidth,
											maxHeight: Te.maxHeight,
											width: Te.width,
											height: Te.height,
											disposeOnNavigation: Te.closeOnNavigation
										});
										return Te.backdropClass && (Je.backdropClass = Te.backdropClass), Je
									}
									_attachContainer(Te, Je, yt) {
										const Ht = yt.injector || yt.viewContainerRef?.injector,
											pn = [{
												provide: oe,
												useValue: yt
											}, {
												provide: Le,
												useValue: Je
											}, {
												provide: p.Iu,
												useValue: Te
											}];
										let $t;
										yt.container ? "function" == typeof yt.container ? $t = yt.container : ($t = yt.container.type, pn.push(...yt.container.providers(yt))) : $t = Fe;
										const hn = new P.C5($t, yt.viewContainerRef, D.zs3.create({
											parent: Ht || this._injector,
											providers: pn
										}), yt.componentFactoryResolver);
										return Te.attach(hn).instance
									}
									_attachDialogContent(Te, Je, yt, Ht) {
										if (Te instanceof D.Rgc) {
											const pn = this._createInjector(Ht, Je, yt, void 0);
											let $t = {
												$implicit: Ht.data,
												dialogRef: Je
											};
											Ht.templateContext && ($t = {
												...$t,
												..."function" == typeof Ht.templateContext ? Ht.templateContext() : Ht.templateContext
											}), yt.attachTemplatePortal(new P.UE(Te, null, $t, pn))
										} else {
											const pn = this._createInjector(Ht, Je, yt, this._injector),
												$t = yt.attachComponentPortal(new P.C5(Te, Ht.viewContainerRef, pn, Ht.componentFactoryResolver));
											Je.componentInstance = $t.instance
										}
									}
									_createInjector(Te, Je, yt, Ht) {
										const pn = Te.injector || Te.viewContainerRef?.injector,
											$t = [{
												provide: Ce,
												useValue: Te.data
											}, {
												provide: Le,
												useValue: Je
											}];
										return Te.providers && ("function" == typeof Te.providers ? $t.push(...Te.providers(Je, Te, yt)) : $t.push(...Te.providers)), Te.direction && (!pn || !pn.get(X.Is, null, {
											optional: !0
										})) && $t.push({
											provide: X.Is,
											useValue: {
												value: Te.direction,
												change: (0, Q.of)()
											}
										}), D.zs3.create({
											parent: pn || Ht,
											providers: $t
										})
									}
									_removeOpenDialog(Te, Je) {
										const yt = this.openDialogs.indexOf(Te);
										yt > -1 && (this.openDialogs.splice(yt, 1), this.openDialogs.length || (this._ariaHiddenElements.forEach((Ht, pn) => {
											Ht ? pn.setAttribute("aria-hidden", Ht) : pn.removeAttribute("aria-hidden")
										}), this._ariaHiddenElements.clear(), Je && this._getAfterAllClosed().next()))
									}
									_hideNonDialogContentFromAssistiveTechnology() {
										const Te = this._overlayContainer.getContainerElement();
										if (Te.parentElement) {
											const Je = Te.parentElement.children;
											for (let yt = Je.length - 1; yt > -1; yt--) {
												const Ht = Je[yt];
												Ht !== Te && "SCRIPT" !== Ht.nodeName && "STYLE" !== Ht.nodeName && !Ht.hasAttribute("aria-live") && (this._ariaHiddenElements.set(Ht, Ht.getAttribute("aria-hidden")), Ht.setAttribute("aria-hidden", "true"))
											}
										}
									}
									_getAfterAllClosed() {
										const Te = this._parentDialog;
										return Te ? Te._getAfterAllClosed() : this._afterAllClosedAtThisLevel
									}
								}
								return Xe.\u0275fac = function(Te) {
									return new(Te || Xe)(D.LFG(p.aV), D.LFG(D.zs3), D.LFG(F, 8), D.LFG(Xe, 12), D.LFG(p.Xj), D.LFG(je))
								}, Xe.\u0275prov = D.Yz7({
									token: Xe,
									factory: Xe.\u0275fac
								}), Xe
							})();

						function Ge(Xe, pe) {
							let Te = Xe.length;
							for (; Te--;) pe(Xe[Te])
						}
						let ft = (() => {
							class Xe {}
							return Xe.\u0275fac = function(Te) {
								return new(Te || Xe)
							}, Xe.\u0275mod = D.oAB({
								type: Xe
							}), Xe.\u0275inj = D.cJS({
								providers: [ke, Ee],
								imports: [p.U8, P.eL, z.rt, P.eL]
							}), Xe
						})();
						var nt = E(5903),
							Pt = E(805),
							at = E(9754),
							lt = E(2653),
							et = E(2051);

						function Be(Xe, pe) {}
						E(6191);
						class ze {
							constructor() {
								this.role = "dialog", this.panelClass = "", this.hasBackdrop = !0, this.backdropClass = "", this.disableClose = !1, this.width = "", this.height = "", this.maxWidth = "80vw", this.data = null, this.ariaDescribedBy = null, this.ariaLabelledBy = null, this.ariaLabel = null, this.ariaModal = !0, this.autoFocus = "first-tabbable", this.restoreFocus = !0, this.delayFocusTrap = !0, this.closeOnNavigation = !0
							}
						}
						const it = "mdc-dialog--open",
							ce = "mdc-dialog--opening",
							ht = "mdc-dialog--closing";
						let Bt = (() => {
							class Xe extends Fe {
								constructor(Te, Je, yt, Ht, pn, $t, hn, kt) {
									super(Te, Je, yt, Ht, pn, $t, hn, kt), this._animationStateChanged = new D.vpe
								}
								_captureInitialFocus() {
									this._config.delayFocusTrap || this._trapFocus()
								}
								_openAnimationDone(Te) {
									this._config.delayFocusTrap && this._trapFocus(), this._animationStateChanged.next({
										state: "opened",
										totalTime: Te
									})
								}
							}
							return Xe.\u0275fac = function(Te) {
								return new(Te || Xe)(D.Y36(D.SBq), D.Y36(z.qV), D.Y36(y.K0, 8), D.Y36(ze), D.Y36(z.ic), D.Y36(D.R0b), D.Y36(p.Iu), D.Y36(z.tE))
							}, Xe.\u0275cmp = D.Xpm({
								type: Xe,
								selectors: [
									["ng-component"]
								],
								features: [D.qOj],
								decls: 0,
								vars: 0,
								template: function(Te, Je) {},
								encapsulation: 2
							}), Xe
						})();
						const ot = "--mat-dialog-transition-duration";

						function Vt(Xe) {
							return null == Xe ? null : "number" == typeof Xe ? Xe : Xe.endsWith("ms") ? (0, nt.su)(Xe.substring(0, Xe.length - 2)) : Xe.endsWith("s") ? 1e3 * (0, nt.su)(Xe.substring(0, Xe.length - 1)) : "0" === Xe ? 0 : null
						}
						let Qt = (() => {
							class Xe extends Bt {
								constructor(Te, Je, yt, Ht, pn, $t, hn, kt, ct) {
									super(Te, Je, yt, Ht, pn, $t, hn, ct), this._animationMode = kt, this._animationsEnabled = "NoopAnimations" !== this._animationMode, this._hostElement = this._elementRef.nativeElement, this._openAnimationDuration = this._animationsEnabled ? Vt(this._config.enterAnimationDuration) ?? 150 : 0, this._closeAnimationDuration = this._animationsEnabled ? Vt(this._config.exitAnimationDuration) ?? 75 : 0, this._animationTimer = null, this._finishDialogOpen = () => {
										this._clearAnimationClasses(), this._openAnimationDone(this._openAnimationDuration)
									}, this._finishDialogClose = () => {
										this._clearAnimationClasses(), this._animationStateChanged.emit({
											state: "closed",
											totalTime: this._closeAnimationDuration
										})
									}
								}
								_contentAttached() {
									super._contentAttached(), this._startOpenAnimation()
								}
								ngOnDestroy() {
									super.ngOnDestroy(), null !== this._animationTimer && clearTimeout(this._animationTimer)
								}
								_startOpenAnimation() {
									this._animationStateChanged.emit({
										state: "opening",
										totalTime: this._openAnimationDuration
									}), this._animationsEnabled ? (this._hostElement.style.setProperty(ot, `${this._openAnimationDuration}ms`), this._hostElement.classList.add(ce), this._hostElement.classList.add(it), this._waitForAnimationToComplete(this._openAnimationDuration, this._finishDialogOpen)) : (this._hostElement.classList.add(it), Promise.resolve().then(() => this._finishDialogOpen()))
								}
								_startExitAnimation() {
									this._animationStateChanged.emit({
										state: "closing",
										totalTime: this._closeAnimationDuration
									}), this._hostElement.classList.remove(it), this._animationsEnabled ? (this._hostElement.style.setProperty(ot, `${this._openAnimationDuration}ms`), this._hostElement.classList.add(ht), this._waitForAnimationToComplete(this._closeAnimationDuration, this._finishDialogClose)) : Promise.resolve().then(() => this._finishDialogClose())
								}
								_clearAnimationClasses() {
									this._hostElement.classList.remove(ce), this._hostElement.classList.remove(ht)
								}
								_waitForAnimationToComplete(Te, Je) {
									null !== this._animationTimer && clearTimeout(this._animationTimer), this._animationTimer = setTimeout(Je, Te)
								}
							}
							return Xe.\u0275fac = function(Te) {
								return new(Te || Xe)(D.Y36(D.SBq), D.Y36(z.qV), D.Y36(y.K0, 8), D.Y36(ze), D.Y36(z.ic), D.Y36(D.R0b), D.Y36(p.Iu), D.Y36(D.QbO, 8), D.Y36(z.tE))
							}, Xe.\u0275cmp = D.Xpm({
								type: Xe,
								selectors: [
									["mat-dialog-container"]
								],
								hostAttrs: ["tabindex", "-1", 1, "mat-mdc-dialog-container", "mdc-dialog"],
								hostVars: 8,
								hostBindings: function(Te, Je) {
									2 & Te && (D.Ikx("id", Je._config.id), D.uIk("aria-modal", Je._config.ariaModal)("role", Je._config.role)("aria-labelledby", Je._config.ariaLabel ? null : Je._ariaLabelledBy)("aria-label", Je._config.ariaLabel)("aria-describedby", Je._config.ariaDescribedBy || null), D.ekj("_mat-animation-noopable", !Je._animationsEnabled))
								},
								features: [D.qOj],
								decls: 3,
								vars: 0,
								consts: [
									[1, "mdc-dialog__container"],
									[1, "mat-mdc-dialog-surface", "mdc-dialog__surface"],
									["cdkPortalOutlet", ""]
								],
								template: function(Te, Je) {
									1 & Te && (D.TgZ(0, "div", 0)(1, "div", 1), D.YNc(2, Be, 0, 0, "ng-template", 2), D.qZA()())
								},
								dependencies: [P.Pl],
								styles: ['.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-dialog,.mdc-dialog__scrim{position:fixed;top:0;left:0;align-items:center;justify-content:center;box-sizing:border-box;width:100%;height:100%}.mdc-dialog{display:none;z-index:var(--mdc-dialog-z-index, 7)}.mdc-dialog .mdc-dialog__content{padding:20px 24px 20px 24px}.mdc-dialog .mdc-dialog__surface{min-width:280px}@media(max-width: 592px){.mdc-dialog .mdc-dialog__surface{max-width:calc(100vw - 32px)}}@media(min-width: 592px){.mdc-dialog .mdc-dialog__surface{max-width:560px}}.mdc-dialog .mdc-dialog__surface{max-height:calc(100% - 32px)}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-width:none}@media(max-width: 960px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:560px;width:560px}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}@media(max-width: 720px)and (max-width: 672px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:calc(100vw - 112px)}}@media(max-width: 720px)and (min-width: 672px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:560px}}@media(max-width: 720px)and (max-height: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:calc(100vh - 160px)}}@media(max-width: 720px)and (min-height: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:560px}}@media(max-width: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}@media(max-width: 720px)and (max-height: 400px),(max-width: 600px),(min-width: 720px)and (max-height: 400px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{height:100%;max-height:100vh;max-width:100vw;width:100vw;border-radius:0}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{order:-1;left:-12px}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__header{padding:0 16px 9px;justify-content:flex-start}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__title{margin-left:calc(16px - 2 * 12px)}}@media(min-width: 960px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:calc(100vw - 400px)}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}.mdc-dialog.mdc-dialog__scrim--hidden .mdc-dialog__scrim{opacity:0}.mdc-dialog__scrim{opacity:0;z-index:-1}.mdc-dialog__container{display:flex;flex-direction:row;align-items:center;justify-content:space-around;box-sizing:border-box;height:100%;transform:scale(0.8);opacity:0;pointer-events:none}.mdc-dialog__surface{position:relative;display:flex;flex-direction:column;flex-grow:0;flex-shrink:0;box-sizing:border-box;max-width:100%;max-height:100%;pointer-events:auto;overflow-y:auto}.mdc-dialog__surface .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}[dir=rtl] .mdc-dialog__surface,.mdc-dialog__surface[dir=rtl]{text-align:right}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mdc-dialog__surface{outline:2px solid windowText}}.mdc-dialog__surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:2px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-dialog__surface::before{border-color:CanvasText}}@media screen and (-ms-high-contrast: active),screen and (-ms-high-contrast: none){.mdc-dialog__surface::before{content:none}}.mdc-dialog__title{display:block;margin-top:0;position:relative;flex-shrink:0;box-sizing:border-box;margin:0 0 1px;padding:0 24px 9px}.mdc-dialog__title::before{display:inline-block;width:0;height:40px;content:"";vertical-align:0}[dir=rtl] .mdc-dialog__title,.mdc-dialog__title[dir=rtl]{text-align:right}.mdc-dialog--scrollable .mdc-dialog__title{margin-bottom:1px;padding-bottom:15px}.mdc-dialog--fullscreen .mdc-dialog__header{align-items:baseline;border-bottom:1px solid rgba(0,0,0,0);display:inline-flex;justify-content:space-between;padding:0 24px 9px;z-index:1}@media screen and (forced-colors: active){.mdc-dialog--fullscreen .mdc-dialog__header{border-bottom-color:CanvasText}}.mdc-dialog--fullscreen .mdc-dialog__header .mdc-dialog__close{right:-12px}.mdc-dialog--fullscreen .mdc-dialog__title{margin-bottom:0;padding:0;border-bottom:0}.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__title{border-bottom:0;margin-bottom:0}.mdc-dialog--fullscreen .mdc-dialog__close{top:5px}.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__actions{border-top:1px solid rgba(0,0,0,0)}@media screen and (forced-colors: active){.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__actions{border-top-color:CanvasText}}.mdc-dialog--fullscreen--titleless .mdc-dialog__close{margin-top:4px}.mdc-dialog--fullscreen--titleless.mdc-dialog--scrollable .mdc-dialog__close{margin-top:0}.mdc-dialog__content{flex-grow:1;box-sizing:border-box;margin:0;overflow:auto}.mdc-dialog__content>:first-child{margin-top:0}.mdc-dialog__content>:last-child{margin-bottom:0}.mdc-dialog__title+.mdc-dialog__content,.mdc-dialog__header+.mdc-dialog__content{padding-top:0}.mdc-dialog--scrollable .mdc-dialog__title+.mdc-dialog__content{padding-top:8px;padding-bottom:8px}.mdc-dialog__content .mdc-deprecated-list:first-child:last-child{padding:6px 0 0}.mdc-dialog--scrollable .mdc-dialog__content .mdc-deprecated-list:first-child:last-child{padding:0}.mdc-dialog__actions{display:flex;position:relative;flex-shrink:0;flex-wrap:wrap;align-items:center;justify-content:flex-end;box-sizing:border-box;min-height:52px;margin:0;padding:8px;border-top:1px solid rgba(0,0,0,0)}@media screen and (forced-colors: active){.mdc-dialog__actions{border-top-color:CanvasText}}.mdc-dialog--stacked .mdc-dialog__actions{flex-direction:column;align-items:flex-end}.mdc-dialog__button{margin-left:8px;margin-right:0;max-width:100%;text-align:right}[dir=rtl] .mdc-dialog__button,.mdc-dialog__button[dir=rtl]{margin-left:0;margin-right:8px}.mdc-dialog__button:first-child{margin-left:0;margin-right:0}[dir=rtl] .mdc-dialog__button:first-child,.mdc-dialog__button:first-child[dir=rtl]{margin-left:0;margin-right:0}[dir=rtl] .mdc-dialog__button,.mdc-dialog__button[dir=rtl]{text-align:left}.mdc-dialog--stacked .mdc-dialog__button:not(:first-child){margin-top:12px}.mdc-dialog--open,.mdc-dialog--opening,.mdc-dialog--closing{display:flex}.mdc-dialog--opening .mdc-dialog__scrim{transition:opacity 150ms linear}.mdc-dialog--opening .mdc-dialog__container{transition:opacity 75ms linear,transform 150ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-dialog--closing .mdc-dialog__scrim,.mdc-dialog--closing .mdc-dialog__container{transition:opacity 75ms linear}.mdc-dialog--closing .mdc-dialog__container{transform:none}.mdc-dialog--open .mdc-dialog__scrim{opacity:1}.mdc-dialog--open .mdc-dialog__container{transform:none;opacity:1}.mdc-dialog--open.mdc-dialog__surface-scrim--shown .mdc-dialog__surface-scrim{opacity:1}.mdc-dialog--open.mdc-dialog__surface-scrim--hiding .mdc-dialog__surface-scrim{transition:opacity 75ms linear}.mdc-dialog--open.mdc-dialog__surface-scrim--showing .mdc-dialog__surface-scrim{transition:opacity 150ms linear}.mdc-dialog__surface-scrim{display:none;opacity:0;position:absolute;width:100%;height:100%;z-index:1}.mdc-dialog__surface-scrim--shown .mdc-dialog__surface-scrim,.mdc-dialog__surface-scrim--showing .mdc-dialog__surface-scrim,.mdc-dialog__surface-scrim--hiding .mdc-dialog__surface-scrim{display:block}.mdc-dialog-scroll-lock{overflow:hidden}.mdc-dialog--no-content-padding .mdc-dialog__content{padding:0}.mdc-dialog--sheet .mdc-dialog__close{right:12px;top:9px;position:absolute;z-index:1}.mdc-dialog__scrim--removed{pointer-events:none}.mdc-dialog__scrim--removed .mdc-dialog__scrim,.mdc-dialog__scrim--removed .mdc-dialog__surface-scrim{display:none}.mat-mdc-dialog-content{max-height:65vh}.mat-mdc-dialog-container{position:static;display:block}.mat-mdc-dialog-container,.mat-mdc-dialog-container .mdc-dialog__container,.mat-mdc-dialog-container .mdc-dialog__surface{max-height:inherit;min-height:inherit;min-width:inherit;max-width:inherit}.mat-mdc-dialog-container .mdc-dialog__surface{display:block;width:100%;height:100%}.mat-mdc-dialog-container{outline:0}.mat-mdc-dialog-container .mdc-dialog__surface{background-color:var(--mdc-dialog-container-color, white)}.mat-mdc-dialog-container .mdc-dialog__surface{box-shadow:var(--mdc-dialog-container-elevation, 0px 11px 15px -7px rgba(0, 0, 0, 0.2), 0px 24px 38px 3px rgba(0, 0, 0, 0.14), 0px 9px 46px 8px rgba(0, 0, 0, 0.12))}.mat-mdc-dialog-container .mdc-dialog__surface{border-radius:var(--mdc-dialog-container-shape, var(--mdc-shape-medium, 4px))}.mat-mdc-dialog-container.mdc-dialog--scrollable .mdc-dialog__title,.mat-mdc-dialog-container.mdc-dialog--scrollable .mdc-dialog__actions,.mat-mdc-dialog-container.mdc-dialog--scrollable.mdc-dialog-scroll-divider-footer .mdc-dialog__actions{border-color:var(--mdc-dialog-with-divider-divider-color, black)}.mat-mdc-dialog-container.mdc-dialog--scrollable .mdc-dialog__title{border-bottom-color:var(--mdc-dialog-with-divider-divider-color, black)}.mat-mdc-dialog-container .mdc-dialog__title{font-family:var(--mdc-dialog-subhead-font, "Arial");line-height:var(--mdc-dialog-subhead-line-height, 14px);font-size:var(--mdc-dialog-subhead-size, 14px);font-weight:var(--mdc-dialog-subhead-weight, 500);letter-spacing:var(--mdc-dialog-subhead-tracking, 1px)}.mat-mdc-dialog-container .mdc-dialog__title{color:var(--mdc-dialog-subhead-color, black)}.mat-mdc-dialog-container .mdc-dialog__content{font-family:var(--mdc-dialog-supporting-text-font, "Arial");line-height:var(--mdc-dialog-supporting-text-line-height, 14px);font-size:var(--mdc-dialog-supporting-text-size, 14px);font-weight:var(--mdc-dialog-supporting-text-weight, 500);letter-spacing:var(--mdc-dialog-supporting-text-tracking, 1px)}.mat-mdc-dialog-container .mdc-dialog__content{color:var(--mdc-dialog-supporting-text-color, black)}.mat-mdc-dialog-container .mdc-dialog__container{transition-duration:var(--mat-dialog-transition-duration, 0ms)}.mat-mdc-dialog-container._mat-animation-noopable .mdc-dialog__container{transition:none}.mat-mdc-dialog-content{display:block}.mat-mdc-dialog-actions{justify-content:start}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-center,.mat-mdc-dialog-actions[align=center]{justify-content:center}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-end,.mat-mdc-dialog-actions[align=end]{justify-content:flex-end}.mat-mdc-dialog-actions .mat-button-base+.mat-button-base,.mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-mdc-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}'],
								encapsulation: 2
							}), Xe
						})();
						class cn {
							constructor(pe, Te, Je) {
								this._ref = pe, this._containerInstance = Je, this._afterOpened = new Y.x, this._beforeClosed = new Y.x, this._state = 0, this.disableClose = Te.disableClose, this.id = pe.id, Je._animationStateChanged.pipe((0, at.h)(yt => "opened" === yt.state), (0, lt.q)(1)).subscribe(() => {
									this._afterOpened.next(), this._afterOpened.complete()
								}), Je._animationStateChanged.pipe((0, at.h)(yt => "closed" === yt.state), (0, lt.q)(1)).subscribe(() => {
									clearTimeout(this._closeFallbackTimeout), this._finishDialogClose()
								}), pe.overlayRef.detachments().subscribe(() => {
									this._beforeClosed.next(this._result), this._beforeClosed.complete(), this._finishDialogClose()
								}), (0, Pt.T)(this.backdropClick(), this.keydownEvents().pipe((0, at.h)(yt => yt.keyCode === N.hY && !this.disableClose && !(0, N.Vb)(yt)))).subscribe(yt => {
									this.disableClose || (yt.preventDefault(), function Sn(Xe, pe, Te) {
										Xe._closeInteractionType = pe, Xe.close(Te)
									}(this, "keydown" === yt.type ? "keyboard" : "mouse"))
								})
							}
							close(pe) {
								this._result = pe, this._containerInstance._animationStateChanged.pipe((0, at.h)(Te => "closing" === Te.state), (0, lt.q)(1)).subscribe(Te => {
									this._beforeClosed.next(pe), this._beforeClosed.complete(), this._ref.overlayRef.detachBackdrop(), this._closeFallbackTimeout = setTimeout(() => this._finishDialogClose(), Te.totalTime + 100)
								}), this._state = 1, this._containerInstance._startExitAnimation()
							}
							afterOpened() {
								return this._afterOpened
							}
							afterClosed() {
								return this._ref.closed
							}
							beforeClosed() {
								return this._beforeClosed
							}
							backdropClick() {
								return this._ref.backdropClick
							}
							keydownEvents() {
								return this._ref.keydownEvents
							}
							updatePosition(pe) {
								let Te = this._ref.config.positionStrategy;
								return pe && (pe.left || pe.right) ? pe.left ? Te.left(pe.left) : Te.right(pe.right) : Te.centerHorizontally(), pe && (pe.top || pe.bottom) ? pe.top ? Te.top(pe.top) : Te.bottom(pe.bottom) : Te.centerVertically(), this._ref.updatePosition(), this
							}
							updateSize(pe = "", Te = "") {
								return this._ref.updateSize(pe, Te), this
							}
							addPanelClass(pe) {
								return this._ref.addPanelClass(pe), this
							}
							removePanelClass(pe) {
								return this._ref.removePanelClass(pe), this
							}
							getState() {
								return this._state
							}
							_finishDialogClose() {
								this._state = 2, this._ref.close(this._result, {
									focusOrigin: this._closeInteractionType
								}), this.componentInstance = null
							}
						}
						const Pn = new D.OlP("MatMdcDialogData"),
							mn = new D.OlP("mat-mdc-dialog-default-options"),
							Un = new D.OlP("mat-mdc-dialog-scroll-strategy"),
							Vn = {
								provide: Un,
								deps: [p.aV],
								useFactory: function Kn(Xe) {
									return () => Xe.scrollStrategies.block()
								}
							};
						let bn = 0,
							Bn = (() => {
								class Xe {
									get openDialogs() {
										return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel
									}
									get afterOpened() {
										return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel
									}
									_getAfterAllClosed() {
										const Te = this._parentDialog;
										return Te ? Te._getAfterAllClosed() : this._afterAllClosedAtThisLevel
									}
									constructor(Te, Je, yt, Ht, pn, $t, hn, kt, ct, De) {
										this._overlay = Te, this._defaultOptions = yt, this._parentDialog = Ht, this._dialogRefConstructor = hn, this._dialogContainerType = kt, this._dialogDataToken = ct, this._openDialogsAtThisLevel = [], this._afterAllClosedAtThisLevel = new Y.x, this._afterOpenedAtThisLevel = new Y.x, this._idPrefix = "mat-dialog-", this.dialogConfigClass = ze, this.afterAllClosed = (0, G.P)(() => this.openDialogs.length ? this._getAfterAllClosed() : this._getAfterAllClosed().pipe((0, te.O)(void 0))), this._scrollStrategy = $t, this._dialog = Je.get(ke)
									}
									open(Te, Je) {
										let yt;
										(Je = {
											...this._defaultOptions || new ze,
											...Je
										}).id = Je.id || `${this._idPrefix}${bn++}`, Je.scrollStrategy = Je.scrollStrategy || this._scrollStrategy();
										const Ht = this._dialog.open(Te, {
											...Je,
											positionStrategy: this._overlay.position().global().centerHorizontally().centerVertically(),
											disableClose: !0,
											closeOnDestroy: !1,
											container: {
												type: this._dialogContainerType,
												providers: () => [{
													provide: this.dialogConfigClass,
													useValue: Je
												}, {
													provide: oe,
													useValue: Je
												}]
											},
											templateContext: () => ({
												dialogRef: yt
											}),
											providers: (pn, $t, hn) => (yt = new this._dialogRefConstructor(pn, Je, hn), yt.updatePosition(Je?.position), [{
												provide: this._dialogContainerType,
												useValue: hn
											}, {
												provide: this._dialogDataToken,
												useValue: $t.data
											}, {
												provide: this._dialogRefConstructor,
												useValue: yt
											}])
										});
										return yt.componentInstance = Ht.componentInstance, this.openDialogs.push(yt), this.afterOpened.next(yt), yt.afterClosed().subscribe(() => {
											const pn = this.openDialogs.indexOf(yt);
											pn > -1 && (this.openDialogs.splice(pn, 1), this.openDialogs.length || this._getAfterAllClosed().next())
										}), yt
									}
									closeAll() {
										this._closeDialogs(this.openDialogs)
									}
									getDialogById(Te) {
										return this.openDialogs.find(Je => Je.id === Te)
									}
									ngOnDestroy() {
										this._closeDialogs(this._openDialogsAtThisLevel), this._afterAllClosedAtThisLevel.complete(), this._afterOpenedAtThisLevel.complete()
									}
									_closeDialogs(Te) {
										let Je = Te.length;
										for (; Je--;) Te[Je].close()
									}
								}
								return Xe.\u0275fac = function(Te) {
									D.$Z()
								}, Xe.\u0275prov = D.Yz7({
									token: Xe,
									factory: Xe.\u0275fac
								}), Xe
							})(),
							qt = (() => {
								class Xe extends Bn {
									constructor(Te, Je, yt, Ht, pn, $t, hn, kt) {
										super(Te, Je, Ht, $t, hn, pn, cn, Qt, Pn, kt), this._idPrefix = "mat-mdc-dialog-"
									}
								}
								return Xe.\u0275fac = function(Te) {
									return new(Te || Xe)(D.LFG(p.aV), D.LFG(D.zs3), D.LFG(y.Ye, 8), D.LFG(mn, 8), D.LFG(Un), D.LFG(Xe, 12), D.LFG(p.Xj), D.LFG(D.QbO, 8))
								}, Xe.\u0275prov = D.Yz7({
									token: Xe,
									factory: Xe.\u0275fac
								}), Xe
							})(),
							hr = (() => {
								class Xe {}
								return Xe.\u0275fac = function(Te) {
									return new(Te || Xe)
								}, Xe.\u0275mod = D.oAB({
									type: Xe
								}), Xe.\u0275inj = D.cJS({
									providers: [qt, Vn],
									imports: [ft, p.U8, P.eL, et.BQ, et.BQ]
								}), Xe
							})()
					}, 4510: (be, ue, E) => {
						E.d(ue, {
							Dx: () => ar,
							H7: () => yn,
							b2: () => tn,
							q6: () => Zt,
							se: () => lt
						});
						var p = E(7774),
							y = E(3991);
						class D extends p.w_ {
							constructor() {
								super(...arguments), this.supportsDOMEvents = !0
							}
						}
						class z extends D {
							static makeCurrent() {
								(0, p.HT)(new z)
							}
							onAndCancel(Ie, ge, Ke) {
								return Ie.addEventListener(ge, Ke, !1), () => {
									Ie.removeEventListener(ge, Ke, !1)
								}
							}
							dispatchEvent(Ie, ge) {
								Ie.dispatchEvent(ge)
							}
							remove(Ie) {
								Ie.parentNode && Ie.parentNode.removeChild(Ie)
							}
							createElement(Ie, ge) {
								return (ge = ge || this.getDefaultDocument()).createElement(Ie)
							}
							createHtmlDocument() {
								return document.implementation.createHTMLDocument("fakeTitle")
							}
							getDefaultDocument() {
								return document
							}
							isElementNode(Ie) {
								return Ie.nodeType === Node.ELEMENT_NODE
							}
							isShadowRoot(Ie) {
								return Ie instanceof DocumentFragment
							}
							getGlobalEventTarget(Ie, ge) {
								return "window" === ge ? window : "document" === ge ? Ie : "body" === ge ? Ie.body : null
							}
							getBaseHref(Ie) {
								const ge = function P() {
									return ee = ee || document.querySelector("base"), ee ? ee.getAttribute("href") : null
								}();
								return null == ge ? null : function Y(Me) {
									N = N || document.createElement("a"), N.setAttribute("href", Me);
									const Ie = N.pathname;
									return "/" === Ie.charAt(0) ? Ie : `/${Ie}`
								}(ge)
							}
							resetBaseElement() {
								ee = null
							}
							getUserAgent() {
								return window.navigator.userAgent
							}
							getCookie(Ie) {
								return (0, p.Mx)(document.cookie, Ie)
							}
						}
						let N, ee = null;
						const G = new y.OlP("TRANSITION_ID"),
							X = [{
								provide: y.ip1,
								useFactory: function Q(Me, Ie, ge) {
									return () => {
										ge.get(y.CZH).donePromise.then(() => {
											const Ke = (0, p.q)(),
												Tt = Ie.querySelectorAll(`style[ng-transition="${Me}"]`);
											for (let Xt = 0; Xt < Tt.length; Xt++) Ke.remove(Tt[Xt])
										})
									}
								},
								deps: [G, p.K0, y.zs3],
								multi: !0
							}];
						let ie = (() => {
							class Me {
								build() {
									return new XMLHttpRequest
								}
							}
							return Me.\u0275fac = function(ge) {
								return new(ge || Me)
							}, Me.\u0275prov = y.Yz7({
								token: Me,
								factory: Me.\u0275fac
							}), Me
						})();
						const oe = new y.OlP("EventManagerPlugins");
						let we = (() => {
							class Me {
								constructor(ge, Ke) {
									this._zone = Ke, this._eventNameToPlugin = new Map, ge.forEach(Tt => Tt.manager = this), this._plugins = ge.slice().reverse()
								}
								addEventListener(ge, Ke, Tt) {
									return this._findPluginFor(Ke).addEventListener(ge, Ke, Tt)
								}
								addGlobalEventListener(ge, Ke, Tt) {
									return this._findPluginFor(Ke).addGlobalEventListener(ge, Ke, Tt)
								}
								getZone() {
									return this._zone
								}
								_findPluginFor(ge) {
									const Ke = this._eventNameToPlugin.get(ge);
									if (Ke) return Ke;
									const Tt = this._plugins;
									for (let Xt = 0; Xt < Tt.length; Xt++) {
										const Tn = Tt[Xt];
										if (Tn.supports(ge)) return this._eventNameToPlugin.set(ge, Tn), Tn
									}
									throw new Error(`No event manager plugin found for event ${ge}`)
								}
							}
							return Me.\u0275fac = function(ge) {
								return new(ge || Me)(y.LFG(oe), y.LFG(y.R0b))
							}, Me.\u0275prov = y.Yz7({
								token: Me,
								factory: Me.\u0275fac
							}), Me
						})();
						class Fe {
							constructor(Ie) {
								this._doc = Ie
							}
							addGlobalEventListener(Ie, ge, Ke) {
								const Tt = (0, p.q)().getGlobalEventTarget(this._doc, Ie);
								if (!Tt) throw new Error(`Unsupported event target ${Tt} for event ${ge}`);
								return this.addEventListener(Tt, ge, Ke)
							}
						}
						let Le = (() => {
								class Me {
									constructor() {
										this._stylesSet = new Set
									}
									addStyles(ge) {
										const Ke = new Set;
										ge.forEach(Tt => {
											this._stylesSet.has(Tt) || (this._stylesSet.add(Tt), Ke.add(Tt))
										}), this.onStylesAdded(Ke)
									}
									onStylesAdded(ge) {}
									getAllStyles() {
										return Array.from(this._stylesSet)
									}
								}
								return Me.\u0275fac = function(ge) {
									return new(ge || Me)
								}, Me.\u0275prov = y.Yz7({
									token: Me,
									factory: Me.\u0275fac
								}), Me
							})(),
							je = (() => {
								class Me extends Le {
									constructor(ge) {
										super(), this._doc = ge, this._hostNodes = new Map, this._hostNodes.set(ge.head, [])
									}
									_addStylesToHost(ge, Ke, Tt) {
										ge.forEach(Xt => {
											const Tn = this._doc.createElement("style");
											Tn.textContent = Xt, Tt.push(Ke.appendChild(Tn))
										})
									}
									addHost(ge) {
										const Ke = [];
										this._addStylesToHost(this._stylesSet, ge, Ke), this._hostNodes.set(ge, Ke)
									}
									removeHost(ge) {
										const Ke = this._hostNodes.get(ge);
										Ke && Ke.forEach(Ce), this._hostNodes.delete(ge)
									}
									onStylesAdded(ge) {
										this._hostNodes.forEach((Ke, Tt) => {
											this._addStylesToHost(ge, Tt, Ke)
										})
									}
									ngOnDestroy() {
										this._hostNodes.forEach(ge => ge.forEach(Ce))
									}
								}
								return Me.\u0275fac = function(ge) {
									return new(ge || Me)(y.LFG(p.K0))
								}, Me.\u0275prov = y.Yz7({
									token: Me,
									factory: Me.\u0275fac
								}), Me
							})();

						function Ce(Me) {
							(0, p.q)().remove(Me)
						}
						const F = {
								svg: "http://www.w3.org/2000/svg",
								xhtml: "http://www.w3.org/1999/xhtml",
								xlink: "http://www.w3.org/1999/xlink",
								xml: "http://www.w3.org/XML/1998/namespace",
								xmlns: "http://www.w3.org/2000/xmlns/",
								math: "http://www.w3.org/1998/MathML/"
							},
							xe = /%COMP%/g;

						function Pt(Me, Ie) {
							return Ie.flat(100).map(ge => ge.replace(xe, Me))
						}

						function at(Me) {
							return Ie => {
								if ("__ngUnwrap__" === Ie) return Me;
								!1 === Me(Ie) && (Ie.preventDefault(), Ie.returnValue = !1)
							}
						}
						let lt = (() => {
							class Me {
								constructor(ge, Ke, Tt) {
									this.eventManager = ge, this.sharedStylesHost = Ke, this.appId = Tt, this.rendererByCompId = new Map, this.defaultRenderer = new et(ge)
								}
								createRenderer(ge, Ke) {
									if (!ge || !Ke) return this.defaultRenderer;
									switch (Ke.encapsulation) {
										case y.ifc.Emulated: {
											let Tt = this.rendererByCompId.get(Ke.id);
											return Tt || (Tt = new it(this.eventManager, this.sharedStylesHost, Ke, this.appId), this.rendererByCompId.set(Ke.id, Tt)), Tt.applyToHost(ge), Tt
										}
										case y.ifc.ShadowDom:
											return new ce(this.eventManager, this.sharedStylesHost, ge, Ke);
										default:
											if (!this.rendererByCompId.has(Ke.id)) {
												const Tt = Pt(Ke.id, Ke.styles);
												this.sharedStylesHost.addStyles(Tt), this.rendererByCompId.set(Ke.id, this.defaultRenderer)
											}
											return this.defaultRenderer
									}
								}
								begin() {}
								end() {}
							}
							return Me.\u0275fac = function(ge) {
								return new(ge || Me)(y.LFG(we), y.LFG(je), y.LFG(y.AFp))
							}, Me.\u0275prov = y.Yz7({
								token: Me,
								factory: Me.\u0275fac
							}), Me
						})();
						class et {
							constructor(Ie) {
								this.eventManager = Ie, this.data = Object.create(null), this.destroyNode = null
							}
							destroy() {}
							createElement(Ie, ge) {
								return ge ? document.createElementNS(F[ge] || ge, Ie) : document.createElement(Ie)
							}
							createComment(Ie) {
								return document.createComment(Ie)
							}
							createText(Ie) {
								return document.createTextNode(Ie)
							}
							appendChild(Ie, ge) {
								(ze(Ie) ? Ie.content : Ie).appendChild(ge)
							}
							insertBefore(Ie, ge, Ke) {
								Ie && (ze(Ie) ? Ie.content : Ie).insertBefore(ge, Ke)
							}
							removeChild(Ie, ge) {
								Ie && Ie.removeChild(ge)
							}
							selectRootElement(Ie, ge) {
								let Ke = "string" == typeof Ie ? document.querySelector(Ie) : Ie;
								if (!Ke) throw new Error(`The selector "${Ie}" did not match any elements`);
								return ge || (Ke.textContent = ""), Ke
							}
							parentNode(Ie) {
								return Ie.parentNode
							}
							nextSibling(Ie) {
								return Ie.nextSibling
							}
							setAttribute(Ie, ge, Ke, Tt) {
								if (Tt) {
									ge = Tt + ":" + ge;
									const Xt = F[Tt];
									Xt ? Ie.setAttributeNS(Xt, ge, Ke) : Ie.setAttribute(ge, Ke)
								} else Ie.setAttribute(ge, Ke)
							}
							removeAttribute(Ie, ge, Ke) {
								if (Ke) {
									const Tt = F[Ke];
									Tt ? Ie.removeAttributeNS(Tt, ge) : Ie.removeAttribute(`${Ke}:${ge}`)
								} else Ie.removeAttribute(ge)
							}
							addClass(Ie, ge) {
								Ie.classList.add(ge)
							}
							removeClass(Ie, ge) {
								Ie.classList.remove(ge)
							}
							setStyle(Ie, ge, Ke, Tt) {
								Tt & (y.JOm.DashCase | y.JOm.Important) ? Ie.style.setProperty(ge, Ke, Tt & y.JOm.Important ? "important" : "") : Ie.style[ge] = Ke
							}
							removeStyle(Ie, ge, Ke) {
								Ke & y.JOm.DashCase ? Ie.style.removeProperty(ge) : Ie.style[ge] = ""
							}
							setProperty(Ie, ge, Ke) {
								Ie[ge] = Ke
							}
							setValue(Ie, ge) {
								Ie.nodeValue = ge
							}
							listen(Ie, ge, Ke) {
								return "string" == typeof Ie ? this.eventManager.addGlobalEventListener(Ie, ge, at(Ke)) : this.eventManager.addEventListener(Ie, ge, at(Ke))
							}
						}

						function ze(Me) {
							return "TEMPLATE" === Me.tagName && void 0 !== Me.content
						}
						class it extends et {
							constructor(Ie, ge, Ke, Tt) {
								super(Ie), this.component = Ke;
								const Xt = Pt(Tt + "-" + Ke.id, Ke.styles);
								ge.addStyles(Xt), this.contentAttr = function ft(Me) {
									return "_ngcontent-%COMP%".replace(xe, Me)
								}(Tt + "-" + Ke.id), this.hostAttr = function nt(Me) {
									return "_nghost-%COMP%".replace(xe, Me)
								}(Tt + "-" + Ke.id)
							}
							applyToHost(Ie) {
								super.setAttribute(Ie, this.hostAttr, "")
							}
							createElement(Ie, ge) {
								const Ke = super.createElement(Ie, ge);
								return super.setAttribute(Ke, this.contentAttr, ""), Ke
							}
						}
						class ce extends et {
							constructor(Ie, ge, Ke, Tt) {
								super(Ie), this.sharedStylesHost = ge, this.hostEl = Ke, this.shadowRoot = Ke.attachShadow({
									mode: "open"
								}), this.sharedStylesHost.addHost(this.shadowRoot);
								const Xt = Pt(Tt.id, Tt.styles);
								for (let Tn = 0; Tn < Xt.length; Tn++) {
									const Zn = document.createElement("style");
									Zn.textContent = Xt[Tn], this.shadowRoot.appendChild(Zn)
								}
							}
							nodeOrShadowRoot(Ie) {
								return Ie === this.hostEl ? this.shadowRoot : Ie
							}
							destroy() {
								this.sharedStylesHost.removeHost(this.shadowRoot)
							}
							appendChild(Ie, ge) {
								return super.appendChild(this.nodeOrShadowRoot(Ie), ge)
							}
							insertBefore(Ie, ge, Ke) {
								return super.insertBefore(this.nodeOrShadowRoot(Ie), ge, Ke)
							}
							removeChild(Ie, ge) {
								return super.removeChild(this.nodeOrShadowRoot(Ie), ge)
							}
							parentNode(Ie) {
								return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(Ie)))
							}
						}
						let ht = (() => {
							class Me extends Fe {
								constructor(ge) {
									super(ge)
								}
								supports(ge) {
									return !0
								}
								addEventListener(ge, Ke, Tt) {
									return ge.addEventListener(Ke, Tt, !1), () => this.removeEventListener(ge, Ke, Tt)
								}
								removeEventListener(ge, Ke, Tt) {
									return ge.removeEventListener(Ke, Tt)
								}
							}
							return Me.\u0275fac = function(ge) {
								return new(ge || Me)(y.LFG(p.K0))
							}, Me.\u0275prov = y.Yz7({
								token: Me,
								factory: Me.\u0275fac
							}), Me
						})();
						const Pe = ["alt", "control", "meta", "shift"],
							pt = {
								"\b": "Backspace",
								"\t": "Tab",
								"\x7f": "Delete",
								"\x1b": "Escape",
								Del: "Delete",
								Esc: "Escape",
								Left: "ArrowLeft",
								Right: "ArrowRight",
								Up: "ArrowUp",
								Down: "ArrowDown",
								Menu: "ContextMenu",
								Scroll: "ScrollLock",
								Win: "OS"
							},
							Bt = {
								alt: Me => Me.altKey,
								control: Me => Me.ctrlKey,
								meta: Me => Me.metaKey,
								shift: Me => Me.shiftKey
							};
						let ot = (() => {
							class Me extends Fe {
								constructor(ge) {
									super(ge)
								}
								supports(ge) {
									return null != Me.parseEventName(ge)
								}
								addEventListener(ge, Ke, Tt) {
									const Xt = Me.parseEventName(Ke),
										Tn = Me.eventCallback(Xt.fullKey, Tt, this.manager.getZone());
									return this.manager.getZone().runOutsideAngular(() => (0, p.q)().onAndCancel(ge, Xt.domEventName, Tn))
								}
								static parseEventName(ge) {
									const Ke = ge.toLowerCase().split("."),
										Tt = Ke.shift();
									if (0 === Ke.length || "keydown" !== Tt && "keyup" !== Tt) return null;
									const Xt = Me._normalizeKey(Ke.pop());
									let Tn = "",
										Zn = Ke.indexOf("code");
									if (Zn > -1 && (Ke.splice(Zn, 1), Tn = "code."), Pe.forEach(Pr => {
											const vt = Ke.indexOf(Pr);
											vt > -1 && (Ke.splice(vt, 1), Tn += Pr + ".")
										}), Tn += Xt, 0 != Ke.length || 0 === Xt.length) return null;
									const pr = {};
									return pr.domEventName = Tt, pr.fullKey = Tn, pr
								}
								static matchEventFullKeyCode(ge, Ke) {
									let Tt = pt[ge.key] || ge.key,
										Xt = "";
									return Ke.indexOf("code.") > -1 && (Tt = ge.code, Xt = "code."), !(null == Tt || !Tt) && (Tt = Tt.toLowerCase(), " " === Tt ? Tt = "space" : "." === Tt && (Tt = "dot"), Pe.forEach(Tn => {
										Tn !== Tt && (0, Bt[Tn])(ge) && (Xt += Tn + ".")
									}), Xt += Tt, Xt === Ke)
								}
								static eventCallback(ge, Ke, Tt) {
									return Xt => {
										Me.matchEventFullKeyCode(Xt, ge) && Tt.runGuarded(() => Ke(Xt))
									}
								}
								static _normalizeKey(ge) {
									return "esc" === ge ? "escape" : ge
								}
							}
							return Me.\u0275fac = function(ge) {
								return new(ge || Me)(y.LFG(p.K0))
							}, Me.\u0275prov = y.Yz7({
								token: Me,
								factory: Me.\u0275fac
							}), Me
						})();
						const Zt = (0, y.eFA)(y._c5, "browser", [{
								provide: y.Lbi,
								useValue: p.bD
							}, {
								provide: y.g9A,
								useValue: function mn() {
									z.makeCurrent()
								},
								multi: !0
							}, {
								provide: p.K0,
								useFactory: function Kn() {
									return (0, y.RDi)(document), document
								},
								deps: []
							}]),
							bn = new y.OlP(""),
							Bn = [{
								provide: y.rWj,
								useClass: class te {
									addToWindow(Ie) {
										y.dqk.getAngularTestability = (Ke, Tt = !0) => {
											const Xt = Ie.findTestabilityInTree(Ke, Tt);
											if (null == Xt) throw new Error("Could not find testability for element.");
											return Xt
										}, y.dqk.getAllAngularTestabilities = () => Ie.getAllTestabilities(), y.dqk.getAllAngularRootElements = () => Ie.getAllRootElements(), y.dqk.frameworkStabilizers || (y.dqk.frameworkStabilizers = []), y.dqk.frameworkStabilizers.push(Ke => {
											const Tt = y.dqk.getAllAngularTestabilities();
											let Xt = Tt.length,
												Tn = !1;
											const Zn = function(pr) {
												Tn = Tn || pr, Xt--, 0 == Xt && Ke(Tn)
											};
											Tt.forEach(function(pr) {
												pr.whenStable(Zn)
											})
										})
									}
									findTestabilityInTree(Ie, ge, Ke) {
										return null == ge ? null : Ie.getTestability(ge) ?? (Ke ? (0, p.q)().isShadowRoot(ge) ? this.findTestabilityInTree(Ie, ge.host, !0) : this.findTestabilityInTree(Ie, ge.parentElement, !0) : null)
									}
								},
								deps: []
							}, {
								provide: y.lri,
								useClass: y.dDg,
								deps: [y.R0b, y.eoX, y.rWj]
							}, {
								provide: y.dDg,
								useClass: y.dDg,
								deps: [y.R0b, y.eoX, y.rWj]
							}],
							qt = [{
									provide: y.zSh,
									useValue: "root"
								}, {
									provide: y.qLn,
									useFactory: function Un() {
										return new y.qLn
									},
									deps: []
								}, {
									provide: oe,
									useClass: ht,
									multi: !0,
									deps: [p.K0, y.R0b, y.Lbi]
								}, {
									provide: oe,
									useClass: ot,
									multi: !0,
									deps: [p.K0]
								}, {
									provide: lt,
									useClass: lt,
									deps: [we, je, y.AFp]
								}, {
									provide: y.FYo,
									useExisting: lt
								}, {
									provide: Le,
									useExisting: je
								}, {
									provide: je,
									useClass: je,
									deps: [p.K0]
								}, {
									provide: we,
									useClass: we,
									deps: [oe, y.R0b]
								}, {
									provide: p.JF,
									useClass: ie,
									deps: []
								},
								[]
							];
						let tn = (() => {
								class Me {
									constructor(ge) {}
									static withServerTransition(ge) {
										return {
											ngModule: Me,
											providers: [{
												provide: y.AFp,
												useValue: ge.appId
											}, {
												provide: G,
												useExisting: y.AFp
											}, X]
										}
									}
								}
								return Me.\u0275fac = function(ge) {
									return new(ge || Me)(y.LFG(bn, 12))
								}, Me.\u0275mod = y.oAB({
									type: Me
								}), Me.\u0275inj = y.cJS({
									providers: [...qt, ...Bn],
									imports: [p.ez, y.hGG]
								}), Me
							})(),
							ar = (() => {
								class Me {
									constructor(ge) {
										this._doc = ge
									}
									getTitle() {
										return this._doc.title
									}
									setTitle(ge) {
										this._doc.title = ge || ""
									}
								}
								return Me.\u0275fac = function(ge) {
									return new(ge || Me)(y.LFG(p.K0))
								}, Me.\u0275prov = y.Yz7({
									token: Me,
									factory: function(ge) {
										let Ke = null;
										return Ke = ge ? new ge : function Nn() {
											return new ar((0, y.LFG)(p.K0))
										}(), Ke
									},
									providedIn: "root"
								}), Me
							})();
						typeof window < "u" && window;
						let yn = (() => {
								class Me {}
								return Me.\u0275fac = function(ge) {
									return new(ge || Me)
								}, Me.\u0275prov = y.Yz7({
									token: Me,
									factory: function(ge) {
										let Ke = null;
										return Ke = ge ? new(ge || Me) : y.LFG(Dn), Ke
									},
									providedIn: "root"
								}), Me
							})(),
							Dn = (() => {
								class Me extends yn {
									constructor(ge) {
										super(), this._doc = ge
									}
									sanitize(ge, Ke) {
										if (null == Ke) return null;
										switch (ge) {
											case y.q3G.NONE:
												return Ke;
											case y.q3G.HTML:
												return (0, y.qzn)(Ke, "HTML") ? (0, y.z3N)(Ke) : (0, y.EiD)(this._doc, String(Ke)).toString();
											case y.q3G.STYLE:
												return (0, y.qzn)(Ke, "Style") ? (0, y.z3N)(Ke) : Ke;
											case y.q3G.SCRIPT:
												if ((0, y.qzn)(Ke, "Script")) return (0, y.z3N)(Ke);
												throw new Error("unsafe value used in a script context");
											case y.q3G.URL:
												return (0, y.qzn)(Ke, "URL") ? (0, y.z3N)(Ke) : (0, y.mCW)(String(Ke));
											case y.q3G.RESOURCE_URL:
												if ((0, y.qzn)(Ke, "ResourceURL")) return (0, y.z3N)(Ke);
												throw new Error(`unsafe value used in a resource URL context (see ${y.JZr})`);
											default:
												throw new Error(`Unexpected SecurityContext ${ge} (see ${y.JZr})`)
										}
									}
									bypassSecurityTrustHtml(ge) {
										return (0, y.JVY)(ge)
									}
									bypassSecurityTrustStyle(ge) {
										return (0, y.L6k)(ge)
									}
									bypassSecurityTrustScript(ge) {
										return (0, y.eBb)(ge)
									}
									bypassSecurityTrustUrl(ge) {
										return (0, y.LAX)(ge)
									}
									bypassSecurityTrustResourceUrl(ge) {
										return (0, y.pB0)(ge)
									}
								}
								return Me.\u0275fac = function(ge) {
									return new(ge || Me)(y.LFG(p.K0))
								}, Me.\u0275prov = y.Yz7({
									token: Me,
									factory: function(ge) {
										let Ke = null;
										return Ke = ge ? new ge : function nr(Me) {
											return new Dn(Me.get(p.K0))
										}(y.LFG(y.zs3)), Ke
									},
									providedIn: "root"
								}), Me
							})()
					}, 6425: (be, ue, E) => {
						E.d(ue, {
							gz: () => oo,
							gk: () => Gt,
							m2: () => Et,
							Q3: () => Ot,
							OD: () => mt,
							Av: () => xn,
							F0: () => Ir,
							rH: () => wa,
							Od: () => Fo,
							Bz: () => Eu,
							lC: () => Qi,
							R9: () => Jt
						});
						var p = E(3991),
							y = E(3998),
							D = E(5195),
							z = E(3216),
							ee = E(8167),
							P = E(754),
							N = E(1785),
							Y = E(2588),
							G = E(602),
							Q = E(9099),
							X = E(4070),
							te = E(8440),
							ie = E(2292),
							oe = E(9681),
							we = E(5694);

						function Fe() {
							return (0, oe.e)((v, C) => {
								let g = null;
								v._refCount++;
								const b = (0, we.x)(C, void 0, void 0, void 0, () => {
									if (!v || v._refCount <= 0 || 0 < --v._refCount) return void(g = null);
									const x = v._connection,
										re = g;
									g = null, x && (!re || x === re) && x.unsubscribe(), C.unsubscribe()
								});
								v.subscribe(b), b.closed || (g = v.connect())
							})
						}
						class Le extends X.y {
							constructor(C, g) {
								super(), this.source = C, this.subjectFactory = g, this._subject = null, this._refCount = 0, this._connection = null, (0, oe.A)(C) && (this.lift = C.lift)
							}
							_subscribe(C) {
								return this.getSubject().subscribe(C)
							}
							getSubject() {
								const C = this._subject;
								return (!C || C.isStopped) && (this._subject = this.subjectFactory()), this._subject
							}
							_teardown() {
								this._refCount = 0;
								const {
									_connection: C
								} = this;
								this._subject = this._connection = null, C?.unsubscribe()
							}
							connect() {
								let C = this._connection;
								if (!C) {
									C = this._connection = new ie.w0;
									const g = this.getSubject();
									C.add(this.source.subscribe((0, we.x)(g, void 0, () => {
										this._teardown(), g.complete()
									}, b => {
										this._teardown(), g.error(b)
									}, () => this._teardown()))), C.closed && (this._connection = null, C = ie.w0.EMPTY)
								}
								return C
							}
							refCount() {
								return Fe()(this)
							}
						}
						var je = E(8264),
							Ce = E(7774),
							F = E(7580),
							xe = E(1565),
							Ee = E(2653),
							Ue = E(1743),
							ke = E(9754),
							Ge = E(6443),
							ft = E(3710),
							nt = E(6424),
							Pt = E(7374),
							at = E(2837),
							lt = E(3356);

						function et(v) {
							return v <= 0 ? () => te.E : (0, oe.e)((C, g) => {
								let b = [];
								C.subscribe((0, we.x)(g, x => {
									b.push(x), v < b.length && b.shift()
								}, () => {
									for (const x of b) g.next(x);
									g.complete()
								}, void 0, () => {
									b = null
								}))
							})
						}
						var Se = E(8827),
							Be = E(2595),
							ze = E(4874);

						function it(v, C) {
							const g = arguments.length >= 2;
							return b => b.pipe(v ? (0, ke.h)((x, re) => v(x, re, b)) : ze.y, et(1), g ? (0, Be.d)(C) : (0, Se.T)(() => new ee.K))
						}
						var ht = E(3532);

						function Pe(v) {
							return (0, oe.e)((C, g) => {
								try {
									C.subscribe(g)
								} finally {
									g.add(v)
								}
							})
						}
						var pt = E(3834),
							Bt = E(4510);
						const ot = "primary",
							Vt = Symbol("RouteTitle");
						class Qt {
							constructor(C) {
								this.params = C || {}
							}
							has(C) {
								return Object.prototype.hasOwnProperty.call(this.params, C)
							}
							get(C) {
								if (this.has(C)) {
									const g = this.params[C];
									return Array.isArray(g) ? g[0] : g
								}
								return null
							}
							getAll(C) {
								if (this.has(C)) {
									const g = this.params[C];
									return Array.isArray(g) ? g : [g]
								}
								return []
							}
							get keys() {
								return Object.keys(this.params)
							}
						}

						function cn(v) {
							return new Qt(v)
						}

						function Sn(v, C, g) {
							const b = g.path.split("/");
							if (b.length > v.length || "full" === g.pathMatch && (C.hasChildren() || b.length < v.length)) return null;
							const x = {};
							for (let re = 0; re < b.length; re++) {
								const de = b[re],
									We = v[re];
								if (de.startsWith(":")) x[de.substring(1)] = We;
								else if (de !== We.path) return null
							}
							return {
								consumed: v.slice(0, b.length),
								posParams: x
							}
						}

						function mn(v, C) {
							const g = v ? Object.keys(v) : void 0,
								b = C ? Object.keys(C) : void 0;
							if (!g || !b || g.length != b.length) return !1;
							let x;
							for (let re = 0; re < g.length; re++)
								if (x = g[re], !Un(v[x], C[x])) return !1;
							return !0
						}

						function Un(v, C) {
							if (Array.isArray(v) && Array.isArray(C)) {
								if (v.length !== C.length) return !1;
								const g = [...v].sort(),
									b = [...C].sort();
								return g.every((x, re) => b[re] === x)
							}
							return v === C
						}

						function Kn(v) {
							return Array.prototype.concat.apply([], v)
						}

						function Vn(v) {
							return v.length > 0 ? v[v.length - 1] : null
						}

						function bn(v, C) {
							for (const g in v) v.hasOwnProperty(g) && C(v[g], g)
						}

						function Bn(v) {
							return (0, p.CqO)(v) ? v : (0, p.QGY)(v) ? (0, y.D)(Promise.resolve(v)) : (0, D.of)(v)
						}
						const qt = !1,
							tn = {
								exact: function Nn(v, C, g) {
									if (!yt(v.segments, C.segments) || !Nt(v.segments, C.segments, g) || v.numberOfChildren !== C.numberOfChildren) return !1;
									for (const b in C.children)
										if (!v.children[b] || !Nn(v.children[b], C.children[b], g)) return !1;
									return !0
								},
								subset: hr
							},
							en = {
								exact: function Wn(v, C) {
									return mn(v, C)
								},
								subset: function ar(v, C) {
									return Object.keys(C).length <= Object.keys(v).length && Object.keys(C).every(g => Un(v[g], C[g]))
								},
								ignored: () => !0
							};

						function Qn(v, C, g) {
							return tn[g.paths](v.root, C.root, g.matrixParams) && en[g.queryParams](v.queryParams, C.queryParams) && !("exact" === g.fragment && v.fragment !== C.fragment)
						}

						function hr(v, C, g) {
							return un(v, C, C.segments, g)
						}

						function un(v, C, g, b) {
							if (v.segments.length > g.length) {
								const x = v.segments.slice(0, g.length);
								return !(!yt(x, g) || C.hasChildren() || !Nt(x, g, b))
							}
							if (v.segments.length === g.length) {
								if (!yt(v.segments, g) || !Nt(v.segments, g, b)) return !1;
								for (const x in C.children)
									if (!v.children[x] || !hr(v.children[x], C.children[x], b)) return !1;
								return !0
							} {
								const x = g.slice(0, v.segments.length),
									re = g.slice(v.segments.length);
								return !!(yt(v.segments, x) && Nt(v.segments, x, b) && v.children[ot]) && un(v.children[ot], C, re, b)
							}
						}

						function Nt(v, C, g) {
							return C.every((b, x) => en[g](v[x].parameters, b.parameters))
						}
						class Xe {
							constructor(C = new pe([], {}), g = {}, b = null) {
								this.root = C, this.queryParams = g, this.fragment = b
							}
							get queryParamMap() {
								return this._queryParamMap || (this._queryParamMap = cn(this.queryParams)), this._queryParamMap
							}
							toString() {
								return hn.serialize(this)
							}
						}
						class pe {
							constructor(C, g) {
								this.segments = C, this.children = g, this.parent = null, bn(g, (b, x) => b.parent = this)
							}
							hasChildren() {
								return this.numberOfChildren > 0
							}
							get numberOfChildren() {
								return Object.keys(this.children).length
							}
							toString() {
								return kt(this)
							}
						}
						class Te {
							constructor(C, g) {
								this.path = C, this.parameters = g
							}
							get parameterMap() {
								return this._parameterMap || (this._parameterMap = cn(this.parameters)), this._parameterMap
							}
							toString() {
								return Ne(this)
							}
						}

						function yt(v, C) {
							return v.length === C.length && v.every((g, b) => g.path === C[b].path)
						}
						let pn = (() => {
							class v {}
							return v.\u0275fac = function(g) {
								return new(g || v)
							}, v.\u0275prov = p.Yz7({
								token: v,
								factory: function() {
									return new $t
								},
								providedIn: "root"
							}), v
						})();
						class $t {
							parse(C) {
								const g = new En(C);
								return new Xe(g.parseRootSegment(), g.parseQueryParams(), g.parseFragment())
							}
							serialize(C) {
								const g = `/${ct(C.root,!0)}`,
									b = function Ft(v) {
										const C = Object.keys(v).map(g => {
											const b = v[g];
											return Array.isArray(b) ? b.map(x => `${B(g)}=${B(x)}`).join("&") : `${B(g)}=${B(b)}`
										}).filter(g => !!g);
										return C.length ? `?${C.join("&")}` : ""
									}(C.queryParams);
								return `${g}${b}${"string"==typeof C.fragment?`#${function J(v){return encodeURI(v)}(C.fragment)}`:""}`
							}
						}
						const hn = new $t;

						function kt(v) {
							return v.segments.map(C => Ne(C)).join("/")
						}

						function ct(v, C) {
							if (!v.hasChildren()) return kt(v);
							if (C) {
								const g = v.children[ot] ? ct(v.children[ot], !1) : "",
									b = [];
								return bn(v.children, (x, re) => {
									re !== ot && b.push(`${re}:${ct(x,!1)}`)
								}), b.length > 0 ? `${g}(${b.join("//")})` : g
							} {
								const g = function Ht(v, C) {
									let g = [];
									return bn(v.children, (b, x) => {
										x === ot && (g = g.concat(C(b, x)))
									}), bn(v.children, (b, x) => {
										x !== ot && (g = g.concat(C(b, x)))
									}), g
								}(v, (b, x) => x === ot ? [ct(v.children[ot], !1)] : [`${x}:${ct(b,!1)}`]);
								return 1 === Object.keys(v.children).length && null != v.children[ot] ? `${kt(v)}/${g[0]}` : `${kt(v)}/(${g.join("//")})`
							}
						}

						function De(v) {
							return encodeURIComponent(v).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",")
						}

						function B(v) {
							return De(v).replace(/%3B/gi, ";")
						}

						function k(v) {
							return De(v).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&")
						}

						function H(v) {
							return decodeURIComponent(v)
						}

						function ne(v) {
							return H(v.replace(/\+/g, "%20"))
						}

						function Ne(v) {
							return `${k(v.path)}${function Ye(v){return Object.keys(v).map(C=>`;${k(C)}=${k(v[C])}`).join("")}(v.parameters)}`
						}
						const an = /^[^\/()?;=#]+/;

						function xt(v) {
							const C = v.match(an);
							return C ? C[0] : ""
						}
						const ln = /^[^=?&#]+/,
							nr = /^[^&#]+/;
						class En {
							constructor(C) {
								this.url = C, this.remaining = C
							}
							parseRootSegment() {
								return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new pe([], {}) : new pe([], this.parseChildren())
							}
							parseQueryParams() {
								const C = {};
								if (this.consumeOptional("?"))
									do {
										this.parseQueryParam(C)
									} while (this.consumeOptional("&"));
								return C
							}
							parseFragment() {
								return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null
							}
							parseChildren() {
								if ("" === this.remaining) return {};
								this.consumeOptional("/");
								const C = [];
								for (this.peekStartsWith("(") || C.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");) this.capture("/"), C.push(this.parseSegment());
								let g = {};
								this.peekStartsWith("/(") && (this.capture("/"), g = this.parseParens(!0));
								let b = {};
								return this.peekStartsWith("(") && (b = this.parseParens(!1)), (C.length > 0 || Object.keys(g).length > 0) && (b[ot] = new pe(C, g)), b
							}
							parseSegment() {
								const C = xt(this.remaining);
								if ("" === C && this.peekStartsWith(";")) throw new p.vHH(4009, qt);
								return this.capture(C), new Te(H(C), this.parseMatrixParams())
							}
							parseMatrixParams() {
								const C = {};
								for (; this.consumeOptional(";");) this.parseParam(C);
								return C
							}
							parseParam(C) {
								const g = xt(this.remaining);
								if (!g) return;
								this.capture(g);
								let b = "";
								if (this.consumeOptional("=")) {
									const x = xt(this.remaining);
									x && (b = x, this.capture(b))
								}
								C[H(g)] = H(b)
							}
							parseQueryParam(C) {
								const g = function yn(v) {
									const C = v.match(ln);
									return C ? C[0] : ""
								}(this.remaining);
								if (!g) return;
								this.capture(g);
								let b = "";
								if (this.consumeOptional("=")) {
									const de = function Dn(v) {
										const C = v.match(nr);
										return C ? C[0] : ""
									}(this.remaining);
									de && (b = de, this.capture(b))
								}
								const x = ne(g),
									re = ne(b);
								if (C.hasOwnProperty(x)) {
									let de = C[x];
									Array.isArray(de) || (de = [de], C[x] = de), de.push(re)
								} else C[x] = re
							}
							parseParens(C) {
								const g = {};
								for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) {
									const b = xt(this.remaining),
										x = this.remaining[b.length];
									if ("/" !== x && ")" !== x && ";" !== x) throw new p.vHH(4010, qt);
									let re;
									b.indexOf(":") > -1 ? (re = b.slice(0, b.indexOf(":")), this.capture(re), this.capture(":")) : C && (re = ot);
									const de = this.parseChildren();
									g[re] = 1 === Object.keys(de).length ? de[ot] : new pe([], de), this.consumeOptional("//")
								}
								return g
							}
							peekStartsWith(C) {
								return this.remaining.startsWith(C)
							}
							consumeOptional(C) {
								return !!this.peekStartsWith(C) && (this.remaining = this.remaining.substring(C.length), !0)
							}
							capture(C) {
								if (!this.consumeOptional(C)) throw new p.vHH(4011, qt)
							}
						}

						function Me(v) {
							return v.segments.length > 0 ? new pe([], {
								[ot]: v
							}) : v
						}

						function Ie(v) {
							const C = {};
							for (const b of Object.keys(v.children)) {
								const re = Ie(v.children[b]);
								(re.segments.length > 0 || re.hasChildren()) && (C[b] = re)
							}
							return function ge(v) {
								if (1 === v.numberOfChildren && v.children[ot]) {
									const C = v.children[ot];
									return new pe(v.segments.concat(C.segments), C.children)
								}
								return v
							}(new pe(v.segments, C))
						}

						function Ke(v) {
							return v instanceof Xe
						}
						const Tt = !1;

						function pr(v, C, g, b, x) {
							if (0 === g.length) return ei(C.root, C.root, C.root, b, x);
							const re = function $r(v) {
								if ("string" == typeof v[0] && 1 === v.length && "/" === v[0]) return new Sr(!0, 0, v);
								let C = 0,
									g = !1;
								const b = v.reduce((x, re, de) => {
									if ("object" == typeof re && null != re) {
										if (re.outlets) {
											const We = {};
											return bn(re.outlets, (bt, Kt) => {
												We[Kt] = "string" == typeof bt ? bt.split("/") : bt
											}), [...x, {
												outlets: We
											}]
										}
										if (re.segmentPath) return [...x, re.segmentPath]
									}
									return "string" != typeof re ? [...x, re] : 0 === de ? (re.split("/").forEach((We, bt) => {
										0 == bt && "." === We || (0 == bt && "" === We ? g = !0 : ".." === We ? C++ : "" != We && x.push(We))
									}), x) : [...x, re]
								}, []);
								return new Sr(g, C, b)
							}(g);
							return re.toRoot() ? ei(C.root, C.root, new pe([], {}), b, x) : function de(bt) {
								const Kt = function V(v, C, g, b) {
										if (v.isAbsolute) return new Ur(C.root, !0, 0);
										if (-1 === b) return new Ur(g, g === C.root, 0);
										return function U(v, C, g) {
											let b = v,
												x = C,
												re = g;
											for (; re > x;) {
												if (re -= x, b = b.parent, !b) throw new p.vHH(4005, Tt && "Invalid number of '../'");
												x = b.segments.length
											}
											return new Ur(b, !1, x - re)
										}(g, b + (Pr(v.commands[0]) ? 0 : 1), v.numberOfDoubleDots)
									}(re, C, v.snapshot?._urlSegment, bt),
									on = Kt.processChildren ? T(Kt.segmentGroup, Kt.index, re.commands) : f(Kt.segmentGroup, Kt.index, re.commands);
								return ei(C.root, Kt.segmentGroup, on, b, x)
							}(v.snapshot?._lastPathIndex)
						}

						function Pr(v) {
							return "object" == typeof v && null != v && !v.outlets && !v.segmentPath
						}

						function vt(v) {
							return "object" == typeof v && null != v && v.outlets
						}

						function ei(v, C, g, b, x) {
							let de, re = {};
							b && bn(b, (bt, Kt) => {
								re[Kt] = Array.isArray(bt) ? bt.map(on => `${on}`) : `${bt}`
							}), de = v === C ? g : ti(v, C, g);
							const We = Me(Ie(de));
							return new Xe(We, re, x)
						}

						function ti(v, C, g) {
							const b = {};
							return bn(v.children, (x, re) => {
								b[re] = x === C ? g : ti(x, C, g)
							}), new pe(v.segments, b)
						}
						class Sr {
							constructor(C, g, b) {
								if (this.isAbsolute = C, this.numberOfDoubleDots = g, this.commands = b, C && b.length > 0 && Pr(b[0])) throw new p.vHH(4003, Tt && "Root segment cannot have matrix parameters");
								const x = b.find(vt);
								if (x && x !== Vn(b)) throw new p.vHH(4004, Tt && "{outlets:{}} has to be the last command")
							}
							toRoot() {
								return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0]
							}
						}
						class Ur {
							constructor(C, g, b) {
								this.segmentGroup = C, this.processChildren = g, this.index = b
							}
						}

						function f(v, C, g) {
							if (v || (v = new pe([], {})), 0 === v.segments.length && v.hasChildren()) return T(v, C, g);
							const b = function L(v, C, g) {
									let b = 0,
										x = C;
									const re = {
										match: !1,
										pathIndex: 0,
										commandIndex: 0
									};
									for (; x < v.segments.length;) {
										if (b >= g.length) return re;
										const de = v.segments[x],
											We = g[b];
										if (vt(We)) break;
										const bt = `${We}`,
											Kt = b < g.length - 1 ? g[b + 1] : null;
										if (x > 0 && void 0 === bt) break;
										if (bt && Kt && "object" == typeof Kt && void 0 === Kt.outlets) {
											if (!He(bt, Kt, de)) return re;
											b += 2
										} else {
											if (!He(bt, {}, de)) return re;
											b++
										}
										x++
									}
									return {
										match: !0,
										pathIndex: x,
										commandIndex: b
									}
								}(v, C, g),
								x = g.slice(b.commandIndex);
							if (b.match && b.pathIndex < v.segments.length) {
								const re = new pe(v.segments.slice(0, b.pathIndex), {});
								return re.children[ot] = new pe(v.segments.slice(b.pathIndex), v.children), T(re, 0, x)
							}
							return b.match && 0 === x.length ? new pe(v.segments, {}) : b.match && !v.hasChildren() ? K(v, C, g) : b.match ? T(v, 0, x) : K(v, C, g)
						}

						function T(v, C, g) {
							if (0 === g.length) return new pe(v.segments, {});
							{
								const b = function fe(v) {
										return vt(v[0]) ? v[0].outlets : {
											[ot]: v
										}
									}(g),
									x = {};
								return !b[ot] && v.children[ot] && 1 === v.numberOfChildren && 0 === v.children[ot].segments.length ? T(v.children[ot], C, g) : (bn(b, (re, de) => {
									"string" == typeof re && (re = [re]), null !== re && (x[de] = f(v.children[de], C, re))
								}), bn(v.children, (re, de) => {
									void 0 === b[de] && (x[de] = re)
								}), new pe(v.segments, x))
							}
						}

						function K(v, C, g) {
							const b = v.segments.slice(0, C);
							let x = 0;
							for (; x < g.length;) {
								const re = g[x];
								if (vt(re)) {
									const bt = he(re.outlets);
									return new pe(b, bt)
								}
								if (0 === x && Pr(g[0])) {
									b.push(new Te(v.segments[C].path, ye(g[0]))), x++;
									continue
								}
								const de = vt(re) ? re.outlets[ot] : `${re}`,
									We = x < g.length - 1 ? g[x + 1] : null;
								de && We && Pr(We) ? (b.push(new Te(de, ye(We))), x += 2) : (b.push(new Te(de, {})), x++)
							}
							return new pe(b, {})
						}

						function he(v) {
							const C = {};
							return bn(v, (g, b) => {
								"string" == typeof g && (g = [g]), null !== g && (C[b] = K(new pe([], {}), 0, g))
							}), C
						}

						function ye(v) {
							const C = {};
							return bn(v, (g, b) => C[b] = `${g}`), C
						}

						function He(v, C, g) {
							return v == g.path && mn(C, g.parameters)
						}
						const gt = "imperative";
						class st {
							constructor(C, g) {
								this.id = C, this.url = g
							}
						}
						class mt extends st {
							constructor(C, g, b = "imperative", x = null) {
								super(C, g), this.type = 0, this.navigationTrigger = b, this.restoredState = x
							}
							toString() {
								return `NavigationStart(id: ${this.id}, url: '${this.url}')`
							}
						}
						class Et extends st {
							constructor(C, g, b) {
								super(C, g), this.urlAfterRedirects = b, this.type = 1
							}
							toString() {
								return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`
							}
						}
						class Gt extends st {
							constructor(C, g, b, x) {
								super(C, g), this.reason = b, this.code = x, this.type = 2
							}
							toString() {
								return `NavigationCancel(id: ${this.id}, url: '${this.url}')`
							}
						}
						class Rt extends st {
							constructor(C, g, b, x) {
								super(C, g), this.reason = b, this.code = x, this.type = 16
							}
						}
						class Ot extends st {
							constructor(C, g, b, x) {
								super(C, g), this.error = b, this.target = x, this.type = 3
							}
							toString() {
								return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`
							}
						}
						class Jt extends st {
							constructor(C, g, b, x) {
								super(C, g), this.urlAfterRedirects = b, this.state = x, this.type = 4
							}
							toString() {
								return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
							}
						}
						class Mn extends st {
							constructor(C, g, b, x) {
								super(C, g), this.urlAfterRedirects = b, this.state = x, this.type = 7
							}
							toString() {
								return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
							}
						}
						class Cn extends st {
							constructor(C, g, b, x, re) {
								super(C, g), this.urlAfterRedirects = b, this.state = x, this.shouldActivate = re, this.type = 8
							}
							toString() {
								return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`
							}
						}
						class Jn extends st {
							constructor(C, g, b, x) {
								super(C, g), this.urlAfterRedirects = b, this.state = x, this.type = 5
							}
							toString() {
								return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
							}
						}
						class xn extends st {
							constructor(C, g, b, x) {
								super(C, g), this.urlAfterRedirects = b, this.state = x, this.type = 6
							}
							toString() {
								return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
							}
						}
						class Br {
							constructor(C) {
								this.route = C, this.type = 9
							}
							toString() {
								return `RouteConfigLoadStart(path: ${this.route.path})`
							}
						}
						class me {
							constructor(C) {
								this.route = C, this.type = 10
							}
							toString() {
								return `RouteConfigLoadEnd(path: ${this.route.path})`
							}
						}
						class tt {
							constructor(C) {
								this.snapshot = C, this.type = 11
							}
							toString() {
								return `ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`
							}
						}
						class qe {
							constructor(C) {
								this.snapshot = C, this.type = 12
							}
							toString() {
								return `ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`
							}
						}
						class dt {
							constructor(C) {
								this.snapshot = C, this.type = 13
							}
							toString() {
								return `ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`
							}
						}
						class Dt {
							constructor(C) {
								this.snapshot = C, this.type = 14
							}
							toString() {
								return `ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`
							}
						}
						class Mt {
							constructor(C, g, b) {
								this.routerEvent = C, this.position = g, this.anchor = b, this.type = 15
							}
							toString() {
								return `Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`
							}
						}
						let cr = (() => {
								class v {
									createUrlTree(g, b, x, re, de, We) {
										return pr(g || b.root, x, re, de, We)
									}
								}
								return v.\u0275fac = function(g) {
									return new(g || v)
								}, v.\u0275prov = p.Yz7({
									token: v,
									factory: v.\u0275fac
								}), v
							})(),
							$n = (() => {
								class v {}
								return v.\u0275fac = function(g) {
									return new(g || v)
								}, v.\u0275prov = p.Yz7({
									token: v,
									factory: function(C) {
										return cr.\u0275fac(C)
									},
									providedIn: "root"
								}), v
							})();
						class or {
							constructor(C) {
								this._root = C
							}
							get root() {
								return this._root.value
							}
							parent(C) {
								const g = this.pathFromRoot(C);
								return g.length > 1 ? g[g.length - 2] : null
							}
							children(C) {
								const g = No(C, this._root);
								return g ? g.children.map(b => b.value) : []
							}
							firstChild(C) {
								const g = No(C, this._root);
								return g && g.children.length > 0 ? g.children[0].value : null
							}
							siblings(C) {
								const g = lr(C, this._root);
								return g.length < 2 ? [] : g[g.length - 2].children.map(x => x.value).filter(x => x !== C)
							}
							pathFromRoot(C) {
								return lr(C, this._root).map(g => g.value)
							}
						}

						function No(v, C) {
							if (v === C.value) return C;
							for (const g of C.children) {
								const b = No(v, g);
								if (b) return b
							}
							return null
						}

						function lr(v, C) {
							if (v === C.value) return [C];
							for (const g of C.children) {
								const b = lr(v, g);
								if (b.length) return b.unshift(C), b
							}
							return []
						}
						class gr {
							constructor(C, g) {
								this.value = C, this.children = g
							}
							toString() {
								return `TreeNode(${this.value})`
							}
						}

						function xi(v) {
							const C = {};
							return v && v.children.forEach(g => C[g.value.outlet] = g), C
						}
						class ni extends or {
							constructor(C, g) {
								super(C), this.snapshot = g, Is(this, C)
							}
							toString() {
								return this.snapshot.toString()
							}
						}

						function Si(v, C) {
							const g = function ri(v, C) {
									const de = new qi([], {}, {}, "", {}, ot, C, null, v.root, -1, {});
									return new Qo("", new gr(de, []))
								}(v, C),
								b = new z.X([new Te("", {})]),
								x = new z.X({}),
								re = new z.X({}),
								de = new z.X({}),
								We = new z.X(""),
								bt = new oo(b, x, de, We, re, ot, C, g.root);
							return bt.snapshot = g.root, new ni(new gr(bt, []), g)
						}
						class oo {
							constructor(C, g, b, x, re, de, We, bt) {
								this.url = C, this.params = g, this.queryParams = b, this.fragment = x, this.data = re, this.outlet = de, this.component = We, this.title = this.data?.pipe((0, F.U)(Kt => Kt[Vt])) ?? (0, D.of)(void 0), this._futureSnapshot = bt
							}
							get routeConfig() {
								return this._futureSnapshot.routeConfig
							}
							get root() {
								return this._routerState.root
							}
							get parent() {
								return this._routerState.parent(this)
							}
							get firstChild() {
								return this._routerState.firstChild(this)
							}
							get children() {
								return this._routerState.children(this)
							}
							get pathFromRoot() {
								return this._routerState.pathFromRoot(this)
							}
							get paramMap() {
								return this._paramMap || (this._paramMap = this.params.pipe((0, F.U)(C => cn(C)))), this._paramMap
							}
							get queryParamMap() {
								return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe((0, F.U)(C => cn(C)))), this._queryParamMap
							}
							toString() {
								return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`
							}
						}

						function bs(v, C = "emptyOnly") {
							const g = v.pathFromRoot;
							let b = 0;
							if ("always" !== C)
								for (b = g.length - 1; b >= 1;) {
									const x = g[b],
										re = g[b - 1];
									if (x.routeConfig && "" === x.routeConfig.path) b--;
									else {
										if (re.component) break;
										b--
									}
								}
							return function ia(v) {
								return v.reduce((C, g) => ({
									params: {
										...C.params,
										...g.params
									},
									data: {
										...C.data,
										...g.data
									},
									resolve: {
										...g.data,
										...C.resolve,
										...g.routeConfig?.data,
										...g._resolvedData
									}
								}), {
									params: {},
									data: {},
									resolve: {}
								})
							}(g.slice(b))
						}
						class qi {
							get title() {
								return this.data?.[Vt]
							}
							constructor(C, g, b, x, re, de, We, bt, Kt, on, zn) {
								this.url = C, this.params = g, this.queryParams = b, this.fragment = x, this.data = re, this.outlet = de, this.component = We, this.routeConfig = bt, this._urlSegment = Kt, this._lastPathIndex = on, this._resolve = zn
							}
							get root() {
								return this._routerState.root
							}
							get parent() {
								return this._routerState.parent(this)
							}
							get firstChild() {
								return this._routerState.firstChild(this)
							}
							get children() {
								return this._routerState.children(this)
							}
							get pathFromRoot() {
								return this._routerState.pathFromRoot(this)
							}
							get paramMap() {
								return this._paramMap || (this._paramMap = cn(this.params)), this._paramMap
							}
							get queryParamMap() {
								return this._queryParamMap || (this._queryParamMap = cn(this.queryParams)), this._queryParamMap
							}
							toString() {
								return `Route(url:'${this.url.map(b=>b.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`
							}
						}
						class Qo extends or {
							constructor(C, g) {
								super(g), this.url = C, Is(this, g)
							}
							toString() {
								return Jo(this._root)
							}
						}

						function Is(v, C) {
							C.value._routerState = v, C.children.forEach(g => Is(v, g))
						}

						function Jo(v) {
							const C = v.children.length > 0 ? ` { ${v.children.map(Jo).join(", ")} } ` : "";
							return `${v.value}${C}`
						}

						function oa(v) {
							if (v.snapshot) {
								const C = v.snapshot,
									g = v._futureSnapshot;
								v.snapshot = g, mn(C.queryParams, g.queryParams) || v.queryParams.next(g.queryParams), C.fragment !== g.fragment && v.fragment.next(g.fragment), mn(C.params, g.params) || v.params.next(g.params),
									function Pn(v, C) {
										if (v.length !== C.length) return !1;
										for (let g = 0; g < v.length; ++g)
											if (!mn(v[g], C[g])) return !1;
										return !0
									}(C.url, g.url) || v.url.next(g.url), mn(C.data, g.data) || v.data.next(g.data)
							} else v.snapshot = v._futureSnapshot, v.data.next(v._futureSnapshot.data)
						}

						function sa(v, C) {
							const g = mn(v.params, C.params) && function Je(v, C) {
								return yt(v, C) && v.every((g, b) => mn(g.parameters, C[b].parameters))
							}(v.url, C.url);
							return g && !(!v.parent != !C.parent) && (!v.parent || sa(v.parent, C.parent))
						}

						function Nr(v, C, g) {
							if (g && v.shouldReuseRoute(C.value, g.value.snapshot)) {
								const b = g.value;
								b._futureSnapshot = C.value;
								const x = function Ds(v, C, g) {
									return C.children.map(b => {
										for (const x of g.children)
											if (v.shouldReuseRoute(b.value, x.value.snapshot)) return Nr(v, b, x);
										return Nr(v, b)
									})
								}(v, C, g);
								return new gr(b, x)
							} {
								if (v.shouldAttach(C.value)) {
									const re = v.retrieve(C.value);
									if (null !== re) {
										const de = re.route;
										return de.value._futureSnapshot = C.value, de.children = C.children.map(We => Nr(v, We)), de
									}
								}
								const b = function aa(v) {
										return new oo(new z.X(v.url), new z.X(v.params), new z.X(v.queryParams), new z.X(v.fragment), new z.X(v.data), v.outlet, v.component, v)
									}(C.value),
									x = C.children.map(re => Nr(v, re));
								return new gr(b, x)
							}
						}
						const Xo = "ngNavigationCancelingError";

						function ac(v, C) {
							const {
								redirectTo: g,
								navigationBehaviorOptions: b
							} = Ke(C) ? {
								redirectTo: C,
								navigationBehaviorOptions: void 0
							} : C, x = ca(!1, 0, C);
							return x.url = g, x.navigationBehaviorOptions = b, x
						}

						function ca(v, C, g) {
							const b = new Error("NavigationCancelingError: " + (v || ""));
							return b[Xo] = !0, b.cancellationCode = C, g && (b.url = g), b
						}

						function As(v) {
							return la(v) && Ke(v.url)
						}

						function la(v) {
							return v && v[Xo]
						}
						class pu {
							constructor() {
								this.outlet = null, this.route = null, this.resolver = null, this.injector = null, this.children = new so, this.attachRef = null
							}
						}
						let so = (() => {
							class v {
								constructor() {
									this.contexts = new Map
								}
								onChildOutletCreated(g, b) {
									const x = this.getOrCreateContext(g);
									x.outlet = b, this.contexts.set(g, x)
								}
								onChildOutletDestroyed(g) {
									const b = this.getContext(g);
									b && (b.outlet = null, b.attachRef = null)
								}
								onOutletDeactivated() {
									const g = this.contexts;
									return this.contexts = new Map, g
								}
								onOutletReAttached(g) {
									this.contexts = g
								}
								getOrCreateContext(g) {
									let b = this.getContext(g);
									return b || (b = new pu, this.contexts.set(g, b)), b
								}
								getContext(g) {
									return this.contexts.get(g) || null
								}
							}
							return v.\u0275fac = function(g) {
								return new(g || v)
							}, v.\u0275prov = p.Yz7({
								token: v,
								factory: v.\u0275fac,
								providedIn: "root"
							}), v
						})();
						const ua = !1;
						let Qi = (() => {
							class v {
								constructor() {
									this.activated = null, this._activatedRoute = null, this.name = ot, this.activateEvents = new p.vpe, this.deactivateEvents = new p.vpe, this.attachEvents = new p.vpe, this.detachEvents = new p.vpe, this.parentContexts = (0, p.f3M)(so), this.location = (0, p.f3M)(p.s_b), this.changeDetector = (0, p.f3M)(p.sBO), this.environmentInjector = (0, p.f3M)(p.lqb)
								}
								ngOnChanges(g) {
									if (g.name) {
										const {
											firstChange: b,
											previousValue: x
										} = g.name;
										if (b) return;
										this.isTrackedInParentContexts(x) && (this.deactivate(), this.parentContexts.onChildOutletDestroyed(x)), this.initializeOutletWithName()
									}
								}
								ngOnDestroy() {
									this.isTrackedInParentContexts(this.name) && this.parentContexts.onChildOutletDestroyed(this.name)
								}
								isTrackedInParentContexts(g) {
									return this.parentContexts.getContext(g)?.outlet === this
								}
								ngOnInit() {
									this.initializeOutletWithName()
								}
								initializeOutletWithName() {
									if (this.parentContexts.onChildOutletCreated(this.name, this), this.activated) return;
									const g = this.parentContexts.getContext(this.name);
									g?.route && (g.attachRef ? this.attach(g.attachRef, g.route) : this.activateWith(g.route, g.injector))
								}
								get isActivated() {
									return !!this.activated
								}
								get component() {
									if (!this.activated) throw new p.vHH(4012, ua);
									return this.activated.instance
								}
								get activatedRoute() {
									if (!this.activated) throw new p.vHH(4012, ua);
									return this._activatedRoute
								}
								get activatedRouteData() {
									return this._activatedRoute ? this._activatedRoute.snapshot.data : {}
								}
								detach() {
									if (!this.activated) throw new p.vHH(4012, ua);
									this.location.detach();
									const g = this.activated;
									return this.activated = null, this._activatedRoute = null, this.detachEvents.emit(g.instance), g
								}
								attach(g, b) {
									this.activated = g, this._activatedRoute = b, this.location.insert(g.hostView), this.attachEvents.emit(g.instance)
								}
								deactivate() {
									if (this.activated) {
										const g = this.component;
										this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(g)
									}
								}
								activateWith(g, b) {
									if (this.isActivated) throw new p.vHH(4013, ua);
									this._activatedRoute = g;
									const x = this.location,
										de = g.snapshot.component,
										We = this.parentContexts.getOrCreateContext(this.name).children,
										bt = new ol(g, We, x.injector);
									if (b && function ko(v) {
											return !!v.resolveComponentFactory
										}(b)) {
										const Kt = b.resolveComponentFactory(de);
										this.activated = x.createComponent(Kt, x.length, bt)
									} else this.activated = x.createComponent(de, {
										index: x.length,
										injector: bt,
										environmentInjector: b ?? this.environmentInjector
									});
									this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance)
								}
							}
							return v.\u0275fac = function(g) {
								return new(g || v)
							}, v.\u0275dir = p.lG2({
								type: v,
								selectors: [
									["router-outlet"]
								],
								inputs: {
									name: "name"
								},
								outputs: {
									activateEvents: "activate",
									deactivateEvents: "deactivate",
									attachEvents: "attach",
									detachEvents: "detach"
								},
								exportAs: ["outlet"],
								standalone: !0,
								features: [p.TTD]
							}), v
						})();
						class ol {
							constructor(C, g, b) {
								this.route = C, this.childContexts = g, this.parent = b
							}
							get(C, g) {
								return C === oo ? this.route : C === so ? this.childContexts : this.parent.get(C, g)
							}
						}
						let ao = (() => {
							class v {}
							return v.\u0275fac = function(g) {
								return new(g || v)
							}, v.\u0275cmp = p.Xpm({
								type: v,
								selectors: [
									["ng-component"]
								],
								standalone: !0,
								features: [p.jDz],
								decls: 1,
								vars: 0,
								template: function(g, b) {
									1 & g && p._UZ(0, "router-outlet")
								},
								dependencies: [Qi],
								encapsulation: 2
							}), v
						})();

						function Rs(v, C) {
							return v.providers && !v._injector && (v._injector = (0, p.MMx)(v.providers, C, `Route: ${v.path}`)), v._injector ?? C
						}

						function es(v) {
							const C = v.children && v.children.map(es),
								g = C ? {
									...v,
									children: C
								} : {
									...v
								};
							return !g.component && !g.loadComponent && (C || g.loadChildren) && g.outlet && g.outlet !== ot && (g.component = ao), g
						}

						function sr(v) {
							return v.outlet || ot
						}

						function Fi(v, C) {
							const g = v.filter(b => sr(b) === C);
							return g.push(...v.filter(b => sr(b) !== C)), g
						}

						function Ai(v) {
							if (!v) return null;
							if (v.routeConfig?._injector) return v.routeConfig._injector;
							for (let C = v.parent; C; C = C.parent) {
								const g = C.routeConfig;
								if (g?._loadedInjector) return g._loadedInjector;
								if (g?._injector) return g._injector
							}
							return null
						}
						class ts {
							constructor(C, g, b, x) {
								this.routeReuseStrategy = C, this.futureState = g, this.currState = b, this.forwardEvent = x
							}
							activate(C) {
								const g = this.futureState._root,
									b = this.currState ? this.currState._root : null;
								this.deactivateChildRoutes(g, b, C), oa(this.futureState.root), this.activateChildRoutes(g, b, C)
							}
							deactivateChildRoutes(C, g, b) {
								const x = xi(g);
								C.children.forEach(re => {
									const de = re.value.outlet;
									this.deactivateRoutes(re, x[de], b), delete x[de]
								}), bn(x, (re, de) => {
									this.deactivateRouteAndItsChildren(re, b)
								})
							}
							deactivateRoutes(C, g, b) {
								const x = C.value,
									re = g ? g.value : null;
								if (x === re)
									if (x.component) {
										const de = b.getContext(x.outlet);
										de && this.deactivateChildRoutes(C, g, de.children)
									} else this.deactivateChildRoutes(C, g, b);
								else re && this.deactivateRouteAndItsChildren(g, b)
							}
							deactivateRouteAndItsChildren(C, g) {
								C.value.component && this.routeReuseStrategy.shouldDetach(C.value.snapshot) ? this.detachAndStoreRouteSubtree(C, g) : this.deactivateRouteAndOutlet(C, g)
							}
							detachAndStoreRouteSubtree(C, g) {
								const b = g.getContext(C.value.outlet),
									x = b && C.value.component ? b.children : g,
									re = xi(C);
								for (const de of Object.keys(re)) this.deactivateRouteAndItsChildren(re[de], x);
								if (b && b.outlet) {
									const de = b.outlet.detach(),
										We = b.children.onOutletDeactivated();
									this.routeReuseStrategy.store(C.value.snapshot, {
										componentRef: de,
										route: C,
										contexts: We
									})
								}
							}
							deactivateRouteAndOutlet(C, g) {
								const b = g.getContext(C.value.outlet),
									x = b && C.value.component ? b.children : g,
									re = xi(C);
								for (const de of Object.keys(re)) this.deactivateRouteAndItsChildren(re[de], x);
								b && b.outlet && (b.outlet.deactivate(), b.children.onOutletDeactivated(), b.attachRef = null, b.resolver = null, b.route = null)
							}
							activateChildRoutes(C, g, b) {
								const x = xi(g);
								C.children.forEach(re => {
									this.activateRoutes(re, x[re.value.outlet], b), this.forwardEvent(new Dt(re.value.snapshot))
								}), C.children.length && this.forwardEvent(new qe(C.value.snapshot))
							}
							activateRoutes(C, g, b) {
								const x = C.value,
									re = g ? g.value : null;
								if (oa(x), x === re)
									if (x.component) {
										const de = b.getOrCreateContext(x.outlet);
										this.activateChildRoutes(C, g, de.children)
									} else this.activateChildRoutes(C, g, b);
								else if (x.component) {
									const de = b.getOrCreateContext(x.outlet);
									if (this.routeReuseStrategy.shouldAttach(x.snapshot)) {
										const We = this.routeReuseStrategy.retrieve(x.snapshot);
										this.routeReuseStrategy.store(x.snapshot, null), de.children.onOutletReAttached(We.contexts), de.attachRef = We.componentRef, de.route = We.route.value, de.outlet && de.outlet.attach(We.componentRef, We.route.value), oa(We.route.value), this.activateChildRoutes(C, null, de.children)
									} else {
										const We = Ai(x.snapshot),
											bt = We?.get(p._Vd) ?? null;
										de.attachRef = null, de.route = x, de.resolver = bt, de.injector = We, de.outlet && de.outlet.activateWith(x, de.injector), this.activateChildRoutes(C, null, de.children)
									}
								} else this.activateChildRoutes(C, null, b)
							}
						}
						class Os {
							constructor(C) {
								this.path = C, this.route = this.path[this.path.length - 1]
							}
						}
						class Ji {
							constructor(C, g) {
								this.component = C, this.route = g
							}
						}

						function di(v, C, g) {
							const b = v._root;
							return co(b, C ? C._root : null, g, [b.value])
						}

						function Li(v, C) {
							const g = Symbol(),
								b = C.get(v, g);
							return b === g ? "function" != typeof v || (0, p.Z0I)(v) ? C.get(v) : v : b
						}

						function co(v, C, g, b, x = {
							canDeactivateChecks: [],
							canActivateChecks: []
						}) {
							const re = xi(C);
							return v.children.forEach(de => {
								(function lo(v, C, g, b, x = {
									canDeactivateChecks: [],
									canActivateChecks: []
								}) {
									const re = v.value,
										de = C ? C.value : null,
										We = g ? g.getContext(v.value.outlet) : null;
									if (de && re.routeConfig === de.routeConfig) {
										const bt = function xo(v, C, g) {
											if ("function" == typeof g) return g(v, C);
											switch (g) {
												case "pathParamsChange":
													return !yt(v.url, C.url);
												case "pathParamsOrQueryParamsChange":
													return !yt(v.url, C.url) || !mn(v.queryParams, C.queryParams);
												case "always":
													return !0;
												case "paramsOrQueryParamsChange":
													return !sa(v, C) || !mn(v.queryParams, C.queryParams);
												default:
													return !sa(v, C)
											}
										}(de, re, re.routeConfig.runGuardsAndResolvers);
										bt ? x.canActivateChecks.push(new Os(b)) : (re.data = de.data, re._resolvedData = de._resolvedData), co(v, C, re.component ? We ? We.children : null : g, b, x), bt && We && We.outlet && We.outlet.isActivated && x.canDeactivateChecks.push(new Ji(We.outlet.component, de))
									} else de && Ui(C, We, x), x.canActivateChecks.push(new Os(b)), co(v, null, re.component ? We ? We.children : null : g, b, x)
								})(de, re[de.value.outlet], g, b.concat([de.value]), x), delete re[de.value.outlet]
							}), bn(re, (de, We) => Ui(de, g.getContext(We), x)), x
						}

						function Ui(v, C, g) {
							const b = xi(v),
								x = v.value;
							bn(b, (re, de) => {
								Ui(re, x.component ? C ? C.children.getContext(de) : null : C, g)
							}), g.canDeactivateChecks.push(new Ji(x.component && C && C.outlet && C.outlet.isActivated ? C.outlet.component : null, x))
						}

						function wn(v) {
							return "function" == typeof v
						}

						function Ct(v) {
							return v instanceof ee.K || "EmptyError" === v?.name
						}
						const Gn = Symbol("INITIAL_VALUE");

						function uo() {
							return (0, xe.w)(v => (0, P.a)(v.map(C => C.pipe((0, Ee.q)(1), (0, Ue.O)(Gn)))).pipe((0, F.U)(C => {
								for (const g of C)
									if (!0 !== g) {
										if (g === Gn) return Gn;
										if (!1 === g || g instanceof Xe) return g
									} return !0
							}), (0, ke.h)(C => C !== Gn), (0, Ee.q)(1)))
						}

						function Ns(v) {
							return (0, G.z)((0, Pt.b)(C => {
								if (Ke(C)) throw ac(0, C)
							}), (0, F.U)(C => !0 === C))
						}
						const hi = {
							matched: !1,
							consumedSegments: [],
							remainingSegments: [],
							parameters: {},
							positionalParamSegments: {}
						};

						function Bi(v, C, g, b, x) {
							const re = ho(v, C, g);
							return re.matched ? function Kr(v, C, g, b) {
								const x = C.canMatch;
								if (!x || 0 === x.length) return (0, D.of)(!0);
								const re = x.map(de => {
									const We = Li(de, v);
									return Bn(function hc(v) {
										return v && wn(v.canMatch)
									}(We) ? We.canMatch(C, g) : v.runInContext(() => We(C, g)))
								});
								return (0, D.of)(re).pipe(uo(), Ns())
							}(b = Rs(C, b), C, g).pipe((0, F.U)(de => !0 === de ? re : {
								...hi
							})) : (0, D.of)(re)
						}

						function ho(v, C, g) {
							if ("" === C.path) return "full" === C.pathMatch && (v.hasChildren() || g.length > 0) ? {
								...hi
							} : {
								matched: !0,
								consumedSegments: [],
								remainingSegments: g,
								parameters: {},
								positionalParamSegments: {}
							};
							const x = (C.matcher || Sn)(g, v, C);
							if (!x) return {
								...hi
							};
							const re = {};
							bn(x.posParams, (We, bt) => {
								re[bt] = We.path
							});
							const de = x.consumed.length > 0 ? {
								...re,
								...x.consumed[x.consumed.length - 1].parameters
							} : re;
							return {
								matched: !0,
								consumedSegments: x.consumed,
								remainingSegments: g.slice(x.consumed.length),
								parameters: de,
								positionalParamSegments: x.posParams ?? {}
							}
						}

						function wi(v, C, g, b) {
							if (g.length > 0 && function _c(v, C, g) {
									return g.some(b => Hr(v, C, b) && sr(b) !== ot)
								}(v, g, b)) {
								const re = new pe(C, function ks(v, C, g, b) {
									const x = {};
									x[ot] = b, b._sourceSegment = v, b._segmentIndexShift = C.length;
									for (const re of g)
										if ("" === re.path && sr(re) !== ot) {
											const de = new pe([], {});
											de._sourceSegment = v, de._segmentIndexShift = C.length, x[sr(re)] = de
										} return x
								}(v, C, b, new pe(g, v.children)));
								return re._sourceSegment = v, re._segmentIndexShift = C.length, {
									segmentGroup: re,
									slicedSegments: []
								}
							}
							if (0 === g.length && function ll(v, C, g) {
									return g.some(b => Hr(v, C, b))
								}(v, g, b)) {
								const re = new pe(v.segments, function _a(v, C, g, b, x) {
									const re = {};
									for (const de of b)
										if (Hr(v, g, de) && !x[sr(de)]) {
											const We = new pe([], {});
											We._sourceSegment = v, We._segmentIndexShift = C.length, re[sr(de)] = We
										} return {
										...x,
										...re
									}
								}(v, C, g, b, v.children));
								return re._sourceSegment = v, re._segmentIndexShift = C.length, {
									segmentGroup: re,
									slicedSegments: g
								}
							}
							const x = new pe(v.segments, v.children);
							return x._sourceSegment = v, x._segmentIndexShift = C.length, {
								segmentGroup: x,
								slicedSegments: g
							}
						}

						function Hr(v, C, g) {
							return (!(v.hasChildren() || C.length > 0) || "full" !== g.pathMatch) && "" === g.path
						}

						function fo(v, C, g, b) {
							return !!(sr(v) === b || b !== ot && Hr(C, g, v)) && ("**" === v.path || ho(C, v, g).matched)
						}

						function Eo(v, C, g) {
							return 0 === C.length && !v.children[g]
						}
						const po = !1;
						class xs {
							constructor(C) {
								this.segmentGroup = C || null
							}
						}
						class va {
							constructor(C) {
								this.urlTree = C
							}
						}

						function Xi(v) {
							return (0, Q._)(new xs(v))
						}

						function ya(v) {
							return (0, Q._)(new va(v))
						}
						class Fs {
							constructor(C, g, b, x, re) {
								this.injector = C, this.configLoader = g, this.urlSerializer = b, this.urlTree = x, this.config = re, this.allowRedirects = !0
							}
							apply() {
								const C = wi(this.urlTree.root, [], [], this.config).segmentGroup,
									g = new pe(C.segments, C.children);
								return this.expandSegmentGroup(this.injector, this.config, g, ot).pipe((0, F.U)(re => this.createUrlTree(Ie(re), this.urlTree.queryParams, this.urlTree.fragment))).pipe((0, at.K)(re => {
									if (re instanceof va) return this.allowRedirects = !1, this.match(re.urlTree);
									throw re instanceof xs ? this.noMatchError(re) : re
								}))
							}
							match(C) {
								return this.expandSegmentGroup(this.injector, this.config, C.root, ot).pipe((0, F.U)(x => this.createUrlTree(Ie(x), C.queryParams, C.fragment))).pipe((0, at.K)(x => {
									throw x instanceof xs ? this.noMatchError(x) : x
								}))
							}
							noMatchError(C) {
								return new p.vHH(4002, po)
							}
							createUrlTree(C, g, b) {
								const x = Me(C);
								return new Xe(x, g, b)
							}
							expandSegmentGroup(C, g, b, x) {
								return 0 === b.segments.length && b.hasChildren() ? this.expandChildren(C, g, b).pipe((0, F.U)(re => new pe([], re))) : this.expandSegment(C, b, g, b.segments, x, !0)
							}
							expandChildren(C, g, b) {
								const x = [];
								for (const re of Object.keys(b.children)) "primary" === re ? x.unshift(re) : x.push(re);
								return (0, y.D)(x).pipe((0, nt.b)(re => {
									const de = b.children[re],
										We = Fi(g, re);
									return this.expandSegmentGroup(C, We, de, re).pipe((0, F.U)(bt => ({
										segment: bt,
										outlet: re
									})))
								}), (0, lt.R)((re, de) => (re[de.outlet] = de.segment, re), {}), it())
							}
							expandSegment(C, g, b, x, re, de) {
								return (0, y.D)(b).pipe((0, nt.b)(We => this.expandSegmentAgainstRoute(C, g, b, We, x, re, de).pipe((0, at.K)(Kt => {
									if (Kt instanceof xs) return (0, D.of)(null);
									throw Kt
								}))), (0, ft.P)(We => !!We), (0, at.K)((We, bt) => {
									if (Ct(We)) return Eo(g, x, re) ? (0, D.of)(new pe([], {})) : Xi(g);
									throw We
								}))
							}
							expandSegmentAgainstRoute(C, g, b, x, re, de, We) {
								return fo(x, g, re, de) ? void 0 === x.redirectTo ? this.matchSegmentAgainstRoute(C, g, x, re, de) : We && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(C, g, b, x, re, de) : Xi(g) : Xi(g)
							}
							expandSegmentAgainstRouteUsingRedirect(C, g, b, x, re, de) {
								return "**" === x.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(C, b, x, de) : this.expandRegularSegmentAgainstRouteUsingRedirect(C, g, b, x, re, de)
							}
							expandWildCardWithParamsAgainstRouteUsingRedirect(C, g, b, x) {
								const re = this.applyRedirectCommands([], b.redirectTo, {});
								return b.redirectTo.startsWith("/") ? ya(re) : this.lineralizeSegments(b, re).pipe((0, Ge.z)(de => {
									const We = new pe(de, {});
									return this.expandSegment(C, We, g, de, x, !1)
								}))
							}
							expandRegularSegmentAgainstRouteUsingRedirect(C, g, b, x, re, de) {
								const {
									matched: We,
									consumedSegments: bt,
									remainingSegments: Kt,
									positionalParamSegments: on
								} = ho(g, x, re);
								if (!We) return Xi(g);
								const zn = this.applyRedirectCommands(bt, x.redirectTo, on);
								return x.redirectTo.startsWith("/") ? ya(zn) : this.lineralizeSegments(x, zn).pipe((0, Ge.z)(xr => this.expandSegment(C, g, b, xr.concat(Kt), de, !1)))
							}
							matchSegmentAgainstRoute(C, g, b, x, re) {
								return "**" === b.path ? (C = Rs(b, C), b.loadChildren ? (b._loadedRoutes ? (0, D.of)({
									routes: b._loadedRoutes,
									injector: b._loadedInjector
								}) : this.configLoader.loadChildren(C, b)).pipe((0, F.U)(We => (b._loadedRoutes = We.routes, b._loadedInjector = We.injector, new pe(x, {})))) : (0, D.of)(new pe(x, {}))) : Bi(g, b, x, C).pipe((0, xe.w)(({
									matched: de,
									consumedSegments: We,
									remainingSegments: bt
								}) => de ? this.getChildConfig(C = b._injector ?? C, b, x).pipe((0, Ge.z)(on => {
									const zn = on.injector ?? C,
										xr = on.routes,
										{
											segmentGroup: Gi,
											slicedSegments: to
										} = wi(g, We, bt, xr),
										gi = new pe(Gi.segments, Gi.children);
									if (0 === to.length && gi.hasChildren()) return this.expandChildren(zn, xr, gi).pipe((0, F.U)(_l => new pe(We, _l)));
									if (0 === xr.length && 0 === to.length) return (0, D.of)(new pe(We, {}));
									const Cr = sr(b) === re;
									return this.expandSegment(zn, gi, xr, to, Cr ? ot : re, !0).pipe((0, F.U)(Xn => new pe(We.concat(Xn.segments), Xn.children)))
								})) : Xi(g)))
							}
							getChildConfig(C, g, b) {
								return g.children ? (0, D.of)({
									routes: g.children,
									injector: C
								}) : g.loadChildren ? void 0 !== g._loadedRoutes ? (0, D.of)({
									routes: g._loadedRoutes,
									injector: g._loadedInjector
								}) : function mc(v, C, g, b) {
									const x = C.canLoad;
									if (void 0 === x || 0 === x.length) return (0, D.of)(!0);
									const re = x.map(de => {
										const We = Li(de, v);
										return Bn(function sl(v) {
											return v && wn(v.canLoad)
										}(We) ? We.canLoad(C, g) : v.runInContext(() => We(C, g)))
									});
									return (0, D.of)(re).pipe(uo(), Ns())
								}(C, g, b).pipe((0, Ge.z)(x => x ? this.configLoader.loadChildren(C, g).pipe((0, Pt.b)(re => {
									g._loadedRoutes = re.routes, g._loadedInjector = re.injector
								})) : function rs(v) {
									return (0, Q._)(ca(po, 3))
								}())) : (0, D.of)({
									routes: [],
									injector: C
								})
							}
							lineralizeSegments(C, g) {
								let b = [],
									x = g.root;
								for (;;) {
									if (b = b.concat(x.segments), 0 === x.numberOfChildren) return (0, D.of)(b);
									if (x.numberOfChildren > 1 || !x.children[ot]) return C.redirectTo, (0, Q._)(new p.vHH(4e3, po));
									x = x.children[ot]
								}
							}
							applyRedirectCommands(C, g, b) {
								return this.applyRedirectCreateUrlTree(g, this.urlSerializer.parse(g), C, b)
							}
							applyRedirectCreateUrlTree(C, g, b, x) {
								const re = this.createSegmentGroup(C, g.root, b, x);
								return new Xe(re, this.createQueryParams(g.queryParams, this.urlTree.queryParams), g.fragment)
							}
							createQueryParams(C, g) {
								const b = {};
								return bn(C, (x, re) => {
									if ("string" == typeof x && x.startsWith(":")) {
										const We = x.substring(1);
										b[re] = g[We]
									} else b[re] = x
								}), b
							}
							createSegmentGroup(C, g, b, x) {
								const re = this.createSegments(C, g.segments, b, x);
								let de = {};
								return bn(g.children, (We, bt) => {
									de[bt] = this.createSegmentGroup(C, We, b, x)
								}), new pe(re, de)
							}
							createSegments(C, g, b, x) {
								return g.map(re => re.path.startsWith(":") ? this.findPosParam(C, re, x) : this.findOrReturn(re, b))
							}
							findPosParam(C, g, b) {
								const x = b[g.path.substring(1)];
								if (!x) throw new p.vHH(4001, po);
								return x
							}
							findOrReturn(C, g) {
								let b = 0;
								for (const x of g) {
									if (x.path === C.path) return g.splice(b), x;
									b++
								}
								return C
							}
						}
						class ur {}
						class ul {
							constructor(C, g, b, x, re, de, We) {
								this.injector = C, this.rootComponentType = g, this.config = b, this.urlTree = x, this.url = re, this.paramsInheritanceStrategy = de, this.urlSerializer = We
							}
							recognize() {
								const C = wi(this.urlTree.root, [], [], this.config.filter(g => void 0 === g.redirectTo)).segmentGroup;
								return this.processSegmentGroup(this.injector, this.config, C, ot).pipe((0, F.U)(g => {
									if (null === g) return null;
									const b = new qi([], Object.freeze({}), Object.freeze({
											...this.urlTree.queryParams
										}), this.urlTree.fragment, {}, ot, this.rootComponentType, null, this.urlTree.root, -1, {}),
										x = new gr(b, g),
										re = new Qo(this.url, x);
									return this.inheritParamsAndData(re._root), re
								}))
							}
							inheritParamsAndData(C) {
								const g = C.value,
									b = bs(g, this.paramsInheritanceStrategy);
								g.params = Object.freeze(b.params), g.data = Object.freeze(b.data), C.children.forEach(x => this.inheritParamsAndData(x))
							}
							processSegmentGroup(C, g, b, x) {
								return 0 === b.segments.length && b.hasChildren() ? this.processChildren(C, g, b) : this.processSegment(C, g, b, b.segments, x)
							}
							processChildren(C, g, b) {
								return (0, y.D)(Object.keys(b.children)).pipe((0, nt.b)(x => {
									const re = b.children[x],
										de = Fi(g, x);
									return this.processSegmentGroup(C, de, re, x)
								}), (0, lt.R)((x, re) => x && re ? (x.push(...re), x) : null), function ce(v, C = !1) {
									return (0, oe.e)((g, b) => {
										let x = 0;
										g.subscribe((0, we.x)(b, re => {
											const de = v(re, x++);
											(de || C) && b.next(re), !de && b.complete()
										}))
									})
								}(x => null !== x), (0, Be.d)(null), it(), (0, F.U)(x => {
									if (null === x) return null;
									const re = is(x);
									return function Ec(v) {
										v.sort((C, g) => C.value.outlet === ot ? -1 : g.value.outlet === ot ? 1 : C.value.outlet.localeCompare(g.value.outlet))
									}(re), re
								}))
							}
							processSegment(C, g, b, x, re) {
								return (0, y.D)(g).pipe((0, nt.b)(de => this.processSegmentAgainstRoute(de._injector ?? C, de, b, x, re)), (0, ft.P)(de => !!de), (0, at.K)(de => {
									if (Ct(de)) return Eo(b, x, re) ? (0, D.of)([]) : (0, D.of)(null);
									throw de
								}))
							}
							processSegmentAgainstRoute(C, g, b, x, re) {
								if (g.redirectTo || !fo(g, b, x, re)) return (0, D.of)(null);
								let de;
								if ("**" === g.path) {
									const We = x.length > 0 ? Vn(x).parameters : {},
										bt = I(b) + x.length,
										Kt = new qi(x, We, Object.freeze({
											...this.urlTree.queryParams
										}), this.urlTree.fragment, M(g), sr(g), g.component ?? g._loadedComponent ?? null, g, os(b), bt, ae(g));
									de = (0, D.of)({
										snapshot: Kt,
										consumedSegments: [],
										remainingSegments: []
									})
								} else de = Bi(b, g, x, C).pipe((0, F.U)(({
									matched: We,
									consumedSegments: bt,
									remainingSegments: Kt,
									parameters: on
								}) => {
									if (!We) return null;
									const zn = I(b) + bt.length;
									return {
										snapshot: new qi(bt, on, Object.freeze({
											...this.urlTree.queryParams
										}), this.urlTree.fragment, M(g), sr(g), g.component ?? g._loadedComponent ?? null, g, os(b), zn, ae(g)),
										consumedSegments: bt,
										remainingSegments: Kt
									}
								}));
								return de.pipe((0, xe.w)(We => {
									if (null === We) return (0, D.of)(null);
									const {
										snapshot: bt,
										consumedSegments: Kt,
										remainingSegments: on
									} = We;
									C = g._injector ?? C;
									const zn = g._loadedInjector ?? C,
										xr = function dl(v) {
											return v.children ? v.children : v.loadChildren ? v._loadedRoutes : []
										}(g),
										{
											segmentGroup: Gi,
											slicedSegments: to
										} = wi(b, Kt, on, xr.filter(Cr => void 0 === Cr.redirectTo));
									if (0 === to.length && Gi.hasChildren()) return this.processChildren(zn, xr, Gi).pipe((0, F.U)(Cr => null === Cr ? null : [new gr(bt, Cr)]));
									if (0 === xr.length && 0 === to.length) return (0, D.of)([new gr(bt, [])]);
									const gi = sr(g) === re;
									return this.processSegment(zn, xr, Gi, to, gi ? ot : re).pipe((0, F.U)(Cr => null === Cr ? null : [new gr(bt, Cr)]))
								}))
							}
						}

						function Cc(v) {
							const C = v.value.routeConfig;
							return C && "" === C.path && void 0 === C.redirectTo
						}

						function is(v) {
							const C = [],
								g = new Set;
							for (const b of v) {
								if (!Cc(b)) {
									C.push(b);
									continue
								}
								const x = C.find(re => b.value.routeConfig === re.value.routeConfig);
								void 0 !== x ? (x.children.push(...b.children), g.add(x)) : C.push(b)
							}
							for (const b of g) {
								const x = is(b.children);
								C.push(new gr(b.value, x))
							}
							return C.filter(b => !g.has(b))
						}

						function os(v) {
							let C = v;
							for (; C._sourceSegment;) C = C._sourceSegment;
							return C
						}

						function I(v) {
							let C = v,
								g = C._segmentIndexShift ?? 0;
							for (; C._sourceSegment;) C = C._sourceSegment, g += C._segmentIndexShift ?? 0;
							return g - 1
						}

						function M(v) {
							return v.data || {}
						}

						function ae(v) {
							return v.resolve || {}
						}

						function rr(v) {
							return "string" == typeof v.title || null === v.title
						}

						function jn(v) {
							return (0, xe.w)(C => {
								const g = v(C);
								return g ? (0, y.D)(g).pipe((0, F.U)(() => C)) : (0, D.of)(C)
							})
						}
						const Tr = new p.OlP("ROUTES");
						let bi = (() => {
							class v {
								constructor(g, b) {
									this.injector = g, this.compiler = b, this.componentLoaders = new WeakMap, this.childrenLoaders = new WeakMap
								}
								loadComponent(g) {
									if (this.componentLoaders.get(g)) return this.componentLoaders.get(g);
									if (g._loadedComponent) return (0, D.of)(g._loadedComponent);
									this.onLoadStartListener && this.onLoadStartListener(g);
									const b = Bn(g.loadComponent()).pipe((0, F.U)(Hi), (0, Pt.b)(re => {
											this.onLoadEndListener && this.onLoadEndListener(g), g._loadedComponent = re
										}), Pe(() => {
											this.componentLoaders.delete(g)
										})),
										x = new Le(b, () => new je.x).pipe(Fe());
									return this.componentLoaders.set(g, x), x
								}
								loadChildren(g, b) {
									if (this.childrenLoaders.get(b)) return this.childrenLoaders.get(b);
									if (b._loadedRoutes) return (0, D.of)({
										routes: b._loadedRoutes,
										injector: b._loadedInjector
									});
									this.onLoadStartListener && this.onLoadStartListener(b);
									const re = this.loadModuleFactoryOrRoutes(b.loadChildren).pipe((0, F.U)(We => {
											this.onLoadEndListener && this.onLoadEndListener(b);
											let bt, Kt, on = !1;
											Array.isArray(We) ? Kt = We : (bt = We.create(g).injector, Kt = Kn(bt.get(Tr, [], p.XFs.Self | p.XFs.Optional)));
											return {
												routes: Kt.map(es),
												injector: bt
											}
										}), Pe(() => {
											this.childrenLoaders.delete(b)
										})),
										de = new Le(re, () => new je.x).pipe(Fe());
									return this.childrenLoaders.set(b, de), de
								}
								loadModuleFactoryOrRoutes(g) {
									return Bn(g()).pipe((0, F.U)(Hi), (0, Ge.z)(x => x instanceof p.YKP || Array.isArray(x) ? (0, D.of)(x) : (0, y.D)(this.compiler.compileModuleAsync(x))))
								}
							}
							return v.\u0275fac = function(g) {
								return new(g || v)(p.LFG(p.zs3), p.LFG(p.Sil))
							}, v.\u0275prov = p.Yz7({
								token: v,
								factory: v.\u0275fac,
								providedIn: "root"
							}), v
						})();

						function Hi(v) {
							return function Ii(v) {
								return v && "object" == typeof v && "default" in v
							}(v) ? v.default : v
						}
						let Mi = (() => {
							class v {
								get hasRequestedNavigation() {
									return 0 !== this.navigationId
								}
								constructor() {
									this.currentNavigation = null, this.lastSuccessfulNavigation = null, this.events = new je.x, this.configLoader = (0, p.f3M)(bi), this.environmentInjector = (0, p.f3M)(p.lqb), this.urlSerializer = (0, p.f3M)(pn), this.rootContexts = (0, p.f3M)(so), this.navigationId = 0, this.afterPreactivation = () => (0, D.of)(void 0), this.rootComponentType = null, this.configLoader.onLoadEndListener = x => this.events.next(new me(x)), this.configLoader.onLoadStartListener = x => this.events.next(new Br(x))
								}
								complete() {
									this.transitions?.complete()
								}
								handleNavigationRequest(g) {
									const b = ++this.navigationId;
									this.transitions?.next({
										...this.transitions.value,
										...g,
										id: b
									})
								}
								setupNavigations(g) {
									return this.transitions = new z.X({
										id: 0,
										targetPageId: 0,
										currentUrlTree: g.currentUrlTree,
										currentRawUrl: g.currentUrlTree,
										extractedUrl: g.urlHandlingStrategy.extract(g.currentUrlTree),
										urlAfterRedirects: g.urlHandlingStrategy.extract(g.currentUrlTree),
										rawUrl: g.currentUrlTree,
										extras: {},
										resolve: null,
										reject: null,
										promise: Promise.resolve(!0),
										source: gt,
										restoredState: null,
										currentSnapshot: g.routerState.snapshot,
										targetSnapshot: null,
										currentRouterState: g.routerState,
										targetRouterState: null,
										guards: {
											canActivateChecks: [],
											canDeactivateChecks: []
										},
										guardsResult: null
									}), this.transitions.pipe((0, ke.h)(b => 0 !== b.id), (0, F.U)(b => ({
										...b,
										extractedUrl: g.urlHandlingStrategy.extract(b.rawUrl)
									})), (0, xe.w)(b => {
										let x = !1,
											re = !1;
										return (0, D.of)(b).pipe((0, Pt.b)(de => {
											this.currentNavigation = {
												id: de.id,
												initialUrl: de.rawUrl,
												extractedUrl: de.extractedUrl,
												trigger: de.source,
												extras: de.extras,
												previousNavigation: this.lastSuccessfulNavigation ? {
													...this.lastSuccessfulNavigation,
													previousNavigation: null
												} : null
											}
										}), (0, xe.w)(de => {
											const We = g.browserUrlTree.toString(),
												bt = !g.navigated || de.extractedUrl.toString() !== We || We !== g.currentUrlTree.toString();
											if (!bt && "reload" !== (de.extras.onSameUrlNavigation ?? g.onSameUrlNavigation)) {
												const on = "";
												return this.events.next(new Rt(de.id, g.serializeUrl(b.rawUrl), on, 0)), g.rawUrlTree = de.rawUrl, de.resolve(null), te.E
											}
											if (g.urlHandlingStrategy.shouldProcessUrl(de.rawUrl)) return Co(de.source) && (g.browserUrlTree = de.extractedUrl), (0, D.of)(de).pipe((0, xe.w)(on => {
												const zn = this.transitions?.getValue();
												return this.events.next(new mt(on.id, this.urlSerializer.serialize(on.extractedUrl), on.source, on.restoredState)), zn !== this.transitions?.getValue() ? te.E : Promise.resolve(on)
											}), function Ea(v, C, g, b) {
												return (0, xe.w)(x => function yc(v, C, g, b, x) {
													return new Fs(v, C, g, b, x).apply()
												}(v, C, g, x.extractedUrl, b).pipe((0, F.U)(re => ({
													...x,
													urlAfterRedirects: re
												}))))
											}(this.environmentInjector, this.configLoader, this.urlSerializer, g.config), (0, Pt.b)(on => {
												this.currentNavigation = {
													...this.currentNavigation,
													finalUrl: on.urlAfterRedirects
												}, b.urlAfterRedirects = on.urlAfterRedirects
											}), function Oe(v, C, g, b, x) {
												return (0, Ge.z)(re => function yr(v, C, g, b, x, re, de = "emptyOnly") {
													return new ul(v, C, g, b, x, de, re).recognize().pipe((0, xe.w)(We => null === We ? function yi(v) {
														return new X.y(C => C.error(v))
													}(new ur) : (0, D.of)(We)))
												}(v, C, g, re.urlAfterRedirects, b.serialize(re.urlAfterRedirects), b, x).pipe((0, F.U)(de => ({
													...re,
													targetSnapshot: de
												}))))
											}(this.environmentInjector, this.rootComponentType, g.config, this.urlSerializer, g.paramsInheritanceStrategy), (0, Pt.b)(on => {
												if (b.targetSnapshot = on.targetSnapshot, "eager" === g.urlUpdateStrategy) {
													if (!on.extras.skipLocationChange) {
														const xr = g.urlHandlingStrategy.merge(on.urlAfterRedirects, on.rawUrl);
														g.setBrowserUrl(xr, on)
													}
													g.browserUrlTree = on.urlAfterRedirects
												}
												const zn = new Jt(on.id, this.urlSerializer.serialize(on.extractedUrl), this.urlSerializer.serialize(on.urlAfterRedirects), on.targetSnapshot);
												this.events.next(zn)
											}));
											if (bt && g.urlHandlingStrategy.shouldProcessUrl(g.rawUrlTree)) {
												const {
													id: on,
													extractedUrl: zn,
													source: xr,
													restoredState: Gi,
													extras: to
												} = de, gi = new mt(on, this.urlSerializer.serialize(zn), xr, Gi);
												this.events.next(gi);
												const Cr = Si(zn, this.rootComponentType).snapshot;
												return b = {
													...de,
													targetSnapshot: Cr,
													urlAfterRedirects: zn,
													extras: {
														...to,
														skipLocationChange: !1,
														replaceUrl: !1
													}
												}, (0, D.of)(b)
											} {
												const on = "";
												return this.events.next(new Rt(de.id, g.serializeUrl(b.extractedUrl), on, 1)), g.rawUrlTree = de.rawUrl, de.resolve(null), te.E
											}
										}), (0, Pt.b)(de => {
											const We = new Mn(de.id, this.urlSerializer.serialize(de.extractedUrl), this.urlSerializer.serialize(de.urlAfterRedirects), de.targetSnapshot);
											this.events.next(We)
										}), (0, F.U)(de => b = {
											...de,
											guards: di(de.targetSnapshot, de.currentSnapshot, this.rootContexts)
										}), function cl(v, C) {
											return (0, Ge.z)(g => {
												const {
													targetSnapshot: b,
													currentSnapshot: x,
													guards: {
														canActivateChecks: re,
														canDeactivateChecks: de
													}
												} = g;
												return 0 === de.length && 0 === re.length ? (0, D.of)({
													...g,
													guardsResult: !0
												}) : function zr(v, C, g, b) {
													return (0, y.D)(v).pipe((0, Ge.z)(x => function gc(v, C, g, b, x) {
														const re = C && C.routeConfig ? C.routeConfig.canDeactivate : null;
														if (!re || 0 === re.length) return (0, D.of)(!0);
														const de = re.map(We => {
															const bt = Ai(C) ?? x,
																Kt = Li(We, bt);
															return Bn(function Ps(v) {
																return v && wn(v.canDeactivate)
															}(Kt) ? Kt.canDeactivate(v, C, g, b) : bt.runInContext(() => Kt(v, C, g, b))).pipe((0, ft.P)())
														});
														return (0, D.of)(de).pipe(uo())
													}(x.component, x.route, g, C, b)), (0, ft.P)(x => !0 !== x, !0))
												}(de, b, x, v).pipe((0, Ge.z)(We => We && function pa(v) {
													return "boolean" == typeof v
												}(We) ? function pc(v, C, g, b) {
													return (0, y.D)(C).pipe((0, nt.b)(x => (0, N.z)(function Ri(v, C) {
														return null !== v && C && C(new tt(v)), (0, D.of)(!0)
													}(x.route.parent, b), function ns(v, C) {
														return null !== v && C && C(new dt(v)), (0, D.of)(!0)
													}(x.route, b), function ma(v, C, g) {
														const b = C[C.length - 1],
															re = C.slice(0, C.length - 1).reverse().map(de => function uc(v) {
																const C = v.routeConfig ? v.routeConfig.canActivateChild : null;
																return C && 0 !== C.length ? {
																	node: v,
																	guards: C
																} : null
															}(de)).filter(de => null !== de).map(de => (0, Y.P)(() => {
																const We = de.guards.map(bt => {
																	const Kt = Ai(de.node) ?? g,
																		on = Li(bt, Kt);
																	return Bn(function al(v) {
																		return v && wn(v.canActivateChild)
																	}(on) ? on.canActivateChild(b, v) : Kt.runInContext(() => on(b, v))).pipe((0, ft.P)())
																});
																return (0, D.of)(We).pipe(uo())
															}));
														return (0, D.of)(re).pipe(uo())
													}(v, x.path, g), function ga(v, C, g) {
														const b = C.routeConfig ? C.routeConfig.canActivate : null;
														if (!b || 0 === b.length) return (0, D.of)(!0);
														const x = b.map(re => (0, Y.P)(() => {
															const de = Ai(C) ?? g,
																We = Li(re, de);
															return Bn(function dc(v) {
																return v && wn(v.canActivate)
															}(We) ? We.canActivate(C, v) : de.runInContext(() => We(C, v))).pipe((0, ft.P)())
														}));
														return (0, D.of)(x).pipe(uo())
													}(v, x.route, g))), (0, ft.P)(x => !0 !== x, !0))
												}(b, re, v, C) : (0, D.of)(We)), (0, F.U)(We => ({
													...g,
													guardsResult: We
												})))
											})
										}(this.environmentInjector, de => this.events.next(de)), (0, Pt.b)(de => {
											if (b.guardsResult = de.guardsResult, Ke(de.guardsResult)) throw ac(0, de.guardsResult);
											const We = new Cn(de.id, this.urlSerializer.serialize(de.extractedUrl), this.urlSerializer.serialize(de.urlAfterRedirects), de.targetSnapshot, !!de.guardsResult);
											this.events.next(We)
										}), (0, ke.h)(de => !!de.guardsResult || (g.restoreHistory(de), this.cancelNavigationTransition(de, "", 3), !1)), jn(de => {
											if (de.guards.canActivateChecks.length) return (0, D.of)(de).pipe((0, Pt.b)(We => {
												const bt = new Jn(We.id, this.urlSerializer.serialize(We.extractedUrl), this.urlSerializer.serialize(We.urlAfterRedirects), We.targetSnapshot);
												this.events.next(bt)
											}), (0, xe.w)(We => {
												let bt = !1;
												return (0, D.of)(We).pipe(function ut(v, C) {
													return (0, Ge.z)(g => {
														const {
															targetSnapshot: b,
															guards: {
																canActivateChecks: x
															}
														} = g;
														if (!x.length) return (0, D.of)(g);
														let re = 0;
														return (0, y.D)(x).pipe((0, nt.b)(de => function It(v, C, g, b) {
															const x = v.routeConfig,
																re = v._resolve;
															return void 0 !== x?.title && !rr(x) && (re[Vt] = x.title),
																function dn(v, C, g, b) {
																	const x = function qn(v) {
																		return [...Object.keys(v), ...Object.getOwnPropertySymbols(v)]
																	}(v);
																	if (0 === x.length) return (0, D.of)({});
																	const re = {};
																	return (0, y.D)(x).pipe((0, Ge.z)(de => function Yn(v, C, g, b) {
																		const x = Ai(C) ?? b,
																			re = Li(v, x);
																		return Bn(re.resolve ? re.resolve(C, g) : x.runInContext(() => re(C, g)))
																	}(v[de], C, g, b).pipe((0, ft.P)(), (0, Pt.b)(We => {
																		re[de] = We
																	}))), et(1), (0, ht.h)(re), (0, at.K)(de => Ct(de) ? te.E : (0, Q._)(de)))
																}(re, v, C, b).pipe((0, F.U)(de => (v._resolvedData = de, v.data = bs(v, g).resolve, x && rr(x) && (v.data[Vt] = x.title), null)))
														}(de.route, b, v, C)), (0, Pt.b)(() => re++), et(1), (0, Ge.z)(de => re === x.length ? (0, D.of)(g) : te.E))
													})
												}(g.paramsInheritanceStrategy, this.environmentInjector), (0, Pt.b)({
													next: () => bt = !0,
													complete: () => {
														bt || (g.restoreHistory(We), this.cancelNavigationTransition(We, "", 2))
													}
												}))
											}), (0, Pt.b)(We => {
												const bt = new xn(We.id, this.urlSerializer.serialize(We.extractedUrl), this.urlSerializer.serialize(We.urlAfterRedirects), We.targetSnapshot);
												this.events.next(bt)
											}))
										}), jn(de => {
											const We = bt => {
												const Kt = [];
												bt.routeConfig?.loadComponent && !bt.routeConfig._loadedComponent && Kt.push(this.configLoader.loadComponent(bt.routeConfig).pipe((0, Pt.b)(on => {
													bt.component = on
												}), (0, F.U)(() => {})));
												for (const on of bt.children) Kt.push(...We(on));
												return Kt
											};
											return (0, P.a)(We(de.targetSnapshot.root)).pipe((0, Be.d)(), (0, Ee.q)(1))
										}), jn(() => this.afterPreactivation()), (0, F.U)(de => {
											const We = function il(v, C, g) {
												const b = Nr(v, C._root, g ? g._root : void 0);
												return new ni(b, C)
											}(g.routeReuseStrategy, de.targetSnapshot, de.currentRouterState);
											return b = {
												...de,
												targetRouterState: We
											}
										}), (0, Pt.b)(de => {
											g.currentUrlTree = de.urlAfterRedirects, g.rawUrlTree = g.urlHandlingStrategy.merge(de.urlAfterRedirects, de.rawUrl), g.routerState = de.targetRouterState, "deferred" === g.urlUpdateStrategy && (de.extras.skipLocationChange || g.setBrowserUrl(g.rawUrlTree, de), g.browserUrlTree = de.urlAfterRedirects)
										}), ((v, C, g) => (0, F.U)(b => (new ts(C, b.targetRouterState, b.currentRouterState, g).activate(v), b)))(this.rootContexts, g.routeReuseStrategy, de => this.events.next(de)), (0, Pt.b)({
											next: de => {
												x = !0, this.lastSuccessfulNavigation = this.currentNavigation, g.navigated = !0, this.events.next(new Et(de.id, this.urlSerializer.serialize(de.extractedUrl), this.urlSerializer.serialize(g.currentUrlTree))), g.titleStrategy?.updateTitle(de.targetRouterState.snapshot), de.resolve(!0)
											},
											complete: () => {
												x = !0
											}
										}), Pe(() => {
											x || re || this.cancelNavigationTransition(b, "", 1), this.currentNavigation?.id === b.id && (this.currentNavigation = null)
										}), (0, at.K)(de => {
											if (re = !0, la(de)) {
												As(de) || (g.navigated = !0, g.restoreHistory(b, !0));
												const We = new Gt(b.id, this.urlSerializer.serialize(b.extractedUrl), de.message, de.cancellationCode);
												if (this.events.next(We), As(de)) {
													const bt = g.urlHandlingStrategy.merge(de.url, g.rawUrlTree),
														Kt = {
															skipLocationChange: b.extras.skipLocationChange,
															replaceUrl: "eager" === g.urlUpdateStrategy || Co(b.source)
														};
													g.scheduleNavigation(bt, gt, null, Kt, {
														resolve: b.resolve,
														reject: b.reject,
														promise: b.promise
													})
												} else b.resolve(!1)
											} else {
												g.restoreHistory(b, !0);
												const We = new Ot(b.id, this.urlSerializer.serialize(b.extractedUrl), de, b.targetSnapshot ?? void 0);
												this.events.next(We);
												try {
													b.resolve(g.errorHandler(de))
												} catch (bt) {
													b.reject(bt)
												}
											}
											return te.E
										}))
									}))
								}
								cancelNavigationTransition(g, b, x) {
									const re = new Gt(g.id, this.urlSerializer.serialize(g.extractedUrl), b, x);
									this.events.next(re), g.resolve(!1)
								}
							}
							return v.\u0275fac = function(g) {
								return new(g || v)
							}, v.\u0275prov = p.Yz7({
								token: v,
								factory: v.\u0275fac,
								providedIn: "root"
							}), v
						})();

						function Co(v) {
							return v !== gt
						}
						let So = (() => {
								class v {
									buildTitle(g) {
										let b, x = g.root;
										for (; void 0 !== x;) b = this.getResolvedTitleForRoute(x) ?? b, x = x.children.find(re => re.outlet === ot);
										return b
									}
									getResolvedTitleForRoute(g) {
										return g.data[Vt]
									}
								}
								return v.\u0275fac = function(g) {
									return new(g || v)
								}, v.\u0275prov = p.Yz7({
									token: v,
									factory: function() {
										return (0, p.f3M)(ch)
									},
									providedIn: "root"
								}), v
							})(),
							ch = (() => {
								class v extends So {
									constructor(g) {
										super(), this.title = g
									}
									updateTitle(g) {
										const b = this.buildTitle(g);
										void 0 !== b && this.title.setTitle(b)
									}
								}
								return v.\u0275fac = function(g) {
									return new(g || v)(p.LFG(Bt.Dx))
								}, v.\u0275prov = p.Yz7({
									token: v,
									factory: v.\u0275fac,
									providedIn: "root"
								}), v
							})(),
							Sc = (() => {
								class v {}
								return v.\u0275fac = function(g) {
									return new(g || v)
								}, v.\u0275prov = p.Yz7({
									token: v,
									factory: function() {
										return (0, p.f3M)(Sa)
									},
									providedIn: "root"
								}), v
							})();
						class fl {
							shouldDetach(C) {
								return !1
							}
							store(C, g) {}
							shouldAttach(C) {
								return !1
							}
							retrieve(C) {
								return null
							}
							shouldReuseRoute(C, g) {
								return C.routeConfig === g.routeConfig
							}
						}
						let Sa = (() => {
							class v extends fl {}
							return v.\u0275fac = function() {
								let C;
								return function(b) {
									return (C || (C = p.n5z(v)))(b || v)
								}
							}(), v.\u0275prov = p.Yz7({
								token: v,
								factory: v.\u0275fac,
								providedIn: "root"
							}), v
						})();
						const Ls = new p.OlP("", {
							providedIn: "root",
							factory: () => ({})
						});
						let _e = (() => {
								class v {}
								return v.\u0275fac = function(g) {
									return new(g || v)
								}, v.\u0275prov = p.Yz7({
									token: v,
									factory: function() {
										return (0, p.f3M)(St)
									},
									providedIn: "root"
								}), v
							})(),
							St = (() => {
								class v {
									shouldProcessUrl(g) {
										return !0
									}
									extract(g) {
										return g
									}
									merge(g, b) {
										return g
									}
								}
								return v.\u0275fac = function(g) {
									return new(g || v)
								}, v.\u0275prov = p.Yz7({
									token: v,
									factory: v.\u0275fac,
									providedIn: "root"
								}), v
							})();

						function mu(v) {
							throw v
						}

						function q(v, C, g) {
							return C.parse("/")
						}
						const _t = {
								paths: "exact",
								fragment: "ignored",
								matrixParams: "ignored",
								queryParams: "exact"
							},
							vn = {
								paths: "subset",
								fragment: "ignored",
								matrixParams: "ignored",
								queryParams: "subset"
							};
						let Ir = (() => {
								class v {
									get navigationId() {
										return this.navigationTransitions.navigationId
									}
									get browserPageId() {
										return this.location.getState()?.\u0275routerPageId
									}
									get events() {
										return this.navigationTransitions.events
									}
									constructor() {
										this.disposed = !1, this.currentPageId = 0, this.console = (0, p.f3M)(p.c2e), this.isNgZoneEnabled = !1, this.options = (0, p.f3M)(Ls, {
											optional: !0
										}) || {}, this.errorHandler = this.options.errorHandler || mu, this.malformedUriErrorHandler = this.options.malformedUriErrorHandler || q, this.navigated = !1, this.lastSuccessfulId = -1, this.urlHandlingStrategy = (0, p.f3M)(_e), this.routeReuseStrategy = (0, p.f3M)(Sc), this.urlCreationStrategy = (0, p.f3M)($n), this.titleStrategy = (0, p.f3M)(So), this.onSameUrlNavigation = this.options.onSameUrlNavigation || "ignore", this.paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || "emptyOnly", this.urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred", this.canceledNavigationResolution = this.options.canceledNavigationResolution || "replace", this.config = Kn((0, p.f3M)(Tr, {
											optional: !0
										}) ?? []), this.navigationTransitions = (0, p.f3M)(Mi), this.urlSerializer = (0, p.f3M)(pn), this.location = (0, p.f3M)(Ce.Ye), this.isNgZoneEnabled = (0, p.f3M)(p.R0b) instanceof p.R0b && p.R0b.isInAngularZone(), this.resetConfig(this.config), this.currentUrlTree = new Xe, this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.routerState = Si(this.currentUrlTree, null), this.navigationTransitions.setupNavigations(this).subscribe(g => {
											this.lastSuccessfulId = g.id, this.currentPageId = g.targetPageId
										}, g => {
											this.console.warn(`Unhandled Navigation Error: ${g}`)
										})
									}
									resetRootComponentType(g) {
										this.routerState.root.component = g, this.navigationTransitions.rootComponentType = g
									}
									initialNavigation() {
										if (this.setUpLocationChangeListener(), !this.navigationTransitions.hasRequestedNavigation) {
											const g = this.location.getState();
											this.navigateToSyncWithBrowser(this.location.path(!0), gt, g)
										}
									}
									setUpLocationChangeListener() {
										this.locationSubscription || (this.locationSubscription = this.location.subscribe(g => {
											const b = "popstate" === g.type ? "popstate" : "hashchange";
											"popstate" === b && setTimeout(() => {
												this.navigateToSyncWithBrowser(g.url, b, g.state)
											}, 0)
										}))
									}
									navigateToSyncWithBrowser(g, b, x) {
										const re = {
												replaceUrl: !0
											},
											de = x?.navigationId ? x : null;
										if (x) {
											const bt = {
												...x
											};
											delete bt.navigationId, delete bt.\u0275routerPageId, 0 !== Object.keys(bt).length && (re.state = bt)
										}
										const We = this.parseUrl(g);
										this.scheduleNavigation(We, b, de, re)
									}
									get url() {
										return this.serializeUrl(this.currentUrlTree)
									}
									getCurrentNavigation() {
										return this.navigationTransitions.currentNavigation
									}
									resetConfig(g) {
										this.config = g.map(es), this.navigated = !1, this.lastSuccessfulId = -1
									}
									ngOnDestroy() {
										this.dispose()
									}
									dispose() {
										this.navigationTransitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0
									}
									createUrlTree(g, b = {}) {
										const {
											relativeTo: x,
											queryParams: re,
											fragment: de,
											queryParamsHandling: We,
											preserveFragment: bt
										} = b, Kt = bt ? this.currentUrlTree.fragment : de;
										let on = null;
										switch (We) {
											case "merge":
												on = {
													...this.currentUrlTree.queryParams,
													...re
												};
												break;
											case "preserve":
												on = this.currentUrlTree.queryParams;
												break;
											default:
												on = re || null
										}
										return null !== on && (on = this.removeEmptyProps(on)), this.urlCreationStrategy.createUrlTree(x, this.routerState, this.currentUrlTree, g, on, Kt ?? null)
									}
									navigateByUrl(g, b = {
										skipLocationChange: !1
									}) {
										const x = Ke(g) ? g : this.parseUrl(g),
											re = this.urlHandlingStrategy.merge(x, this.rawUrlTree);
										return this.scheduleNavigation(re, gt, null, b)
									}
									navigate(g, b = {
										skipLocationChange: !1
									}) {
										return function Ta(v) {
											for (let C = 0; C < v.length; C++) {
												const g = v[C];
												if (null == g) throw new p.vHH(4008, false)
											}
										}(g), this.navigateByUrl(this.createUrlTree(g, b), b)
									}
									serializeUrl(g) {
										return this.urlSerializer.serialize(g)
									}
									parseUrl(g) {
										let b;
										try {
											b = this.urlSerializer.parse(g)
										} catch (x) {
											b = this.malformedUriErrorHandler(x, this.urlSerializer, g)
										}
										return b
									}
									isActive(g, b) {
										let x;
										if (x = !0 === b ? {
												..._t
											} : !1 === b ? {
												...vn
											} : b, Ke(g)) return Qn(this.currentUrlTree, g, x);
										const re = this.parseUrl(g);
										return Qn(this.currentUrlTree, re, x)
									}
									removeEmptyProps(g) {
										return Object.keys(g).reduce((b, x) => {
											const re = g[x];
											return null != re && (b[x] = re), b
										}, {})
									}
									scheduleNavigation(g, b, x, re, de) {
										if (this.disposed) return Promise.resolve(!1);
										let We, bt, Kt, on;
										return de ? (We = de.resolve, bt = de.reject, Kt = de.promise) : Kt = new Promise((zn, xr) => {
											We = zn, bt = xr
										}), on = "computed" === this.canceledNavigationResolution ? x && x.\u0275routerPageId ? x.\u0275routerPageId : re.replaceUrl || re.skipLocationChange ? this.browserPageId ?? 0 : (this.browserPageId ?? 0) + 1 : 0, this.navigationTransitions.handleNavigationRequest({
											targetPageId: on,
											source: b,
											restoredState: x,
											currentUrlTree: this.currentUrlTree,
											currentRawUrl: this.currentUrlTree,
											rawUrl: g,
											extras: re,
											resolve: We,
											reject: bt,
											promise: Kt,
											currentSnapshot: this.routerState.snapshot,
											currentRouterState: this.routerState
										}), Kt.catch(zn => Promise.reject(zn))
									}
									setBrowserUrl(g, b) {
										const x = this.urlSerializer.serialize(g),
											re = {
												...b.extras.state,
												...this.generateNgRouterState(b.id, b.targetPageId)
											};
										this.location.isCurrentPathEqualTo(x) || b.extras.replaceUrl ? this.location.replaceState(x, "", re) : this.location.go(x, "", re)
									}
									restoreHistory(g, b = !1) {
										if ("computed" === this.canceledNavigationResolution) {
											const x = this.currentPageId - g.targetPageId;
											"popstate" !== g.source && "eager" !== this.urlUpdateStrategy && this.currentUrlTree !== this.getCurrentNavigation()?.finalUrl || 0 === x ? this.currentUrlTree === this.getCurrentNavigation()?.finalUrl && 0 === x && (this.resetState(g), this.browserUrlTree = g.currentUrlTree, this.resetUrlToCurrentUrlTree()) : this.location.historyGo(x)
										} else "replace" === this.canceledNavigationResolution && (b && this.resetState(g), this.resetUrlToCurrentUrlTree())
									}
									resetState(g) {
										this.routerState = g.currentRouterState, this.currentUrlTree = g.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, g.rawUrl)
									}
									resetUrlToCurrentUrlTree() {
										this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId))
									}
									generateNgRouterState(g, b) {
										return "computed" === this.canceledNavigationResolution ? {
											navigationId: g,
											\u0275routerPageId: b
										} : {
											navigationId: g
										}
									}
								}
								return v.\u0275fac = function(g) {
									return new(g || v)
								}, v.\u0275prov = p.Yz7({
									token: v,
									factory: v.\u0275fac,
									providedIn: "root"
								}), v
							})(),
							wa = (() => {
								class v {
									constructor(g, b, x, re, de, We) {
										this.router = g, this.route = b, this.tabIndexAttribute = x, this.renderer = re, this.el = de, this.locationStrategy = We, this._preserveFragment = !1, this._skipLocationChange = !1, this._replaceUrl = !1, this.href = null, this.commands = null, this.onChanges = new je.x;
										const bt = de.nativeElement.tagName;
										this.isAnchorElement = "A" === bt || "AREA" === bt, this.isAnchorElement ? this.subscription = g.events.subscribe(Kt => {
											Kt instanceof Et && this.updateHref()
										}) : this.setTabIndexIfNotOnNativeEl("0")
									}
									set preserveFragment(g) {
										this._preserveFragment = (0, p.D6c)(g)
									}
									get preserveFragment() {
										return this._preserveFragment
									}
									set skipLocationChange(g) {
										this._skipLocationChange = (0, p.D6c)(g)
									}
									get skipLocationChange() {
										return this._skipLocationChange
									}
									set replaceUrl(g) {
										this._replaceUrl = (0, p.D6c)(g)
									}
									get replaceUrl() {
										return this._replaceUrl
									}
									setTabIndexIfNotOnNativeEl(g) {
										null != this.tabIndexAttribute || this.isAnchorElement || this.applyAttributeValue("tabindex", g)
									}
									ngOnChanges(g) {
										this.isAnchorElement && this.updateHref(), this.onChanges.next(this)
									}
									set routerLink(g) {
										null != g ? (this.commands = Array.isArray(g) ? g : [g], this.setTabIndexIfNotOnNativeEl("0")) : (this.commands = null, this.setTabIndexIfNotOnNativeEl(null))
									}
									onClick(g, b, x, re, de) {
										return !!(null === this.urlTree || this.isAnchorElement && (0 !== g || b || x || re || de || "string" == typeof this.target && "_self" != this.target)) || (this.router.navigateByUrl(this.urlTree, {
											skipLocationChange: this.skipLocationChange,
											replaceUrl: this.replaceUrl,
											state: this.state
										}), !this.isAnchorElement)
									}
									ngOnDestroy() {
										this.subscription?.unsubscribe()
									}
									updateHref() {
										this.href = null !== this.urlTree && this.locationStrategy ? this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) : null;
										const g = null === this.href ? null : (0, p.P3R)(this.href, this.el.nativeElement.tagName.toLowerCase(), "href");
										this.applyAttributeValue("href", g)
									}
									applyAttributeValue(g, b) {
										const x = this.renderer,
											re = this.el.nativeElement;
										null !== b ? x.setAttribute(re, g, b) : x.removeAttribute(re, g)
									}
									get urlTree() {
										return null === this.commands ? null : this.router.createUrlTree(this.commands, {
											relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route,
											queryParams: this.queryParams,
											fragment: this.fragment,
											queryParamsHandling: this.queryParamsHandling,
											preserveFragment: this.preserveFragment
										})
									}
								}
								return v.\u0275fac = function(g) {
									return new(g || v)(p.Y36(Ir), p.Y36(oo), p.$8M("tabindex"), p.Y36(p.Qsj), p.Y36(p.SBq), p.Y36(Ce.S$))
								}, v.\u0275dir = p.lG2({
									type: v,
									selectors: [
										["", "routerLink", ""]
									],
									hostVars: 1,
									hostBindings: function(g, b) {
										1 & g && p.NdJ("click", function(re) {
											return b.onClick(re.button, re.ctrlKey, re.shiftKey, re.altKey, re.metaKey)
										}), 2 & g && p.uIk("target", b.target)
									},
									inputs: {
										target: "target",
										queryParams: "queryParams",
										fragment: "fragment",
										queryParamsHandling: "queryParamsHandling",
										state: "state",
										relativeTo: "relativeTo",
										preserveFragment: "preserveFragment",
										skipLocationChange: "skipLocationChange",
										replaceUrl: "replaceUrl",
										routerLink: "routerLink"
									},
									standalone: !0,
									features: [p.TTD]
								}), v
							})(),
							Fo = (() => {
								class v {
									get isActive() {
										return this._isActive
									}
									constructor(g, b, x, re, de) {
										this.router = g, this.element = b, this.renderer = x, this.cdr = re, this.link = de, this.classes = [], this._isActive = !1, this.routerLinkActiveOptions = {
											exact: !1
										}, this.isActiveChange = new p.vpe, this.routerEventsSubscription = g.events.subscribe(We => {
											We instanceof Et && this.update()
										})
									}
									ngAfterContentInit() {
										(0, D.of)(this.links.changes, (0, D.of)(null)).pipe((0, pt.J)()).subscribe(g => {
											this.update(), this.subscribeToEachLinkOnChanges()
										})
									}
									subscribeToEachLinkOnChanges() {
										this.linkInputChangesSubscription?.unsubscribe();
										const g = [...this.links.toArray(), this.link].filter(b => !!b).map(b => b.onChanges);
										this.linkInputChangesSubscription = (0, y.D)(g).pipe((0, pt.J)()).subscribe(b => {
											this._isActive !== this.isLinkActive(this.router)(b) && this.update()
										})
									}
									set routerLinkActive(g) {
										const b = Array.isArray(g) ? g : g.split(" ");
										this.classes = b.filter(x => !!x)
									}
									ngOnChanges(g) {
										this.update()
									}
									ngOnDestroy() {
										this.routerEventsSubscription.unsubscribe(), this.linkInputChangesSubscription?.unsubscribe()
									}
									update() {
										!this.links || !this.router.navigated || Promise.resolve().then(() => {
											const g = this.hasActiveLinks();
											this._isActive !== g && (this._isActive = g, this.cdr.markForCheck(), this.classes.forEach(b => {
												g ? this.renderer.addClass(this.element.nativeElement, b) : this.renderer.removeClass(this.element.nativeElement, b)
											}), g && void 0 !== this.ariaCurrentWhenActive ? this.renderer.setAttribute(this.element.nativeElement, "aria-current", this.ariaCurrentWhenActive.toString()) : this.renderer.removeAttribute(this.element.nativeElement, "aria-current"), this.isActiveChange.emit(g))
										})
									}
									isLinkActive(g) {
										const b = function Oi(v) {
											return !!v.paths
										}(this.routerLinkActiveOptions) ? this.routerLinkActiveOptions : this.routerLinkActiveOptions.exact || !1;
										return x => !!x.urlTree && g.isActive(x.urlTree, b)
									}
									hasActiveLinks() {
										const g = this.isLinkActive(this.router);
										return this.link && g(this.link) || this.links.some(g)
									}
								}
								return v.\u0275fac = function(g) {
									return new(g || v)(p.Y36(Ir), p.Y36(p.SBq), p.Y36(p.Qsj), p.Y36(p.sBO), p.Y36(wa, 8))
								}, v.\u0275dir = p.lG2({
									type: v,
									selectors: [
										["", "routerLinkActive", ""]
									],
									contentQueries: function(g, b, x) {
										if (1 & g && p.Suo(x, wa, 5), 2 & g) {
											let re;
											p.iGM(re = p.CRH()) && (b.links = re)
										}
									},
									inputs: {
										routerLinkActiveOptions: "routerLinkActiveOptions",
										ariaCurrentWhenActive: "ariaCurrentWhenActive",
										routerLinkActive: "routerLinkActive"
									},
									outputs: {
										isActiveChange: "isActiveChange"
									},
									exportAs: ["routerLinkActive"],
									standalone: !0,
									features: [p.TTD]
								}), v
							})();
						class Qe {}
						let Ia = (() => {
							class v {
								constructor(g, b, x, re, de) {
									this.router = g, this.injector = x, this.preloadingStrategy = re, this.loader = de
								}
								setUpPreloading() {
									this.subscription = this.router.events.pipe((0, ke.h)(g => g instanceof Et), (0, nt.b)(() => this.preload())).subscribe(() => {})
								}
								preload() {
									return this.processRoutes(this.injector, this.router.config)
								}
								ngOnDestroy() {
									this.subscription && this.subscription.unsubscribe()
								}
								processRoutes(g, b) {
									const x = [];
									for (const re of b) {
										re.providers && !re._injector && (re._injector = (0, p.MMx)(re.providers, g, `Route: ${re.path}`));
										const de = re._injector ?? g,
											We = re._loadedInjector ?? de;
										re.loadChildren && !re._loadedRoutes && void 0 === re.canLoad || re.loadComponent && !re._loadedComponent ? x.push(this.preloadConfig(de, re)) : (re.children || re._loadedRoutes) && x.push(this.processRoutes(We, re.children ?? re._loadedRoutes))
									}
									return (0, y.D)(x).pipe((0, pt.J)())
								}
								preloadConfig(g, b) {
									return this.preloadingStrategy.preload(b, () => {
										let x;
										x = b.loadChildren && void 0 === b.canLoad ? this.loader.loadChildren(g, b) : (0, D.of)(null);
										const re = x.pipe((0, Ge.z)(de => null === de ? (0, D.of)(void 0) : (b._loadedRoutes = de.routes, b._loadedInjector = de.injector, this.processRoutes(de.injector ?? g, de.routes))));
										if (b.loadComponent && !b._loadedComponent) {
											const de = this.loader.loadComponent(b);
											return (0, y.D)([re, de]).pipe((0, pt.J)())
										}
										return re
									})
								}
							}
							return v.\u0275fac = function(g) {
								return new(g || v)(p.LFG(Ir), p.LFG(p.Sil), p.LFG(p.lqb), p.LFG(Qe), p.LFG(bi))
							}, v.\u0275prov = p.Yz7({
								token: v,
								factory: v.\u0275fac,
								providedIn: "root"
							}), v
						})();
						const Er = new p.OlP("");
						let Tc = (() => {
							class v {
								constructor(g, b, x, re, de = {}) {
									this.urlSerializer = g, this.transitions = b, this.viewportScroller = x, this.zone = re, this.options = de, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, de.scrollPositionRestoration = de.scrollPositionRestoration || "disabled", de.anchorScrolling = de.anchorScrolling || "disabled"
								}
								init() {
									"disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents()
								}
								createScrollEvents() {
									return this.transitions.events.subscribe(g => {
										g instanceof mt ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = g.navigationTrigger, this.restoredId = g.restoredState ? g.restoredState.navigationId : 0) : g instanceof Et && (this.lastId = g.id, this.scheduleScrollEvent(g, this.urlSerializer.parse(g.urlAfterRedirects).fragment))
									})
								}
								consumeScrollEvents() {
									return this.transitions.events.subscribe(g => {
										g instanceof Mt && (g.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(g.position) : g.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(g.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0]))
									})
								}
								scheduleScrollEvent(g, b) {
									this.zone.runOutsideAngular(() => {
										setTimeout(() => {
											this.zone.run(() => {
												this.transitions.events.next(new Mt(g, "popstate" === this.lastSource ? this.store[this.restoredId] : null, b))
											})
										}, 0)
									})
								}
								ngOnDestroy() {
									this.routerEventsSubscription?.unsubscribe(), this.scrollEventsSubscription?.unsubscribe()
								}
							}
							return v.\u0275fac = function(g) {
								p.$Z()
							}, v.\u0275prov = p.Yz7({
								token: v,
								factory: v.\u0275fac
							}), v
						})();
						const pi = !1;

						function rn(v, C) {
							return {
								\u0275kind: v,
								\u0275providers: C
							}
						}
						const Da = new p.OlP("", {
							providedIn: "root",
							factory: () => !1
						});

						function Aa() {
							const v = (0, p.f3M)(p.zs3);
							return C => {
								const g = v.get(p.z2F);
								if (C !== g.components[0]) return;
								const b = v.get(Ir),
									x = v.get(Zi);
								1 === v.get(To) && b.initialNavigation(), v.get(wo, null, p.XFs.Optional)?.setUpPreloading(), v.get(Er, null, p.XFs.Optional)?.init(), b.resetRootComponentType(g.componentTypes[0]), x.closed || (x.next(), x.unsubscribe())
							}
						}
						const Zi = new p.OlP(pi ? "bootstrap done indicator" : "", {
								factory: () => new je.x
							}),
							To = new p.OlP(pi ? "initial navigation" : "", {
								providedIn: "root",
								factory: () => 1
							});

						function bc() {
							let v = [];
							return v = pi ? [{
								provide: p.Xts,
								multi: !0,
								useFactory: () => {
									const C = (0, p.f3M)(Ir);
									return () => C.events.subscribe(g => {
										console.group?.(`Router Event: ${g.constructor.name}`), console.log(function Fn(v) {
											if (!("type" in v)) return `Unknown Router Event: ${v.constructor.name}`;
											switch (v.type) {
												case 14:
													return `ActivationEnd(path: '${v.snapshot.routeConfig?.path||""}')`;
												case 13:
													return `ActivationStart(path: '${v.snapshot.routeConfig?.path||""}')`;
												case 12:
													return `ChildActivationEnd(path: '${v.snapshot.routeConfig?.path||""}')`;
												case 11:
													return `ChildActivationStart(path: '${v.snapshot.routeConfig?.path||""}')`;
												case 8:
													return `GuardsCheckEnd(id: ${v.id}, url: '${v.url}', urlAfterRedirects: '${v.urlAfterRedirects}', state: ${v.state}, shouldActivate: ${v.shouldActivate})`;
												case 7:
													return `GuardsCheckStart(id: ${v.id}, url: '${v.url}', urlAfterRedirects: '${v.urlAfterRedirects}', state: ${v.state})`;
												case 2:
													return `NavigationCancel(id: ${v.id}, url: '${v.url}')`;
												case 16:
													return `NavigationSkipped(id: ${v.id}, url: '${v.url}')`;
												case 1:
													return `NavigationEnd(id: ${v.id}, url: '${v.url}', urlAfterRedirects: '${v.urlAfterRedirects}')`;
												case 3:
													return `NavigationError(id: ${v.id}, url: '${v.url}', error: ${v.error})`;
												case 0:
													return `NavigationStart(id: ${v.id}, url: '${v.url}')`;
												case 6:
													return `ResolveEnd(id: ${v.id}, url: '${v.url}', urlAfterRedirects: '${v.urlAfterRedirects}', state: ${v.state})`;
												case 5:
													return `ResolveStart(id: ${v.id}, url: '${v.url}', urlAfterRedirects: '${v.urlAfterRedirects}', state: ${v.state})`;
												case 10:
													return `RouteConfigLoadEnd(path: ${v.route.path})`;
												case 9:
													return `RouteConfigLoadStart(path: ${v.route.path})`;
												case 4:
													return `RoutesRecognized(id: ${v.id}, url: '${v.url}', urlAfterRedirects: '${v.urlAfterRedirects}', state: ${v.state})`;
												case 15:
													return `Scroll(anchor: '${v.anchor}', position: '${v.position?`${v.position[0]}, ${v.position[1]}`:null}')`
											}
										}(g)), console.log(g), console.groupEnd?.()
									})
								}
							}] : [], rn(1, v)
						}
						const wo = new p.OlP(pi ? "router preloader" : "");

						function dh(v) {
							return rn(0, [{
								provide: wo,
								useExisting: Ia
							}, {
								provide: Qe,
								useExisting: v
							}])
						}
						const bo = !1,
							yu = new p.OlP(bo ? "router duplicate forRoot guard" : "ROUTER_FORROOT_GUARD"),
							_n = [Ce.Ye, {
								provide: pn,
								useClass: $t
							}, Ir, so, {
								provide: oo,
								useFactory: function Lo(v) {
									return v.routerState.root
								},
								deps: [Ir]
							}, bi, bo ? {
								provide: Da,
								useValue: !0
							} : []];

						function Wr() {
							return new p.PXZ("Router", Ir)
						}
						let Eu = (() => {
							class v {
								constructor(g) {}
								static forRoot(g, b) {
									return {
										ngModule: v,
										providers: [_n, bo && b?.enableTracing ? bc().\u0275providers : [], {
												provide: Tr,
												multi: !0,
												useValue: g
											}, {
												provide: yu,
												useFactory: Ic,
												deps: [
													[Ir, new p.FiY, new p.tp0]
												]
											}, {
												provide: Ls,
												useValue: b || {}
											}, b?.useHash ? {
												provide: Ce.S$,
												useClass: Ce.Do
											} : {
												provide: Ce.S$,
												useClass: Ce.b0
											}, {
												provide: Er,
												useFactory: () => {
													const v = (0, p.f3M)(Ce.EM),
														C = (0, p.f3M)(p.R0b),
														g = (0, p.f3M)(Ls),
														b = (0, p.f3M)(Mi),
														x = (0, p.f3M)(pn);
													return g.scrollOffset && v.setOffset(g.scrollOffset), new Tc(x, b, v, C, g)
												}
											}, b?.preloadingStrategy ? dh(b.preloadingStrategy).\u0275providers : [], {
												provide: p.PXZ,
												multi: !0,
												useFactory: Wr
											}, b?.initialNavigation ? zt(b) : [],
											[{
												provide: Bo,
												useFactory: Aa
											}, {
												provide: p.tb,
												multi: !0,
												useExisting: Bo
											}]
										]
									}
								}
								static forChild(g) {
									return {
										ngModule: v,
										providers: [{
											provide: Tr,
											multi: !0,
											useValue: g
										}]
									}
								}
							}
							return v.\u0275fac = function(g) {
								return new(g || v)(p.LFG(yu, 8))
							}, v.\u0275mod = p.oAB({
								type: v
							}), v.\u0275inj = p.cJS({
								imports: [ao]
							}), v
						})();

						function Ic(v) {
							if (bo && v) throw new p.vHH(4007, "The Router was provided more than once. This can happen if 'forRoot' is used outside of the root injector. Lazy loaded modules should use RouterModule.forChild() instead.");
							return "guarded"
						}

						function zt(v) {
							return ["disabled" === v.initialNavigation ? rn(3, [{
								provide: p.ip1,
								multi: !0,
								useFactory: () => {
									const C = (0, p.f3M)(Ir);
									return () => {
										C.setUpLocationChangeListener()
									}
								}
							}, {
								provide: To,
								useValue: 2
							}]).\u0275providers : [], "enabledBlocking" === v.initialNavigation ? rn(2, [{
								provide: To,
								useValue: 0
							}, {
								provide: p.ip1,
								multi: !0,
								deps: [p.zs3],
								useFactory: C => {
									const g = C.get(Ce.V_, Promise.resolve());
									return () => g.then(() => new Promise(x => {
										const re = C.get(Ir),
											de = C.get(Zi);
										(function b(x) {
											C.get(Ir).events.pipe((0, ke.h)(de => de instanceof Et || de instanceof Gt || de instanceof Ot), (0, F.U)(de => de instanceof Et || de instanceof Gt && (0 === de.code || 1 === de.code) && null), (0, ke.h)(de => null !== de), (0, Ee.q)(1)).subscribe(() => {
												x()
											})
										})(() => {
											x(!0)
										}), C.get(Mi).afterPreactivation = () => (x(!0), de.closed ? (0, D.of)(void 0) : de), re.initialNavigation()
									}))
								}
							}]).\u0275providers : []]
						}
						const Bo = new p.OlP(bo ? "Router Initializer" : "")
					}, 9702: (be, ue, E) => {
						E.d(ue, {
							eX: () => Vt,
							sQ: () => pn,
							IC: () => ct,
							GW: () => et,
							l4: () => Qt
						});
						var p = E(805),
							y = E(4070),
							D = E(8264),
							z = E(602),
							ee = E(5195),
							P = E(7155),
							N = E(8440),
							Y = E(9099),
							G = E(7479);
						class X {
							constructor(J, k, H) {
								this.kind = J, this.value = k, this.error = H, this.hasValue = "N" === J
							}
							observe(J) {
								return te(this, J)
							}
							do(J, k, H) {
								const {
									kind: ne,
									value: Ne,
									error: Ye
								} = this;
								return "N" === ne ? J?.(Ne) : "E" === ne ? k?.(Ye) : H?.()
							}
							accept(J, k, H) {
								var ne;
								return (0, G.m)(null === (ne = J) || void 0 === ne ? void 0 : ne.next) ? this.observe(J) : this.do(J, k, H)
							}
							toObservable() {
								const {
									kind: J,
									value: k,
									error: H
								} = this, ne = "N" === J ? (0, ee.of)(k) : "E" === J ? (0, Y._)(() => H) : "C" === J ? N.E : 0;
								if (!ne) throw new TypeError(`Unexpected notification kind ${J}`);
								return ne
							}
							static
							createNext(J) {
								return new X("N", J)
							}
							static createError(J) {
								return new X("E", void 0, J)
							}
							static createComplete() {
								return X.completeNotification
							}
						}

						function te(B, J) {
							var k, H, ne;
							const {
								kind: Ne,
								value: Ye,
								error: Ft
							} = B;
							if ("string" != typeof Ne) throw new TypeError('Invalid notification, missing "kind"');
							"N" === Ne ? null === (k = J.next) || void 0 === k || k.call(J, Ye) : "E" === Ne ? null === (H = J.error) || void 0 === H || H.call(J, Ft) : null === (ne = J.complete) || void 0 === ne || ne.call(J)
						}
						X.completeNotification = new X("C");
						var ie = E(9681),
							oe = E(5694),
							Fe = E(7580),
							Le = E(2837),
							je = E(9754),
							Ce = E(3171);

						function F(B, J, k, H) {
							return (0, ie.e)((ne, Ne) => {
								let Ye;
								J && "function" != typeof J ? ({
									duration: k,
									element: Ye,
									connector: H
								} = J) : Ye = J;
								const Ft = new Map,
									an = En => {
										Ft.forEach(En), En(Ne)
									},
									xt = En => an(Me => Me.error(En));
								let ln = 0,
									yn = !1;
								const nr = new oe.Q(Ne, En => {
									try {
										const Me = B(En);
										let Ie = Ft.get(Me);
										if (!Ie) {
											Ft.set(Me, Ie = H ? H() : new D.x);
											const ge = function Dn(En, Me) {
												const Ie = new y.y(ge => {
													ln++;
													const Ke = Me.subscribe(ge);
													return () => {
														Ke.unsubscribe(), 0 == --ln && yn && nr.unsubscribe()
													}
												});
												return Ie.key = En, Ie
											}(Me, Ie);
											if (Ne.next(ge), k) {
												const Ke = (0, oe.x)(Ie, () => {
													Ie.complete(), Ke?.unsubscribe()
												}, void 0, void 0, () => Ft.delete(Me));
												nr.add((0, Ce.Xf)(k(ge)).subscribe(Ke))
											}
										}
										Ie.next(Ye ? Ye(En) : En)
									} catch (Me) {
										xt(Me)
									}
								}, () => an(En => En.complete()), xt, () => Ft.clear(), () => (yn = !0, 0 === ln));
								ne.subscribe(nr)
							})
						}
						var xe = E(6443);

						function Ee(B, J) {
							return J ? k => k.pipe(Ee((H, ne) => (0, Ce.Xf)(B(H, ne)).pipe((0, Fe.U)((Ne, Ye) => J(H, Ne, ne, Ye))))) : (0, ie.e)((k, H) => {
								let ne = 0,
									Ne = null,
									Ye = !1;
								k.subscribe((0, oe.x)(H, Ft => {
									Ne || (Ne = (0, oe.x)(H, void 0, () => {
										Ne = null, Ye && H.complete()
									}), (0, Ce.Xf)(B(Ft, ne++)).subscribe(Ne))
								}, () => {
									Ye = !0, !Ne && H.complete()
								}))
							})
						}
						var ke = E(2653),
							Ge = E(6424),
							ft = E(422),
							nt = E(3991),
							Pt = E(5424);
						const at = {
								dispatch: !0,
								functional: !1,
								useEffectsErrorHandler: !0
							},
							lt = "__@ngrx/effects_create__";

						function et(B, J = {}) {
							const k = J.functional ? B : B(),
								H = {
									...at,
									...J
								};
							return Object.defineProperty(k, lt, {
								value: H
							}), k
						}

						function it(B) {
							return Object.getPrototypeOf(B)
						}

						function ht(B) {
							return "function" == typeof B
						}

						function Pe(B) {
							return B.filter(ht)
						}

						function pt(B, J, k) {
							const H = it(B).constructor.name,
								ne = function ze(B) {
									return function Se(B) {
										return Object.getOwnPropertyNames(B).filter(H => !(!B[H] || !B[H].hasOwnProperty(lt)) && B[H][lt].hasOwnProperty("dispatch")).map(H => ({
											propertyName: H,
											...B[H][lt]
										}))
									}(B)
								}(B).map(({
									propertyName: Ne,
									dispatch: Ye,
									useEffectsErrorHandler: Ft
								}) => {
									const an = "function" == typeof B[Ne] ? B[Ne]() : B[Ne],
										xt = Ft ? k(an, J) : an;
									return !1 === Ye ? xt.pipe((0, P.l)()) : xt.pipe(function we() {
										return (0, ie.e)((B, J) => {
											B.subscribe((0, oe.x)(J, k => {
												J.next(X.createNext(k))
											}, () => {
												J.next(X.createComplete()), J.complete()
											}, k => {
												J.next(X.createError(k)), J.complete()
											}))
										})
									}()).pipe((0, Fe.U)(yn => ({
										effect: B[Ne],
										notification: yn,
										propertyName: Ne,
										sourceName: H,
										sourceInstance: B
									})))
								});
							return (0, p.T)(...ne)
						}
						const Bt = 10;

						function ot(B, J, k = Bt) {
							return B.pipe((0, Le.K)(H => (J && J.handleError(H), k <= 1 ? B : ot(B, J, k - 1))))
						}
						let Vt = (() => {
							class B extends y.y {
								constructor(k) {
									super(), k && (this.source = k)
								}
								lift(k) {
									const H = new B;
									return H.source = this, H.operator = k, H
								}
							}
							return B.\u0275fac = function(k) {
								return new(k || B)(nt.LFG(Pt.Y$))
							}, B.\u0275prov = nt.Yz7({
								token: B,
								factory: B.\u0275fac,
								providedIn: "root"
							}), B
						})();

						function Qt(...B) {
							return (0, je.h)(J => B.some(k => "string" == typeof k ? k === J.type : k.type === J.type))
						}
						const cn = new nt.OlP("@ngrx/effects Internal Root Guard"),
							Sn = new nt.OlP("@ngrx/effects User Provided Effects"),
							Pn = new nt.OlP("@ngrx/effects Internal Root Effects"),
							mn = new nt.OlP("@ngrx/effects Internal Root Effects Instances"),
							Un = new nt.OlP("@ngrx/effects Internal Feature Effects"),
							Kn = new nt.OlP("@ngrx/effects Internal Feature Effects Instance Groups"),
							Vn = new nt.OlP("@ngrx/effects Effects Error Handler", {
								providedIn: "root",
								factory: () => ot
							}),
							Zt = "@ngrx/effects/init";
						(0, Pt.PH)(Zt);
						const Qn = "ngrxOnIdentifyEffects",
							hr = "ngrxOnInitEffects";

						function un(B) {
							return Nt(B, hr)
						}

						function Nt(B, J) {
							return B && J in B && "function" == typeof B[J]
						}
						let Xe = (() => {
							class B extends D.x {
								constructor(k, H) {
									super(), this.errorHandler = k, this.effectsErrorHandler = H
								}
								addEffects(k) {
									this.next(k)
								}
								toActions() {
									return this.pipe(F(k => function ce(B) {
										return "Object" !== B.constructor.name && "Function" !== B.constructor.name
									}(k) ? it(k) : k), (0, xe.z)(k => k.pipe(F(pe))), (0, xe.z)(k => {
										const H = k.pipe(Ee(Ne => function Te(B, J) {
												return k => {
													const H = pt(k, B, J);
													return function ar(B) {
														return Nt(B, "ngrxOnRunEffects")
													}(k) ? k.ngrxOnRunEffects(H) : H
												}
											}(this.errorHandler, this.effectsErrorHandler)(Ne)), (0, Fe.U)(Ne => (function Bn(B, J) {
												if ("N" === B.notification.kind) {
													const k = B.notification.value;
													! function qt(B) {
														return "function" != typeof B && B && B.type && "string" == typeof B.type
													}(k) && J.handleError(new Error(`Effect ${function tn({propertyName:B,sourceInstance:J,sourceName:k}){const H="function"==typeof J[B];return`
														"${k}.${String(B)}${H?"()
														":"
														"}"
														`}(B)} dispatched an invalid action: ${function en(B){try{return JSON.stringify(B)}catch{return B}}(k)}`))
												}
											}(Ne, this.errorHandler), Ne.notification)), (0, je.h)(Ne => "N" === Ne.kind && null != Ne.value), function Ue() {
												return (0, ie.e)((B, J) => {
													B.subscribe((0, oe.x)(J, k => te(k, J)))
												})
											}()),
											ne = k.pipe((0, ke.q)(1), (0, je.h)(un), (0, Fe.U)(Ne => Ne.ngrxOnInitEffects()));
										return (0, p.T)(H, ne)
									}))
								}
							}
							return B.\u0275fac = function(k) {
								return new(k || B)(nt.LFG(nt.qLn), nt.LFG(Vn))
							}, B.\u0275prov = nt.Yz7({
								token: B,
								factory: B.\u0275fac,
								providedIn: "root"
							}), B
						})();

						function pe(B) {
							return function Wn(B) {
								return Nt(B, Qn)
							}(B) ? B.ngrxOnIdentifyEffects() : ""
						}
						let Je = (() => {
								class B {
									constructor(k, H) {
										this.effectSources = k, this.store = H, this.effectsSubscription = null
									}
									get isStarted() {
										return !!this.effectsSubscription
									}
									start() {
										this.effectsSubscription || (this.effectsSubscription = this.effectSources.toActions().subscribe(this.store))
									}
									ngOnDestroy() {
										this.effectsSubscription && (this.effectsSubscription.unsubscribe(), this.effectsSubscription = null)
									}
								}
								return B.\u0275fac = function(k) {
									return new(k || B)(nt.LFG(Xe), nt.LFG(Pt.yh))
								}, B.\u0275prov = nt.Yz7({
									token: B,
									factory: B.\u0275fac,
									providedIn: "root"
								}), B
							})(),
							yt = (() => {
								class B {
									constructor(k, H, ne, Ne, Ye, Ft, an) {
										this.sources = k, H.start();
										for (const xt of Ne) k.addEffects(xt);
										ne.dispatch({
											type: Zt
										})
									}
									addEffects(k) {
										this.sources.addEffects(k)
									}
								}
								return B.\u0275fac = function(k) {
									return new(k || B)(nt.LFG(Xe), nt.LFG(Je), nt.LFG(Pt.yh), nt.LFG(mn), nt.LFG(Pt.cr, 8), nt.LFG(Pt.CK, 8), nt.LFG(cn, 8))
								}, B.\u0275mod = nt.oAB({
									type: B
								}), B.\u0275inj = nt.cJS({}), B
							})(),
							Ht = (() => {
								class B {
									constructor(k, H, ne, Ne) {
										const Ye = H.flat();
										for (const Ft of Ye) k.addEffects(Ft)
									}
								}
								return B.\u0275fac = function(k) {
									return new(k || B)(nt.LFG(yt), nt.LFG(Kn), nt.LFG(Pt.cr, 8), nt.LFG(Pt.CK, 8))
								}, B.\u0275mod = nt.oAB({
									type: B
								}), B.\u0275inj = nt.cJS({}), B
							})(),
							pn = (() => {
								class B {
									static forFeature(...k) {
										const H = k.flat(),
											ne = Pe(H);
										return {
											ngModule: Ht,
											providers: [ne, {
												provide: Un,
												multi: !0,
												useValue: H
											}, {
												provide: Sn,
												multi: !0,
												useValue: []
											}, {
												provide: Kn,
												multi: !0,
												useFactory: $t,
												deps: [Un, Sn]
											}]
										}
									}
									static forRoot(...k) {
										const H = k.flat(),
											ne = Pe(H);
										return {
											ngModule: yt,
											providers: [ne, {
												provide: Pn,
												useValue: [H]
											}, {
												provide: cn,
												useFactory: hn
											}, {
												provide: Sn,
												multi: !0,
												useValue: []
											}, {
												provide: mn,
												useFactory: $t,
												deps: [Pn, Sn]
											}]
										}
									}
								}
								return B.\u0275fac = function(k) {
									return new(k || B)
								}, B.\u0275mod = nt.oAB({
									type: B
								}), B.\u0275inj = nt.cJS({}), B
							})();

						function $t(B, J) {
							const k = [];
							for (const H of B) k.push(...H);
							for (const H of J) k.push(...H);
							return k.map(H => ht(H) ? (0, nt.f3M)(H) : H)
						}

						function hn() {
							const B = (0, nt.f3M)(Je, {
									optional: !0,
									skipSelf: !0
								}),
								J = (0, nt.f3M)(Pn, {
									self: !0
								});
							if ((1 !== J.length || 0 !== J[0].length) && B) throw new TypeError("EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead.");
							return "guarded"
						}

						function ct(B) {
							return (0, z.z)((0, Ge.b)(J => {
								const k = B(J),
									H = Array.isArray(k) ? k : [k];
								return (0, ee.of)(J).pipe((0, ft.M)(...H))
							}))
						}
					}, 343: (be, ue, E) => {
						E.d(ue, {
							H: () => X
						});
						var p = E(5424),
							y = E(3991),
							P = (() => {
								return (ie = P || (P = {}))[ie.EntitiesOnly = 0] = "EntitiesOnly", ie[ie.Both = 1] = "Both", ie[ie.None = 2] = "None", P;
								var ie
							})();

						function N(ie) {
							return function(we, Fe) {
								const Le = {
										ids: [...Fe.ids],
										entities: {
											...Fe.entities
										}
									},
									je = ie(we, Le);
								return je === P.Both ? Object.assign({}, Fe, Le) : je === P.EntitiesOnly ? {
									...Fe,
									entities: Le.entities
								} : Fe
							}
						}

						function Y(ie, oe) {
							const we = oe(ie);
							return (0, y.X6Q)() && void 0 === we && console.warn("@ngrx/entity: The entity passed to the `selectId` implementation returned undefined.", "You should probably provide your own `selectId` implementation.", "The entity that was passed:", ie, "The `selectId` implementation:", oe.toString()), we
						}

						function G(ie) {
							function oe(at, lt) {
								const et = Y(at, ie);
								return et in lt.entities ? P.None : (lt.ids.push(et), lt.entities[et] = at, P.Both)
							}

							function we(at, lt) {
								let et = !1;
								for (const Se of at) et = oe(Se, lt) !== P.None || et;
								return et ? P.Both : P.None
							}

							function Le(at, lt) {
								const et = Y(at, ie);
								return et in lt.entities ? (lt.entities[et] = at, P.EntitiesOnly) : (lt.ids.push(et), lt.entities[et] = at, P.Both)
							}

							function F(at, lt) {
								const Se = (at instanceof Array ? at : lt.ids.filter(Be => at(lt.entities[Be]))).filter(Be => Be in lt.entities).map(Be => delete lt.entities[Be]).length > 0;
								return Se && (lt.ids = lt.ids.filter(Be => Be in lt.entities)), Se ? P.Both : P.None
							}

							function Ue(at, lt) {
								return ke([at], lt)
							}

							function ke(at, lt) {
								const et = {};
								return (at = at.filter(Be => Be.id in lt.entities)).length > 0 ? at.filter(ze => function Ee(at, lt, et) {
									const Be = Object.assign({}, et.entities[lt.id], lt.changes),
										ze = Y(Be, ie),
										it = ze !== lt.id;
									return it && (at[lt.id] = ze, delete et.entities[lt.id]), et.entities[ze] = Be, it
								}(et, ze, lt)).length > 0 ? (lt.ids = lt.ids.map(ze => et[ze] || ze), P.Both) : P.EntitiesOnly : P.None
							}

							function Pt(at, lt) {
								const et = [],
									Se = [];
								for (const it of at) {
									const ce = Y(it, ie);
									ce in lt.entities ? Se.push({
										id: ce,
										changes: it
									}) : et.push(it)
								}
								const Be = ke(Se, lt),
									ze = we(et, lt);
								switch (!0) {
									case ze === P.None && Be === P.None:
										return P.None;
									case ze === P.Both || Be === P.Both:
										return P.Both;
									default:
										return P.EntitiesOnly
								}
							}
							return {
								removeAll: function xe(at) {
									return Object.assign({}, at, {
										ids: [],
										entities: {}
									})
								},
								addOne: N(oe),
								addMany: N(we),
								setAll: N(function Fe(at, lt) {
									return lt.ids = [], lt.entities = {}, we(at, lt), P.Both
								}),
								setOne: N(Le),
								setMany: N(function je(at, lt) {
									const et = at.map(Se => Le(Se, lt));
									switch (!0) {
										case et.some(Se => Se === P.Both):
											return P.Both;
										case et.some(Se => Se === P.EntitiesOnly):
											return P.EntitiesOnly;
										default:
											return P.None
									}
								}),
								updateOne: N(Ue),
								updateMany: N(ke),
								upsertOne: N(function nt(at, lt) {
									return Pt([at], lt)
								}),
								upsertMany: N(Pt),
								removeOne: N(function Ce(at, lt) {
									return F([at], lt)
								}),
								removeMany: N(F),
								map: N(function Ge(at, lt) {
									return ke(lt.ids.reduce((Be, ze) => {
										const it = at(lt.entities[ze]);
										return it !== lt.entities[ze] && Be.push({
											id: ze,
											changes: it
										}), Be
									}, []).filter(({
										id: Be
									}) => Be in lt.entities), lt)
								}),
								mapOne: N(function ft({
									map: at,
									id: lt
								}, et) {
									const Se = et.entities[lt];
									return Se ? Ue({
										id: lt,
										changes: at(Se)
									}, et) : P.None
								})
							}
						}

						function Q(ie, oe) {
							const {
								removeOne: we,
								removeMany: Fe,
								removeAll: Le
							} = G(ie);

							function je(et, Se) {
								return Ce([et], Se)
							}

							function Ce(et, Se) {
								const Be = et.filter(ze => !(Y(ze, ie) in Se.entities));
								return 0 === Be.length ? P.None : (lt(Be, Se), P.Both)
							}

							function xe(et, Se) {
								const Be = Y(et, ie);
								return Be in Se.entities ? (Se.ids = Se.ids.filter(ze => ze !== Be), lt([et], Se), P.Both) : je(et, Se)
							}

							function Ue(et, Se) {
								return Ge([et], Se)
							}

							function Ge(et, Se) {
								const Be = [],
									ze = et.filter(it => function ke(et, Se, Be) {
										if (!(Se.id in Be.entities)) return !1;
										const it = Object.assign({}, Be.entities[Se.id], Se.changes),
											ce = Y(it, ie);
										return delete Be.entities[Se.id], et.push(it), ce !== Se.id
									}(Be, it, Se)).length > 0;
								if (0 === Be.length) return P.None;
								{
									const it = Se.ids,
										ce = [];
									return Se.ids = Se.ids.filter((ht, Pe) => ht in Se.entities || (ce.push(Pe), !1)), lt(Be, Se), !ze && ce.every(ht => Se.ids[ht] === it[ht]) ? P.EntitiesOnly : P.Both
								}
							}

							function at(et, Se) {
								const Be = [],
									ze = [];
								for (const ht of et) {
									const Pe = Y(ht, ie);
									Pe in Se.entities ? ze.push({
										id: Pe,
										changes: ht
									}) : Be.push(ht)
								}
								const it = Ge(ze, Se),
									ce = Ce(Be, Se);
								switch (!0) {
									case ce === P.None && it === P.None:
										return P.None;
									case ce === P.Both || it === P.Both:
										return P.Both;
									default:
										return P.EntitiesOnly
								}
							}

							function lt(et, Se) {
								et.sort(oe);
								const Be = [];
								let ze = 0,
									it = 0;
								for (; ze < et.length && it < Se.ids.length;) {
									const ce = et[ze],
										ht = Y(ce, ie),
										Pe = Se.ids[it];
									oe(ce, Se.entities[Pe]) <= 0 ? (Be.push(ht), ze++) : (Be.push(Pe), it++)
								}
								Se.ids = Be.concat(ze < et.length ? et.slice(ze).map(ie) : Se.ids.slice(it)), et.forEach((ce, ht) => {
									Se.entities[ie(ce)] = ce
								})
							}
							return {
								removeOne: we,
								removeMany: Fe,
								removeAll: Le,
								addOne: N(je),
								updateOne: N(Ue),
								upsertOne: N(function Pt(et, Se) {
									return at([et], Se)
								}),
								setAll: N(function F(et, Se) {
									return Se.entities = {}, Se.ids = [], Ce(et, Se), P.Both
								}),
								setOne: N(xe),
								setMany: N(function Ee(et, Se) {
									const Be = et.map(ze => xe(ze, Se));
									switch (!0) {
										case Be.some(ze => ze === P.Both):
											return P.Both;
										case Be.some(ze => ze === P.EntitiesOnly):
											return P.EntitiesOnly;
										default:
											return P.None
									}
								}),
								addMany: N(Ce),
								updateMany: N(Ge),
								upsertMany: N(at),
								map: N(function ft(et, Se) {
									return Ge(Se.ids.reduce((ze, it) => {
										const ce = et(Se.entities[it]);
										return ce !== Se.entities[it] && ze.push({
											id: it,
											changes: ce
										}), ze
									}, []), Se)
								}),
								mapOne: N(function nt({
									map: et,
									id: Se
								}, Be) {
									const ze = Be.entities[Se];
									return ze ? Ue({
										id: Se,
										changes: et(ze)
									}, Be) : P.None
								})
							}
						}

						function X(ie = {}) {
							const {
								selectId: oe,
								sortComparer: we
							} = {
								selectId: ie.selectId ?? (Ce => Ce.id),
								sortComparer: ie.sortComparer ?? !1
							}, Fe = function z() {
								return {
									getInitialState: function ie(oe = {}) {
										return Object.assign({
											ids: [],
											entities: {}
										}, oe)
									}
								}
							}(), Le = function ee() {
								return {
									getSelectors: function ie(oe) {
										const we = Ce => Ce.ids,
											Fe = Ce => Ce.entities,
											Le = (0, p.P1)(we, Fe, (Ce, F) => Ce.map(xe => F[xe])),
											je = (0, p.P1)(we, Ce => Ce.length);
										return oe ? {
											selectIds: (0, p.P1)(oe, we),
											selectEntities: (0, p.P1)(oe, Fe),
											selectAll: (0, p.P1)(oe, Le),
											selectTotal: (0, p.P1)(oe, je)
										} : {
											selectIds: we,
											selectEntities: Fe,
											selectAll: Le,
											selectTotal: je
										}
									}
								}
							}();
							return {
								selectId: oe,
								sortComparer: we,
								...Fe,
								...Le,
								...we ? Q(oe, we) : G(oe)
							}
						}
					}, 116: (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
						__webpack_require__.d(__webpack_exports__, {
							FT: () => StoreDevtoolsModule
						});
						var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3991),
							_ngrx_store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5424),
							rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8440),
							rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4070),
							rxjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(5195),
							rxjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(805),
							rxjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(7450),
							rxjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(1970),
							rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7957),
							rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9754),
							rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7580),
							rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6424),
							rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(7571),
							rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(9435),
							rxjs_operators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(2837),
							rxjs_operators__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(2653),
							rxjs_operators__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(3),
							rxjs_operators__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(1565),
							rxjs_operators__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(4276),
							rxjs_operators__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(9534),
							rxjs_operators__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(422),
							rxjs_operators__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(3356);
						const PERFORM_ACTION = "PERFORM_ACTION",
							REFRESH = "REFRESH",
							RESET = "RESET",
							ROLLBACK = "ROLLBACK",
							COMMIT = "COMMIT",
							SWEEP = "SWEEP",
							TOGGLE_ACTION = "TOGGLE_ACTION",
							SET_ACTIONS_ACTIVE = "SET_ACTIONS_ACTIVE",
							JUMP_TO_STATE = "JUMP_TO_STATE",
							JUMP_TO_ACTION = "JUMP_TO_ACTION",
							IMPORT_STATE = "IMPORT_STATE",
							LOCK_CHANGES = "LOCK_CHANGES",
							PAUSE_RECORDING = "PAUSE_RECORDING";
						class PerformAction {
							constructor(ue, E) {
								if (this.action = ue, this.timestamp = E, this.type = PERFORM_ACTION, typeof ue.type > "u") throw new Error('Actions may not have an undefined "type" property. Have you misspelled a constant?')
							}
						}
						class Refresh {
							constructor() {
								this.type = REFRESH
							}
						}
						class Reset {
							constructor(ue) {
								this.timestamp = ue, this.type = RESET
							}
						}
						class Rollback {
							constructor(ue) {
								this.timestamp = ue, this.type = ROLLBACK
							}
						}
						class Commit {
							constructor(ue) {
								this.timestamp = ue, this.type = COMMIT
							}
						}
						class Sweep {
							constructor() {
								this.type = SWEEP
							}
						}
						class ToggleAction {
							constructor(ue) {
								this.id = ue, this.type = TOGGLE_ACTION
							}
						}
						class SetActionsActive {
							constructor(ue, E, p = !0) {
								this.start = ue, this.end = E, this.active = p, this.type = SET_ACTIONS_ACTIVE
							}
						}
						class JumpToState {
							constructor(ue) {
								this.index = ue, this.type = JUMP_TO_STATE
							}
						}
						class JumpToAction {
							constructor(ue) {
								this.actionId = ue, this.type = JUMP_TO_ACTION
							}
						}
						class ImportState {
							constructor(ue) {
								this.nextLiftedState = ue, this.type = IMPORT_STATE
							}
						}
						class LockChanges {
							constructor(ue) {
								this.status = ue, this.type = LOCK_CHANGES
							}
						}
						class PauseRecording {
							constructor(ue) {
								this.status = ue, this.type = PAUSE_RECORDING
							}
						}
						class StoreDevtoolsConfig {
							constructor() {
								this.maxAge = !1
							}
						}
						const STORE_DEVTOOLS_CONFIG = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.OlP("@ngrx/store-devtools Options"),
							INITIAL_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.OlP("@ngrx/store-devtools Initial Config");

						function noMonitor() {
							return null
						}
						const DEFAULT_NAME = "NgRx Store DevTools";

						function createConfig(be) {
							const ue = {
									maxAge: !1,
									monitor: noMonitor,
									actionSanitizer: void 0,
									stateSanitizer: void 0,
									name: DEFAULT_NAME,
									serialize: !1,
									logOnly: !1,
									autoPause: !1,
									trace: !1,
									traceLimit: 75,
									features: {
										pause: !0,
										lock: !0,
										persist: !0,
										export: !0,
										import: "custom",
										jump: !0,
										skip: !0,
										reorder: !0,
										dispatch: !0,
										test: !0
									}
								},
								E = "function" == typeof be ? be() : be,
								D = Object.assign({}, ue, {
									features: E.features || !!E.logOnly && {
										pause: !0,
										export: !0,
										test: !0
									} || ue.features
								}, E);
							if (D.maxAge && D.maxAge < 2) throw new Error(`Devtools 'maxAge' cannot be less than 2, got ${D.maxAge}`);
							return D
						}

						function difference(be, ue) {
							return be.filter(E => ue.indexOf(E) < 0)
						}

						function unliftState(be) {
							const {
								computedStates: ue,
								currentStateIndex: E
							} = be;
							if (E >= ue.length) {
								const {
									state: y
								} = ue[ue.length - 1];
								return y
							}
							const {
								state: p
							} = ue[E];
							return p
						}

						function unliftAction(be) {
							return be.actionsById[be.nextActionId - 1]
						}

						function liftAction(be) {
							return new PerformAction(be, +Date.now())
						}

						function sanitizeActions(be, ue) {
							return Object.keys(ue).reduce((E, p) => {
								const y = Number(p);
								return E[y] = sanitizeAction(be, ue[y], y), E
							}, {})
						}

						function sanitizeAction(be, ue, E) {
							return {
								...ue,
								action: be(ue.action, E)
							}
						}

						function sanitizeStates(be, ue) {
							return ue.map((E, p) => ({
								state: sanitizeState(be, E.state, p),
								error: E.error
							}))
						}

						function sanitizeState(be, ue, E) {
							return be(ue, E)
						}

						function shouldFilterActions(be) {
							return be.predicate || be.actionsSafelist || be.actionsBlocklist
						}

						function filterLiftedState(be, ue, E, p) {
							const y = [],
								D = {},
								z = [];
							return be.stagedActionIds.forEach((ee, P) => {
								const N = be.actionsById[ee];
								N && (P && isActionFiltered(be.computedStates[P], N, ue, E, p) || (D[ee] = N, y.push(ee), z.push(be.computedStates[P])))
							}), {
								...be,
								stagedActionIds: y,
								actionsById: D,
								computedStates: z
							}
						}

						function isActionFiltered(be, ue, E, p, y) {
							const D = E && !E(be, ue.action),
								z = p && !ue.action.type.match(p.map(P => escapeRegExp(P)).join("|")),
								ee = y && ue.action.type.match(y.map(P => escapeRegExp(P)).join("|"));
							return D || z || ee
						}

						function escapeRegExp(be) {
							return be.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
						}
						let DevtoolsDispatcher = (() => {
							class be extends _ngrx_store__WEBPACK_IMPORTED_MODULE_1__.UO {}
							return be.\u0275fac = function() {
								let ue;
								return function(p) {
									return (ue || (ue = _angular_core__WEBPACK_IMPORTED_MODULE_0__.n5z(be)))(p || be)
								}
							}(), be.\u0275prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Yz7({
								token: be,
								factory: be.\u0275fac
							}), be
						})();
						const ExtensionActionTypes = {
								START: "START",
								DISPATCH: "DISPATCH",
								STOP: "STOP",
								ACTION: "ACTION"
							},
							REDUX_DEVTOOLS_EXTENSION = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.OlP("@ngrx/store-devtools Redux Devtools Extension");
						let DevtoolsExtension = (() => {
							class DevtoolsExtension {
								constructor(be, ue, E) {
									this.config = ue, this.dispatcher = E, this.devtoolsExtension = be, this.createActionStreams()
								}
								notify(be, ue) {
									if (this.devtoolsExtension)
										if (be.type === PERFORM_ACTION) {
											if (ue.isLocked || ue.isPaused) return;
											const E = unliftState(ue);
											if (shouldFilterActions(this.config) && isActionFiltered(E, be, this.config.predicate, this.config.actionsSafelist, this.config.actionsBlocklist)) return;
											const p = this.config.stateSanitizer ? sanitizeState(this.config.stateSanitizer, E, ue.currentStateIndex) : E,
												y = this.config.actionSanitizer ? sanitizeAction(this.config.actionSanitizer, be, ue.nextActionId) : be;
											this.sendToReduxDevtools(() => this.extensionConnection.send(y, p))
										} else {
											const E = {
												...ue,
												stagedActionIds: ue.stagedActionIds,
												actionsById: this.config.actionSanitizer ? sanitizeActions(this.config.actionSanitizer, ue.actionsById) : ue.actionsById,
												computedStates: this.config.stateSanitizer ? sanitizeStates(this.config.stateSanitizer, ue.computedStates) : ue.computedStates
											};
											this.sendToReduxDevtools(() => this.devtoolsExtension.send(null, E, this.getExtensionConfig(this.config)))
										}
								}
								createChangesObservable() {
									return this.devtoolsExtension ? new rxjs__WEBPACK_IMPORTED_MODULE_3__.y(be => {
										const ue = this.devtoolsExtension.connect(this.getExtensionConfig(this.config));
										return this.extensionConnection = ue, ue.init(), ue.subscribe(E => be.next(E)), ue.unsubscribe
									}) : rxjs__WEBPACK_IMPORTED_MODULE_2__.E
								}
								createActionStreams() {
									const be = this.createChangesObservable().pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.B)()),
										ue = be.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.h)(ee => ee.type === ExtensionActionTypes.START)),
										E = be.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.h)(ee => ee.type === ExtensionActionTypes.STOP)),
										p = be.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.h)(ee => ee.type === ExtensionActionTypes.DISPATCH), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.U)(ee => this.unwrapAction(ee.payload)), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.b)(ee => ee.type === IMPORT_STATE ? this.dispatcher.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.h)(P => P.type === _ngrx_store__WEBPACK_IMPORTED_MODULE_1__.wb), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.V)(1e3), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.b)(1e3), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.U)(() => ee), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.K)(() => (0, rxjs__WEBPACK_IMPORTED_MODULE_11__.of)(ee)), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_12__.q)(1)) : (0, rxjs__WEBPACK_IMPORTED_MODULE_11__.of)(ee))),
										D = be.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.h)(ee => ee.type === ExtensionActionTypes.ACTION), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.U)(ee => this.unwrapAction(ee.payload))).pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_13__.R)(E)),
										z = p.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_13__.R)(E));
									this.start$ = ue.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_13__.R)(E)), this.actions$ = this.start$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_14__.w)(() => D)), this.liftedActions$ = this.start$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_14__.w)(() => z))
								}
								unwrapAction(action) {
									return "string" == typeof action ? eval(`(${action})`) : action
								}
								getExtensionConfig(be) {
									const ue = {
										name: be.name,
										features: be.features,
										serialize: be.serialize,
										autoPause: be.autoPause ?? !1,
										trace: be.trace ?? !1,
										traceLimit: be.traceLimit ?? 75
									};
									return !1 !== be.maxAge && (ue.maxAge = be.maxAge), ue
								}
								sendToReduxDevtools(be) {
									try {
										be()
									} catch (ue) {
										console.warn("@ngrx/store-devtools: something went wrong inside the redux devtools", ue)
									}
								}
							}
							return DevtoolsExtension.\u0275fac = function be(ue) {
								return new(ue || DevtoolsExtension)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.LFG(REDUX_DEVTOOLS_EXTENSION), _angular_core__WEBPACK_IMPORTED_MODULE_0__.LFG(STORE_DEVTOOLS_CONFIG), _angular_core__WEBPACK_IMPORTED_MODULE_0__.LFG(DevtoolsDispatcher))
							}, DevtoolsExtension.\u0275prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Yz7({
								token: DevtoolsExtension,
								factory: DevtoolsExtension.\u0275fac
							}), DevtoolsExtension
						})();
						const INIT_ACTION = {
								type: _ngrx_store__WEBPACK_IMPORTED_MODULE_1__.qg
							},
							RECOMPUTE = "@ngrx/store-devtools/recompute",
							RECOMPUTE_ACTION = {
								type: RECOMPUTE
							};

						function computeNextEntry(be, ue, E, p, y) {
							if (p) return {
								state: E,
								error: "Interrupted by an error up the chain"
							};
							let z, D = E;
							try {
								D = be(E, ue)
							} catch (ee) {
								z = ee.toString(), y.handleError(ee)
							}
							return {
								state: D,
								error: z
							}
						}

						function recomputeStates(be, ue, E, p, y, D, z, ee, P) {
							if (ue >= be.length && be.length === D.length) return be;
							const N = be.slice(0, ue),
								Y = D.length - (P ? 1 : 0);
							for (let G = ue; G < Y; G++) {
								const Q = D[G],
									X = y[Q].action,
									te = N[G - 1],
									ie = te ? te.state : p,
									oe = te ? te.error : void 0,
									Fe = z.indexOf(Q) > -1 ? te : computeNextEntry(E, X, ie, oe, ee);
								N.push(Fe)
							}
							return P && N.push(be[be.length - 1]), N
						}

						function liftInitialState(be, ue) {
							return {
								monitorState: ue(void 0, {}),
								nextActionId: 1,
								actionsById: {
									0: liftAction(INIT_ACTION)
								},
								stagedActionIds: [0],
								skippedActionIds: [],
								committedState: be,
								currentStateIndex: 0,
								computedStates: [],
								isLocked: !1,
								isPaused: !1
							}
						}

						function liftReducerWith(be, ue, E, p, y = {}) {
							return D => (z, ee) => {
								let {
									monitorState: P,
									actionsById: N,
									nextActionId: Y,
									stagedActionIds: G,
									skippedActionIds: Q,
									committedState: X,
									currentStateIndex: te,
									computedStates: ie,
									isLocked: oe,
									isPaused: we
								} = z || ue;

								function Fe(Ce) {
									let F = Ce,
										xe = G.slice(1, F + 1);
									for (let Ee = 0; Ee < xe.length; Ee++) {
										if (ie[Ee + 1].error) {
											F = Ee, xe = G.slice(1, F + 1);
											break
										}
										delete N[xe[Ee]]
									}
									Q = Q.filter(Ee => -1 === xe.indexOf(Ee)), G = [0, ...G.slice(F + 1)], X = ie[F].state, ie = ie.slice(F), te = te > F ? te - F : 0
								}

								function Le() {
									N = {
										0: liftAction(INIT_ACTION)
									}, Y = 1, G = [0], Q = [], X = ie[te].state, te = 0, ie = []
								}
								z || (N = Object.create(N));
								let je = 0;
								switch (ee.type) {
									case LOCK_CHANGES:
										oe = ee.status, je = 1 / 0;
										break;
									case PAUSE_RECORDING:
										we = ee.status, we ? (G = [...G, Y], N[Y] = new PerformAction({
											type: "@ngrx/devtools/pause"
										}, +Date.now()), Y++, je = G.length - 1, ie = ie.concat(ie[ie.length - 1]), te === G.length - 2 && te++, je = 1 / 0) : Le();
										break;
									case RESET:
										N = {
											0: liftAction(INIT_ACTION)
										}, Y = 1, G = [0], Q = [], X = be, te = 0, ie = [];
										break;
									case COMMIT:
										Le();
										break;
									case ROLLBACK:
										N = {
											0: liftAction(INIT_ACTION)
										}, Y = 1, G = [0], Q = [], te = 0, ie = [];
										break;
									case TOGGLE_ACTION: {
										const {
											id: Ce
										} = ee;
										Q = -1 === Q.indexOf(Ce) ? [Ce, ...Q] : Q.filter(xe => xe !== Ce), je = G.indexOf(Ce);
										break
									}
									case SET_ACTIONS_ACTIVE: {
										const {
											start: Ce,
											end: F,
											active: xe
										} = ee, Ee = [];
										for (let Ue = Ce; Ue < F; Ue++) Ee.push(Ue);
										Q = xe ? difference(Q, Ee) : [...Q, ...Ee], je = G.indexOf(Ce);
										break
									}
									case JUMP_TO_STATE:
										te = ee.index, je = 1 / 0;
										break;
									case JUMP_TO_ACTION: {
										const Ce = G.indexOf(ee.actionId); - 1 !== Ce && (te = Ce), je = 1 / 0;
										break
									}
									case SWEEP:
										G = difference(G, Q), Q = [], te = Math.min(te, G.length - 1);
										break;
									case PERFORM_ACTION: {
										if (oe) return z || ue;
										if (we || z && isActionFiltered(z.computedStates[te], ee, y.predicate, y.actionsSafelist, y.actionsBlocklist)) {
											const F = ie[ie.length - 1];
											ie = [...ie.slice(0, -1), computeNextEntry(D, ee.action, F.state, F.error, E)], je = 1 / 0;
											break
										}
										y.maxAge && G.length === y.maxAge && Fe(1), te === G.length - 1 && te++;
										const Ce = Y++;
										N[Ce] = ee, G = [...G, Ce], je = G.length - 1;
										break
									}
									case IMPORT_STATE:
										({
											monitorState: P,
											actionsById: N,
											nextActionId: Y,
											stagedActionIds: G,
											skippedActionIds: Q,
											committedState: X,
											currentStateIndex: te,
											computedStates: ie,
											isLocked: oe,
											isPaused: we
										} = ee.nextLiftedState);
										break;
									case _ngrx_store__WEBPACK_IMPORTED_MODULE_1__.qg:
										je = 0, y.maxAge && G.length > y.maxAge && (ie = recomputeStates(ie, je, D, X, N, G, Q, E, we), Fe(G.length - y.maxAge), je = 1 / 0);
										break;
									case _ngrx_store__WEBPACK_IMPORTED_MODULE_1__.wb:
										if (ie.filter(F => F.error).length > 0) je = 0, y.maxAge && G.length > y.maxAge && (ie = recomputeStates(ie, je, D, X, N, G, Q, E, we), Fe(G.length - y.maxAge), je = 1 / 0);
										else {
											if (!we && !oe) {
												te === G.length - 1 && te++;
												const F = Y++;
												N[F] = new PerformAction(ee, +Date.now()), G = [...G, F], je = G.length - 1, ie = recomputeStates(ie, je, D, X, N, G, Q, E, we)
											}
											ie = ie.map(F => ({
												...F,
												state: D(F.state, RECOMPUTE_ACTION)
											})), te = G.length - 1, y.maxAge && G.length > y.maxAge && Fe(G.length - y.maxAge), je = 1 / 0
										}
										break;
									default:
										je = 1 / 0
								}
								return ie = recomputeStates(ie, je, D, X, N, G, Q, E, we), P = p(P, ee), {
									monitorState: P,
									actionsById: N,
									nextActionId: Y,
									stagedActionIds: G,
									skippedActionIds: Q,
									committedState: X,
									currentStateIndex: te,
									computedStates: ie,
									isLocked: oe,
									isPaused: we
								}
							}
						}
						let StoreDevtools = (() => {
							class be {
								constructor(E, p, y, D, z, ee, P, N) {
									const Y = liftInitialState(P, N.monitor),
										G = liftReducerWith(P, Y, ee, N.monitor, N),
										Q = (0, rxjs__WEBPACK_IMPORTED_MODULE_15__.T)((0, rxjs__WEBPACK_IMPORTED_MODULE_15__.T)(p.asObservable().pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_16__.T)(1)), D.actions$).pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.U)(liftAction)), E, D.liftedActions$).pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_17__.Q)(rxjs__WEBPACK_IMPORTED_MODULE_18__.N)),
										X = y.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.U)(G)),
										te = new rxjs__WEBPACK_IMPORTED_MODULE_19__.t(1),
										ie = Q.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_20__.M)(X), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_21__.R)(({
											state: Le
										}, [je, Ce]) => {
											let F = Ce(Le, je);
											return je.type !== PERFORM_ACTION && shouldFilterActions(N) && (F = filterLiftedState(F, N.predicate, N.actionsSafelist, N.actionsBlocklist)), D.notify(je, F), {
												state: F,
												action: je
											}
										}, {
											state: Y,
											action: null
										})).subscribe(({
											state: Le,
											action: je
										}) => {
											te.next(Le), je.type === PERFORM_ACTION && z.next(je.action)
										}),
										oe = D.start$.subscribe(() => {
											this.refresh()
										}),
										we = te.asObservable(),
										Fe = we.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.U)(unliftState));
									this.extensionStartSubscription = oe, this.stateSubscription = ie, this.dispatcher = E, this.liftedState = we, this.state = Fe
								}
								dispatch(E) {
									this.dispatcher.next(E)
								}
								next(E) {
									this.dispatcher.next(E)
								}
								error(E) {}
								complete() {}
								performAction(E) {
									this.dispatch(new PerformAction(E, +Date.now()))
								}
								refresh() {
									this.dispatch(new Refresh)
								}
								reset() {
									this.dispatch(new Reset(+Date.now()))
								}
								rollback() {
									this.dispatch(new Rollback(+Date.now()))
								}
								commit() {
									this.dispatch(new Commit(+Date.now()))
								}
								sweep() {
									this.dispatch(new Sweep)
								}
								toggleAction(E) {
									this.dispatch(new ToggleAction(E))
								}
								jumpToAction(E) {
									this.dispatch(new JumpToAction(E))
								}
								jumpToState(E) {
									this.dispatch(new JumpToState(E))
								}
								importState(E) {
									this.dispatch(new ImportState(E))
								}
								lockChanges(E) {
									this.dispatch(new LockChanges(E))
								}
								pauseRecording(E) {
									this.dispatch(new PauseRecording(E))
								}
							}
							return be.\u0275fac = function(E) {
								return new(E || be)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.LFG(DevtoolsDispatcher), _angular_core__WEBPACK_IMPORTED_MODULE_0__.LFG(_ngrx_store__WEBPACK_IMPORTED_MODULE_1__.UO), _angular_core__WEBPACK_IMPORTED_MODULE_0__.LFG(_ngrx_store__WEBPACK_IMPORTED_MODULE_1__.n$), _angular_core__WEBPACK_IMPORTED_MODULE_0__.LFG(DevtoolsExtension), _angular_core__WEBPACK_IMPORTED_MODULE_0__.LFG(_ngrx_store__WEBPACK_IMPORTED_MODULE_1__.Y$), _angular_core__WEBPACK_IMPORTED_MODULE_0__.LFG(_angular_core__WEBPACK_IMPORTED_MODULE_0__.qLn), _angular_core__WEBPACK_IMPORTED_MODULE_0__.LFG(_ngrx_store__WEBPACK_IMPORTED_MODULE_1__.Y6), _angular_core__WEBPACK_IMPORTED_MODULE_0__.LFG(STORE_DEVTOOLS_CONFIG))
							}, be.\u0275prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Yz7({
								token: be,
								factory: be.\u0275fac
							}), be
						})();
						const IS_EXTENSION_OR_MONITOR_PRESENT = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.OlP("@ngrx/store-devtools Is Devtools Extension or Monitor Present");

						function createIsExtensionOrMonitorPresent(be, ue) {
							return Boolean(be) || ue.monitor !== noMonitor
						}

						function createReduxDevtoolsExtension() {
							const be = "__REDUX_DEVTOOLS_EXTENSION__";
							return "object" == typeof window && typeof window[be] < "u" ? window[be] : null
						}

						function provideStoreDevtools(be = {}) {
							return (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__.MR2)([DevtoolsExtension, DevtoolsDispatcher, StoreDevtools, {
								provide: INITIAL_OPTIONS,
								useValue: be
							}, {
								provide: IS_EXTENSION_OR_MONITOR_PRESENT,
								deps: [REDUX_DEVTOOLS_EXTENSION, STORE_DEVTOOLS_CONFIG],
								useFactory: createIsExtensionOrMonitorPresent
							}, {
								provide: REDUX_DEVTOOLS_EXTENSION,
								useFactory: createReduxDevtoolsExtension
							}, {
								provide: STORE_DEVTOOLS_CONFIG,
								deps: [INITIAL_OPTIONS],
								useFactory: createConfig
							}, {
								provide: _ngrx_store__WEBPACK_IMPORTED_MODULE_1__.FR,
								deps: [StoreDevtools],
								useFactory: createStateObservable
							}, {
								provide: _ngrx_store__WEBPACK_IMPORTED_MODULE_1__.mK,
								useExisting: DevtoolsDispatcher
							}])
						}

						function createStateObservable(be) {
							return be.state
						}
						let StoreDevtoolsModule = (() => {
							class be {
								static instrument(E = {}) {
									return {
										ngModule: be,
										providers: [provideStoreDevtools(E)]
									}
								}
							}
							return be.\u0275fac = function(E) {
								return new(E || be)
							}, be.\u0275mod = _angular_core__WEBPACK_IMPORTED_MODULE_0__.oAB({
								type: be
							}), be.\u0275inj = _angular_core__WEBPACK_IMPORTED_MODULE_0__.cJS({}), be
						})()
					}, 5424: (be, ue, E) => {
						E.d(ue, {
							hg: () => Sn,
							UO: () => ke,
							qg: () => Ue,
							Y6: () => Pt,
							mK: () => tn,
							n$: () => qt,
							Y$: () => Nn,
							FR: () => hr,
							yh: () => pe,
							CK: () => Cn,
							Aw: () => Jn,
							cr: () => Mn,
							wb: () => en,
							PH: () => oe,
							R7: () => Ce,
							Tz: () => Ke,
							ZF: () => Me,
							Lq: () => Br,
							P1: () => nr,
							uZ: () => F,
							rM: () => Ft,
							on: () => xn,
							Ky: () => we,
							Ys: () => Je
						});
						var p = E(3991),
							y = E(3216),
							D = E(4070),
							z = E(8264),
							ee = E(7450),
							P = E(9534),
							N = E(422),
							Y = E(3356),
							G = E(7580),
							X = E(354);
						const te = {};

						function oe(me, tt) {
							if (te[me] = (te[me] || 0) + 1, "function" == typeof tt) return Le(me, (...dt) => ({
								...tt(...dt),
								type: me
							}));
							switch (tt ? tt._as : "empty") {
								case "empty":
									return Le(me, () => ({
										type: me
									}));
								case "props":
									return Le(me, dt => ({
										...dt,
										type: me
									}));
								default:
									throw new Error("Unexpected config.")
							}
						}

						function we() {
							return {
								_as: "props",
								_p: void 0
							}
						}

						function Le(me, tt) {
							return Object.defineProperty(tt, "type", {
								value: me,
								writable: !1
							})
						}

						function je(me) {
							return me.charAt(0).toUpperCase() + me.substring(1)
						}

						function Ce(me) {
							const {
								source: tt,
								events: qe
							} = me;
							return Object.keys(qe).reduce((dt, Dt) => ({
								...dt,
								[xe(Dt)]: oe(Ee(tt, Dt), qe[Dt])
							}), {})
						}

						function F() {
							return {
								_as: "props",
								_p: void 0
							}
						}

						function xe(me) {
							return me.trim().toLowerCase().split(" ").map((tt, qe) => 0 === qe ? tt : je(tt)).join("")
						}

						function Ee(me, tt) {
							return `[${me}] ${tt}`
						}
						const Ue = "@ngrx/store/init";
						let ke = (() => {
							class me extends y.X {
								constructor() {
									super({
										type: Ue
									})
								}
								next(qe) {
									if ("function" == typeof qe) throw new TypeError("\n        Dispatch expected an object, instead it received a function.\n        If you're using the createAction function, make sure to invoke the function\n        before dispatching the action. For example, someAction should be someAction().");
									if (typeof qe > "u") throw new TypeError("Actions must be objects");
									if (typeof qe.type > "u") throw new TypeError("Actions must have a type property");
									super.next(qe)
								}
								complete() {}
								ngOnDestroy() {
									super.complete()
								}
							}
							return me.\u0275fac = function(qe) {
								return new(qe || me)
							}, me.\u0275prov = p.Yz7({
								token: me,
								factory: me.\u0275fac
							}), me
						})();
						const Ge = [ke],
							ft = new p.OlP("@ngrx/store Internal Root Guard"),
							nt = new p.OlP("@ngrx/store Internal Initial State"),
							Pt = new p.OlP("@ngrx/store Initial State"),
							at = new p.OlP("@ngrx/store Reducer Factory"),
							lt = new p.OlP("@ngrx/store Internal Reducer Factory Provider"),
							et = new p.OlP("@ngrx/store Initial Reducers"),
							Se = new p.OlP("@ngrx/store Internal Initial Reducers"),
							Be = new p.OlP("@ngrx/store Store Features"),
							ze = new p.OlP("@ngrx/store Internal Store Reducers"),
							it = new p.OlP("@ngrx/store Internal Feature Reducers"),
							ce = new p.OlP("@ngrx/store Internal Feature Configs"),
							ht = new p.OlP("@ngrx/store Internal Store Features"),
							Pe = new p.OlP("@ngrx/store Internal Feature Reducers Token"),
							pt = new p.OlP("@ngrx/store Feature Reducers"),
							Bt = new p.OlP("@ngrx/store User Provided Meta Reducers"),
							ot = new p.OlP("@ngrx/store Meta Reducers"),
							Vt = new p.OlP("@ngrx/store Internal Resolved Meta Reducers"),
							Qt = new p.OlP("@ngrx/store User Runtime Checks Config"),
							cn = new p.OlP("@ngrx/store Internal User Runtime Checks Config"),
							Sn = new p.OlP("@ngrx/store Internal Runtime Checks"),
							Pn = new p.OlP("@ngrx/store Check if Action types are unique");

						function Kn(me, tt = {}) {
							const qe = Object.keys(me),
								dt = {};
							for (let Mt = 0; Mt < qe.length; Mt++) {
								const Fn = qe[Mt];
								"function" == typeof me[Fn] && (dt[Fn] = me[Fn])
							}
							const Dt = Object.keys(dt);
							return function(Fn, ir) {
								Fn = void 0 === Fn ? tt : Fn;
								let cr = !1;
								const br = {};
								for (let $n = 0; $n < Dt.length; $n++) {
									const or = Dt[$n],
										lr = Fn[or],
										gr = (0, dt[or])(lr, ir);
									br[or] = gr, cr = cr || gr !== lr
								}
								return cr ? br : Fn
							}
						}

						function Zt(...me) {
							return function(tt) {
								if (0 === me.length) return tt;
								const qe = me[me.length - 1];
								return me.slice(0, -1).reduceRight((Dt, Mt) => Mt(Dt), qe(tt))
							}
						}

						function bn(me, tt) {
							return Array.isArray(tt) && tt.length > 0 && (me = Zt.apply(null, [...tt, me])), (qe, dt) => {
								const Dt = me(qe);
								return (Mt, Fn) => Dt(Mt = void 0 === Mt ? dt : Mt, Fn)
							}
						}
						new p.OlP("@ngrx/store Root Store Provider"), new p.OlP("@ngrx/store Feature State Provider");
						class qt extends D.y {}
						class tn extends ke {}
						const en = "@ngrx/store/update-reducers";
						let Qn = (() => {
							class me extends y.X {
								constructor(qe, dt, Dt, Mt) {
									super(Mt(Dt, dt)), this.dispatcher = qe, this.initialState = dt, this.reducers = Dt, this.reducerFactory = Mt
								}
								get currentReducers() {
									return this.reducers
								}
								addFeature(qe) {
									this.addFeatures([qe])
								}
								addFeatures(qe) {
									const dt = qe.reduce((Dt, {
										reducers: Mt,
										reducerFactory: Fn,
										metaReducers: ir,
										initialState: cr,
										key: br
									}) => {
										const $n = "function" == typeof Mt ? function Bn(me) {
											const tt = Array.isArray(me) && me.length > 0 ? Zt(...me) : qe => qe;
											return (qe, dt) => (qe = tt(qe), (Dt, Mt) => qe(Dt = void 0 === Dt ? dt : Dt, Mt))
										}(ir)(Mt, cr) : bn(Fn, ir)(Mt, cr);
										return Dt[br] = $n, Dt
									}, {});
									this.addReducers(dt)
								}
								removeFeature(qe) {
									this.removeFeatures([qe])
								}
								removeFeatures(qe) {
									this.removeReducers(qe.map(dt => dt.key))
								}
								addReducer(qe, dt) {
									this.addReducers({
										[qe]: dt
									})
								}
								addReducers(qe) {
									this.reducers = {
										...this.reducers,
										...qe
									}, this.updateReducers(Object.keys(qe))
								}
								removeReducer(qe) {
									this.removeReducers([qe])
								}
								removeReducers(qe) {
									qe.forEach(dt => {
										this.reducers = function Vn(me, tt) {
											return Object.keys(me).filter(qe => qe !== tt).reduce((qe, dt) => Object.assign(qe, {
												[dt]: me[dt]
											}), {})
										}(this.reducers, dt)
									}), this.updateReducers(qe)
								}
								updateReducers(qe) {
									this.next(this.reducerFactory(this.reducers, this.initialState)), this.dispatcher.next({
										type: en,
										features: qe
									})
								}
								ngOnDestroy() {
									this.complete()
								}
							}
							return me.\u0275fac = function(qe) {
								return new(qe || me)(p.LFG(tn), p.LFG(Pt), p.LFG(et), p.LFG(at))
							}, me.\u0275prov = p.Yz7({
								token: me,
								factory: me.\u0275fac
							}), me
						})();
						const Wn = [Qn, {
							provide: qt,
							useExisting: Qn
						}, {
							provide: tn,
							useExisting: ke
						}];
						let Nn = (() => {
							class me extends z.x {
								ngOnDestroy() {
									this.complete()
								}
							}
							return me.\u0275fac = function() {
								let tt;
								return function(dt) {
									return (tt || (tt = p.n5z(me)))(dt || me)
								}
							}(), me.\u0275prov = p.Yz7({
								token: me,
								factory: me.\u0275fac
							}), me
						})();
						const ar = [Nn];
						class hr extends D.y {}
						let un = (() => {
							class me extends y.X {
								constructor(qe, dt, Dt, Mt) {
									super(Mt);
									const br = qe.pipe((0, P.Q)(ee.N)).pipe((0, N.M)(dt)).pipe((0, Y.R)(Nt, {
										state: Mt
									}));
									this.stateSubscription = br.subscribe(({
										state: $n,
										action: or
									}) => {
										this.next($n), Dt.next(or)
									})
								}
								ngOnDestroy() {
									this.stateSubscription.unsubscribe(), this.complete()
								}
							}
							return me.INIT = Ue, me.\u0275fac = function(qe) {
								return new(qe || me)(p.LFG(ke), p.LFG(qt), p.LFG(Nn), p.LFG(Pt))
							}, me.\u0275prov = p.Yz7({
								token: me,
								factory: me.\u0275fac
							}), me
						})();

						function Nt(me = {
							state: void 0
						}, [tt, qe]) {
							const {
								state: dt
							} = me;
							return {
								state: qe(dt, tt),
								action: tt
							}
						}
						const Xe = [un, {
							provide: hr,
							useExisting: un
						}];
						let pe = (() => {
							class me extends D.y {
								constructor(qe, dt, Dt) {
									super(), this.actionsObserver = dt, this.reducerManager = Dt, this.source = qe
								}
								select(qe, ...dt) {
									return Je.call(null, qe, ...dt)(this)
								}
								lift(qe) {
									const dt = new me(this, this.actionsObserver, this.reducerManager);
									return dt.operator = qe, dt
								}
								dispatch(qe) {
									this.actionsObserver.next(qe)
								}
								next(qe) {
									this.actionsObserver.next(qe)
								}
								error(qe) {
									this.actionsObserver.error(qe)
								}
								complete() {
									this.actionsObserver.complete()
								}
								addReducer(qe, dt) {
									this.reducerManager.addReducer(qe, dt)
								}
								removeReducer(qe) {
									this.reducerManager.removeReducer(qe)
								}
							}
							return me.\u0275fac = function(qe) {
								return new(qe || me)(p.LFG(hr), p.LFG(ke), p.LFG(Qn))
							}, me.\u0275prov = p.Yz7({
								token: me,
								factory: me.\u0275fac
							}), me
						})();
						const Te = [pe];

						function Je(me, tt, ...qe) {
							return function(Dt) {
								let Mt;
								if ("string" == typeof me) {
									const Fn = [tt, ...qe].filter(Boolean);
									Mt = Dt.pipe(function Q(...me) {
										const tt = me.length;
										if (0 === tt) throw new Error("list of properties cannot be empty.");
										return (0, G.U)(qe => {
											let dt = qe;
											for (let Dt = 0; Dt < tt; Dt++) {
												const Mt = dt?.[me[Dt]];
												if (!(typeof Mt < "u")) return;
												dt = Mt
											}
											return dt
										})
									}(me, ...Fn))
								} else {
									if ("function" != typeof me) throw new TypeError(`Unexpected type '${typeof me}' in select operator, expected 'string' or 'function'`);
									Mt = Dt.pipe((0, G.U)(Fn => me(Fn, tt)))
								}
								return Mt.pipe((0, X.x)())
							}
						}
						const yt = "https://ngrx.io/guide/store/configuration/runtime-checks";

						function Ht(me) {
							return void 0 === me
						}

						function pn(me) {
							return null === me
						}

						function $t(me) {
							return Array.isArray(me)
						}

						function De(me) {
							return "object" == typeof me && null !== me
						}

						function J(me) {
							if (! function B(me) {
									return De(me) && !$t(me)
								}(me)) return !1;
							const tt = Object.getPrototypeOf(me);
							return tt === Object.prototype || null === tt
						}

						function k(me) {
							return "function" == typeof me
						}
						let Ne = !1;

						function Ft() {
							return Ne
						}

						function an(me, tt) {
							return me === tt
						}

						function yn(me, tt = an, qe = an) {
							let Mt, dt = null,
								Dt = null;
							return {
								memoized: function br() {
									if (void 0 !== Mt) return Mt.result;
									if (!dt) return Dt = me.apply(null, arguments), dt = arguments, Dt;
									if (! function xt(me, tt, qe) {
											for (let dt = 0; dt < me.length; dt++)
												if (!qe(me[dt], tt[dt])) return !0;
											return !1
										}(arguments, dt, tt)) return Dt;
									const $n = me.apply(null, arguments);
									return dt = arguments, qe(Dt, $n) ? Dt : (Dt = $n, $n)
								},
								reset: function Fn() {
									dt = null, Dt = null
								},
								setResult: function ir($n) {
									Mt = {
										result: $n
									}
								},
								clearResult: function cr() {
									Mt = void 0
								}
							}
						}

						function nr(...me) {
							return function En(me, tt = {
								stateFn: Dn
							}) {
								return function(...qe) {
									let dt = qe;
									if (Array.isArray(dt[0])) {
										const [$n, ...or] = dt;
										dt = [...$n, ...or]
									} else 1 === dt.length && function Ie(me) {
										return !!me && "object" == typeof me && Object.values(me).every(tt => "function" == typeof tt)
									}(dt[0]) && (dt = function ge(me) {
										const tt = Object.values(me),
											qe = Object.keys(me);
										return [...tt, (...Dt) => qe.reduce((Mt, Fn, ir) => ({
											...Mt,
											[Fn]: Dt[ir]
										}), {})]
									}(dt[0]));
									const Dt = dt.slice(0, dt.length - 1),
										Mt = dt[dt.length - 1],
										Fn = Dt.filter($n => $n.release && "function" == typeof $n.release),
										ir = me(function(...$n) {
											return Mt.apply(null, $n)
										}),
										cr = yn(function($n, or) {
											return tt.stateFn.apply(null, [$n, Dt, or, ir])
										});
									return Object.assign(cr.memoized, {
										release: function br() {
											cr.reset(), ir.reset(), Fn.forEach($n => $n.release())
										},
										projector: ir.memoized,
										setResult: cr.setResult,
										clearResult: cr.clearResult
									})
								}
							}(yn)(...me)
						}

						function Dn(me, tt, qe, dt) {
							if (void 0 === qe) {
								const Mt = tt.map(Fn => Fn(me));
								return dt.memoized.apply(null, Mt)
							}
							const Dt = tt.map(Mt => Mt(me, qe));
							return dt.memoized.apply(null, [...Dt, qe])
						}

						function Me(me) {
							return nr(tt => {
								const qe = tt[me];
								return !Ft() && (0, p.X6Q)() && !(me in tt) && console.warn(`@ngrx/store: The feature name "${me}" does not exist in the state, therefore createFeatureSelector cannot access it.  Be sure it is imported in a loaded module using StoreModule.forRoot('${me}', ...) or StoreModule.forFeature('${me}', ...).  If the default state is intended to be undefined, as is the case with router state, this development-only warning message can be ignored.`), qe
							}, tt => tt)
						}

						function Ke(me) {
							const {
								name: tt,
								reducer: qe,
								extraSelectors: dt
							} = me, Dt = Me(tt), Mt = function Tt(me, tt) {
								const qe = function Xt(me) {
									return me(void 0, {
										type: "@ngrx/feature/init"
									})
								}(tt);
								return (J(qe) ? Object.keys(qe) : []).reduce((Dt, Mt) => ({
									...Dt,
									[`select${je(Mt)}`]: nr(me, Fn => Fn?.[Mt])
								}), {})
							}(Dt, qe), Fn = {
								[`select${je(tt)}State`]: Dt,
								...Mt
							}, ir = dt ? dt(Fn) : {};
							return {
								name: tt,
								reducer: qe,
								...Fn,
								...ir
							}
						}

						function Tn(me) {
							return me instanceof p.OlP ? (0, p.f3M)(me) : me
						}

						function Zn(me, tt) {
							return tt.map((qe, dt) => {
								if (me[dt] instanceof p.OlP) {
									const Dt = (0, p.f3M)(me[dt]);
									return {
										key: qe.key,
										reducerFactory: Dt.reducerFactory ? Dt.reducerFactory : Kn,
										metaReducers: Dt.metaReducers ? Dt.metaReducers : [],
										initialState: Dt.initialState
									}
								}
								return qe
							})
						}

						function pr(me) {
							return me.map(tt => tt instanceof p.OlP ? (0, p.f3M)(tt) : tt)
						}

						function Pr(me) {
							return "function" == typeof me ? me() : me
						}

						function vt(me, tt) {
							return me.concat(tt)
						}

						function ei() {
							if ((0, p.f3M)(pe, {
									optional: !0,
									skipSelf: !0
								})) throw new TypeError("The root Store has been provided more than once. Feature modules should provide feature states instead.");
							return "guarded"
						}

						function Sr(me) {
							Object.freeze(me);
							const tt = k(me);
							return Object.getOwnPropertyNames(me).forEach(qe => {
								if (!qe.startsWith("\u0275") && function ne(me, tt) {
										return Object.prototype.hasOwnProperty.call(me, tt)
									}(me, qe) && (!tt || "caller" !== qe && "callee" !== qe && "arguments" !== qe)) {
									const dt = me[qe];
									(De(dt) || k(dt)) && !Object.isFrozen(dt) && Sr(dt)
								}
							}), me
						}

						function Ur(me, tt = []) {
							return (Ht(me) || pn(me)) && 0 === tt.length ? {
								path: ["root"],
								value: me
							} : Object.keys(me).reduce((dt, Dt) => {
								if (dt) return dt;
								const Mt = me[Dt];
								return function H(me) {
									return k(me) && me.hasOwnProperty("\u0275cmp")
								}(Mt) ? dt : !(Ht(Mt) || pn(Mt) || function ct(me) {
									return "number" == typeof me
								}(Mt) || function kt(me) {
									return "boolean" == typeof me
								}(Mt) || function hn(me) {
									return "string" == typeof me
								}(Mt) || $t(Mt)) && (J(Mt) ? Ur(Mt, [...tt, Dt]) : {
									path: [...tt, Dt],
									value: Mt
								})
							}, !1)
						}

						function Ve(me, tt) {
							if (!1 === me) return;
							const qe = me.path.join("."),
								dt = new Error(`Detected unserializable ${tt} at "${qe}". ${yt}#strict${tt}serializability`);
							throw dt.value = me.value, dt.unserializablePath = qe, dt
						}

						function U(me) {
							return (0, p.X6Q)() ? {
								strictStateSerializability: !1,
								strictActionSerializability: !1,
								strictStateImmutability: !0,
								strictActionImmutability: !0,
								strictActionWithinNgZone: !1,
								strictActionTypeUniqueness: !1,
								...me
							} : {
								strictStateSerializability: !1,
								strictActionSerializability: !1,
								strictStateImmutability: !1,
								strictActionImmutability: !1,
								strictActionWithinNgZone: !1,
								strictActionTypeUniqueness: !1
							}
						}

						function fe({
							strictActionSerializability: me,
							strictStateSerializability: tt
						}) {
							return qe => me || tt ? function $r(me, tt) {
								return function(qe, dt) {
									tt.action(dt) && Ve(Ur(dt), "action");
									const Dt = me(qe, dt);
									return tt.state() && Ve(Ur(Dt), "state"), Dt
								}
							}(qe, {
								action: dt => me && !T(dt),
								state: () => tt
							}) : qe
						}

						function f({
							strictActionImmutability: me,
							strictStateImmutability: tt
						}) {
							return qe => me || tt ? function ti(me, tt) {
								return function(qe, dt) {
									const Dt = tt.action(dt) ? Sr(dt) : dt,
										Mt = me(qe, Dt);
									return tt.state() ? Sr(Mt) : Mt
								}
							}(qe, {
								action: dt => me && !T(dt),
								state: () => tt
							}) : qe
						}

						function T(me) {
							return me.type.startsWith("@ngrx")
						}

						function L({
							strictActionWithinNgZone: me
						}) {
							return tt => me ? function V(me, tt) {
								return function(qe, dt) {
									if (tt.action(dt) && !p.R0b.isInAngularZone()) throw new Error(`Action '${dt.type}' running outside NgZone. ${yt}#strictactionwithinngzone`);
									return me(qe, dt)
								}
							}(tt, {
								action: qe => me && !T(qe)
							}) : tt
						}

						function K(me) {
							return [{
								provide: cn,
								useValue: me
							}, {
								provide: Qt,
								useFactory: ye,
								deps: [cn]
							}, {
								provide: Sn,
								deps: [Qt],
								useFactory: U
							}, {
								provide: ot,
								multi: !0,
								deps: [Sn],
								useFactory: f
							}, {
								provide: ot,
								multi: !0,
								deps: [Sn],
								useFactory: fe
							}, {
								provide: ot,
								multi: !0,
								deps: [Sn],
								useFactory: L
							}]
						}

						function he() {
							return [{
								provide: Pn,
								multi: !0,
								deps: [Sn],
								useFactory: He
							}]
						}

						function ye(me) {
							return me
						}

						function He(me) {
							if (!me.strictActionTypeUniqueness) return;
							const tt = Object.entries(te).filter(([, qe]) => qe > 1).map(([qe]) => qe);
							if (tt.length) throw new Error(`Action types are registered more than once, ${tt.map(qe=>`"${qe}"`).join(", ")}. ${yt}#strictactiontypeuniqueness`)
						}

						function st(me = {}, tt = {}) {
							return [{
								provide: ft,
								useFactory: ei
							}, {
								provide: nt,
								useValue: tt.initialState
							}, {
								provide: Pt,
								useFactory: Pr,
								deps: [nt]
							}, {
								provide: Se,
								useValue: me
							}, {
								provide: ze,
								useExisting: me instanceof p.OlP ? me : Se
							}, {
								provide: et,
								deps: [Se, [new p.tBr(ze)]],
								useFactory: Tn
							}, {
								provide: Bt,
								useValue: tt.metaReducers ? tt.metaReducers : []
							}, {
								provide: Vt,
								deps: [ot, Bt],
								useFactory: vt
							}, {
								provide: lt,
								useValue: tt.reducerFactory ? tt.reducerFactory : Kn
							}, {
								provide: at,
								deps: [lt, Vt],
								useFactory: bn
							}, Ge, Wn, ar, Xe, Te, K(tt.runtimeChecks), he()]
						}

						function Jt(me, tt, qe = {}) {
							return [{
								provide: ce,
								multi: !0,
								useValue: me instanceof Object ? {} : qe
							}, {
								provide: Be,
								multi: !0,
								useValue: {
									key: me instanceof Object ? me.name : me,
									reducerFactory: qe instanceof p.OlP || !qe.reducerFactory ? Kn : qe.reducerFactory,
									metaReducers: qe instanceof p.OlP || !qe.metaReducers ? [] : qe.metaReducers,
									initialState: qe instanceof p.OlP || !qe.initialState ? void 0 : qe.initialState
								}
							}, {
								provide: ht,
								deps: [ce, Be],
								useFactory: Zn
							}, {
								provide: it,
								multi: !0,
								useValue: me instanceof Object ? me.reducer : tt
							}, {
								provide: Pe,
								multi: !0,
								useExisting: tt instanceof p.OlP ? tt : it
							}, {
								provide: pt,
								multi: !0,
								deps: [it, [new p.tBr(Pe)]],
								useFactory: pr
							}, he()]
						}
						let Mn = (() => {
								class me {
									constructor(qe, dt, Dt, Mt, Fn, ir) {}
								}
								return me.\u0275fac = function(qe) {
									return new(qe || me)(p.LFG(ke), p.LFG(qt), p.LFG(Nn), p.LFG(pe), p.LFG(ft, 8), p.LFG(Pn, 8))
								}, me.\u0275mod = p.oAB({
									type: me
								}), me.\u0275inj = p.cJS({}), me
							})(),
							Cn = (() => {
								class me {
									constructor(qe, dt, Dt, Mt, Fn) {
										this.features = qe, this.featureReducers = dt, this.reducerManager = Dt;
										const ir = qe.map((cr, br) => {
											const or = dt.shift()[br];
											return {
												...cr,
												reducers: or,
												initialState: Pr(cr.initialState)
											}
										});
										Dt.addFeatures(ir)
									}
									ngOnDestroy() {
										this.reducerManager.removeFeatures(this.features)
									}
								}
								return me.\u0275fac = function(qe) {
									return new(qe || me)(p.LFG(ht), p.LFG(pt), p.LFG(Qn), p.LFG(Mn), p.LFG(Pn, 8))
								}, me.\u0275mod = p.oAB({
									type: me
								}), me.\u0275inj = p.cJS({}), me
							})(),
							Jn = (() => {
								class me {
									static forRoot(qe, dt) {
										return {
											ngModule: Mn,
											providers: [...st(qe, dt)]
										}
									}
									static forFeature(qe, dt, Dt = {}) {
										return {
											ngModule: Cn,
											providers: [...Jt(qe, dt, Dt)]
										}
									}
								}
								return me.\u0275fac = function(qe) {
									return new(qe || me)
								}, me.\u0275mod = p.oAB({
									type: me
								}), me.\u0275inj = p.cJS({}), me
							})();

						function xn(...me) {
							return {
								reducer: me.pop(),
								types: me.map(dt => dt.type)
							}
						}

						function Br(me, ...tt) {
							const qe = new Map;
							for (const dt of tt)
								for (const Dt of dt.types) {
									const Mt = qe.get(Dt);
									qe.set(Dt, Mt ? (ir, cr) => dt.reducer(Mt(ir, cr), cr) : dt.reducer)
								}
							return function(dt = me, Dt) {
								const Mt = qe.get(Dt.type);
								return Mt ? Mt(dt, Dt) : dt
							}
						}
					}
				},
				be => {
					be(be.s = 1141)
				}]);